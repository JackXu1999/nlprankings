



















































Output Strictly Local Functions


Proceedings of the 14th Meeting on the Mathematics of Language (MoL 14), pages 112–125,
Chicago, USA, July 25–26, 2015. c©2015 Association for Computational Linguistics

Output Strictly Local Functions

Jane Chandlee
University of Delaware
janemc@udel.edu

Rémi Eyraud
QARMA Team
LIF Marseille

remi.eyraud@
lif.univ-mrs.fr

Jeffrey Heinz
University of Delaware
heinz@udel.edu

Abstract

This paper characterizes a subclass of subse-
quential string-to-string functions called Out-
put Strictly Local (OSL) and presents a learn-
ing algorithm which provably learns any OSL
function in polynomial time and data. This al-
gorithm is more efficient than other existing
ones capable of learning this class. The OSL
class is motivated by the study of the nature of
string-to-string transformations, a cornerstone
of modern phonological grammars.

1 Introduction

Motivated by questions in phonology, this paper
studies the Output Strictly Local (OSL) functions
originally defined by Chandlee (2014) and Chandlee
et al. (2014). The OSL class is one way Strictly
Local (SL) stringsets can be generalized to string-
to-string maps. Their definition is a functional ver-
sion of a defining characteristic of SL stringsets
called Suffix Substitution Closure (Rogers and Pul-
lum, 2011). Similar to SL stringsets, the OSL func-
tions contain nested subclasses parameterized by a
value k, which is the length of the suffix of output
strings that matters for computing the function.

As Chandlee (2014) argues, almost all local
phonological processes can be modeled with Input
Strictly Local (ISL) functions. Yet there is one no-
table class of exceptions: so-called spreading pro-
cesses, in which a feature like nasality iteratively as-
similates over a contiguous span of segments. As we
show, the OSL functions are needed to describe this
sort of phenomenon.

Here we provide a slight, but important, revision
to the original definition of OSL functions in Chan-
dlee (2014) and Chandlee et al. (2014), which allows
two important theoretical contributions while pre-
serving the previous results The first is a finite-state
transducer (FST) characterization of OSL functions,
which leads to the second result, the OSLFIA (OSL
Function Inference Algorithm) and a proof that it ef-
ficiently identifies the k-OSL functions from posi-
tive examples. We compare this algorithm to OS-
TIA (Onward Subsequential Transducer Inference
Algorithm, Oncina et al. (1993)) which identifies to-
tal subsequential functions in cubic time, its modi-
fications OSTIA-D and OSTIA-R, which can learn
particular subclasses of subsequential functions us-
ing domain and range information, respectively, in
at least cubic time (Oncina and Varò, 1996; Castel-
lanos et al., 1998), and SOSFIA (Structured On-
ward Subsequential Inference Algorithm, Jardine et
al. (2014)), which can learn particular subclasses of
subsequential functions in linear time and data. We
show these algorithms either cannot learn the OSL
functions or do so less efficiently than the OSLFIA.
These contributions were missing from the initial re-
search on OSL functions (except for a preliminary
FST characterization in Chandlee (2014)). Finally,
we explain how a unified theory of local phonol-
ogy will have to draw insights from both the ISL
and OSL classes and offer an idea of how this might
work. Thus, this paper is a crucial and necessary in-
termediate step towards an empirically adequate but
restrictive characterization of phonological locality.

The remainder of the paper is organized as fol-
lows. Motivation and related work are given in sec-

112



tion 2, including an example of the spreading pro-
cesses that cannot be modeled with ISL functions.
Notations and background concepts are presented in
section 3. In section 4 we define OSL functions,
and the theoretical characterization and learning re-
sults are given in sections 5 and 6. In section 7, we
explain how OSL functions model spreading pro-
cesses. In section 8 we elaborate on a few important
areas for future work, and in section 9 we conclude.

2 Background and related work

A foundational principle of modern generative
phonology is that systematic variation in morpheme
pronunciation is best explained with a single under-
lying representation of the morpheme that is trans-
formed into various surface representations based on
context (Kenstowicz and Kisseberth, 1979; Odden,
2014). Thus, much of generative phonology is con-
cerned with the nature of these transformations.

One way to better understand the nature of
linguistic phenomena is to develop strong com-
putational characterizations of them. Discussing
SPE-style phonological rewrite rules (Chomsky and
Halle, 1968), Johnson (1972, p. 43) expresses the
reasoning behind this approach:

It is a well-established principle that any
mapping whatever that can be computed
by a finitely statable, well-defined proce-
dure can be effected by a rewriting sys-
tem (in particular, by a Turing machine,
which is a special kind of rewriting sys-
tem). Hence any theory which allows
phonological rules to simulate arbitrary
rewriting systems is seriously defective,
for it asserts next to nothing about the sorts
of mappings these rules can perform.

This leads to the important question of what kinds of
transformations ought a theory of phonology allow?

Earlier work suggests that phonological theo-
ries ought to exclude nonregular relations (Johnson,
1972; Kaplan and Kay, 1994; Frank and Satta, 1998;
Graf, 2010). More recently, it has been hypothe-
sized that phonological theory ought to only allow
certain subclasses of the regular relations (Gainor
et al., 2012; Chandlee et al., 2012; Chandlee and
Heinz, 2012; Payne, 2013; Luo, 2014; Heinz and

Lai, 2013). This research places particular em-
phasis on subsequential functions, which can infor-
mally be characterized as functions definable with a
weighted, deterministic finite-state acceptor where
the weights are strings and multiplication is con-
catenation. The aforementioned work suggests that
this hypothesis enjoys strong support in segmental
phonology, with interesting and important excep-
tions in the domain of tone (Jardine, 2014).

Recent research has also showed an increased
awareness and understanding of subregular classes
of stringsets (formal languages) and their impor-
tance for theories of phonotactics (Heinz, 2007;
Heinz, 2009; Heinz, 2010; Rogers et al., 2010;
Rogers and Pullum, 2011; Rogers et al., 2013).
While many of these classes and their properties
were studied much earlier (McNaughton and Papert,
1971; Thomas, 1997), little to no attention has been
paid to similar classes properly contained within the
subsequential functions. Thus, at least within the do-
main of segmental phonology, there is an important
question of whether stronger computational charac-
terizations of phonological transformations are pos-
sible, as seems to be the case for phonotactics.

As mentioned above, Chandlee (2014) shows that
many phonological processes belong to a subclass
of subsequential functions, the Input Strictly Lo-
cal (ISL) functions. Informally, a function is k-
ISL if the output of every input string a0a1 · · · an
is u0u1 · · ·un where ui is a string which only de-
pends on ai and the k − 1 input symbols before ai
(so ai−k+1ai−k+2 · · · ai−1). (A formal definition is
given in section 4). ISL functions can model a range
of processes including local substitution, epenthesis,
deletion, and metathesis. For more details on the ex-
act range of ISL processes, see Chandlee (2014) and
Chandlee and Heinz (to appear).

Processes that aren’t ISL include long-distance
processes as well as local iterative spreading pro-
cesses. As an example of the latter, consider nasal
spreading in Johore Malay (Onn, 1980). As shown
in (1), contiguous sequences of vowels and glides
are nasalized following a nasal:

(1) /p@Nawasan/ 7→ [p@Nãw̃ãsan], ‘supervision’
This process is not ISL, because the initial trigger of
the spreading (the nasal) can be arbitrarily far from a
target (as suggested by the nasalization of the glide

113



and the second [ã]) when the distance is measured
on the input side. However, on the output side, the
triggering context is local; the second [ã] is nasal-
ized because the preceding glide on the output side
is nasalized. Every segment between the trigger and
target is affected; nasalization applies to a contigu-
ous, but arbitrarily long, substring. It is this type
of process that we will show requires the notion of
Output Strict Locality.

Processes in which a potentially unbounded num-
ber of unaffected segments can intervene between
the trigger and target - such as long-distance conso-
nant agreement (Hansson, 2010; Rose and Walker,
2004), vowel harmony (Nevins, 2010; Walker,
2011), and consonant dissimilation (Suzuki, 1998;
Bennett, 2013) - are neither ISL nor OSL. More will
be said about such long-distance processes in §7.

3 Preliminaries

The set of all possible finite strings of symbols from
a finite alphabet Σ and the set of strings of length ≤
n are Σ∗ and Σ≤n, respectively. The cardinality of a
set S is denoted card(S). The unique empty string
is represented with λ. The length of a stringw is |w|,
so |λ| = 0. If w1 and w2 are strings then w1w2 is
their concatenation. The prefixes of w, Pref(w), is
{p ∈ Σ∗ | (∃s ∈ Σ∗)[w = ps]}, and the suffixes of
w, Suff(w), is {s ∈ Σ∗ | (∃p ∈ Σ∗)[w = ps]}. For
all w ∈ Σ∗ and n ∈ N, Suffn(w) is the single suffix
of w of length n if |w| ≥ n; otherwise Suffn(w) =
w. The following reduction will prove useful later.

Remark 1. For all w, v ∈ Σ∗, n ∈ N,
Suffn

(
Suffn(w)v

)
= Suffn(wv).

If w = uv is a string then let v = u−1 · w and
u = w · v−1. Trivially, λ−1 · w = w = w · λ−1,
uu−1 · w = w, and w · v−1v = w.

We assume a fixed but arbitrary total order < on
the letters of Σ. As usual, we extend < to Σ∗ by
defining the hierarchical order (Oncina et al., 1993),
denoted �, as follows: ∀w1, w2 ∈ Σ∗, w1 � w2 iff



|w1| < |w2| or
|w1| = |w2| and ∃u, v1, v2 ∈ Σ∗, ∃a1, a2 ∈ Σ
s.t. w1 = ua1v1, w2 = ua2v2 and a1 < a2.

� is a total strict order over Σ∗, and if Σ = {a, b}
and a < b, then λ�a�b�aa�ab�ba�bb�aaa�. . .

The longest common prefix of a set of strings S,
lcp(S), is p ∈ ∩w∈SPref(w) such that ∀p′ ∈
∩w∈SPref(w), |p′| < |p|. Let f : A→ B be a func-
tion f with domain A and co-domain B. When A
and B are stringsets, the input and output languages
of f are pre image(f) = {x | (∃y)[x 7→f y]} and
image(f) = {y | (∃x)[x 7→f y]}, respectively.

Jardine et al. (2014) introduce delimited subse-
quential FSTs (DSFSTs). The class of functions
describable with DSFSTs is exactly the class repre-
sentable by traditional subsequential FSTs (Oncina
and Garcia, 1991; Oncina et al., 1993; Mohri, 1997),
but DSFSTs make explicit use of symbols marking
both the beginnings and ends of input strings.
Definition 1. A delimited subsequential FST (DS-
FST) is a 6-tuple 〈Q, q0, qf ,Σ,∆, δ〉 where Q is a
finite set of states, q0 ∈ Q is the initial state, qf ∈ Q
is the final state, Σ and ∆ are finite alphabets of
symbols, δ ⊆ Q × (Σ ∪ {o,n}) × ∆∗ × Q is the
transition function (where o 6∈ Σ indicates the ‘start
of the input’ and n 6∈ Σ indicates the ‘end of the in-
put’), and the following hold:

1. if (q, σ, u, q′) ∈ δ then q 6= qf and q′ 6= q0,
2. if (q, σ, u, qf ) ∈ δ then σ = n and q 6= q0,
3. if (q0, σ, u, q′) ∈ δ then σ = o and if

(q,o, u, q′) ∈ δ then q = q0,
4. if (q, σ, w, r), (q, σ, v, s) ∈ δ then (r = s) ∧

(w = v).

In words, in DSFST, initial states have no incom-
ing transitions (1) and exactly one outgoing transi-
tion for input o (3) which leads to a nonfinal state
(2), and final states have no outgoing transitions (1)
and every incoming transition comes from a non-
initial state and has input n (2). DSFSTs are also
deterministic on the input (4). In addition, the tran-
sition function may be partial. We extend the transi-
tion function to δ∗ recursively in the usual way: δ∗ is
the smallest set containing δ and which is closed un-
der the following condition: if (q, w, u, q′) ∈ δ∗ and
(q′, σ, v, q′′) ∈ δ then (q, wσ, uv, q′′) ∈ δ∗. Note no
elements of the form (q, λ, λ, q′) are elements of δ∗.

The size of a DSFST T = 〈Q, q0, qf ,Σ,∆, δ〉 is
|T | = card(Q) + card(δ) +∑(q,a,u,q′)∈δ |u|.

A DSFST T defines the following relation:

R(T ) =
{

(x, y) ∈ Σ∗ ×∆∗ |
[
(q0,oxn, y, qf ) ∈ δ∗

]}

114



Since DSFSTs are deterministic, the relations they
recognize are (possibly partial) functions. Sequen-
tial functions are defined as those representable with
DSFSTs for which for all (q,n, u, qf ) ∈ δ, u = λ.1

For any function f : Σ∗ → ∆∗ and x ∈ Σ∗, let
the tails of x with respect to f be defined as

tailsf (x) =
{

(y, v) | f(xy) = uv ∧
u = lcp(f(xΣ∗))

}
.

If x1, x2 ∈ Σ∗ have the same set of tails with respect
to f , they are tail-equivalent with respect to f , writ-
ten x1 ∼f x2. Clearly,∼f is an equivalence relation
which partitions Σ∗.

Theorem 1 (Oncina and Garcia, 1991). A function
f is subsequential iff ∼f partitions Σ∗ into finitely
many blocks.

The above theorem can be seen as the functional
analogue to the Myhill-Nerode theorem for regular
languages. Recall that for any stringset L, the tails
of a word w w.r.t. L is defined as tailsL(w) =
{u | wu ∈ L}. These tails can be used to partition
Σ∗ into a finite set of equivalence classes iff L is
regular. Furthermore, these equivalence classes are
the basis for constructing the (unique up to isomor-
phism) smallest deterministic acceptor for a regular
language. Likewise, Oncina and Garcia’s proof of
Theorem 1 shows how to construct the (unique up
to isomorphism) smallest subsequential transducer
for a subsequential function f . With little modifi-
cation to their proof, the smallest DSFST for f can
also be constructed. We refer to this DSFST as the
canonical DSFST for f and denote it TC(f). (If f is
understood from context, we may write TC .) States
of TC(f) which are neither initial nor final are in
one-to-one correspondence with tailsf (x) for all
x ∈ Σ∗ (Oncina and Garcia, 1991). To construct
TC(f) we first let, for all x ∈ Σ∗ and a ∈ Σ,
the contribution of a w.r.t. x be contf (a, x) =
lcp(f(xΣ∗)−1 · lcp(f(xaΣ∗)). Then,

• Q = {tailsf (x) | x ∈ Σ∗} ∪ {q0, qf},
•
(
q0,o, lcp(f(Σ∗)), tailsf (λ)

)
∈ δ

• For all x ∈ Σ∗,(
tailsf (x),n, lcp(f(xΣ∗))−1 · f(x), qf

)
∈

δ iff x ∈ pre image(f)
1Sakarovitch (2009) inverts these terms.

• For all x ∈ Σ∗, a ∈ Σ, if ∃y ∈ Σ∗
with xay ∈ pre image(f) then

(
tailsf (x),

a, contf (a, x), tailsf (xa)
)
∈ δ.

• Nothing else is in δ.

Observe that unlike the traditional construction, the
initial state q0 is not tailsf (λ). The single outgo-
ing transition from q0, however, goes to this state
with the input o. Canonical DSFSTs have an im-
portant property called onwardness.

Definition 2 (onwardness). A DSFST T is onward if
for every w ∈ Σ∗, u ∈ ∆∗, (q0,ow, u, q) ∈ δ∗ ⇐⇒
u = lcp({f(wΣ∗)}).
Informally, this means that the writing of output is
never delayed. For all q ∈ Q let the outputs of the
edges out of q be outputs(q) =

{
u | (∃σ ∈ Σ ∪

{o,n})(∃q′ ∈ Q)[(q, σ, u, q′) ∈ δ]
}

.

Lemma 1. If DSFST T recognizes f and is on-
ward then ∀q 6= q0 lcp(outputs(q)) = λ and
lcp(outputs(q0)) = lcp(f(Σ

∗)).

Proof. By construction of a DSFST, only one
transition leaves q0: (q0,o, u, q). This implies
(q0,oλ, u, q) ∈ δ∗ and as the transducer is onward
we have lcp(outputs(q0)) = lcp(u) = u =
lcp(f(λΣ∗)) = lcp(f(Σ∗)). Now take q 6= q0
and w ∈ Σ∗ such that (q0,ow, u, q) ∈ δ∗. Suppose
lcp(outputs(q)) = v 6= λ. Then v is a prefix of
lcp({f(wσx) | σ ∈ Σ ∪ {n}, x ∈ Σ∗}) which im-
plies uv is a prefix of lcp(f(wΣ∗)). But v 6= λ,
contradicting the fact that T is onward.

Readers are referred to Oncina and Garcia (1991),
Oncina et al. (1993), and Mohri (1997) for more
on subsequential transducers, and Eisner (2003) for
generalizations regarding onwardness.

4 Output Strictly Local functions

Here we define Output Strictly Local (OSL) func-
tions, which were originally introduced by Chandlee
(2014) and Chandlee et al. (2014) along with the In-
put Strictly Local (ISL) functions. Both classes gen-
eralize SL stringsets to functions based on a defin-
ing property of SL languages, the Suffix Substitution
Closure (Rogers and Pullum, 2011).

Theorem 2 (Suffix Substitution Closure). L is
Strictly Local iff for all strings u1, v1, u2, v2, there

115



exists k ∈ N such that for any string x of length
k − 1, if u1xv1, u2xv2 ∈ L, then u1xv2 ∈ L.

An important corollary of this theorem follows.

Corollary 1 (Suffix-defined Residuals). L is Strictly
Local iff ∀w1, w2 ∈ Σ∗, there exists k ∈ N such that
if Suffk−1(w1) = Suffk−1(w2) then the residuals
(the tails) of w1, w2 with respect to L are the same;
formally, {v | w1v ∈ L} = {v | w2v ∈ L}.

Input and Output Strictly Local functions were
defined by Chandlee (2014) and Chandlee et al.
(2014) in the manner suggested by the corollary.

Definition 3 (Input Strictly Local Functions). A
function f : Σ∗ → ∆∗ is ISL if there is a k such that
for all u1, u2 ∈ Σ∗, if Suffk−1(u1) = Suffk−1(u2)
then tailsf (u1) = tailsf (u2).

Definition 4 (Output Strictly Local Functions (orig-
inal)). A function f : Σ∗ → ∆∗ is OSL if there is a k
such that for all u1, u2 ∈ Σ∗, if Suffk−1(f(u1)) =
Suffk−1(f(u2)) then tailsf (u1) = tailsf (u2).

While Definition 3 lead to an automata-theoretic
characterization and learning results for ISL (Chan-
dlee et al., 2014), such results do not appear possi-
ble with the original definition of OSL. The trouble
is with subsequential functions that are not sequen-
tial. The value returned by the function includes the
writing that occurs when the input string has been
fully read (i.e., the output of transitions going to the
final state in a corresponding DSFST). This creates
a problem because it does not allow for separation
of what happens during the computation from what
happens at its end.

Figure 1 illustrates the distinction Definition 4 is
unable to make.2 Function f is sequential, but g is
not. Otherwise, they are identical. While f(bab) =
bba, g(bab) = bbaa. With the original OSL defini-
tion, there is no way to refer to the output for input
bab before the final output string has been appended.

To deal with this problem we first define the prefix
function associated to a subsequential function.

Definition 5 (Prefix function). Let f : Σ∗ → ∆∗
be a subsequential function. We define the prefix
function fp : Σ∗ → ∆∗ associated to f such that
fp(w) = lcp({f(wΣ∗)}).

2Here and in Figure 3, state qf is not shown. Non-initial
states are labeled q : u with q being the state’s name and
(q,n, u, qf ) ∈ δ.

Tf

q0

λ : λ

! : λ

a:λ

a:a

a:a

b:λ

b:b

b:bb:a

a:b

q0

Tg

λ : λ

! : λ

a:a

a:a

a:a

b:b

b:b

b:bb:a

a:b

1

Figure 1: Two DSFST recognizing functions f and g.
Except for their final transitions, Tf and Tg are identical.

Remark 2. If T is an onward DSFST for f , then
∀w ∈ Σ∗, fp(w) = u⇐⇒ ∃q, (q0,ow, u, q) ∈ δ∗.
Remark 3. If f is sequential then f = fp.
We can now revise the definition of OSL functions.

Definition 6 (Output Strictly Local Function (re-
vised)). We say that a subsequential function f is
k-OSL if for all w1, w2 in Σ∗, Suffk−1(fp(w1)) =
Suffk−1(fp(w2))⇒ tailsf (w1) = tailsf (w2).

Chandlee et al. (2014) provide several theorems
which relate ISL functions, OSL functions (defined
as in Definition 4), and SL stringsets. Here we ex-
plain why those results still hold with Definition 6.
The proofs for those results depend on the six func-
tions (fi, 1 ≤ i ≤ 6) reproduced here in Figure 2.
The transducers shown there are not DSFSTs but
traditional subsequential transducers; readers are re-
ferred to Chandlee et al. (2014) for formal defini-
tions. With the exception of f5, these functions are
clearly sequential since each state outputs λ on n
(shown as # in Figure 2). The transducer for f5 is
not onward, but an onward, sequential version of this
transducer recognizing exactly the same function is
obtained by suffixing a (which is the lcp of the out-
puts of state 1) onto the output of state 1’s incoming
transition. Thus, f5 is also sequential. By Remark 3
then, Theorems 4, 5, 6, and 7 of that paper still hold
under Definition 6.

5 Automata characterization

First we show, for any non-initial state of any canon-
ical transducer recognizing an OSL function, that if
reading a letter a implies writing λ, then this corre-
sponds to a self-loop. So writing the empty string
never causes a change of state (except from q0).

Lemma 2. For any OSL function f whose canonical
DSFST is TC , if ∃q 6= q0, a ∈ Σ, and q′ ∈ Q such

116



0 1
a

#:λ #:λ
b,c a,b:a,c

f1

a

bλ

b
aa

b

#:λ

#:λ#:λ

a:b

b

f2

1

a

bλ

a
a

b,c:b

#:λ

#:λ#:λ

a,b:a,c:a

b,c:b

f3

a

bλ

b

a:aa
a:aa

b

#:λ

#:λ
#:λ

a:aa

b

f4

1

0 1
a

#:λ #:a

a

f5

10
a

a:λ

#:λ#:λ

f6

1

Figure 2: Examples used in proofs of Theorems 4 to 7 of
Chandlee et al. (2014, see Figure 2).

that (q, a, λ, q′) ∈ δC then q′ = q.
Proof. Consider w and u such that
(q0,ow, u, q) ∈ δ∗C and suppose (q, a, λ, q′) ∈ δC .
Then fp(w) = fp(wa) which implies
Suffk−1(fp(w)) = Suffk−1(fp(wa)). As f
is k-OSL, tailsf (w) = tailsf (wa). As TC
is canonical the non-initial and non-final states
correspond to unique tail-equivalence classes, and
two distinct states correspond to two different
classes. Therefore q′ = q.

Next we define k-OSL transducers.

Definition 7 (k-OSL transducer). An onward DS-
FST T = 〈Q, q0, qf ,Σ,∆, δ〉 is k-OSL if

1. Q = S ∪ {q0, qf} with S ⊆ ∆≤k−1
2. (∀u ∈ ∆∗)

[
(q0,o, u, q′) ∈ δ =⇒ q′ =

Suffk−1(u)
]

3. (∀q ∈ Q\{q0},∀a ∈ Σ,∀u ∈ ∆∗)[
(q, a, u, q′) ∈ δ =⇒ q′ = Suffk−1(qu)

]
.

Next we show that k-OSL functions and functions
represented by k-OSL DSFSTs exactly correspond.

Lemma 3 (extended transition function). Let T =
〈Q, q0, qf ,Σ,∆, δ〉 be a k-OSL DSFST. We have

(q0,ow, u, q) ∈ δ∗ =⇒ q = Suffk−1(u)

Proof. By recursion on the size of w ∈ Σ∗. The ini-
tial case is valid for |w| = 0 since if (q0,o, u, q) ∈
δ∗ then (q0,o, u, q) ∈ δ. By Definition 7, q =
Suffk−1(u). Suppose now that the lemma holds for
inputs of size n 6= 0. Let w be of size n such that
(q0,ow, u, q) ∈ δ∗ and suppose (q, a, v, q′) ∈ δ
(i.e., (q0,owa, uv, q′) ∈ δ∗). By recursion, we
know that q = Suffk−1(u). By Definition 7,
q′ = Suffk−1(qv) = Suffk−1(Suffk−1(u)v) =
Suffk−1(uv) (by Remark 1).

Lemma 4. Any k-OSL DSFST corresponds to a k-
OSL function.

Proof. Let T = 〈Q, q0, qf ,Σ,∆, δ〉 be a k-
OSL DSFST computing f and let w1, w2 ∈ Σ∗
such that Suffk−1(fp(w1)) = Suffk−1(fp(w2)).
Since T is onward, by Remark 2 there exists
q, q′ ∈ Q such that (q0,ow1, fp(w1), q) ∈ δ∗ and
(q0,ow2, fp(w2), q′) ∈ δ∗. By Lemma 3, q =
Suffk−1(fp(w1)) = Suffk−1(fp(w2)) = q′ which
implies tailsf (w1) = tailsf (w2). Therefore f is
a k-OSL function.

We now need to show that every k-OSL function
can be represented by a k-OSL DSFST. An issue
here is that one cannot work from TC since its states
are defined in terms of its tails, which themselves are
defined in terms of input strings, not output strings.
Hence, the proof below is constructive.

Theorem 3. Let f be a k-OSL function. The DSFST
T defined as followed computes f :

• Q = S ∪ {q0, qf} with S ⊆ ∆≤k−1
• (q0,o, u, Suffk−1(u)) ∈ δ ⇐⇒ u = fp(λ)
• a ∈ Σ, (q, a, u, Suffk−1(qu)) ∈ δ, ⇐⇒

(∃w)
[
Suffk−1(fp(w)) = q ∧ fp(wa) = vqu

with v = fp(w) · q−1
]
,

• (q,n, u, qf ) ∈ δ ⇐⇒ u = fp(wq)−1 · f(wq),
where wq = min�{w | ∃u, (q0,ow, u, q) ∈
δ∗}.

The diagram below helps express pictorially how
the transitions are organized per the second and third
bullets above. The input is written above the arrows,
and the output written below.

q0
ow−−−−−−→

fp(w)=vq
q

a−−→
u

q′

117



Note that T is a k-OSL SFST. To prove this result,
we first show the following lemma:

Lemma 5. Let T be the transducer defined in The-
orem 3. We have:

(q0,ow, u, q) ∈ δ∗ ⇐⇒ fp(w) = u

Proof. (⇒) By recursion on the length of w. Sup-
pose (q0,ow, u, q) ∈ δ∗ and |w| = 0. Then
(q0,o, u, q) ∈ δ; by construction, q = Suffk−1(u)
and fp(λ) = u which validates the initial case.

Suppose the result holds for w of size n and pick
such a w. Suppose then that (q0,owa, u, q) ∈ δ∗.
By definition of δ∗, there exists u1, u2, q′ such that
u = u1u2, (q0,ow, u1, q′) ∈ δ∗ and (q′, a, u2, q) ∈
δ. We have fp(w) = u1 (by recursion) and thus
q′ = Suffk−1(fp(w)) (by Lemma 3).

By construction of T , q = Suffk−1(q′u2)
and thus fp(wa) = vq′u2 with v =
fp(w) · Suffk−1(fp(w))−1. Therefore fp(wa) =
vq′u2 = fp(w) · Suffk−1(fp(w))−1q′u2 =
fp(w) · Suffk−1(fp(w))−1Suffk−1(fp(w))u2 =
fp(w)u2 = u1u2 = u.
(⇐) By recursion on the length of w. If |w| =
0, then fp(λ) = u. By construction of T ,
(q0,o, u, Suffk−1(u)) ∈ δ, which validates the
base case.

Now fix n > 0 and suppose the result holds
for all w of size n. Pick such a w and let
fp(wa) = u. As f is subsequential, there ex-
ists u1 such that fp(w) = u1. By recursion,
there exists q such that (q0,ow, u1, q) ∈ δ∗. By
Lemma 3, q = Suffk−1(u1) = Suffk−1(fp(w)).
By definition fp(wa) = u1u−11 · u, which
equals u1 · Suffk−1(u1)−1Suffk−1(u1)u−11 · u.
Hence fp(wa) = vqu′, with u′ = u−11 · u
and v = u1 · Suffk−1(u1)−1, which equals
fp(w) · Suffk−1(fp(w))−1. Thus, by construction
(q, a, u′, Suffk−1(qu′)) ∈ δ. Since u1u′ = u1u−11 ·
u = u, (q0,owa, u, Suffk−1(qu′)) ∈ δ∗.

We can now prove Theorem 3.

Proof. Let T be the transducer defined in Theo-
rem 3. We show that ∀w ∈ Σ∗,

(w, u) ∈ R(T )⇐⇒ f(w) = u.

By definition of R(T ), we know that
(q0,own, u, qf ) ∈ δ∗. By definition of δ∗,

q0

λ:λ

C:λ

Ṽ:λ

V:λ

N:λ

! : λ C:C

V:V

N:N

V:Ṽ

C:C

V:V

C:C

N:N

N:N

C:C

N:NN:N

V:Ṽ

V:V

C:C

1

Figure 3: A 2-OSL DSFST that models Johore Malay
nasal spreading. Σ={C, N, V} and ∆ = {C, N, V, Ṽ}.

there exists u1, u2 ∈ ∆∗ and q ∈ Q\{q0, qf}
such that (q0,ow, u1, q) ∈ δ∗, (q,n, u2, qf ) ∈ δ,
and u = u1u2. By Lemma 5 we know that
fp(w) = u1. By construction of the DS-
FST, we have u2 = fp(wq)−1 · f(wq) where
wq = min�{w′ | ∃u, (q0,ow′, u′, q) ∈ δ∗}.
Therefore (wq, u′u2) ∈ R(T ). Again, by Lemma 5,
fp(wq) = u

′ and so u′u2 = fp(wq)u2 =
fp(wq)f

p(wq)
−1 · f(wq) = f(wq).

We have Suffk−1(u1) = Suffk−1(fp(wq)) =
Suffk−1(fp(w)). As f is k-OSL, we know
tailsf (wq) = tailsf (w), which implies that
(λ, fp(wq)

−1 · f(wq)) ∈ tailsf (w). Thus f(w) =
fp(w)fp(wq)

−1 · f(wq) = u1u2 = u.

Figure 3 presents a 2-OSL transducer that mod-
els the nasal spreading example from §2. Note C =
obstruent, V = vowels and glides, Ṽ = nasalized V,
and N = nasal consonant.

6 Learning OSL functions

6.1 Learning criterion

We adopt the identification in the limit learning
paradigm (Gold, 1967), with polynomial bounds on
time and data (de la Higuera, 1997). The underlying
idea of the paradigm is that if the data available to
the algorithm does not contain enough information
to distinguish the target from other potential targets,
then it is impossible to learn.

We first need to define the following notions. A
class T of functions is represented by a class R
of representations if every r ∈ R is of finite size

118



and there is a total and surjective naming function
L : R → T such that L(r) = t if and only if for
all w ∈ pre image(t), r(w) = t(w), where r(w)
is the output of representation r on the input w. We
observe that the class of k-OSL functions can be rep-
resented by the class of k-OSL DSFSTs.

Definition 8. Let T be a class of functions repre-
sented by some class R of representations.

1. A sample S for a function t ∈ T is a finite set of
data consistent with t, that is to say (w, v) ∈ S
iff t(w) = v. The size of a sample S is the sum
of the length of the strings it is composed of:
|S| = ∑(w,v)∈S |w|+ |v|.

2. A (T,R)-learning algorithm A is a program
that takes as input a sample for a function t ∈ T
and outputs a representation from R.

The paradigm relies on the notion of characteristic
sample, adapted here for functions:

Definition 9 (Characteristic sample). For a (T,R)-
learning algorithm A, a sample CS is a character-
istic sample of a function t ∈ T if for all samples
S for t it is the case that CS ⊆ S and A returns a
representation r such that L(r) = t.

This definition is the one used in the proof of the
OSTIA algorithm. The learning paradigm can now
be defined as follows.

Definition 10 (Identification in polynomial time
and data). A class T of functions is identifiable in
polynomial time and data if there exists a (T,R)-
learning algorithm A and two polynomials p() and
q() such that:

1. For any sample S of sizem for t ∈ T, A returns
a hypothesis r ∈ R in O(p(m)) time.

2. For each representation r ∈ R of size n, with
t = L(r), there exists a characteristic sample
of t for A of size at most O(q(n)).

6.2 Learning algorithm
We show here that Algorithm 1 learns the OSL func-
tions under the criterion introduced. We call this the
Output Strictly Local Function Inference Algorithm
(OSLFIA). We assume Σ, ∆, and k are fixed and not
part of the input to the learning problem.

Essentially, the algorithm computes a breadth-
first search through the states that are reachable

Data: Sample S ⊂ {o}Σ∗{n} ×∆∗ and
k ∈ N

Let q0, qf be states with {q0, qf} ∩∆≤k−1 = ∅
s← lcp({y | (x, y) ∈ S}); q ← Suffk−1(s);
smallest(q) = o; out(q) = s;
δ ← {(q0,o, s, q)}; R← {q}; C ← {q0, qf};
while R 6= ∅ do

q ← first(R); s← smallest(q);
for all a ∈ Σ in alphabetical order do

if ∃(w, u) ∈ S, x ∈ Σ∗ s.t. w = sax
then

v ← lcp({y | ∃x, (sax, y) ∈ S});
r ← Suffk−1(qv);
δ ← δ ∪ {(q, a, out(q)−1 · v, r)};
if r /∈ R ∪ C then

R← R ∪ {r};
smallest(r)← sa;
out(r)← v;

if ∃u, (s, u) ∈ S then
δ ← δ ∪ {(q,n, out(q)−1 · u, qf )}

R← R \ {q};
C ← C ∪ {q};

return 〈C, q0, qf ,Σ,∆, δ〉;
Algorithm 1: OSLFIA

given the learning sample: the set C contains the
states already checked while R is a queue made of
the states that are reachable but have not been treated
yet. Initially, the only transition leaving the initial
state is writing the lcp of the output strings of the
sample and reaches the state corresponding to the
k − 1 suffix of this lcp. At each step of the main
loop, OSLFIA treats the first state that is in the queue
R and computes whenever possible the transitions
that leave that state. The outputs associated with
each added transition are the longest common pre-
fixes of the outputs associated with the smallest in-
put prefix in the sample that allows the state to be
reachable. We show that provided the algorithm is
given a sufficient sample the transducer outputted by
OSLFIA is onward and in fact a k-OSL transducer.
After adding transitions with input letters from Σ to
a state, the transition to the final state is added, pro-
vided it can be calculated.

6.3 Theoretical results

Here we establish the theoretical results, which cul-
minate in the theorem that OSLFIA identifies the k-

119



OSL functions in polynomial time and data.

Lemma 6. For any input sample S, OSLFIA pro-
duces its output in time polynomial in the size of S.

Proof. The main loop is used at most |∆|k−1 which
is constant since both ∆ and k are fixed for any
learning sample. The smaller loop is executed |Σ|
times. At each execution: the first conditional can be
tested in time linear in n, where n =

∑
(w,u)∈S |w|;

the computation of the lcp can be done in nm steps
where m = max{|u| : (w, u) ∈ S} with an appro-
priate data structure (for instance a prefix tree); com-
puting the suffix requires at most m steps. The sec-
ond conditional can be tested in at most card(S) ·m
steps; the computation of the final transitions can be
done in less than m steps; all the other instructions
can be done in constant time. The overall computa-
tion time is thus O(|∆|k−1|Σ|(n+ nm+ card(S) ·
m+2m)) = O(n+m(n+card(S)) which is poly-
nomial (in fact bounded by a quadratic function) in
the size of the learning sample.

Next we show that for each k-OSL function f ,
there is a finite kernel of data consistent with f (a
‘seed’) that is a characteristic sample for OSLFIA.

Definition 11 (A OSLFIA seed). Given a k-OSL
transducer 〈Q, q0, qf ,Σ,∆, δ〉 computing a k-OSL
function f , a sample S is a OSLFIA seed for f if

• For all q ∈ Q such that ∃v ∈ ∆∗
(q,n, v, qf ) ∈ δ, (owqn, f(wq)) ∈ S, where
wq = min�{w | ∃u, (q0,ow, u, q) ∈ δ∗}
• For all (q, a, u, q′) ∈ δ with q′ 6= qf and
a ∈ {o}∪Σ, for all b ∈ Σ such that there exists
(q′, b, u′, q′′) ∈ δ, there exists (own, f(w)) ∈
S and x ∈ Σ∗ such that w = wqabx and
f(w) is defined. Also, if there exists v such that
(q′,n, v, qf ) ∈ δ then (owqan, f(wqa)) ∈ S.

In what follows, we set T � =
〈Q�, q0� , qf� ,Σ,∆, δ�〉 be the target k-OSL
transducer, f the function it computes, and
T = 〈Q, q0, qf ,Σ,∆, δ〉 be the transducer OSLFIA
constructs on a sample that contains a seed.

Lemma 7. If a learning sample S contains a seed
then (q0,ow, u, r) ∈ δ∗ ⇐⇒ (q0� ,ow, u, r) ∈ δ∗� .
Proof. (⇒). By induction on the length of w. If
|w| = 0 then (q0,o, u, r) ∈ δ and so u = lcp({y |

(x, y) ∈ S}) and r = Suffk−1(u) (initial steps of
the algorithm). As S is a seed there is an element
(obxn, f(bx)) ∈ S for all b ∈ Σ and (on, f(λ)) ∈
S if λ ∈ pre image(f), which implies that u =
lcp(f(λΣ∗)). As the target is onward, we have
(q0� ,o, lcp(f(λΣ∗)), r′) ∈ δ� and since it is a
k-OSL DSFST r′ = Suffk−1(lcp(f(λΣ∗))) =
Suffk−1(u) = r.

Suppose the lemma is true for strings of length
less than or equal to n. We refer to this as
the first Inductive Hypothesis (IH1). Let wa be
of size n + 1 such that (q0,owa, u, r) ∈ δ∗.
By definition of δ∗, there exist u1, u2, q such that
(q0,ow, u1, q) ∈ δ∗, (q, a, u2, r) ∈ δ, and u =
u1u2. By IH1 (q0� ,ow, u1, q) ∈ δ∗� . We want to
show (q0� ,owa, u, r) ∈ δ∗� (i.e., (q, a, u2, r) ∈ δ�).

First we show that IH1 also implies that s =
smallest(q) such that s = owq. Since the algo-
rithm searches breadth-first, s is the smallest input
that reaches q in T . If owq � s then ∃q′ 6= q such
that (q0,owq, u′, q′) ∈ δ∗ because owq is a prefix
of an input string of the sample S (since S contains
a seed). Since owq � s and |s| ≤ n, by IH1 then
(q0� ,owq, u′, q′) ∈ δ∗� which implies q = q′ which
contradicts the supposition that owq�s. If s�owq,
then again since (q0,os, u′, q) ∈ δ∗ then by IH1
(q0� ,os, u′, q) ∈ δ∗� . This contradicts the definition
of wq. Therefore s = owq.

Next we show that IH1 implies fp(wq) = out(q).
By construction of the seed, (owqn, f(wq)) ∈ S if
∃v (q,n, v, qf�) ∈ δ� and (owqaw′n, f(wqaw′)) ∈
S for all transitions (q, a, x, q′) leaving q in T �. As
the target is onward, lcp({x | (q, σ, x, q′) ∈ δ�, σ ∈
Σ ∪ {n}} = λ (Lemma 1). This implies out(q) =
lcp({y | ∃a ∈ Σ, x ∈ Σ∗{n}, (osax, y) ∈ S}) =
lcp({y | ∃a ∈ Σ, x ∈ Σ∗{n}, (owqax, y) ∈
S}) = lcp({f(wqΣ∗)}) = fp(wq).

Recalling that (q, a, u2, r) ∈ δ, we now char-
acterize u2 to help establish (q, a, u2, r) ∈ δ�.
By construction of a seed, there exist elements
(owqabxn, f(wqabx)) in S for all possible b ∈ Σ
and an element (owqan, f(wqa)) ∈ S if f(wqa)
is defined. By the onwardness of the target, this
implies that v = lcp({y | ∃b, x, (osabxn, y) ∈
S} ∪ {f(sa)}) = lcp(f(saΣ∗)) = fp(sa). There-
fore u2 = out(q)−1 · v = fp(s)−1 · fp(sa) =
fp(wq)

−1 · fp(wqa).
Finally we identify r to complete this part

120



of the proof. As the target is OSL, we have
(q0� ,owqa, fp(wqa), r′) ∈ δ∗� (Lemma 3). The
fact that (q0� ,owq, fp(wq), q) ∈ δ∗� by IH1 and
the fact the target is OSL implies (q, a, fp(wq)−1 ·
fp(wqa), r

′) = (q, a, out(q)−1 · s, r′) ∈ δ�. As
T � is k-OSL, r′ = Suffk−1(qout(q)−1 · s) which
is r by construction of the transition in the algo-
rithm. Therefore, as (q0� ,ow, u1, q) ∈ δ∗� by
IH1, we have (q0� ,owa, u1out(q)−1 · s, r) =
(q0� ,owa, u1u2, r) = (q0� ,owa, u, r) ∈ δ∗�

(⇐). This is also by induction on the length
of w. If |w| = 0, as T � is onward we have
lcp(outputs(q0�)) = lcp(f(Σ

∗)) (Lemma 1)
and thus (q0� ,o, lcp(f(Σ∗)), r) ∈ δ� with r =
Suffk−1(lcp(f(Σ∗))) as T � is k-OSL. By con-
struction of the seed, there is at least one ele-
ment in S using each transition leaving r. As
lcp(outputs(r)) = λ (Lemma 1), this implies
lcp({y | (x, y) ∈ S}) = lcp(f(Σ∗)). Therefore
(q0,o, lcp(f(Σ∗)), r) ∈ δ.

Suppose the lemma is true for all strings up to
length n. We refer to this as the second Inductive
Hypothesis (IH2). Pick wa of length n + 1 such
that (q0� ,owa, u, r) ∈ δ∗� . By definition of δ∗,
q, u1, u2 exist such that (q0� ,ow, u1, q) ∈ δ∗� and
(q, a, u2, r) ∈ δ�, with u1u2 = u. By IH2, we
have (q0,ow, u1, q), (q0,owq, u′1, q) ∈ δ∗ (since
wq � w). We want to show (q, a, u2, r) ∈ δ.

We first show that s = smallest(q) = owq.
Suppose s � owq. By construction of the SFST s
is a prefix of an element of S which means there
exists q′ such that (q0, s, fp(s), q′) ∈ δ∗� . But by
IH2, this implies that q′ = q and the definition of
wq contradicts s�owq. Suppose now that owq�s.
By the construction of the seed, owq is a prefix of an
element of the sample, which implies it is considered
by the algorithm. As (q0,owq, u′1, q) ∈ δ∗ by IH2,
owq is a smaller prefix than s that reaches the same
state which is impossible as s is the earliest prefix
that makes the state q reachable. Therefore owq =
s and thus the transition from state q reading a is
created when s = owq.

Next we show that fp(wq) = out(q). By
construction of the seed, there is an element
(owqaw′n, f(wqaw′)) ∈ S for all transitions
(q, a, x, q′) ∈ δ� leaving q and (owqn, f(wq)) ∈
S if ∃v, (q,n, v, qf ) ∈ δ�. As the target is
onward, lcp({x | (q, σ, x, q) ∈ δ∗, σ ∈ Σ ∪

n} = λ (Lemma 1). This implies out(q) =
lcp({y | ∃a, x, (sax, y) ∈ S}) = lcp({y |
∃a, x, (wqax, y) ∈ S}) = lcp(f(wqΣ∗)) =
fp(wq) = f

p(s).
Now let v = lcp({y | ∃b, x, (sabx, y) ∈ S}).

Since s = owq, (q0� ,owqa, v, r) ∈ δ∗� since, as be-
fore, the onwardness of the target implies the lcp of
the output written from r is λ. This is because each
possible output from r is in S (because it is in the
seed according to the second item of Definition 11).
Consequently v = fp(wqa) = fp(sa).

Together these results imply that u2 = fp(wq)−1 ·
fp(wqa) = f

p(s)−1 · fp(sa) = out(q)−1 · v.
As the target is a k-OSL transducer (and thus de-

terministic) Suffk−1(qu2) = r. Therefore the tran-
sition (q, a, out(q)−1 · v, r) that is added to δ is the
same as the transition (q, a, u2, r) in δ�. This implies
(q0,owa, u, r) ∈ δ∗ and proves the lemma.

Lemma 8. Any seed for the OSL Learner is a char-
acteristic sample for this algorithm.

Proof. A corollary of Lemma 7 is that if a
seed is contained in a learning sample we have
(q0,ow, u, q) ∈ δ∗ ⇐⇒ fp(w) = u (Lemma 3) as
the target transducer is k-OSL. For all states q where
∃v, (q,n, v, qf�) ∈ δ�, we have (owqn, f(wq))
in the seed, which implies the algorithm will add
(q,n, fp(wq)−1 · f(wq), qf ) to δ which is exactly
the output function of the target. As every state
is treated only once, this holds for any learning
set containing a seed. Therefore, from any super-
set of a seed, for any w, the function computed by
the outputted transducer of Algorithm 1 is equal to
fp(w)fp(w)−1 · f(w) = f(w).

Observe that OSLFIA is designed to work with
seeds, which contains minimal strings. We believe
both the seed and algorithm can be adjusted to relax
this requirement, though this is left for future work.

Lemma 9. Given any k-OSL transducer T �, there
exists a seed for the OSL learner that is of size poly-
nomial in the size of T �.

Proof. Let T � = 〈Q�, q0� , qf�Σ,∆, δ�, 〉. There are
at most card(Q�) pairs (owqn, f(wq)) in a seed
that corresponds to the first item of Definition 11,
each of which is such that | o wq n | ≤ card(Q�)

121



and |f(wq)| ≤
∑

(q,σ,u,q′)∈δ� |u|. We denote by m�
this last quantity and note that m� = O(|T �|).

For the elements of the second item of Def-
inition 11 we restrict ourselves without loss of
generality to pairs (owqabw′n, f(wqabw′)) where
w′ = min�{x : f(wqabx) is defined}. We
have |w′| ≤ card(Q�) and |f(wqabw′)| is in
O(card(Q�)m�). There are at most |Σ| pairs
(owqabw′n, f(wqabw′)) for a given transition
(q, a, u, q′) which implies that the overall bound
on the number of such pairs is in O(|Σ|card(δ)).
The overall length of the elements in the seed
that fulfill the second item of the definition is in
O(card(Q�)(card(Q�) +m� + |Σ|card(δ)m�)).

The size of the seed studied in this proof is thus in
O((m� + |Q�|)(|Q�| + |Σ|card(δ)) which is poly-
nomial (in fact quadratic) in the size of the target
transducer.

Theorem 4. OSLFIA identifies the k-OSL functions
in polynomial time and data.

Proof. Immediate from Lemmas 6, 7, 8, and 9.

We conclude this section by comparing this result
to other subsequential function-learning algorithms.

OSTIA (Oncina et al., 1993) is a state-merging
algorithm which can identify the class of total sub-
sequential functions in cubic time. (Partial subse-
quential functions cannot be learned exactly; for a
partial function, OSTIA will learn some superset of
it.) k-OSL functions include both partial and total
functions, so the classes exactly learnable by OSTIA
and OSLFIA are, strictly speaking, incomparable.

SOSFIA (Jardine et al., 2014) identifies sub-
classes of subsequential functions in linear time and
data. These subclasses are determined by fixing the
structure of a transducer in advance. For every in-
put string, SOSFIA knows exactly which state in the
transducer is reached. The sole carrier of informa-
tion regarding reached states is the input string. But
for k-OSL functions, the output strings carry the in-
formation about the states reached. As the theorems
demonstrate, the destination of a transition is only
determined by the output of the transition. Thus no
class learned by SOSFIA contains any k-OSL class.

OSTIA-D (OSTIA-R) (Oncina and Varò, 1996;
Castellanos et al., 1998) identify a class of subse-
quential functions with a given domain D (range R)

in at least cubic time because it adds steps to OSTIA
to prevent merging states that would result in a trans-
ducer whose domain (range) is not compatible with
D (R). OSTIA-D cannot represent k-OSL functions
for the same reasons SOSFIA cannot: domain in-
formation is about input strings, not output strings.
On the other hand, the range of a k-OSL function
is a k-OSL stringset which can be represented with
a single acceptor, and thus OSL functions may be
learned by OSTIA-R. However, OSLFIA is more ef-
ficient both in time and data.3

To sum up, OSLFIA is the most efficient algo-
rithm for learning k-OSL functions.

7 Phonology

The example of Johore Malay nasal spreading given
in §2 is an example of progressive spreading, since
it proceeds from a triggering segment (the nasal) to
vowels and glides that follow it. There also exist
regressive spreading processes, in which the trigger
follows the target(s). An example from the Mòbà di-
alect of Yoruba (Ajı́bóyè, 2001; Ajı́bóyè and Pulley-
blank, 2008; Walker, 2014) is shown in (2). An un-
derlying nasalized vowel spreads its nasality to pre-
ceding oral vowels and glides.

(2) /ujĩ/ 7→ [ũj̃ĩ], ‘praise(n.)’
The difference between progressive and regressive
spreading corresponds to reading the input from left-
to-right or right-to-left, respectively (Heinz and Lai,
2013). Regressive spreading cannot be modeled
with OSL in a left-to-right fashion, because the out-
put of the preceding vowels and glides depends on
the presence or absence of a following nasal that
could be an unbounded number of segments away.
By reading from right-to-left, that nasal trigger will
always be read before the target(s), making it akin to
progressive spreading. Thus there are two overlap-
ping but non-identical classes, which we call left(-
to-right) OSL and right(-to-left) OSL.

There are other types of phonological maps that
are neither ISL nor OSL. Consider the optional pro-
cess of French @-deletion shown in (3) (Dell, 1973;
Dell, 1980; Dell, 1985; Noske, 1993).

3To our knowledge no analysis of data complexity for OS-
TIA, OSTIA-D, and OSTIA-R has been completed (probably
because they predate de la Higuera (1997)). Also, an analysis
of the data complexity of OSTIA appears daunting.

122



(3) @→ ∅ / VC CV
At issue is how this rule applies. There are two
licit pronunciations of /ty d@v@nE/ ‘you became’
which are [ty dv@nE] and [ty d@vnE]. The form
*[ty dvnE] is considered ungrammatical. As Ka-
plan and Kay (1994) explain, these outputs can be
understood as the rule in (3) applying left-to-right
([ty dv@nE]), right-to-left ([ty dv@nE]) or simultane-
ously (*[ty dvnE]). What matters is whether the left
and right contexts of the rule match the input or out-
put string: if both match the input it is simultaneous
application, and if one side matches the input and
the other the output it is left-to-right or right-to-left.

ISL functions always match contexts against the
input and therefore they cannot model @-deletion. In
this respect, ISL functions model simultaneous rule
application. But there is also a problem with mod-
eling the process as OSL, which is what to output
when the @ that will be deleted is read. Consider the
input VC@CV. When the DSFST reads the @, it can-
not decide what to output, because whether or not
that @ is deleted depends on whether or not the next
two symbols in the input are CV. But since the DS-
FST is deterministic, it must make a decision at this
point. It could postpone the decision and output λ.
But that would require it to loop at the current state
(Lemma 2), which in turn means it cannot distin-
guish VC@CV from VC@@@CV, a significant problem
since only the former meets the context for deletion.

Thus the range of phonological processes that can
be modeled with OSL functions is limited to those
with one-sided contexts (e.g., either C or D, the
former being left OSL and the latter right OSL). In
such cases the entire triggering context will be read
before the potential target, so there is never a need to
delay the decision about what to output. To summa-
rize, phonological rules that apply simultaneously
are ISL, and phonological rules with one-sided con-
texts that apply left-to-right or right-to-left are OSL.

In addition to iterative rules with two-sided con-
texts, long-distance processes like vowel harmony
and consonant agreement and dissimilation are also
excluded from the current analysis. While such
process have been shown to be subsequential and
therefore subregular (see Gainor et al. (2012; Luo
(2014; Payne (2013; Heinz and Lai (2013)) they are
neither ISL nor OSL because the target and trigger-

ing context are not within a fixed window of length
k in either the input or output. An example is the
long-distance nasal assimilation process in Kikongo
(Rose and Walker, 2004), as in (4).

(4) /tu+nik+idi/ 7→ [tunikini] ‘we ground’
In Kikongo, the alveolar stop in the suffix /-idi/ sur-
faces as a nasal when joined to a stem containing a
nasal. Since stem nasals appear to occur arbitrarily
far from the suffix, there is no k such that the target
/d/ and the trigger /n/ are within a window of size k.
Thus the process is neither ISL nor OSL.

8 Future Work

Processes like French @-deletion that have two-sided
contexts, with one being on the output side, sug-
gest a class that combines the ISL and OSL prop-
erties. We are tentatively calling this class ‘Input-
Output SL’ and are currently working on its prop-
erties, FST characterization, and learning algorithm.
For long-distance processes, we expect other func-
tional subclasses will strongly characterize these.
SL stringsets are just one region of the Subregular
Hierarchy (Rogers and Pullum, 2011; Rogers et al.,
2013), so we expect functional counterparts of the
other regions can be defined. Some of these other
regions model long-distance phonotactics (Heinz,
2007; Heinz, 2010; Rogers et al., 2010), so their
functional counterparts may prove equally useful for
modeling and learning long-distance phonology.

9 Conclusion

We have defined a subregular class of func-
tions called the OSL functions and provided both
language-theoretic and automata-theoretic charac-
terizations. The structure of this class is sufficient to
allow any k-OSL function to be efficiently learned
from positive data. It was shown that the OSL
functions—unlike the ISL functions—can model lo-
cal iterative spreading processes. Future work will
aim to combine the results for both ISL and OSL to
model iterative processes with two-sided contexts.

Acknowledgments

We thank three reviewers for useful comments, es-
pecially the third, who caught a significant error in
the first version of this paper.

123



References

Oládiı́pò Ajı́bóyè and Douglas Pulleyblank. 2008. Mòbà
nasal harmony. Ms., University of Lagos and Univer-
sity of British Columbia.

Oládiı́pò Ajı́bóyè. 2001. Nasalization in Mòbà. In Suny-
oung Oh, Naomi Sawai, Kayono Shiobara, and Rachel
Wojdak, editors, Proceedings of the Northwest Lin-
guistics Conference, pages 1–18. University of British
Columbia Working Papers in Linguistics 8. Vancou-
ver: University of British Columbia, Department of
Linguistics.

William Bennett. 2013. Dissimilation, Consonant Har-
mony, and Surface Correspondence. Ph.D. thesis, Rut-
gers.

Antonio Castellanos, Enrique Vidal, Miguel A. Varó, and
José Oncina. 1998. Language understanding and sub-
sequential transducer learning. Computer Speech and
Language, 12:193–228.

Jane Chandlee and Jeffrey Heinz. 2012. Bounded copy-
ing is subsequential: Implications for metathesis and
reduplication. In Proceedings of the 12th Meeting
of the ACL Special Interest Group on Computational
Morphology and Phonology, pages 42–51, Montreal,
Canada, June. Association for Computational Linguis-
tics.

Jane Chandlee and Jeffrey Heinz. to appear. Strictly lo-
cal phonological processes. Linguistic Inquiry,. under
revision.

Jane Chandlee, Angeliki Athanasopoulou, and Jeffrey
Heinz. 2012. Evidence for classifying metathesis pat-
terns as subsequential. In The Proceedings of the 29th
West Coast Conference on Formal Linguistics, pages
303–309. Cascadilla Press.

Jane Chandlee, Rémi Eyraud, and Jeffrey Heinz. 2014.
Learning strictly local subsequential functions. Trans-
actions of the Association for Computational Linguis-
tics, 2:491–503, November.

Jane Chandlee. 2014. Strictly Local Phonological Pro-
cesses. Ph.D. thesis, The University of Delaware.

Noam Chomsky and Morris Halle. 1968. The Sound
Pattern of English. New York: Harper & Row.

Colin de la Higuera. 1997. Characteristic sets for
polynomial grammatical inference. Machine Learning
Journal, 27:125–138.

François Dell. 1973. Les régles et les sons. Paris: Her-
mann.

François Dell. 1980. Generative phonology and French
phonology. Cambridge: Cambridge University Press.

François Dell. 1985. Les régles et les sons. Paris: Her-
mann, 2 edition.

Jason Eisner. 2003. Simpler and more general minimiza-
tion for weighted finite-state automata. In Proceedings

of the Joint Meeting of the Human Language Technol-
ogy Conference and the North American Chapter of
the Association for Computational Linguistics (HLT-
NAACL 2003), pages 64–71.

Robert Frank and Giorgo Satta. 1998. Optimality Theory
and the generative complexity of constraint violability.
Computational Linguistics, 24(2):307–315.

Brian Gainor, Regine Lai, and Jeffrey Heinz. 2012.
Computational characterizations of vowel harmony
patterns and pathologies. In Jaehoon Choi, E. Alan
Hogue, Jeffrey Punske, Deniz Tat, Jessamyn Schertz,
and Alex Trueman, editors, WCCFL 29: Proceedings
of the 29th West Coast Conference on Formal Linguis-
tics, pages 63–71, Somerville, MA. Cascadilla.

E.Mark Gold. 1967. Language identification in the limit.
Information and Control, 10:447–474.

Thomas Graf. 2010. Logics of phonological reasoning.
Master’s thesis, University of California, Los Angeles.

Gunnar Hansson. 2010. Consonant Harmony: Long-
Distance Interaction in Phonology. Number 145 in
University of California Publications in Linguistics.
University of California Press, Berkeley, CA. Avail-
able on-line (free) at eScholarship.org.

Jeffrey Heinz and Regine Lai. 2013. Vowel harmony
and subsequentiality. In Andras Kornai and Marco
Kuhlmann, editors, Proceedings of the 13th Meeting
on the Mathematics of Language (MoL 13), pages 52–
63, Sofia, Bulgaria.

Jeffrey Heinz. 2007. The Inductive Learning of Phono-
tactic Patterns. Ph.D. thesis, University of California,
Los Angeles.

Jeffrey Heinz. 2009. On the role of locality in learning
stress patterns. Phonology, 26(2):303–351.

Jeffrey Heinz. 2010. Learning long-distance phonotac-
tics. Linguistic Inquiry, 41(4):623–661.

Adam Jardine, Jane Chandlee, Rémi Eyraud, and Jef-
frey Heinz. 2014. Very efficient learning of struc-
tured classes of subsequential functions from positive
data. In Alexander Clark, Makoto Kanazawa, and Ryo
Yoshinaka, editors, Proceedings of the Twelfth Inter-
national Conference on Grammatical Inference (ICGI
2014), volume 34, pages 94–108. JMLR: Workshop
and Conference Proceedings, September.

Adam Jardine. 2014. Computationally, tone is different.
Under review with Phonology.

C. Douglas Johnson. 1972. Formal Aspects of Phonolog-
ical Description. The Hague: Mouton.

Ronald Kaplan and Martin Kay. 1994. Regular models
of phonological rule systems. Computational Linguis-
tics, 20(3):331–378.

Michael Kenstowicz and Charles Kisseberth. 1979. Gen-
erative Phonology. Academic Press, Inc.

124



Huan Luo. 2014. Long-distance consonant harmony and
subsequantiality. Qualifying paper for the University
of Delaware’s Linguistics PhD Progam.

Robert McNaughton and Seymour Papert. 1971.
Counter-Free Automata. MIT Press.

Mehryar Mohri. 1997. Finite-state transducers in lan-
guage and speech processing. Computational Linguis-
tics, 23(2):269–311.

Andrew Nevins. 2010. Locality in Vowel Harmony. MIT
Press.

Roland Noske. 1993. A theory of syllabification and seg-
mental alternation. Niemeyer, Tübingen.

David Odden. 2014. Introducing Phonology. Cam-
bridge University Press, 2nd edition.

Jose Oncina and Pedro Garcia. 1991. Inductive learning
of subsequential functions. Technical Report DSIC II-
34, University Politécnia de Valencia.

José Oncina and Miguel A. Varò. 1996. Using do-
main information during the learning of a subsequen-
tial transducer. Lecture Notes in Artificial Intelligence,
pages 313–325.

José Oncina, Pedro Garcı́a, and Enrique Vidal. 1993.
Learning subsequential transducers for pattern recog-
nition tasks. IEEE Transactions on Pattern Analysis
and Machine Intelligence, 15:448–458, May.

Farid M. Onn. 1980. Aspects of Malay Phonology and
Morphology: A Generative Approach. Kuala Lumpur:
Universiti Kebangsaan Malaysia.

Amanda Payne. 2013. Dissimilation as a subsequen-
tial process. Qualifying paper for the University of
Delaware’s Linguistics PhD Progam.

James Rogers and Geoffrey Pullum. 2011. Aural pattern
recognition experiments and the subregular hierarchy.
Journal of Logic, Language and Information, 20:329–
342.

James Rogers, Jeffrey Heinz, Gil Bailey, Matt Edlefsen,
Molly Visscher, David Wellcome, and Sean Wibel.
2010. On languages piecewise testable in the strict
sense. In Christian Ebert, Gerhard Jäger, and Jens
Michaelis, editors, The Mathematics of Language, vol-
ume 6149 of Lecture Notes in Artifical Intelligence,
pages 255–265. Springer.

James Rogers, Jeffrey Heinz, Margaret Fero, Jeremy
Hurst, Dakotah Lambert, and Sean Wibel. 2013. Cog-
nitive and sub-regular complexity. In Glyn Morrill
and Mark-Jan Nederhof, editors, Formal Grammar,
volume 8036 of Lecture Notes in Computer Science,
pages 90–108. Springer.

Sharon Rose and Rachel Walker. 2004. A typology of
consonant agreement as correspondence. Language,
80:475–531.

Jaques Sakarovitch. 2009. Elements of Automata The-
ory. Cambridge University Press. Translated by

Reuben Thomas from the 2003 edition published by
Vuibert, Paris.

Keiichiro Suzuki. 1998. A Typological Investigation of
Dissimilation. Ph.D. thesis, University of Arizona.

Wolfgang Thomas. 1997. Languages, automata, and
logic. volume 3, chapter 7. Springer.

Rachel Walker. 2011. Vowel Patterns in Language.
Cambridge: Cambridge University Press.

Rachel Walker. 2014. Nonlocal trigger-target relations.
Linguistic Inquiry, 45(3):501–523.

125


