








































The Galactic Dependencies Treebanks:
Getting More Data by Synthesizing New Languages

Dingquan Wang and Jason Eisner
Department of Computer Science, Johns Hopkins University

{wdd,eisner}@jhu.edu

Abstract

We release Galactic Dependencies 1.0—a
large set of synthetic languages not found on
Earth, but annotated in Universal Dependen-
cies format. This new resource aims to pro-
vide training and development data for NLP
methods that aim to adapt to unfamiliar lan-
guages. Each synthetic treebank is produced
from a real treebank by stochastically permut-
ing the dependents of nouns and/or verbs to
match the word order of other real languages.
We discuss the usefulness, realism, parsabil-
ity, perplexity, and diversity of the synthetic
languages. As a simple demonstration of the
use of Galactic Dependencies, we consider
single-source transfer, which attempts to parse
a real target language using a parser trained
on a “nearby” source language. We find that
including synthetic source languages some-
what increases the diversity of the source pool,
which significantly improves results for most
target languages.

1 Motivation

Some potential NLP tasks have very sparse data by
machine learning standards, as each of the IID train-
ing examples is an entire language. For instance:

• typological classification of a language on var-
ious dimensions;
• adaptation of any existing NLP system to new,

low-resource languages;
• induction of a syntactic grammar from text;
• discovery of a morphological lexicon from text;
• other types of unsupervised discovery of lin-

guistic structure.

Given a corpus or other data about a language,
we might aim to predict whether it is an SVO lan-
guage, or to learn to pick out its noun phrases. For
such problems, a single training or test example cor-
responds to an entire human language.

Unfortunately, we usually have only from 1 to 40
languages to work with. In contrast, machine learn-
ing methods thrive on data, and recent AI successes
have mainly been on tasks where one can train richly
parameterized predictors on a huge set of IID (input,
output) examples. Even 7,000 training examples—
one for each language or dialect on Earth—would be
a small dataset by contemporary standards.

As a result, it is challenging to develop systems
that will discover structure in new languages in the
same way that an image segmentation method, for
example, will discover structure in new images. The
limited resources even make it challenging to de-
velop methods that handle new languages by un-
supervised, semi-supervised, or transfer learning.
Some such projects evaluate their methods on new
sentences of the same languages that were used to
develop the methods in the first place—which leaves
one worried that the methods may be inadvertently
tuned to the development languages and may not be
able to discover correct structure in other languages.
Other projects take care to hold out languages for
evaluation (Spitkovsky, 2013; Cotterell et al., 2015),
but then are left with only a few development lan-
guages on which to experiment with different unsu-
pervised methods and their hyperparameters.

If we had many languages, then we could develop
better unsupervised language learners. Even better,
we could treat linguistic structure discovery as a su-
pervised learning problem. That is, we could train
a system to extract features from the surface of a
language that are predictive of its deeper structure.
Principles & Parameters theory (Chomsky, 1981)
conjectures that such features exist and that the ju-
venile human brain is adapted to extract them.

Our goal in this paper is to release a set of about
50,000 high-resource languages that could be used
to train supervised learners, or to evaluate less-
supervised learners during development. These “un-
earthly” languages are intended to be at least sim-

491

Transactions of the Association for Computational Linguistics, vol. 4, pp. 491–505, 2016. Action Editor: Joakim Nivre.
Submission batch: 5/2016; Revision batch: 7/2016; Published 9/2016.

c©2016 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.



ilar to possible human languages. As such, they
provide useful additional training and development
data that is slightly out of domain (reducing the
variance of a system’s learned parameters at the
cost of introducing some bias). The initial release
as described in this paper (version 1.0) is avail-
able at https://github.com/gdtreebank/
gdtreebank. We plan to augment this dataset in
future work (§8).

In addition to releasing thousands of treebanks,
we provide scripts that can be used to “translate”
other annotated resources into these synthetic lan-
guages. E.g., given a corpus of English sentences la-
beled with sentiment, a researcher could reorder the
words in each English sentence according to one of
our English-based synthetic languages, thereby ob-
taining labeled sentences in the synthetic language.

2 Related Work

Synthetic data generation is a well-known trick
for effectively training a large model on a small
dataset. Abu-Mostafa (1995) reviews early work
that provided “hints” to a learning system in the
form of virtual training examples. While datasets
have grown in recent years, so have models: e.g.,
neural networks have many parameters to train.
Thus, it is still common to create synthetic train-
ing examples—often by adding noise to real inputs
or otherwise transforming them in ways that are
expected to preserve their labels. Domains where
it is easy to exploit these invariances include im-
age recognition (Simard et al., 2003; Krizhevsky
et al., 2012), speech recognition (Jaitly and Hinton,
2013; Cui et al., 2015), information retrieval (Vilares
et al., 2011), and grammatical error correction (Ro-
zovskaya and Roth, 2010).

Synthetic datasets have also arisen recently for se-
mantic tasks in natural language processing. bAbI
is a dataset of facts, questions, and answers, gen-
erated by random simulation, for training machines
to do simple logic (Weston et al., 2016). Hermann
et al. (2015) generate reading comprehension ques-
tions and their answers, based on a large set of news-
summarization pairs, for training machine readers.
Serban et al. (2016) used RNNs to generate 30 mil-
lion factoid questions about Freebase, with answers,
for training question-answering systems. Wang et al.

(2015) obtain data to train semantic parsers in a new
domain by first generating synthetic (utterance, log-
ical form) pairs and then asking human annotators to
paraphrase the synthetic utterances into more natural
human language.

In speech recognition, morphology-based “vocab-
ulary expansion” creates synthetic word forms (Ra-
sooli et al., 2014; Varjokallio and Klakow, 2016).

Machine translation researchers have often tried
to automatically preprocess parse trees of a source
language to more closely resemble those of the tar-
get language, using either hand-crafted or automati-
cally extracted rules (Dorr et al., 2002; Collins et al.,
2005, etc.; see review by Howlett and Dras, 2011).

3 Synthetic Language Generation

A treebank is a corpus of parsed sentences of some
language. We propose to derive each synthetic tree-
bank from some real treebank. By manipulating
the existing parse trees, we obtain a useful cor-
pus for our synthetic language—a corpus that is
already tagged, parsed, and partitioned into train-
ing/development/test sets. Additional data in the
synthetic language can be obtained, if desired, by
automatically parsing additional real-language sen-
tences and manipulating these trees in the same way.

3.1 Method
We begin with the Universal Dependencies collec-
tion version 1.2 (Nivre et al., 2015, 2016),1 or UD.
This provides manually edge-labeled dependency
treebanks in 37 real languages, in a consistent style
and format—the Universal Dependencies format.
An example appears in Figure 1.

In this paper, we select a substrate language S
represented in the UD treebanks, and systematically
reorder the dependents of some nodes in the S trees,
to obtain trees of a synthetic language S′.

Specifically, we choose a superstrate language
RV, and write S′ = S[RV/V] to denote a (projective)
synthetic language obtained from S by permuting
the dependents of verbs (V) to match the ordering
statistics of the RV treebanks. We can similarly per-
mute the dependents of nouns (N).2 This permutes

1http://universaldependencies.org
2In practice, this means applying a single permutation model

to permute the dependents of every word tagged as NOUN (com-
mon noun), PROPN (proper noun), or PRON (pronoun).

492

https://github.com/gdtreebank/gdtreebank
https://github.com/gdtreebank/gdtreebank
http://universaldependencies.org


∗ DET NOUN PROPN VERB VERB DET ADJ NOUN ADV PUNCT
ROOT Every move Google makes brings this particular future closer .

det

nsubj

nsubj

acl:rel

root

det

amod

dobj

advmod

punct

Language Sentence
English Every move Google makes brings this particular future closer.
English[French/N] Every move Google makes brings this future particular closer.
English[Hindi/V] Every move Google makes this particular future closer brings.
English[French/N, Hindi/V] Every move Google makes this future particular closer brings.

Figure 1: The original UD tree for a short English sentence, and its “translations” into three synthetic languages,
which are obtained by manipulating the tree. (Moved constituents are underlined.) Each language has a different
distribution over surface part-of-speech sequences.

about 93% of S’s nodes (Table 2), as UD treats ad-
positions and conjunctions as childless dependents.

For example, English[French/N, Hindi/V] is a syn-
thetic language based on an English substrate, but
which adopts subject-object-verb (SOV) word order
from the Hindi superstrate and noun-adjective word
order from the French superstrate (Figure 1). Note
that it still uses English lexical items.

Our terms “substrate” and “superstrate” are bor-
rowed from the terminology of creoles, although
our synthetic languages are unlike naturally oc-
curring creoles. Our substitution notation S′ =
S[RN/N, RV/V] is borrowed from the logic and pro-
gramming languages communities.

3.2 Discussion

There may be more adventurous ways to manufac-
ture synthetic languages (see §8 for some options).
However, we emphasize that our current method is
designed to produce fairly realistic languages.

First, we retain the immediate dominance struc-
ture and lexical items of the substrate trees, alter-
ing only their linear precedence relations. Thus each
sentence remains topically coherent; nouns continue
to be distinguished by case according to their role
in the clause structure; wh-words continue to c-
command gaps; different verbs (e.g., transitive vs.
intransitive) continue to be associated with differ-
ent subcategorization frames; and so on. These im-

portant properties would not be captured by a sim-
ple context-free model of dependency trees, which
is why we modify real sentences rather than gen-
erating new sentences from such a model. In ad-
dition, our method obviously preserves the basic
context-free properties, such as the fact that verbs
typically subcategorize for one or two nominal ar-
guments (Naseem et al., 2010).

Second, by drawing on real superstrate languages,
we ensure that our synthetic languages use plausible
word orders. For example, if RV is a V2 language
that favors SVO word order but also allows OVS,
then S′ will match these proportions. Similarly, S′

will place adverbs in reasonable positions with re-
spect to the verb.

We note, however, that our synthetic languages
might violate some typological universals or typo-
logical tendencies. For example, RV might pre-
scribe head-initial verb orderings while RN pre-
scribes head-final noun orderings, yielding an un-
usual language. Worse, we could synthesize a lan-
guage that uses free word order (from RV) even
though nouns (from S) are not marked for case.
Such languages are rare, presumably for the func-
tionalist reason that sentences would be too ambigu-
ous. One could automatically filter out such an im-
plausible language S′, or downweight it, upon dis-
covering that a parser for S′ was much less accurate
on held-out data than a comparable parser for S.

493



We also note that our reordering method (§4) does
ignore some linguistic structure. For example, we
do not currently condition the order of the depen-
dent subtrees on their heaviness or on the length of
resulting dependencies, and thus we will not faith-
fully model phenomena like heavy-shift (Hawkins,
1994; Eisner and Smith, 2010). Nor will we model
the relative order of adjectives. We also treat all
verbs interchangeably, and thus use the same word
orders—drawn fromRV—for both main clauses and
embedded clauses. This means that we will never
produce a language like German (which uses V2
order in main clauses and SOV order in embedded
clauses), even if RV = German. All of these prob-
lems could be addressed by enriching the features
that are described in the next section.

4 Modeling Dependent Order

Let X be a part-of-speech tag, such as Verb.
To produce a dependency tree in language S′ =
S[RX/X], we start with a projective dependency
tree in language S.3 For each node x in the tree that
is tagged with X , we stochastically select a new or-
dering for its dependent nodes, including a position
in this ordering for the head x itself. Thus, if node x
has n − 1 dependents, then we must sample from a
probability distribution over n! orderings.

Our job in this section is to define this probabil-
ity distribution. Using π = (π1, . . . , πn) to denote
an ordering of these n nodes, we define a log-linear
model over the possible values of π:

pθ(π | x) =
1

Z(x)
exp

∑

1≤i<j≤n
θ · f(π, i, j) (1)

Here Z(x) is the normalizing constant for node x.
θ is the parameter vector of the model. f extracts a
sparse feature vector that describes the ordered pair
of nodes πi, πj , where the ordering π would place πi
to the left of πj .

4.1 Efficient sampling
To sample exactly from the distribution pθ,4 we
must explicitly compute all n! unnormalized prob-

3Our method can only produce projective trees. This is be-
cause it recursively generates a node’s dependent subtrees, one
at a time, in some chosen order. Thus, to be safe, we only apply
our method to trees that were originally projective. See §8.

4We could alternatively have used MCMC sampling.

abilities and their sum Z(x).
Fortunately, we can compute each unnormalized

probability in just O(1) amortized time, if we enu-
merate the n! orderings π using the Steinhaus-
Johnson-Trotter algorithm (Sedgewick, 1977). This
enumeration sequence has the property that any two
consecutive permutations π, π′ differ by only a sin-
gle swap of some pair of adjacent nodes. Thus their
probabilities are closely related: the sum in equa-
tion (1) can be updated in O(1) time by subtracting
θ · f(π, i, i+1) and adding θ · f(π′, i, i+1) for some
i. The other O(n2) summands are unchanged.

In addition, if n ≥ 8, we avoid this computation
by omitting the entire tree from our treebank; so we
have at most 7! = 5040 summands.

4.2 Training parameters on a real language
Our feature functions (§4.4) are fixed over all lan-
guages. They refer to the 17 node labels (POS tags)
and 40 edge labels (dependency relations) that are
used consistently throughout the UD treebanks.

For each UD language L and each POS tag X ,
we find parameters θLX that globally maximize the
unregularized log-likelihood:

θLX = argmax
θ

∑

x

log pθ(πx | x) (2)

Here x ranges over all nodes tagged with X in the
projective training trees of the L treebank, omitting
nodes with n ≥ 7 for speed.

The expensive part of this computation is the gra-
dient of logZ(x), which is an expected feature vec-
tor. To compute this expectation efficiently, we
again take care to loop over the permutations in
Steinhaus-Johnson-Trotter order.

A given language L may not use all of the tags
and relations. Universal features that mention un-
used tags or relations do not affect (2), and their
weights remain at 0 during training.

4.3 Setting parameters of a synthetic language
We use (1) to permute the X nodes of substrate lan-
guage S into an order resembling superstrate lan-
guage RX . In essence, this applies the RX order-
ing model to out-of-domain data, since the X nodes
may have rather different sets of dependents in the S
treebank than in the RX treebank. We mitigate this
issue in two ways.

494



First, our ordering model (1) is designed to be
more robust to transfer than, say, a Markov model.
The position of each node is influenced by all n− 1
other nodes, not just by the two adjacent nodes. As
a result, the burden of explaining the ordering is dis-
tributed over more features, and we hope some of
these features will transfer to S. For example, sup-
pose RX lacks adverbs and yet we wish to use θ

RX
X

to permute a sequence of S that contains adverbs.
Even though the resulting order must disrupt some
familiar non-adverb bigrams by inserting adverbs,
other features—which consider non-adjacent tags—
will still favor anRX -like order for the non-adverbs.

Second, we actually sample the reordering from a
distribution pθ with an interpolated parameter vector

θ = θS
′

X = (1− λ)θRXX + λθSX ,

where λ = 0.05. This gives a weighted product of
experts, in which ties are weakly broken in favor of
the substrate ordering. (Ties arise when RX is unfa-
miliar with some tags that appear in S, e.g., adverb.)

4.4 Feature Templates
We write ti for the POS tag of node πi, and ri for
the dependency relation of πi to the head node. If πi
is itself the head, then necessarily ti = X ,5 and we
specially define ri = head.

In our feature vector f(π, i, j), the features with
the following names have value 1, while all others
have value 0:

• L.ti.ri and L.ti and L.ri, provided that rj =
head. For example, L.ADJ will fire on each
ADJ node to the left of the head.

• L.ti.ri.tj.rj and L.ti.tj and L.ri.rj , pro-
vided that ri 6= head, rj 6= head. These fea-
tures detect the relative order of two siblings.

• d.ti.ri.tj .rj , d.ti.tj , and d.ri.rj , where d is
l (left), m (middle), or r (right) according to
whether the head position h satisfies i < j < h,
i < h < j, or h < i < j. For example,
l.nsubj.dobj will fire on SOV clauses.
This is a specialization of the previous feature,
and is skipped if i = h or j = h.

5Recall that for each head POS X of language L, we learn
a separate ordering model with parameter vector θLX .

• A.ti.ri.tj.rj and A.ti.tj and A.ri.rj , pro-
vided that j = i + 1. These “bigram fea-
tures” detect two adjacent nodes. For this fea-
ture and the next one, we extend the summa-
tion in (1) to allow 0 ≤ i < j ≤ n + 1, tak-
ing t0 = r0 = BOS (“beginning of sequence”)
and tn+1 = rn+1 = EOS (“end of sequence”).
Thus, a bigram feature such as A.DET.EOS
would fire on DET when it falls at the end of
the sequence.

• H.ti.ri.ti+1.ri+1.....tj.rj , provided that
i+2 ≤ j ≤ i+4. Among features of this form,
we keep only the 10% that fire most frequently
in the training data. These “higher-order k-
gram” features memorize sequences of lengths
3 to 5 that are common in the language.

Notice that for each non-H feature that mentions
both tags t and relations r, we also defined two
backoff features, omitting the t fields or r fields re-
spectively.

Using the example from Figure 1, for subtree

DET ADJ NOUN
this particular future

det

amod

the features that fire are

Template Features
L.ti.ri L.DET.det, L.ADJ.amod
L.ti.ri.tj.rj L.DET.det.ADJ.amod
d.ti.ri.tj.rj l.DET.det.ADJ.amod
A.t1.r1.t2.r2 A.BOS.BOS.DET.det,

A.DET.det.ADJ.amod,
A.ADJ.amod.NOUN.head,
A.NOUN.head.EOS.EOS

plus backoff features and H features (not shown).

5 The Resource

In Galactic Dependencies v1.0, or GD, we release
real and synthetic treebanks based on UD v1.2. Each
synthetic treebank is a modified work that is freely
licensed under the same CC or GPL license as its
substrate treebank. We provide all languages of the
form S, S[RV/N], S[RN/V], and S[RN/N, RV/V],
where the substrate S and the superstrates RN and

495



Train Dev Test
cs, es, fr, hi,
de, it, la itt,
no, ar, pt

en, nl, da, fi,
got, grc, et,
la proiel,
grc proiel, bg

la, hr, ga, he,
hu, fa, ta, cu,
el, ro, sl,
ja ktc, sv,
fi ftb, id, eu, pl

Table 1: The 37 real UD languages. Following the usual
setting of rich-to-poor transfer, we take the 10 largest
non-English languages (left column) as our pool of real
source languages, which we can combine to synthesize
new languages. The remaining languages are our low-
resource target languages. We randomly hold out 17 non-
English languages (right column) as the test languages
for our final result table. During development, we studied
and graphed performance on the remaining 10 languages
(middle column)—including English for interpretability.

RV each range over the 37 available languages.
(RN = S orRV = S gives “self-permutation”). This
yields 37× 38× 38 = 53, 428 languages in total.

Each language is provided as a directory of 3
files: training, development, and test treebanks. The
directories are systematically named: for example,
English[French/N, Hindi/V] can be found in direc-
tory en∼fr@N∼hi@V.

Our treebanks provide alignment information, to
facilitate error analysis as well as work on machine
translation. Each word in a synthetic sentence is an-
notated with its original position in the substrate sen-
tence. Thus, all synthetic treebanks derived from the
same substrate treebank are node-to-node aligned to
the substrate treebank and hence to one another.

In addition to the generated data, we also pro-
vide the parameters θLX of our ordering models; code
for training new ordering models; and code for pro-
ducing new synthetic trees and synthetic languages.
Our code should produce reproducible results across
platforms, thanks to Java’s portability and our stan-
dard random number seed of 0.

6 Exploratory Data Analysis

How do the synthetic languages compare to the real
ones? For analysis and experimentation, we parti-
tion the real UD languages into train/dev/test (Ta-
ble 1). (This is orthogonal to the train/dev/test split
of each language’s treebank.) Table 2 shows some
properties of the real training languages.

In this section and the next, we use the Yara

lang sents tokens T UAS R
ar 4K / 6K 119K / 226K 85% 72% / 69% 0.37
cs 5K / 7K 687K / 1173K 94% 81% / 78% 0.38
de 9K / 14K 136K / 270K 94% 84% / 80% 0.47
es 10K / 14K 211K / 382K 94% 85% / 82% 0.32
fr 8K / 15K 154K / 356K 95% 86% / 84% 0.27
hi 9K / 13K 160K / 281K 96% 82% / 82% 0.20
it 9K / 12K 144K / 249K 95% 87% / 84% 0.30

la itt 7K / 15K 87K / 247K 90% 66% / 58% 0.72
no 11K / 16K 135K / 245K 93% 82% / 79% 0.31
pt 5K / 9K 87K / 202K 96% 86% / 84% 0.32

Table 2: Some statistics on the 10 real training lan-
guages. When two numbers are separated by “/”, the sec-
ond represents the full UD treebank, and the first comes
from our GD version, which discards non-projective trees
and high-fanout trees (n ≥ 8). UAS is the language’s
parsability: the unlabeled attachment score on its dev
sentences after training on its train sentences. T is the
percentage of GD tokens that are touched by reordering
(namely N, V, and their dependents). R ∈ [0, 1] measures
the freeness of the language’s word order, as the condi-
tional cross-entropy of our trained ordering model pθ rel-
ative to that of a uniform distribution: R = H(p̃,pθ)H(p̃,punif) =
meanx[− log2 pθ(π∗(x)|x)]

meanx[− log2 1/n(x)!] , where x ranges over all N and V
tokens in the dev sentences, n(x) is 1 + the number of
dependents of x, and π∗(x) is the observed ordering at x.

parser (Rasooli and Tetreault, 2015), a fast arc-eager
transition-based projective dependency parser, with
beam size of 8. We train only delexicalized parsers,
whose input is the sequence of POS tags. Parsing
accuracy is evaluated by the unlabeled attachment
score (UAS), that is, the fraction of word tokens in
held-out (dev) data that are assigned their correct
parent. For language modeling, we train simple tri-
gram backoff language models with add-1 smooth-
ing, and we measure predictive accuracy as the per-
plexity of held-out (dev) data.

Figures 2–3 show how the parsability and per-
plexity of a real training language usually get worse
when we permute it. We could have discarded low-
parsability synthetic languages, on the functionalist
grounds that they would be unlikely to survive as
natural languages anywhere in the galaxy. However,
the curves in these figures show that most synthetic
languages have parsability and perplexity within the
plausible range of natural languages, so we elected
to simply keep all of them in our collection.

An interesting exception in Figure 2 is Latin

496



Figure 2: Parsability of real versus synthetic languages
(defined as in Table 2). The upper graphs are kernel den-
sity estimates. Each lower graph is a 1-dimensional scat-
terplot, showing the parsability of some real language S
(large dot) and all its permuted versions, including the
“self-permuted” languages S[S/N] (diamond), S[S/V]
(square), and S[S/N, S/V] (medium dot).

1 2 3 4 5 6 7 8

fr

pt
no

de

it
la_itt

ar
cs

hi

es

real pos
synthetic pos
real word
synthetic word

Figure 3: Perplexity of the POS tag sequence, as well
as the word sequence, of real versus synthetic languages.
Words with count < 10 are mapped to an OOV symbol.

(la itt), whose poor parsability—at least by a delex-
icalized parser that does not look at word endings—
may be due to its especially free word order (Ta-
ble 2). When we impose another language’s more
consistent word order on Latin, it becomes more
parsable. Elsewhere, permutation generally hurts,
perhaps because a real language’s word order is
globally optimized to enhance parsability. It even
hurts slightly when we randomly “self-permute” S
trees to use other word orders that are common in S
itself! Presumably this is because the authors of the
original S sentences chose, or were required, to or-
der each constituent in a way that would enhance its
parsability in context: see the last paragraph of §3.2.

Synthesizing languages is a balancing act. The
synthetic languages are not useful if all of them are
too conservatively close to their real sources to add

de

da

en

fr
et

got

bg

grc

la_proiel

grc_proiel

cs
pt

hi

la_itt

it

ar

nl

no

es

fi

N-superstrate

V-superstrate

2 superstrates

real

Figure 4: Each point represents a language. The color
of a synthetic language is the same as its substrate lan-
guage. Dev languages are shown in black. This 2-
dimensional embedding was constructed using metric
multidimensional scaling (Borg and Groenen, 2005) on
a symmetrized version of our dissimilarity matrix (which
is not itself a metric). The embedded distances are rea-
sonably faithful to the symmetrized dissimilarities: met-
ric MDS achieves a low value of 0.20 on its “stress” ob-
jective, and we find that Kendall’s tau = 0.76, meaning
that if one pair of languages is displayed as farther apart
than another, then in over 7/8 of cases, that pair is in
fact more dissimilar. Among the real languages, note the
clustering of Italic languages (pt, es, fr, it), Germanic lan-
guages (de, no, en, nl, da), Slavic languages (cs, bg), and
Uralic languages (et, fi). Outliers are Arabic (ar), the only
Afroasiatic language here, and Hindi (hi), the only SOV
language, whose permutations are less outré than it is.

diversity—or too radically different to belong in the
galaxy of natural languages. Fortunately, we are at
neither extreme. Figure 4 visualizes a small sam-
ple of 110 languages from our collection.6 For each
ordered pair of languages (S, T ), we defined the dis-
similarity d(S, T ) as the decrease in UAS when we
parse the dev data of T using a parser trained on S
instead of one trained on T . Small dissimilarity (i.e.,
good parsing transfer) translates to small distance
in the figure. The figure shows that the permuta-
tions of a substrate language (which share its color)
can be radically different from it, as we already saw
above. Some may be unnatural, but others are sim-
ilar to other real languages, including held-out dev

6For each of the 10 real training languages, we sampled 9
synthetic languages: 3 N-permuted, 3 V-permuted and 3 {N,V}-
permuted. We also included all 10 training + 10 dev languages.

497



languages. Thus Dutch (nl) and Estonian (et) have
close synthetic neighbors within this small sample,
although they have no close real neighbors.

7 An Experiment

We now illustrate the use of GD by studying how
expanding the set of available treebanks can improve
a simple NLP method, related to Figure 4.

7.1 Single-source transfer

Dependency parsing of low-resource languages has
been intensively studied for years. A simple method
is called “single-source transfer”: parsing a target
language T with a parser that was trained on a source
language S, where the two languages are syntac-
tically similar. Such single-source transfer parsers
(Ganchev et al., 2010; McDonald et al., 2011; Ma
and Xia, 2014; Guo et al., 2015; Duong et al.,
2015; Rasooli and Collins, 2015) are not state-of-
the-art, but they have shown substantial improve-
ments over fully unsupervised grammar induction
systems (Klein and Manning, 2004; Smith and Eis-
ner, 2006; Spitkovsky et al., 2013).

It is permitted for S and T to have different vo-
cabularies. The S parser can nonetheless parse T
(as in Figure 4)—provided that it is a “delexicalized”
parser that only cares about the POS tags of the input
words. In this case, we require only that the target
sentences have already been POS tagged using the
same tagset as S: in our case, the UD tagset.

7.2 Experimental Setup

We evaluate single-source transfer when the pool
of m source languages consists of n real UD lan-
guages, plus m− n synthetic GD languages derived
by “remixing” just these real languages.7 We try var-
ious values of n and m, where n can be as large as
10 (training languages from Table 1) and m can be
as large as n× (n+ 1)× (n+ 1) ≤ 1210 (see §5).

Given a real target language T from outside the
pool, we select a single source language S from the
pool, and try to parse UD sentences of T with a
parser trained on S. We evaluate the results on T
by measuring the unlabeled attachment score (UAS),

7The m− n GD treebanks are comparatively impoverished
because—in the current GD release—they include only projec-
tive sentences (Table 2). The n UD treebanks are unfiltered.

that is, the fraction of word tokens that were as-
signed their correct parent. In these experiments
(unlike those of §6), we always evaluate fairly on
T ’s full dev or test set from UD—not just the sen-
tences we kept for its GD version (cf. Table 2).8

The hope is that a large pool will contain at least
one language—real or synthetic—that is “close” to
T . We have two ways of trying to select a source S
with this property:

Supervised selection selects the S whose parser
achieves the highest UAS on 100 training sen-
tences of language T . This requires 100 good
trees for T , which could be obtained with a modest
investment—a single annotator attempting to follow
the UD annotation standards in a consistent way on
100 sentences of T , without writing out formal T -
specific guidelines. (There is no guarantee that se-
lecting a parser on training data will choose well for
the test sentences of T . We are using a small amount
of data to select among many dubious parsers, many
of which achieve similar results on the training sen-
tences of T . Furthermore, in the UD treebanks, the
test sentences of T are sometimes drawn from a dif-
ferent distribution than the training sentences.)

Unsupervised selection selects the S whose
training sentences had the best “coverage” of the
POS tag sequences in the actual data from T that
we aim to parse. More precisely, we choose the S
that maximizes pS(tag sequences from T )—in other
words, the maximum-likelihood S—where pS is our
trigram language model for the tag sequences of S.
This approach is loosely inspired by Søgaard (2011).

7.3 Results

Our most complete visualization is Figure 5, which
we like to call the “kite graph” for its appearance.
We plot the UAS on the development treebank of T
as a function of n, m, and the selection method. As
Appendix A details, each point on this graph is actu-
ally an average over 10,000 experiments that make
random choices of T (from the UD development lan-
guages), the n real languages (from the UD train-
ing languages), and the m − n synthetic languages
(from the GD languages derived from the n real lan-

8The Yara parser can only produce projective parses. It at-
tempts to parse all test sentences of T projectively, but sadly
ignores non-projective training sentences of S (as can occur for
real S).

498



20 21 22 23 24 25 26 27 28 29 210 211

m = number of source languages

35

40

45

50

55

60

65

A
v
e
ra

g
e
 U

A
S

 (
7
1
.3

8
 s

u
p

e
rv

is
e
d

)

n = 10 real languages

n = 4 real languages

n = 2 real languages

n = 1 real languages

Figure 5: Comprehensive results for single-source trans-
fer from a pool of m languages (the horizontal axis)
synthesized from n real languages. For each color
1, 2, . . . , n, the upper dashed line shows the UAS
achieved by supervised selection; the lower solid line
shows unsupervised selection; and the shaded area high-
lights the difference. The black dashed and solid lines
connect the points where m = n, showing how rapidly
UAS increases with n when only real languages are used.

Each point is the mean dev UAS over 10,000 exper-
iments. We use paler lines in the same color and style
to show the considerable variance of these UAS scores.
These essentially delimit the interdecile range from the
10th to the 90th percentile of UAS score. However, if the
plot shows a mean of 57, an interdecile range from 53
to 61 actually means that the middle 80% of experiments
were within ±4 percentage points of the mean UAS for
their target language. (In other words, before computing
this range, we adjust each UAS score for target T by sub-
tracting the mean UAS from the experiments with target
T , and adding back the mean UAS from all 10,000 exper-
iments (e.g., 57).)

Notice that on the n = 10 curve, there is no variation
among experiments either at the minimum m (where the
pool always consists of all 10 real languages) or at the
maximum m (where the pool always consists of all 1210
galactic languages).

guages). We see from the black lines that increas-
ing the number of real languages n is most benefi-
cial. But crucially, when n is fixed in practice, grad-
ually increasing m by remixing the real languages
does lead to meaningful improvements. This is true
for both selection methods. Supervised selection is
markedly better than unsupervised.

23 24 25 26 27 28 29 210 211
0.0

0.2

0.4

0.6

0.8

1.0
n = 10 real languages

22 23 24 25 26 27

n = 4 real languages

21 22 23 24 25
0.0

0.2

0.4

0.6

0.8

1.0
n = 2 real languages

20 21 22

n = 1 real languages
oracle selection

supervised selection

unsupervised selection

m = number of source languages

C
h

a
n

c
e
 o

f 
se

le
c
ti

n
g

 a
 h

e
lp

fu
l 

sy
n

th
e
ti

c
 l

a
n

g
u

a
g

e

Figure 6: Chance that selecting a source from m lan-
guages achieves strictly better dev UAS than just select-
ing from the n real languages.

The “selection graph” in Figure 6 visualizes the
same experiments in a different way. Here we ask
about the fraction of experiments in which using the
full pool of m source languages was strictly bet-
ter than using only the n real languages. We find
that when m has increased to its maximum, the full
pool nearly always contains a synthetic source lan-
guage that gets better results than anything in the
real pool. After all, our generation of “random” lan-
guages is a scattershot attempt to hit the target: the
more languages we generate, the higher our chances
of coming close. However, our selection methods
only manage to pick a better language in about 60%
of those experiments.

Figure 7 offers a fine-grained look at which real
and synthetic source languages S succeeded best
when T = English. Each curve shows a differ-
ent superstrate, with the x-axis ranging over sub-
strates. (The figure omits the hundreds of synthetic
source languages that use two distinct superstrates,
RV 6= RN.) Real languages are shown as solid black
dots, and are often beaten by synthetic languages.
For comparison, this graph also plots results that
“cheat” by using English supervision.

The above graphs are evaluated on development
sentences in development languages. For our final
results, Table 3, we finally allow ourselves to try
transferring to the UD test languages, and we eval-

499



en n
o

d
e es cs i
t fr

la
_i

tt p
t h
i

ar

Substrate Language

35

40

45

50

55

60

65

70

75

80

U
A

S
 o

n
 e

n

superstrate language
fr

en

pt

no

de

it

la_itt

ar

cs

hi

es

Figure 7: UAS performance of different source parsers
when applied to English development sentences. The
x axis shows the 10 real training languages S, in de-
creasing order of their UAS performance (plotted as large
black dots). For each superstrate R, we plot a curve
showing—for each substrate S—the best UAS of the lan-
guages S[R/N], S[R/V] and S[R/N, R/V]. The points
where R = S are specially colored in black; these are in-
stances of self-permutation (§5). We also add “cheating
results” where English itself is used as the substrate (left
column) and/or the superstrate (solid black line at top).
Thus, the large black dot at the upper left is a supervised
English parser.

uate on test sentences. The comparison is similar
to the comparison in the selection graph: do the
synthetic treebanks add value? We use our largest
source pools, n = 10 and m = 1210. With super-
vised selection, selecting the source language from
the full pool of m options (not just the n real lan-
guages) tends to achieve significantly better UAS on
the target language, often dramatically so. On av-
erage, the UAS on the test languages increases by
2.3 percentage points, and this increase is statisti-
cally significant across these 17 data points. Even
with unsupervised selection, UAS still increases by
1.2 points on average, but this difference could be a
chance effect.

The results above use gold POS tag sequences for
T . These may not be available if T is a low-resource
language; see Appendix B for a further experiment.

7.4 Discussion

Many of the curves in Figures 5–6 still seem to be
increasing steadily at maximum m, which suggests

unsupervised (weakly) supervised
target real +synthetic real +synthetic
el 60.07 65.72 65.87 66.98
he 63.39 60.65 62.86 64.28
la 46.79 51.82 56.62 59.06
hr 68.69 68.89 68.69 69.11
sv 74.96 74.96 74.96 74.96
hu 56.41 64.67 56.72 66.22
fa 53.41 58.37 53.41 60.18
fi ftb 50.90 55.36 53.03 55.86
cu 54.11 57.89 54.11 59.28
ga 53.55 59.38 57.72 64.72
sl 80.41 80.41 80.41 80.41
eu 47.12 48.97 45.35 52.90
ro 66.33 68.01 71.38 69.19
ja ktc 62.51 54.04 62.51 62.49
id 63.79 61.89 65.36 65.36
pl 75.69 74.63 75.69 73.05
ta 63.15 56.20 63.15 63.15
Test Avg. 61.25 62.46 62.81 65.13
bg 79.80 74.52 79.80 79.80
nl 58.44 57.94 58.44 57.85
et 68.83 72.21 68.83 74.75
la proiel 48.50 49.66 48.50 49.66
da 71.65 71.65 71.65 70.79
en 63.37 61.37 63.37 65.43
grc 42.59 42.59 46.15 47.84
grc proiel 50.76 51.29 52.04 54.06
fi 51.28 55.21 54.46 55.21
got 54.98 57.57 54.98 58.66
All Avg. 60.43 61.33 61.71 63.75

Table 3: Our final comparison on the 17 test languages
appears in the upper part of this table. We ask whether
single-source transfer to these 17 real target languages is
improved by augmenting the source pool of 10 real lan-
guages with 1200 synthetic languages. When different
languages are selected in these two settings, we boldface
the setting with higher test UAS, or both settings if they
are not significantly different (paired permutation test by
sentence, p < 0.05). For completeness, we extend the ta-
ble with the 10 development languages. The “Avg.” lines
report the average of 17 test or 27 test+dev languages.
The two supervised-selection averages are significantly
different (paired permutation test by language, p < 0.05).

that we would benefit from finding ways to gener-
ate even more synthetic languages. Diversity of lan-
guages seems to be crucial, since adding new real
languages improves performance much faster than
remixing existing languages. This suggests that we
should explore making more extensive changes to

500



the UD treebanks (see §8).
Surprisingly, Figures 5–6 show improvements

even when n = 1. Evidently, self-permutation of a
single language introduces some useful variety, per-
haps by transporting specialized word orders (e.g.,
English still allows some limited V2 constructions)
into contexts where the source language would not
ordinarily allow them but the target language does.

Figure 5 shows why unsupervised selection is
considerably worse on average than supervised se-
lection. Its 90th percentile is comparable, but at
the 10th percentile—presumably representing ex-
periments where no good sources are available—the
unsupervised heuristic has more trouble at choos-
ing among the mediocre options. The supervised
method can actually test these options using the true
loss function.

Figure 7 is interesting to inspect. English is es-
sentially a Germanic language with French influence
due to the Norman conquest, so it is reassuring that
German and French substrates can each be improved
by using the other as a superstrate. We also see that
Arabic and Hindi are the worst source languages for
English, but that Hindi[Arabic/V] is considerably
better. This is because Hindi is reasonably similar
to English once we correct its SOV word order to
SVO (via almost any superstrate).

8 Conclusions and Future Work

This paper is the first release of a novel resource,
the Galactic Dependencies treebank collection, that
may unlock a wide variety of research opportuni-
ties (discussed in §1). Our empirical studies show
that the synthetic languages in this collection remain
somewhat natural while improving the diversity of
the collection. As a simplistic but illustrative use of
the resource, we carefully evaluated its impact on
the naive technique of single-source transfer pars-
ing. We found that performance could consistently
be improved by adding synthetic languages to the
pool of sources, assuming gold POS tags.

There are several non-trivial opportunities for im-
proving and extending our treebank collection in fu-
ture releases.

1. Our current method is fairly conservative, only
synthesizing languages with word orders already at-
tested in our small collection of real languages. This

does not increase the diversity of the pool as much
as when we add new real languages. Thus, we are
particularly interested in generating a wider range of
synthetic languages. We could condition reorderings
on the surrounding tree structure, as noted in §3.2.
We could choose reordering parameters θX more
adventurously than by drawing them from a single
known superstrate language. We could go beyond
reordering, to systematically choose what function
words (determiners, prepositions, particles), func-
tion morphemes, or punctuation symbols9 should
appear in the synthetic tree, or to otherwise alter the
structure of the tree (Dorr, 1993). These options
may produce implausible languages. To mitigate
this, we could filter or reweight our sample of syn-
thetic languages—via rejection sampling or impor-
tance sampling—so that they are distributed more
like real languages, as measured by their parsabili-
ties, dependency lengths, and estimated WALS fea-
tures (Dryer and Haspelmath, 2013).

2. Currently, our reordering method only gener-
ates projective dependency trees. We should extend
it to allow non-projective trees as well—for exam-
ple, by pseudo-projectivizing the substrate treebank
(Nivre and Nilsson, 2005) and then deprojectivizing
it after reordering.

3. The treebanks of real languages can typically
be augmented with larger unannotated corpora in
those languages (Majliš, 2011), which can be used
to train word embeddings and language models, and
can also be used for self-training and bootstrapping
methods. We plan to release comparable unanno-
tated corpora for our synthetic languages, by au-

9Our current handling of punctuation produces unnatural re-
sults, and not merely because we treat all tokens with tag PUNCT
as interchangeable. Proper handling of punctuation and capital-
ization would require more than just reordering. For example,
“Jane loves her dog, Lexie.” should reorder into
“Her dog, Lexie, Jane loves.”, which has an extra
comma and an extra capital. Accomplishing this would require
first recovering a richer tree for the original sentence, in which
the appositive Lexie is bracketed by a pair of commas and the
name Jane is doubly capitalized. These extra tokens were not
apparent in the original sentence’s surface form because the fi-
nal comma was absorbed into the adjacent period, and the start-
of-sentence capitalization was absorbed into the intrinsic capi-
talization of Jane (Nunberg, 1990). The tokenization provided
by the UD treebanks unfortunately does not attempt to undo
these orthographic processes, even though it undoes some mor-
phological processes such as contraction.

501



tomatically parsing and permuting the unnanotated
corpora of their substrate languages.

4. At present, all languages derived from an En-
glish substrate use the English vocabulary. In the
future, we plan to encipher that vocabulary sepa-
rately for each synthetic language, perhaps choosing
a cipher so that the result loosely conforms to the
realistic phonotactics and/or orthography of some
superstrate language. This would let multilingual
methods exploit lexical features without danger of
overfitting to specific lexical items that appear in
many synthetic training languages. Alphabetic ci-
phers can preserve features of words that are poten-
tially informative for linguistic structure discovery:
their cooccurrence statistics, their length and phono-
logical shape, and the sharing of substrings among
morphologically related words.

5. Finally, we note that this paper has focused on
generating a broadly reusable collection of synthetic
treebanks. For some applications (including single-
source transfer), one might wish to tailor a synthetic
language on demand, e.g., starting with one of our
treebanks but modifying it further to more closely
match the surface statistics of a given target lan-
guage (Dorr et al., 2002). In our setup, this would
involve actively searching the space of reordering
parameters, using algorithms such as gradient ascent
or simulated annealing.

We conclude by revisiting our opening point. Un-
supervised discovery of linguistic structure is diffi-
cult. We often do not know quite what function to
maximize, or how to globally maximize it. If we
could make labeled languages as plentiful as labeled
images, then we could treat linguistic structure dis-
covery as a problem of supervised prediction—one
that need not succeed on all formal languages, but
which should generalize at least to the domain of
possible human languages.

A Constructing the Kite Graph

The mean lines in the “kite graph” (Figure 5) are ac-
tually obtained by averaging 10,000 graphs. Each
of these graphs is “smooth” because it incremen-
tally adds new languages as n or m increases. Pseu-
docode to generate one such graph is given as Algo-
rithm 1; all random choices are made uniformly.

Algorithm 1 Data collection for one graph
Input: Sets T (target languages), S (real source lan-

guages), S ′ (synthetic source languages)
Output: Sets of data points Dsup, Dunsup

1: procedure COLLECTDATA
2: D ← ∅
3: Sample a target language T from T
4: L← random.shuffle(S − {T})
5: L′ ← random.shuffle(S ′)
6: for n = 1 to |L| do
7: L′′ ← a filtered version of L′ that excludes

languages with substrates or super-
strates outside {L1, . . . , Ln}

8: for n′ = 1 to |L′′| do
9: P ← {L1, . . . , Ln, L′′1 , . . . , L′′n′}

10: m← |P|
11: Dsup ← Dsup ∪

{(n,m, UASsup(P, T ))}
12: Dunsup ← Dunsup ∪

{(n,m, UASunsup(P, T ))}
13: return (Dsup, Dunsup)

B Experiment with Noisy Tags

Table 4 repeats the single-source transfer experiment
using noisy automatic POS tags for T for both parser
input and unsupervised selection. We obtained the
tags using RDRPOSTagger (Nguyen et al., 2014)
trained on just 100 gold-tagged sentences (the same
set used for supervised selection). The low tagging
accuracy does considerably degrade UAS and mud-
dies the usefulness of the synthetic sources.

tag unsupervised (weakly) superv.
target real +synth real +synth
bg 78.33 53.24 55.08 53.24 53.24
nl 71.70 39.40 38.99 42.42 42.75
et 72.88 45.19 54.81 56.07 55.09
la proiel 71.83 37.25 38.26 37.25 38.10
da 78.04 47.98 43.40 47.98 45.89
en 77.33 48.29 44.40 48.29 48.15
grc 68.80 32.15 32.15 33.52 34.36
grc proiel 72.93 42.46 41.39 43.49 44.19
fi 65.65 29.59 28.81 36.85 36.90
got 76.66 44.77 44.05 44.77 46.83
Avg. 73.42 42.03 42.13 44.39 44.55

Table 4: Tagging accuracy on the 10 dev languages, and
UAS of the selected source parser with these noisy target-
language tag sequences. The results are formatted as in
Table 3, but here all results are on dev sentences.

502



Acknowledgements This work was funded by the
U.S. National Science Foundation under Grant No.
1423276. Our data release is derived from the Uni-
versal Dependencies project, whose many selfless
contributors have our gratitude. We would also like
to thank Matt Gormley and Sharon Li for early dis-
cussions and code prototypes, Mohammad Sadegh
Rasooli for guidance on working with the Yara
parser, and Jiang Guo, Tim Vieira, Adam Teichert,
and Nathaniel Filardo for additional useful discus-
sion. Finally, we thank TACL editors Joakim Nivre
and Lillian Lee and the anonymous reviewers for
several suggestions that improved the paper.

References

Yaser S. Abu-Mostafa. Hints. Neural Computation, 7:
639–671, July 1995.

Ingwer Borg and Patrick J.F. Groenen. Modern Multidi-
mensional Scaling: Theory and Applications. 2005.

Noam Chomsky. Lectures on Government and Binding:
The Pisa Lectures. Holland: Foris Publications, 1981.

Michael Collins, Philipp Koehn, and Ivona Kucerova.
Clause restructuring for statistical machine translation.
In Proceedings of the 43rd Annual Meeting of the As-
sociation for Computational Linguistics, pages 531–
540, 2005.

Ryan Cotterell, Nanyun Peng, and Jason Eisner. Mod-
eling word forms using latent underlying morphs and
phonology. Transactions of the Association for Com-
putational Linguistics, 3:433–447, 2015.

Xiaodong Cui, Vaibhava Goel, and Brian Kingsbury.
Data augmentation for deep neural network acoustic
modeling. IEEE/ACM Transactions on Audio, Speech
and Language Processing, 23(9):1469–1477, Septem-
ber 2015. ISSN 2329-9290.

Bonnie J. Dorr. Machine Translation: A View from the
Lexicon. MIT Press, Cambridge, MA, 1993.

Bonnie J. Dorr, Lisa Pearl, Rebecca Hwa, and Nizar
Habash. DUSTer: A method for unraveling cross-
language divergences for statistical word-level align-
ment. In Proceedings of the 5th Conference of the As-
sociation for Machine Translation in the Americas on
Machine Translation: From Research to Real Users,
AMTA ’02, pages 31–43, 2002.

Matthew S. Dryer and Martin Haspelmath, editors.
The World Atlas of Language Structures Online.
Max Planck Institute for Evolutionary Anthropology,
Leipzig, 2013.

Long Duong, Trevor Cohn, Steven Bird, and Paul Cook.
Cross-lingual transfer for unsupervised dependency
parsing without parallel data. In Proceedings of the
19th Conference on Computational Natural Language
Learning, pages 113–122, 2015.

Jason Eisner and Noah A. Smith. Favor short dependen-
cies: Parsing with soft and hard constraints on depen-
dency length. In Harry Bunt, Paola Merlo, and Joakim
Nivre, editors, Trends in Parsing Technology: Depen-
dency Parsing, Domain Adaptation, and Deep Parsing,
chapter 8, pages 121–150. 2010.

Kuzman Ganchev, Joao Graça, Jennifer Gillenwater, and
Ben Taskar. Posterior regularization for structured la-
tent variable models. Journal of Machine Learning
Research, 11:2001–2049, 2010.

Jiang Guo, Wanxiang Che, David Yarowsky, Haifeng
Wang, and Ting Liu. Cross-lingual dependency pars-
ing based on distributed representations. In Proceed-
ings of the 53rd Annual Meeting of the Association for
Computational Linguistics and the 7th International
Joint Conference on Natural Language Processing,
pages 1234–1244, 2015.

John Hawkins. A Performance Theory of Order and Con-
stituency. Cambridge University Press, 1994.

Karl Moritz Hermann, Tomas Kocisky, Edward Grefen-
stette, Lasse Espeholt, Will Kay, Mustafa Suleyman,
and Phil Blunsom. Teaching machines to read and
comprehend. In Advances in Neural Information Pro-
cessing Systems, pages 1684–1692, 2015.

Susan Howlett and Mark Dras. Clause restructuring
for SMT not absolutely helpful. In Proceedings
of the 49th Annual Meeting of the Association
for Computational Linguistics: Human Language
Technologies, pages 384–388, 2011. Erratum at
https://www.aclweb.org/anthology/P/
P11/P11-2067e1.pdf.

Navdeep Jaitly and Geoffrey E. Hinton. Vocal tract length
perturbation (VTLP) improves speech recognition. In
Proceedings of the 30th International Conference on
Machine Learning Workshop on Deep Learning for
Audio, Speech and Language, 2013.

Dan Klein and Christopher Manning. Corpus-based in-
duction of syntactic structure: Models of dependency
and constituency. In Proceedings of the 42nd Annual
Meeting of the Association for Computational Linguis-
tics, pages 478–485, 2004.

Alex Krizhevsky, Ilya Sutskever, and Geoffrey E. Hinton.
ImageNet classification with deep convolutional neu-
ral networks. In F. Pereira, C.J.C. Burges, L. Bottou,
and K.Q. Weinberger, editors, Advances in Neural In-
formation Processing Systems 25, pages 1097–1105.
2012.

503

http://www.work.caltech.edu/yaser/paper/95hints.ps
http://www.springer.com/us/book/9780387251509
http://www.springer.com/us/book/9780387251509
http://www.degruyter.com/view/product/60947
http://www.degruyter.com/view/product/60947
http://aclweb.org/anthology/P05-1066
http://cs.jhu.edu/~jason/papers/#cotterell-peng-eisner-2015
http://cs.jhu.edu/~jason/papers/#cotterell-peng-eisner-2015
http://cs.jhu.edu/~jason/papers/#cotterell-peng-eisner-2015
http://dx.doi.org/10.1109/TASLP.2015.2438544
http://dx.doi.org/10.1109/TASLP.2015.2438544
https://mitpress.mit.edu/books/machine-translation
https://mitpress.mit.edu/books/machine-translation
http://dl.acm.org/citation.cfm?id=648181.749385
http://dl.acm.org/citation.cfm?id=648181.749385
http://dl.acm.org/citation.cfm?id=648181.749385
http://wals.info/
http://aclweb.org/anthology/K15-1012
http://aclweb.org/anthology/K15-1012
http://cs.jhu.edu/~jason/papers/#eisner-smith-2010-iwptbook
http://cs.jhu.edu/~jason/papers/#eisner-smith-2010-iwptbook
http://cs.jhu.edu/~jason/papers/#eisner-smith-2010-iwptbook
http://www.jmlr.org/papers/v11/ganchev10a.html
http://www.jmlr.org/papers/v11/ganchev10a.html
http://aclweb.org/anthology/P15-1119
http://aclweb.org/anthology/P15-1119
http://www.cambridge.org/us/academic/subjects/languages-linguistics/grammar-and-syntax/performance-theory-order-and-constituency
http://www.cambridge.org/us/academic/subjects/languages-linguistics/grammar-and-syntax/performance-theory-order-and-constituency
http://arxiv.org/abs/1506.03340
http://arxiv.org/abs/1506.03340
http://aclweb.org/anthology/P11-2067
http://aclweb.org/anthology/P11-2067
https://www.aclweb.org/anthology/P/P11/P11-2067e1.pdf
https://www.aclweb.org/anthology/P/P11/P11-2067e1.pdf
https://www.cs.toronto.edu/~hinton/absps/perturb.pdf
https://www.cs.toronto.edu/~hinton/absps/perturb.pdf
http://dx.doi.org/10.3115/1218955.1219016
http://dx.doi.org/10.3115/1218955.1219016
http://dx.doi.org/10.3115/1218955.1219016
http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf
http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf


Xuezhe Ma and Fei Xia. Unsupervised dependency pars-
ing with transferring distribution via parallel guidance
and entropy regularization. In Proceedings of the 52nd
Annual Meeting of the Association for Computational
Linguistics, volume 1, pages 1337–1348, 2014.

Martin Majliš. W2C—web to corpus—corpora, 2011.
LINDAT/CLARIN digital library at the Institute of
Formal and Applied Linguistics, Charles University in
Prague.

Ryan McDonald, Slav Petrov, and Keith Hall. Multi-
source transfer of delexicalized dependency parsers.
In Proceedings of the 2011 Conference on Empirical
Methods in Natural Language Processing, pages 62–
72, 2011.

Tahira Naseem, Harr Chen, Regina Barzilay, and Mark
Johnson. Using universal linguistic knowledge to
guide grammar induction. In Proceedings of the 2010
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1234–1244, 2010.

Dat Quoc Nguyen, Dai Quoc Nguyen, Dang Duc Pham,
and Son Bao Pham. RDRPOSTagger: A ripple down
rules-based part-of-speech tagger. In Proceedings of
the Demonstrations at the 14th Conference of the Eu-
ropean Chapter of the Association for Computational
Linguistics, pages 17–20, 2014.

Joakim Nivre and Jens Nilsson. Pseudo-projective de-
pendency parsing. In Proceedings of the 43rd Annual
Meeting of the Association for Computational Linguis-
tics, pages 99–106, 2005.

Joakim Nivre, Željko Agić, Maria Jesus Aranzabe,
Masayuki Asahara, Aitziber Atutxa, Miguel Balles-
teros, John Bauer, Kepa Bengoetxea, Riyaz Ah-
mad Bhat, Cristina Bosco, Sam Bowman, Giuseppe
G. A. Celano, Miriam Connor, Marie-Catherine
de Marneffe, Arantza Diaz de Ilarraza, Kaja Do-
brovoljc, Timothy Dozat, Tomaž Erjavec, Richárd
Farkas, Jennifer Foster, Daniel Galbraith, Filip Gin-
ter, Iakes Goenaga, Koldo Gojenola, Yoav Gold-
berg, Berta Gonzales, Bruno Guillaume, Jan Hajič,
Dag Haug, Radu Ion, Elena Irimia, Anders Jo-
hannsen, Hiroshi Kanayama, Jenna Kanerva, Simon
Krek, Veronika Laippala, Alessandro Lenci, Nikola
Ljubešić, Teresa Lynn, Christopher Manning, Ctlina
Mrnduc, David Mareček, Héctor Martı́nez Alonso,
Jan Mašek, Yuji Matsumoto, Ryan McDonald, Anna
Missilä, Verginica Mititelu, Yusuke Miyao, Simon-
etta Montemagni, Shunsuke Mori, Hanna Nurmi,
Petya Osenova, Lilja Øvrelid, Elena Pascual, Marco
Passarotti, Cenel-Augusto Perez, Slav Petrov, Jussi
Piitulainen, Barbara Plank, Martin Popel, Prokopis
Prokopidis, Sampo Pyysalo, Loganathan Ramasamy,
Rudolf Rosa, Shadi Saleh, Sebastian Schuster, Wolf-

gang Seeker, Mojgan Seraji, Natalia Silveira, Maria
Simi, Radu Simionescu, Katalin Simkó, Kiril Simov,
Aaron Smith, Jan Štěpánek, Alane Suhr, Zsolt Szántó,
Takaaki Tanaka, Reut Tsarfaty, Sumire Uematsu, Lar-
raitz Uria, Viktor Varga, Veronika Vincze, Zdeněk
Žabokrtský, Daniel Zeman, and Hanzhi Zhu. Univer-
sal dependencies 1.2, 2015. LINDAT/CLARIN digital
library at the Institute of Formal and Applied Linguis-
tics, Charles University in Prague.

Joakim Nivre, Marie-Catherine de Marneffe, Filip Gin-
ter, Yoav Goldberg, Jan Hajič, Christopher Manning,
Ryan McDonald, Slav Petrov, Sampo Pyysalo, Natalia
Silveira, Reut Tsarfaty, and Daniel Zeman. Universal
dependencies v1: A multilingual treebank collection.
In Proceedings of the 10th International Conference
on Language Resources and Evaluation, pages 1659–
1666, 2016.

Geoffrey Nunberg. The Linguistics of Punctuation. Num-
ber 18 in CSLI Lecture Notes. Center for the Study of
Language and Information, 1990.

Mohammad Sadegh Rasooli and Michael Collins.
Density-driven cross-lingual transfer of dependency
parsers. In Proceedings of the 2015 Conference on
Empirical Methods in Natural Language Processing,
pages 328–338, 2015.

Mohammad Sadegh Rasooli and Joel R. Tetreault. Yara
parser: A fast and accurate dependency parser.
Computing Research Repository, arXiv:1503.06733
(version 2), 2015.

Mohammad Sadegh Rasooli, Thomas Lippincott,
Nizar Habash, and Owen Rambow. Unsupervised
morphology-based vocabulary expansion. In Proceed-
ings of the 52nd Annual Meeting of the Association for
Computational Linguistics (Volume 1: Long Papers),
pages 1349–1359, June 2014.

Alla Rozovskaya and Dan Roth. Training paradigms for
correcting errors in grammar and usage. In Human
Language Technologies: The 2010 Annual Conference
of the North American Chapter of the Association for
Computational Linguistics, pages 154–162, 2010.

Robert Sedgewick. Permutation generation methods.
ACM Computing Surveys, 9(2):137–164, 1977.

Iulian Vlad Serban, Alberto Garcı́a-Durán, Caglar Gul-
cehre, Sungjin Ahn, Sarath Chandar, Aaron Courville,
and Yoshua Bengio. Generating factoid questions with
recurrent neural networks: The 30m factoid question-
answer corpus. In Proceedings of the 54th Annual
Meeting of the Association for Computational Linguis-
tics (Volume 1: Long Papers), pages 588–598. Associ-
ation for Computational Linguistics, 2016.

504

http://aclweb.org/anthology/P14-1126
http://aclweb.org/anthology/P14-1126
http://aclweb.org/anthology/P14-1126
http://hdl.handle.net/11858/00-097C-0000-0022-6133-9
http://aclweb.org/anthology/D11-1006
http://aclweb.org/anthology/D11-1006
http://aclweb.org/anthology/D10-1120
http://aclweb.org/anthology/D10-1120
http://www.aclweb.org/anthology/E14-2005
http://www.aclweb.org/anthology/E14-2005
http://aclweb.org/anthology/P05-1013
http://aclweb.org/anthology/P05-1013
http://hdl.handle.net/11234/1-1548
http://hdl.handle.net/11234/1-1548
http://www.lrec-conf.org/proceedings/lrec2016/pdf/348_Paper.pdf
http://www.lrec-conf.org/proceedings/lrec2016/pdf/348_Paper.pdf
https://web.stanford.edu/group/cslipublications/cslipublications/site/0937073466.shtml
http://aclweb.org/anthology/D15-1039
http://aclweb.org/anthology/D15-1039
http://arxiv.org/abs/1503.06733
http://arxiv.org/abs/1503.06733
http://aclweb.org/anthology/P14-1127
http://aclweb.org/anthology/P14-1127
http://aclweb.org/anthology/N10-1018
http://aclweb.org/anthology/N10-1018
http://dl.acm.org/citation.cfm?id=356692
http://dx.doi.org/10.18653/v1/P16-1056
http://dx.doi.org/10.18653/v1/P16-1056
http://dx.doi.org/10.18653/v1/P16-1056


Patrice Y. Simard, Dave Steinkraus, and John C. Platt.
Best practices for convolutional neural networks ap-
plied to visual document analysis. In Proceedings of
the 7th International Conference on Document Analy-
sis and Recognition, pages 958–, 2003.

Noah A. Smith and Jason Eisner. Annealing struc-
tural bias in multilingual weighted grammar induction.
In Proceedings of the 21st International Conference
on Computational Linguistics and 44th Annual Meet-
ing of the Association for Computational Linguistics,
pages 569–576, 2006.

Anders Søgaard. Data point selection for cross-language
adaptation of dependency parsers. In Proceedings of
the 49th Annual Meeting of the Association for Com-
putational Linguistics: Human Language Technolo-
gies, pages 682–686, 2011.

Valentin I. Spitkovsky. Grammar Induction and Parsing
with Dependency-and-Boundary Models. PhD thesis,
Computer Science Department, Stanford University,
Stanford, CA, 2013.

Valentin I. Spitkovsky, Hiyan Alshawi, and Daniel Juraf-
sky. Breaking out of local optima with count trans-
forms and model recombination: A study in grammar
induction. In Proceedings of the 2013 Conference on
Empirical Methods in Natural Language Processing,
pages 1983–1995, 2013.

Matti Varjokallio and Dietrich Klakow. Unsupervised
morph segmentation and statistical language models
for vocabulary expansion. In Proceedings of the 54th
Annual Meeting of the Association for Computational
Linguistics (Volume 2: Short Papers), pages 175–180,
2016.

Jesús Vilares, Manuel Vilares, and Juan Otero. Manag-
ing misspelled queries in IR applications. Information
Processing & Management, 47(2):263–286, 2011.

Yushi Wang, Jonathan Berant, and Percy Liang. Build-
ing a semantic parser overnight. In Proceedings of the
53rd Annual Meeting of the Association for Computa-
tional Linguistics and the 7th International Joint Con-
ference on Natural Language Processing (Volume 1:
Long Papers), pages 1332–1342, 2015.

Jason Weston, Antoine Bordes, Sumit Chopra, and
Tomas Mikolov. Towards AI-complete question an-
swering: A set of prerequisite toy tasks. In Proceed-
ings of the International Conference on Learning Rep-
resentations, 2016.

505

http://research.microsoft.com/apps/pubs/default.aspx?id=68920
http://research.microsoft.com/apps/pubs/default.aspx?id=68920
http://cs.jhu.edu/~jason/papers/#smith-eisner-2006-acl-sa
http://cs.jhu.edu/~jason/papers/#smith-eisner-2006-acl-sa
http://aclweb.org/anthology/P11-2120
http://aclweb.org/anthology/P11-2120
http://nlp.stanford.edu/pubs/SpitkovskyThesis.pdf
http://nlp.stanford.edu/pubs/SpitkovskyThesis.pdf
http://aclweb.org/anthology/D13-1204
http://aclweb.org/anthology/D13-1204
http://aclweb.org/anthology/D13-1204
http://aclweb.org/anthology/P16-2029
http://aclweb.org/anthology/P16-2029
http://aclweb.org/anthology/P16-2029
http://dl.acm.org/citation.cfm?id=1945179
http://dl.acm.org/citation.cfm?id=1945179
http://aclweb.org/anthology/P15-1129
http://aclweb.org/anthology/P15-1129
http://arxiv.org/abs/1502.05698
http://arxiv.org/abs/1502.05698


506


