



















































Generating Sentences from Disentangled Syntactic and Semantic Spaces


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 6008–6019
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

6008

Generating Sentences from Disentangled Syntactic and Semantic Spaces

Yu Bao1∗ Hao Zhou2∗ Shujian Huang1† Lei Li2 Lili Mou3
Olga Vechtomova3 Xinyu Dai1 Jiajun Chen1

1National Key Laboratory for Novel Software Technology, Nanjing University, China
2ByteDance AI Lab, Beijing, China
3University of Waterloo, Canada

{baoy,huangsj,dxy,chenjj}@nlp.nju.edu.cn
{zhouhao.nlp,lileilab}@bytedance.com

doublepower.mou@gmail.com, ovechtomova@uwaterloo.ca

Abstract

Variational auto-encoders (VAEs) are widely
used in natural language generation due to
the regularization of the latent space. How-
ever, generating sentences from the continu-
ous latent space does not explicitly model the
syntactic information. In this paper, we pro-
pose to generate sentences from disentangled
syntactic and semantic spaces. Our proposed
method explicitly models syntactic informa-
tion in the VAE’s latent space by using the lin-
earized tree sequence, leading to better perfor-
mance of language generation. Additionally,
the advantage of sampling in the disentangled
syntactic and semantic latent spaces enables us
to perform novel applications, such as the un-
supervised paraphrase generation and syntax-
transfer generation. Experimental results show
that our proposed model achieves similar or
better performance in various tasks, compared
with state-of-the-art related work. ‡

1 Introduction

Variational auto-encoders (VAEs, Kingma and
Welling, 2014) are widely used in language gen-
eration tasks (Serban et al., 2017; Kusner et al.,
2017; Semeniuta et al., 2017; Li et al., 2018b).
VAE encodes a sentence into a probabilistic latent
space, from which it learns to decode the same
sentence. In addition to traditional reconstruc-
tion loss of an autoencoder, VAE employs an ex-
tra regularization term, penalizing the Kullback–
Leibler (KL) divergence between the encoded pos-
terior distribution and its prior. This property en-
ables us to sample and generate sentences from
the continuous latent space. Additionally, we can

∗Equal contributions.
†Corresponding author.
‡We release the implementation and models at https://

github.com/baoy-nlp/DSS-VAE

even manually manipulate the latent space, inspir-
ing various applications such as sentence interpo-
lation (Bowman et al., 2016) and text style trans-
fer (Hu et al., 2017).

However, the continuous latent space of VAE
blends syntactic and semantic information to-
gether, without modeling the syntax explicitly. We
argue that it may be not necessarily the best in
the text generation scenario. Recently, researchers
have shown that explicitly syntactic modeling
improves the generation quality in sequence-to-
sequence models (Eriguchi et al., 2016; Zhou
et al., 2017; Li et al., 2017; Chen et al., 2017). It is
straightforward to adopt such idea in the VAE set-
ting, since a vanilla VAE does not explicitly model
the syntax. A line of studies (Kusner et al., 2017;
Gómez-Bombarelli et al., 2018; Dai et al., 2018)
propose to impose context-free grammars (CFGs)
as hard constraints in the VAE decoder, so that
they could generate syntactically valid outputs of
programs, molecules, etc.

However, the above approaches cannot be ap-
plied to syntactic modeling in VAE’s continuous
latent space, and thus, we do not enjoy the two
benefits of VAE, namely, sampling and manipula-
tion, towards the syntax of a sentence.

In this paper, we propose to generate sentences
from a disentangled syntactic and semantic spaces
of VAE (called DSS-VAE). DSS-VAE explicitly
models syntax in the continuous latent space of
VAE, while retaining the sampling and manipu-
lation benefits. In particular, we introduce two
continuous latent variables to capture semantics
and syntax, respectively. To separate the seman-
tic and syntactic information from each other, we
borrow the adversarial approaches from the text
style-transfer research (Hu et al., 2017; Fu et al.,
2018; John et al., 2018), but adapt it into our
scenario of syntactic modeling. We also observe
that syntax and semantics are highly interwoven,

https://github.com/baoy-nlp/DSS-VAE
https://github.com/baoy-nlp/DSS-VAE


6009

and therefore further propose an adversarial recon-
struction loss to regularize the syntactic and se-
mantic spaces.

Our proposed DSS-VAE takes following advan-
tages:

First, explicitly syntactic modeling in VAE’s la-
tent space improves the quality of unconditional
language generation. Experiments show that,
compared with traditional VAE, DSS-VAE gen-
erates more fluent sentences (lower perplexity),
while preserving more amount of encoded infor-
mation (higher BLEU scores for reconstruction).
Comparisons with a state-of-the-art syntactic lan-
guage model (Shen et al., 2017) are also included.

Second, the advantage of manipulation in the
syntactic and semantic spaces of DSS-VAE pro-
vides a natural way of unsupervised paraphrase
generation. If we sample a vector in the syntactic
space but perform max a posterior (MAP) infer-
ence in the semantic space, we are able to gener-
ate a sentence with the same meaning but different
syntax. This is known as unsupervised paraphrase
generation, as no parallel corpus is needed during
training. Experiments show that DSS-VAE outper-
forms the traditional VAE as well as a state-of-the-
art Metropolis-Hastings sampling approach (Miao
et al., 2019) in this task.

Additionally, with the disentangled syntactic
and semantic latent spaces, we propose an inter-
esting application that transfers the syntax of one
sentence to another. Both qualitative and quan-
titative experimental results show that DSS-VAE
could graft the designed syntax to another sen-
tence under certain circumstances.

2 Related Work

The variational auto-encoders (VAEs) is proposed
by Kingma and Welling (2014) for image gener-
ation. Bowman et al. (2016) successfully applied
VAE in the NLP domain, showing that VAE im-
proves recurrent neural network (RNN)-based lan-
guage modeling (RNN-LM, Mikolov et al., 2010);
that VAE allows sentence sampling and sentence
interpolation in the continuous latent space. Later,
VAE is widely used in various natural language
generation tasks (Gupta et al., 2018; Kusner et al.,
2017; Hu et al., 2017; Deriu and Cieliebak, 2018).

Syntactic language modeling, to the best of
our knowledge, could be dated back to Chelba
(1997). Charniak (2001) and Clark (2001) pro-
pose to utilize a top-down parsing mechanism for

language modeling. Dyer et al. (2016) and Kun-
coro et al. (2017) introduce the neural network to
this direction. The Parsing-Reading-Predict Net-
work (PRPN, Shen et al., 2017), which reports a
state-of-the-art results on syntactic language mod-
eling, learns a latent syntax by training with a lan-
guage modeling objective. Different from their
work, our approach models syntax in a continu-
ous space, facilitating sampling and manipulation
of syntax.

Our work is also related to style-transfer text
generation (Fu et al., 2018; Li et al., 2018a; John
et al., 2018). In previous work, the style is usu-
ally defined by categorical features such as sen-
timent. We move one step forward, extending
their approach to the sequence level and dealing
with more complicated, non-categorical syntactic
spaces. Due to the complication of syntax, we fur-
ther design adversarial reconstruction losses to en-
courage the separation of syntax and semantics.

3 Approach

In this section, we present our proposed DSS-VAE
in detail. We first introduce the variational au-
toencoder in §3.1. Then, we describe the gen-
eral architecture of DSS-VAE in §3.2, where we
explain how we generate sentences from disen-
tangled syntactic and semantic latent spaces and
how we disentangle information from the two sep-
arated spaces. Model training is discussed in §3.3.

3.1 Variational Autoencoder
A traditional VAE employs a probabilistic latent
variable z to encode the information of a sentence
x, and then decodes the original x from z. The
probability of a sentence x could be computed as:

p(x) =

∫
p(z)p(x|z) dz (1)

where p(z) is the prior, and p(x|z) is given by
the decoder. VAE is trained by maximizing the
evidence lower bound (ELBO):

log p(x) ≥ ELBO
= E

q(z|x)

[
log p(x|z)

]
−KL

(
q(z|x)

∥∥ p(z))
(2)

3.2 Proposed Method: DSS-VAE
Our DSS-VAE is built upon the vanilla VAE, but
extends Eqn. (1) by adopting two separate latent
variables zsem and zsyn to capture semantic and



6010

syntactic information, respectively. Specifically,
we assume that the probability of a sentence x in
DSS-VAE could be computed as:

p(x) =

∫
p(zsem, zsyn)p(x|zsem, zsyn) dzsem dzsyn

=

∫
p(zsem)p(zsyn)p(x|zsem, zsyn) dzsem dzsyn

where p(zsem) and p(zsyn) are the priors; both
are set to be independent multivariate Gaussian
N (0, I).

Similar to (2), we optimize the evidence lower
bound (ELBO) for training:

log p(x) ≥ ELBO
= E

q(zsem|x)q(zsyn|x)

[
log p(x|zsem, zsyn)

]
−KL

(
q(zsem|x)

∥∥ p(zsem))
−KL

(
q(zsyn|x)

∥∥ p(zsyn))
where q(zsem|x) and q(zsyn|x) are posteriors
for the two latent variables. We further as-
sume the variational posterior families, q(zsem|x)
and q(zsyn|x), are independent, taking the form
N (µsem,σ2sem) and N (µsyn,σ2syn), respectively,
We use RNN to parameterize the posteriors (also
called the encoder). Here, µsem, σsem, µsyn, and
σsyn are predicted by the encoder network, de-
scribed as follows.

Encoding In the encoding phase, we first ob-
tain the sentence representation rx by an RNN
with the gated recurrent units (GRUs, Cho et al.,
2014); then, rx is evenly split into two spaces
rx = [r

sem
x ; r

syn
x ].

For the semantic encoder, we compute the mean
and variance of q(zsem|x) from rsemx as:[
µsem
σsem

]
=

[
Wµsem
W σsem

]
ReLU(Wsemr

sem
x + bsem)

where the activation function is the rectified
linear unit (ReLU, Nair and Hinton, 2010).
Wµsem,W σsem,Wsem, and bsem are the parameters of
the semantic encoder.

Likewise, a syntactic encoder predicts µsyn and
σsyn for q(zsyn|x) in the same way, with parame-
ters Wµsyn,W σsyn,Wsyn, and bsyn.

Decoding in the Training Phase We first sam-
ple from the posterior distributions by the repa-
rameterization trick (Kingma and Welling, 2014),

S

     NP                           VP                              (.,.)

(PRP,This)     (VBZ,is)              NP                

(DT,an)  (JJ,interesting)  (NN,idea)

Constituency parse tree

Linearized representation

S NP PRP /NP VP VBZ NP DT JJ NN /NP /VP . /S

Figure 1: The parse tree and its linearized tree sequence
of a sentence “This is an interesting idea.”

obtaining sampled semantic and syntactic repre-
sentations, zsem and zsyn; then, they are concate-
nated as z = [zsem; zsyn] and fed as the initial state
of the decoder for reconstruction.

Decoding in the Test Phase The treatment de-
pends on applications. If we would like to syn-
thesize a sentence from scratch, both zsyn and
zsem are sampled from prior. If we would like
to preserve/vary semantics/syntax, max a poste-
rior (MAP) inference or sampling could be applied
in respective spaces. Details are provided in § 4.

In the following part, we will introduce how
syntax is modeled in our approach and how syn-
tax and semantics are ensured to be separated.

3.2.1 Modeling Syntax by Predicting
Linearized Tree Sequence

While previous studies have tackled the problem
of categorical sentiment modeling in the latent
space (Hu et al., 2017; Fu et al., 2018), syntax
is much more complicated and not finitely cate-
gorical. We propose to adopt the linearized tree
sequence to explicitly model syntax in the latent
space of VAE.

Figure 1 shows the constituency parse tree of
the sentence “This is an interesting idea.” The lin-
earized tree sequence can be obtained by travers-
ing the syntactic tree in a top-down order; if
the node is non-terminal, we add a backtracking
node (e.g., /NP) after its child nodes are traversed.

We ensure that zsyn contains syntactic informa-
tion by predicting the linearized tree sequence.
In training, the parse tree for sentences are ob-
tained by the ZPar1 toolkit, and serves as the
groundtruth training signals; in testing, we do not
need external syntactic trees. We build an RNN

1https://www.sutd.edu.sg/cmsresource/faculty/yuezhang/
zpar.html

https://www.sutd.edu.sg/cmsresource/faculty/yuezhang/zpar.html
https://www.sutd.edu.sg/cmsresource/faculty/yuezhang/zpar.html


6011

S NP .. . /S

This   is     ...

This   is     ...

S NP .. . /S

This   is  ...

This   is  ...

Figure 2: Overview of our DSS-VAE. Forward dashed
arrows are multi-task losses; backward dashed arrows
are adversarial losses.

(independent of the VAE’s decoder) to predict
such linearized parse trees, where each parsing to-
ken is represented by an embedding (similar to a
traditional RNN decoder). Notice that, a node and
its backtracking, e.g., NP and /NP, have different
embeddings.

The linearized tree sequence has achieved
promising parsing results in a traditional con-
stituency parsing task (Vinyals et al., 2015; Liu
et al., 2018; Vaswani et al., 2017), which shows its
ability of preserving syntactic information. Ad-
ditionally, the linearized tree sequence works in
a sequence-to-sequence fashion, so that it can be
used to regularize the latent spaces.

3.2.2 Disentangling Syntax and Semantics
into Different Latent Spaces

Having solved the problem of syntactic modeling,
we now turn to the question: how could we disen-
tangle syntax and semantics from each other?

We are inspired by the research in text style
transfer and apply auxiliary losses to regularize the
latent space (Hu et al., 2017; Fu et al., 2018).

In particular, we adopt the multi-task and adver-
sarial losses in John et al. (2018), but extend it to
the sequence level. In §3.2.3, we further propose
two adversarial reconstruction losses to discour-
age the model to encode a sentence from a single
subspace.

Multi-Task Loss Intuitively, a multi-task loss
ensures that each space (zsyn or zsem) should cap-
ture respective information.

For the semantic space, we predict the bag-of-
words (BoW) distribution of a sentence from zsem

with softmax, whose objective is the cross-entropy
loss against the groundtruth distribution t, given
by:

L(mul)sem = −
∑

w∈V
tw log p(w|zsem) (3)

where p(w|zsyn) is the predicted distribution.
BoW has been explored by previous work (Weng
et al., 2017; John et al., 2018), showing good abil-
ity of preserving semantics.

For the syntactic space, the multi-task loss
trains a model to predict syntax on zsyn. Due to
our proposal in §3.2.1, we could build a dedicated
RNN, predicting the tokens in the linearized parse
tree sequence, whose loss is:

L(mul)syn = −
∑n

i=1
log p(si|s1 · · · si−1, zsyn) (4)

where si is a token in the linearized parse tree
(with a total length of n).

Adversarial Loss The adversarial loss is widely
used for aligning samples from different distri-
butions. It has various applications, including
style transfer (Hu et al., 2017; Fu et al., 2018;
John et al., 2018) and domain adaptation (Tzeng
et al., 2017). To apply adversarial losses, we
add extra model components (known as adver-
saries) to predict semantic information tw based
on the syntactic space zsyn, but to predict syntac-
tic information s1 · · · sn−1 based on the semantic
space zsem. They are denoted by padv(w|zsyn) and
padv(si|s1 · · · si−1, zsem).

The training of these adversaries are similar to
(3) and (4), except that the gradient only trains
the adversaries themselves, and does not back-
propagate to VAE.

Then, VAE is trained to “fool” the adversaries
by maximizing their losses, i.e., minimizing the
following terms:

L(adv)sem =
∑

w∈V
tw log padv(w|zsyn) (5)

L(adv)syn =
∑n

i=1
log padv(si|s1 · · · si−1, zsem) (6)

In this phase, the adversaries are fixed and their
parameters are not updated.

3.2.3 Adversarial Reconstruction Loss
Our next intuition is that syntax and semantics are
more interwoven to each other than other informa-
tion such as style and content.

Suppose, for example, the syntax and seman-
tics have been perfectly separated by the losses in



6012

§3.2.2, where zsem could predict BoW well, but
does not contain any information about the syn-
tactic tree. Even in this ideal case, the decoder
can reconstruct the original sentence from zsem by
simply learning to re-order words (as zsem does
contain BoW). Such word re-ordering knowledge
is indeed learnable (Ma et al., 2018), and does
not necessarily contain the syntactic information.
Therefore, the multi-task and adversarial losses for
syntax and semantics do not suffice to regularize
DSS-VAE.

We now propose an adversarial reconstruction
loss to discourage the sentence being predicted by
a single subspace zsyn or zsem. When combined,
however, they should provide a holistic view of
the entire sentence. Formally, let zs be a latent
variable (zs = zsyn or zsem). A decoding adver-
sary is trained to predict the sentence based on zs,
denoted by prec(xi|x1 · · ·xi−1, zs). Then, the ad-
versarial reconstruction loss is imposed by mini-
mizing

L(adv)rec (zs) =
∑M

i=1
log prec(xi|x<i, zs) (7)

Such adversarial reconstruction loss is applied to
both the syntactic and semantic spaces, shown by
black bashed arrows in Figure 2.

3.3 Training Details
Overall Training Objective The overall train-
ing loss is a combination of the VAE loss (2), the
multi-task and adversarial losses for syntax and se-
mantics (3–6), as well as the adversarial recon-
struction losses (7), , i.e., minimizing

L = Lvae + Laux
= − E

q(zsem|x)q(zsyn|x)
log
[
p(x|zsem, zsyn)

]
+ λKLsem KL

(
q(zsem|x)

∥∥ p(zsem))
+ λKLsyn KL

(
q(zsyn|x)

∥∥ p(zsyn))
+ λmulsemL(mul)sem + λadvsemL(adv)sem + λrecsemL(adv)rec (zsem)
+ λmulsynL(mul)syn + λadvsynL(adv)syn + λrecsynL(adv)rec (zsyn)

(8)

where the λKLsem, λ
KL
syn, λ

mul
sem, λ

adv
sem, λ

rec
sem, λ

mul
syn , λ

adv
syn ,

and λrecsyn are the hyperparameters to adjust the im-
portance of each loss in overall objective.

Hyperparameter Tuning We select the param-
eter values with the lowest ELBO value on the
validation set in all experiments. They are tuned
by (grouped) grid search on the validation set, but

due to the large hyperparameter space, we conduct
tuning mostly for sensitive hyperparameters and
admit that it is empirical. We choose the VAE as
our baseline, and the KL weight of VAE is tuned
in the same way. We list the hyperparameters in
Appendix A.

The training objective is optimized by
Adam (Kingma and Ba, 2015) with β1 =
0.9, β2 = 0.995, and the initial learning rate is
0.001. Word embeddings are 300-dimensional
and initialized randomly. The dimension of each
latent space (namely, zsyn and zsem) is 100.

KL Annealing and Word Dropout We adopt
the tricks of KL annealing and word dropout
from Bowman et al. (2016) to avoid KL collapse.
We anneal λKLsyn and λ

KL
syn from zero to predefined

values in a sigmoid manner. Besides, the word
dropout trick randomly replaces the ground-truth
token with<unk> with a fixed probability of 0.50
at each time step of the decoder during training.

4 Experiments

We evaluate our method on reconstruction and un-
conditional language generation (§4.1). Then, we
apply it two applications, namely, unsupervised
paraphrase generation (§4.2) and syntax-transfer
generation (§4.3).

4.1 Reconstruction and Unconditional
Language Generation

First, we compare our model in reconstruc-
tion and unconditional language generation with
a traditional VAE and a syntactic language
model (PRPN, Shen et al., 2017).

Dataset We followed previous work (Bowman
et al., 2016) and used a standard benchmark, the
WSJ sections in the Penn Treebank (PTB) (Mar-
cus et al., 1993). We also followed the standard
split: Sections 2–21 for training, Section 24 for
validation, and Section 23 for test.

Settings We trained VAE and DSS-VAE, both
with 100-dimensional RNN states. For the vo-
cabulary, we chose 30k most frequent words. We
trained PRPN with the default parameter in the
code base.2

Evaluation We evaluate model performance
with the following metrics:

2https://github.com/yikangshen/PRPN

https://github.com/yikangshen/PRPN


6013

KL-Weight BLEU↑ Forward PPL↓

1.3 7.26 34.01
1.2 7.41 35.00
1.0 8.19 36.53
0.7 8.98 42.44
0.5 9.07 44.11
0.3 9.26 48.70
0.1 9.36 49.73

Table 1: BLEU and Forward PPL of VAE with vary-
ing KL weights on the PTB test set. The larger↑ (or
lower↓), the better.

1. Reconstruction BLEU. The reconstruction
task aims to generate the input sentence it-
self. In the task, both syntactic and se-
mantic vectors are chosen as the predicted
mean of the encoded distribution. We eval-
uate the reconstruction performance by the
BLEU score (Papineni et al., 2002) with in-
put as the reference.3 It reflects how well
the model could preserve input information,
and is crucial for representation learning and
“goal-oriented” text generation.

2. Forward PPL. We then perform uncondi-
tioned generation, where both syntactic and
semantic vectors are sampled from prior. For-
ward perplexity (PPL) (Zhao et al., 2018)
is the generated sentences’ perplexity score
predicted by a pertained language model.4

It shows the fluency of generated sentences
from VAE’s prior. We computed Forward
PPL based on 100K sampled sentences.

3. Reverse PPL. Unconditioned generation is
further evaluated by Reverse PPL (Zhao
et al., 2018). It is obtained by first training a
language model5 on 100K sampled sentences
from a generation model; then, Reverse PPL
is the perplexity of the PTB test sets with the
trained language model. Reverse PPL evalu-
ates the diversity and fluency of sampled sen-
tences from a language generation model. If
sampled sentences are of low diversity, the
language model would be trained only on
similar sentences; if the sampled sentences
are of low fluency, the language model would

3We evaluate the corpus BLEU implemented in https://
www.nltk.org/ modules/nltk/translate/bleu score.html

4We used an LSTM language model trained on
the One-Billion-Word Corpus (http://www.statmt.org/
lm-benchmark).

5Tied LSTM-LM with 300 dimensions and two lay-
ers, implemented in https://github.com/pytorch/examples/
tree/master/word language model

 1

VAE

34.01 7.26 31.82 8.01

35 7.41 32.09 8.71

36.53 8.19 35.29 9.29

42.44 8.98 35.54 9.55

44.11 9.07 42.36 11.69

48.7 9.26 42.5 11.12

47.33 8.98 45.6 9.6

49.73 9.36 49.79 11.09

syntax-VAE

BL
EU

7

8

9

10

11

12

Forward-PPL

31 36 41 46 51

VAE DSS-VAE

�1

Figure 3: Comparing DSS-VAE and VAE in language
generation with different KL weight. We performed
linear regression for each model to show the trend. The
upper-left corner (larger BLEU but smaller PPL) indi-
cates a better performance.

be trained on unfluent sentences. Both will
lead to higher Reverse PPL. For comparing
VAE and DSS-VAE, we sample latent vari-
ables from the prior, and feed them to the de-
coder for generation; for LSTM-LM, we first
feed the start sentence token <s> to the de-
coder, and sample the word at each time step
by predicted probabilities (i.e., forward sam-
pling).

Results We see in Table 1 that BLEU and PPL
are more or less contradictory. Usually, a smaller
KL weight makes the autoencoder less “varia-
tional” but more “deterministic,” leading to less
fluent sampled sentences but better reconstruction.
If the trade-off is not analyzed explicitly, the VAE
variant could have arbitrary results based on KL-
weight tuning, which is unfair.

We therefore present the scatter plot in Figure 3,
showing the trend of forward PPL and BLEU
scores with different KL weights. Clearly, DSS-
VAE outperforms a plain VAE in BLEU if For-
ward PPL is controlled, and in Forward PPL if
BLEU is controlled. The scatter plot shows that
our proposed DSS-VAE outperforms the original
counterpart in language generation with different
KL weights.

In terms of Reverse PPL (Table 2), DSS-VAE
also achieves better Reverse PPL than a tradi-
tional VAE. Since DSS-VAE leverages syntax to
improve the sentence generation, we also include a
state-of-the-art syntactic language model (PRPN-
LM, Shen et al., 2017) for comparison. Re-
sults show that DSS-VAE has achieved a Re-
verse PPL comparable to (and slightly better than)

https://www.nltk.org/_modules/nltk/translate/bleu_score.html
https://www.nltk.org/_modules/nltk/translate/bleu_score.html
http://www.statmt.org/lm-benchmark
http://www.statmt.org/lm-benchmark
https://github.com/pytorch/examples/tree/master/word_language_model
https://github.com/pytorch/examples/tree/master/word_language_model


6014

Model Reverse PPL↓

Real data 70.76
LSTM-LM 132.46
PRPN-LM 116.67
VAE 125.86
DSS-VAE 116.23

Table 2: Reverse PPL reflect the diversity and fluency
of sampling data, the lower↓, the better. Training on
the model sampled and evaluated on the real test set.
We set the same KL weight for DSS-VAE and VAE
here.(KL weight=1.0)

PRPN-LM. It is also seen that explicitly model-
ing syntactic structures does yield better gener-
ation results—DSS-VAE and PRPN consistently
outperform VAE and LSTM-LM in sentence gen-
eration.

We also include the Reverse PPL of the real
training sentences. As expected, training a lan-
guage model on real data outperforms training
on sampled sentences from a generation model,
showing that there is still much room for improve-
ment for all current sentence generators.

4.2 Unsupervised Paraphrase Generation

Given an input sentence, paraphrase generation
aims to synthesize a sentence that appears differ-
ent from the input, but conveys the same mean-
ing. We propose a novel approach to unsupervised
paraphrase generation with DSS-VAE. Suppose a
DSS-VAE is well trained according to §3.3, our
approach works in the inference stage.

For a particular input sentence x∗, let
q(zsyn|x∗) and q(zsem|x∗) be the encoded pos-
terior distributions of the syntactic and semantic
spaces, respectively. The inferred latent vectors
are:

z∗sem = argmaxzsem q(zsem|x
∗) (9)

z∗syn ∼ q(zsyn|x∗) (10)

and are further combined as:

z∗ =
[
z∗syn; z

∗
sem
]

(11)

Finally, z∗ is fed to the decoder and perform a
greedy decoding for paraphrase generation.

The intuition behind is that, when generating
the paraphrase, semantics should remain the same,
but the syntax of a paraphrase could (and should)
vary. Therefore, we sample a z∗syn vector from its
probabilistic distribution, while fixing z∗sem.

Model BLEU-ref↑ BLEU-ori↓

Origin Sentence† 30.49 100
VAE-SVG-eq (supervised)‡ 22.90 –
VAE (unsupervised)† 9.25 27.23
CGMH† 18.85 50.18
DSS-VAE 20.54 52.77

Table 3: Performance of paraphrase generation. The
larger↑ (or lower↓), the better. Some results are quoted
from †Miao et al. (2019) and ‡Gupta et al. (2018).

Dataset We used the established Quora dataset6
to evaluate paraphrase generation, following pre-
vious work (Miao et al., 2019). The dataset con-
tains 140k pairs of paraphrase sentences and 260k
pairs of non-paraphrase sentences. In the stan-
dard dataset split, there are 3k and 30k held-out
validation and test sets, respectively. In this ex-
periment, we consider the unsupervised setting
as Miao et al. (2019), using all non-paraphrase
sentences as training samples. It is also noted that
we only valid our model on the non-paraphrase
held-out validation set by selecting with the lowest
validation ELBO.

Evaluation Since the test set contains a refer-
ence paraphrase for each input, it is straightfor-
ward to compute the BLEU against the refer-
ence, denoted by BLEU-ref. However, this metric
alone does not model whether the generated sen-
tence is different from the input, and thus, Miao
et al. (2019) propose to measure this by comput-
ing BLEU against the original sentence (denoted
as BLEU-ori), which ideally should be low. We
only consider the DSS-VAE that yields a BLEU-
ori lower than 55, which is empirically suggested
by Miao et al. (2019) that ensures the obtained
sentence is different from the original to at least
a certain degree.

Results Table 3 shows the performance of un-
supervised paraphrase generation. In the first row
of Table 3, simply copying the original sentences
yields the highest BLEU-ref, but is meaningless
as it has a BLEU-ori score of 100. We see that
DSS-VAE outperforms the CGMH and the orig-
inal VAE in BLEU-ref. Especially, DSS-VAE
achieves a closer BLEU-ref compared with super-
vised paraphrase methods (Gupta et al., 2018).

We admit that it is hard to present the trade-off
by listing a single score for each model in the Ta-
ble 3. We therefore have the scatter plot in Fig-

6https://www.kaggle.com/c/quora-question-pairs/data

https://www.kaggle.com/c/quora-question-pairs/data


6015

 1

40.04 16.4 27.23 9.25 50.18 18.85

syntax-VAE

27.26 11.57

24.81 10.91

30.62 13.26

VAE

35.01 15.32

20.84 9.69

51.86 20.44

44.49 18.15

47.43 19.04

50.46 20.01

CGMH

BL
EU
-r
ef

8

11.5

15

18.5

22

BLEU-ori
20 25 30 35 40 45 50 55

50.18, 18.85

27.23, 9.25

DSS-VAE VAE CGMH

�1

Figure 4: Trade-off between BLEU-ori (the lower, the
better) and BLEU-ref (the larger, the better) in unsu-
pervised paraphrase generation. Again, the upper-left
corner indicates a better performance.

ure 4 to further compare these methods. As seen,
the trade-off is pretty linear and less noisy com-
pared with Figure 3. It is seen that the line of
DSS-VAE is located to the upper-left of the com-
peting methods. In other words, the plain VAE and
CGMH are “inadmissible,” meaning that DSS-
VAE simultaneously outperforms them in both
BLEU-ori and BLEU-ref, indicating that DSS-
VAE outperforms previous state-of-the-art meth-
ods in unsupervised paraphrase generation.

4.3 Syntax-Transfer Generation

In this experiment, we propose a novel application
of syntax-transfer text generation, inspired by pre-
vious sentiment-style transfer studies (Hu et al.,
2017; Fu et al., 2018; John et al., 2018).

Consider two sentences:

x1: There is a dog behind the door.

x2: The child is playing in the garden.

If we would like to generate a sentence having the
syntax of “there is/are” as x1 but conveying
the meaning of x2, we could graft the respective
syntactic and semantic vectors as:

z∗sem = argmaxzsem q(zsem|x2)
z∗syn = argmaxzsyn q(zsyn|x1)
z =

[
z∗sem; z

∗
syn
]

and then feed z to the decoder to obtain a syntax-
transferred sentence.

Dataset and Evaluation To evaluate this task,
we constructed a subset of the Stanford Natural

Language Inference (SNLI), containing 1000 non-
paraphrase pairs. SNLI sentences can be thought
of as a simple domain-specific corpus, but were all
written by humans. In each pair we constructed,
one sentence serves as the semantic provider (de-
noted by Refsem), and the other serves as the syn-
tactic provider (denoted by Refsyn). The goal of
syntax-transfer text generation is to synthesize a
sentence that resembles Refsem but not Refsyn in
semantics, and resembles Refsyn but not Refsem in
syntax. For the semantic part, we use the tradi-
tional word-based BLEU scores to evaluate how
the generated sentence is close to Refsem but dif-
ferent from Refsyn. For syntactic similarity, we use
the zss package7 to calculate the Tree Edit Dis-
tance (TED, Zhang and Shasha, 1989). TED is es-
sentially the minimum-cost sequence of node edit
operations (namely, delete, insert, and rename) be-
tween two trees, which reflects the difference of
two syntactic trees.

Since we hope the generated sentence has a
higher word-BLEU score compared with Refsem
but a lower word-BLEU score compared with
Refsyn, we compute their difference, denoted by
∆word-BLEU, to consider both. Likewise, ∆TED
is also computed. We further take the geometric
mean of ∆word-BLEU and ∆TED to take both
into account.

Results We see from Table 4 that a traditional
VAE cannot accomplish the task of syntax transfer.
This is because Refsyn and Refsem—even if we ar-
tificially split the latent space into two parts—play
the same role in the decoder. With the multi-task
and adversarial losses for syntactic and semantic
latent spaces, the total difference is increased by
12.09, which shows the success of syntax-transfer
sentence generation. This further implies that ex-
plicitly modeling syntax is feasible in the latent
space of VAE. We incrementally applied the ad-
versarial reconstruction loss, proposed in § 3.2.3.

As seen, an adversarial reconstruction loss dras-
tically strengthens the role of the other space. For
example, +L(adv)rec (zsem) repels information to the
syntactic space and achieves the highest ∆TED.

When applying the adversarial reconstruction
losses to both semantic and syntactic spaces,
we have a balance between ∆word-BLEU and
∆TED, both ranking second in the respective
columns. Eventually, we achieve the highest total
difference, showing that our full DSS-VAE model

7https://github.com/timtadh/zhang-shasha

https://github.com/timtadh/zhang-shasha


6016

Model
word-BLEU (corpus)

∆word-BLEU↑
Average TED (per sentence)

∆TED↑ Geo Mean ∆↑
Refsem↑ Refsyn↓ Refsem↑ Refsyn↓

VAE 6.81 6.68 0.13 149.22 148.59 0.63 0.29
L(mul)sem + L(mul)syn + L(adv)sem + L(adv)syn 12.14 6.22 5.92 159.51 134.80 24.71 12.09

+L(adv)rec (zsem) 11.83 6.60 5.23 163.40 131.27 32.13 12.96
+L(adv)rec (zsyn) 14.33 6.07 8.26 159.20 134.22 24.98 14.36
+L(adv)rec (zsyn) + L(adv)rec (zsem) 13.74 6.15 7.59 161.94 131.09 30.85 15.30

Table 4: Performance of syntax-transfer generation. The larger↑ (or lower↓), the better. The results of VAE are
obtained by averaging interpolation. ∆word-BLEU = word-BLEU(Refsem)−word-BLEU(Refsyn). We also com-
pute the difference as ∆TED = TED(Refsem)− TED(Refsyn) to measure if the generated sentence is syntactically
similar to Refsyn but not Refsem. Due to the difference of scale between BLEU and TED, we compute the geometric
mean of ∆word-BLEU and ∆TED reflect the total differences.

achieves the best performance of syntax-transfer
generation.

Discussion on syntax transfer between incom-
patible sentences We provide a few case stud-
ies of syntax-transfer generation in Appendix B.
We empirically find that the syntactic transfer be-
tween “compatible” sentences give more promis-
ing results than transfer between “incompatible”
sentences. Intuitively, this is reasonable because it
may be hard to transfer a sentence with a length of
5, say, to a sentence with a length of 50.

5 Conclusion

In this paper, we propose a novel DSS-VAE
model, which explicitly models syntax in the dis-
tributed latent space of VAE and enjoys the ben-
efits of sampling and manipulation in terms of
the syntax of a sentence. Experiments show that
DSS-VAE outperforms the VAE baseline in recon-
struction and unconditioned language generation.
We further make use of the sampling and manipu-
lation advantages of DSS-VAE in two novel ap-
plications, namely unsupervised paraphrase and
syntax-transfer generation. In both experiments,
DSS-VAE achieves promising results.

Acknowledgments

We would like to thank the anonymous review-
ers for their insightful comments. This work is
supported by the National Science Foundation of
China (No. 61772261 and No. 61672277) and the
Jiangsu Provincial Research Foundation for Basic
Research (No. BK20170074).

References
Samuel R. Bowman, Luke Vilnis, Oriol Vinyals, An-

drew Dai, Rafal Jozefowicz, and Samy Bengio.

2016. Generating sentences from a continuous
space. In CoNLL, pages 10–21.

Eugene Charniak. 2001. Immediate-head parsing for
language models. In ACL, pages 124–131.

Ciprian Chelba. 1997. A structured language model.
In ACL, pages 498–500.

Huadong Chen, Shujian Huang, David Chiang, and Ji-
ajun Chen. 2017. Improved neural machine trans-
lation with a syntax-aware encoder and decoder. In
ACL, pages 1936–1945.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using RNN encoder–decoder
for statistical machine translation. In EMNLP, pages
1724–1734.

Alexander Clark. 2001. Unsupervised induction of
stochastic context-free grammars using distribu-
tional clustering. In Proceedings of the ACL
2001 Workshop on Computational Natural Lan-
guage Learning.

Hanjun Dai, Yingtao Tian, Bo Dai, Steven Skiena, and
Le Song. 2018. Syntax-directed variational autoen-
coder for structured data. In ICLR.

Jan Milan Deriu and Mark Cieliebak. 2018. Syntac-
tic manipulation for generating more diverse and in-
teresting texts. In Proceedings of the 11th Interna-
tional Conference on Natural Language Generation,
pages 22–34.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A Smith. 2016. Recurrent neural network
grammars. In NAACL, pages 199–209.

Akiko Eriguchi, Kazuma Hashimoto, and Yoshimasa
Tsuruoka. 2016. Tree-to-sequence attentional neu-
ral machine translation. In ACL, pages 823–833.

Zhenxin Fu, Xiaoye Tan, Nanyun Peng, Dongyan
Zhao, and Rui Yan. 2018. Style transfer in text: Ex-
ploration and evaluation. In AAAI, pages 663–670.

https://doi.org/10.18653/v1/K16-1002
https://doi.org/10.18653/v1/K16-1002
https://doi.org/10.3115/1073012.1073029
https://doi.org/10.3115/1073012.1073029
https://doi.org/10.3115/976909.979681
http://www.aclweb.org/anthology/P17-1177
http://www.aclweb.org/anthology/P17-1177
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/D14-1179
https://www.aclweb.org/anthology/W01-0713
https://www.aclweb.org/anthology/W01-0713
https://www.aclweb.org/anthology/W01-0713
https://arxiv.org/pdf/1802.08786.pdf
https://arxiv.org/pdf/1802.08786.pdf
http://www.aclweb.org/anthology/W18-65#page=42
http://www.aclweb.org/anthology/W18-65#page=42
http://www.aclweb.org/anthology/W18-65#page=42
https://arxiv.org/abs/1602.07776
https://arxiv.org/abs/1602.07776
http://www.aclweb.org/anthology/P16-1078
http://www.aclweb.org/anthology/P16-1078
http://arxiv.org/abs/1711.06861
http://arxiv.org/abs/1711.06861


6017

Rafael Gómez-Bombarelli, Jennifer N Wei, David
Duvenaud, José Miguel Hernández-Lobato, Ben-
jamı́n Sánchez-Lengeling, Dennis Sheberla, Jorge
Aguilera-Iparraguirre, Timothy D Hirzel, Ryan P
Adams, and Alán Aspuru-Guzik. 2018. Automatic
chemical design using a data-driven continuous rep-
resentation of molecules. ACS Central Science,
4(2):268–276.

Ankush Gupta, Arvind Agarwal, Prawaan Singh, and
Piyush Rai. 2018. A deep generative framework for
paraphrase generation. In AAAI, pages 5149–5156.

Zhiting Hu, Zichao Yang, Xiaodan Liang, Ruslan
Salakhutdinov, and Eric P. Xing. 2017. Toward con-
trolled generation of text. In ICML, pages 1587–
1596.

Vineet John, Lili Mou, Hareesh Bahuleyan, and Olga
Vechtomova. 2018. Disentangled representation
learning for text style transfer. arXiv preprint
arXiv:1808.04339.

Diederik P. Kingma and Jimmy Ba. 2015. Adam: A
method for stochastic optimization. In ICLR.

Diederik P Kingma and Max Welling. 2014. Auto-
encoding variational Bayes. In ICLR.

Adhiguna Kuncoro, Miguel Ballesteros, Lingpeng
Kong, Chris Dyer, Graham Neubig, and Noah A
Smith. 2017. What do recurrent neural network
grammars learn about syntax? In EACL, pages
1249–1258.

Matt J. Kusner, Brooks Paige, and José Miguel
Hernández-Lobato. 2017. Grammar variational au-
toencoder. In ICML, pages 1945–1954.

Juncen Li, Robin Jia, He He, and Percy Liang. 2018a.
Delete, Retrieve, Generate: a simple approach to
sentiment and style transfer. In ACL, pages 1865–
1874.

Junhui Li, Deyi Xiong, Zhaopeng Tu, Muhua Zhu, Min
Zhang, and Guodong Zhou. 2017. Modeling source
syntax for neural machine translation. In ACL, pages
688–697.

Juntao Li, Yan Song, Haisong Zhang, Dongmin Chen,
Shuming Shi, Dongyan Zhao, and Rui Yan. 2018b.
Generating classical chinese poems via conditional
variational autoencoder and adversarial training. In
EMNLP, pages 3890–3900.

Lemao Liu, Muhua Zhu, and Shuming Shi. 2018. Im-
proving sequence-to-sequence constituency parsing.
In AAAI, pages 4873–4880.

Shuming Ma, Xu Sun, Yizhong Wang, and Junyang
Lin. 2018. Bag-of-words as target for neural ma-
chine translation. In ACL, pages 332–338.

Mitchell P Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1993. Building a large annotated
corpus of english: The Penn Treebank. Computa-
tional linguistics, 19(2):313–330.

Ning Miao, Hao Zhou, Lili Mou, Rui Yan, and Lei Li.
2019. CGMH: Constrained sentence generation by
Metropolis-Hastings sampling. In AAAI.

Tomáš Mikolov, Martin Karafiát, Lukáš Burget, Jan
Černockỳ, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH.

Vinod Nair and Geoffrey E Hinton. 2010. Rectified
linear units improve restricted boltzmann machines.
In ICML, pages 807–814.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. BLEU: A method for automatic
evaluation of machine translation. In ACL, pages
311–318.

Stanislau Semeniuta, Aliaksei Severyn, and Erhardt
Barth. 2017. A hybrid convolutional variational au-
toencoder for text generation. In EMNLP, pages
627–637.

Iulian Vlad Serban, Alessandro Sordoni, Ryan Lowe,
Laurent Charlin, Joelle Pineau, Aaron C Courville,
and Yoshua Bengio. 2017. A hierarchical latent
variable encoder-decoder model for generating di-
alogues. In AAAI, pages 3295–3301.

Yikang Shen, Zhouhan Lin, Chin-Wei Huang, and
Aaron Courville. 2017. Neural language modeling
by jointly learning syntax and lexicon. In ICLR.

Eric Tzeng, Judy Hoffman, Kate Saenko, and Trevor
Darrell. 2017. Adversarial discriminative domain
adaptation. In CVPR, pages 7167–7176.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In NIPS, pages 5998–6008.

Oriol Vinyals, Łukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey Hinton. 2015. Gram-
mar as a foreign language. In NIPS, pages 2773–
2781.

Rongxiang Weng, Shujian Huang, Zaixiang Zheng,
XIN-YU DAI, and CHEN Jiajun. 2017. Neural ma-
chine translation with word predictions. In EMNLP,
pages 136–145.

Kaizhong Zhang and Dennis Shasha. 1989. Simple
fast algorithms for the editing distance between trees
and related problems. SIAM journal on computing,
18(6):1245–1262.

Junbo Jake Zhao, Yoon Kim, Kelly Zhang, Alexan-
der M. Rush, and Yann LeCun. 2018. Adversarially
regularized autoencoders. In ICML, pages 5897–
5906.

Hao Zhou, Zhaopeng Tu, Shujian Huang, Xiaohua Liu,
Hang Li, and Jiajun Chen. 2017. Chunk-based bi-
scale decoder for neural machine translation. In
ACL, pages 580–586.

https://dash.harvard.edu/bitstream/handle/1/35164975/235.pdf?sequence=1&isAllowed=y
https://dash.harvard.edu/bitstream/handle/1/35164975/235.pdf?sequence=1&isAllowed=y
https://dash.harvard.edu/bitstream/handle/1/35164975/235.pdf?sequence=1&isAllowed=y
https://arxiv.org/pdf/1709.05074.pdf
https://arxiv.org/pdf/1709.05074.pdf
http://proceedings.mlr.press/v70/hu17e.html
http://proceedings.mlr.press/v70/hu17e.html
https://arxiv.org/pdf/1808.04339.pdf
https://arxiv.org/pdf/1808.04339.pdf
http://arxiv.org/abs/1412.6980
http://arxiv.org/abs/1412.6980
https://arxiv.org/pdf/1312.6114.pdf
https://arxiv.org/pdf/1312.6114.pdf
https://aclweb.org/anthology/E17-1117
https://aclweb.org/anthology/E17-1117
http://proceedings.mlr.press/v70/kusner17a/kusner17a.pdf
http://proceedings.mlr.press/v70/kusner17a/kusner17a.pdf
http://www.aclweb.org/anthology/N18-1169
http://www.aclweb.org/anthology/N18-1169
http://www.aclweb.org/anthology/P17-1064
http://www.aclweb.org/anthology/P17-1064
http://www.aclweb.org/anthology/D18-1423
http://www.aclweb.org/anthology/D18-1423
https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16347/16018
https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/view/16347/16018
https://arxiv.org/pdf/1805.04871.pdf
https://arxiv.org/pdf/1805.04871.pdf
http://anthology.aclweb.org/J/J93/J93-2004.pdf
http://anthology.aclweb.org/J/J93/J93-2004.pdf
https://arxiv.org/pdf/1811.10996.pdf
https://arxiv.org/pdf/1811.10996.pdf
https://www.isca-speech.org/archive/archive_papers/interspeech_2010/i10_1045.pdf
https://www.isca-speech.org/archive/archive_papers/interspeech_2010/i10_1045.pdf
https://www.cs.toronto.edu/~hinton/absps/reluICML.pdf
https://www.cs.toronto.edu/~hinton/absps/reluICML.pdf
https://www.aclweb.org/anthology/P02-1040
https://www.aclweb.org/anthology/P02-1040
http://www.aclweb.org/anthology/D17-1066
http://www.aclweb.org/anthology/D17-1066
http://www.cs.toronto.edu/~lcharlin/papers/vhred_aaai17.pdf
http://www.cs.toronto.edu/~lcharlin/papers/vhred_aaai17.pdf
http://www.cs.toronto.edu/~lcharlin/papers/vhred_aaai17.pdf
http://arxiv.org/abs/1711.02013
http://arxiv.org/abs/1711.02013
https://arxiv.org/pdf/1702.05464.pdf
https://arxiv.org/pdf/1702.05464.pdf
https://arxiv.org/pdf/1706.03762v1.pdf
https://arxiv.org/pdf/1706.03762v1.pdf
http://papers.nips.cc/paper/5635-grammar-as-a-foreign-language.pdf
http://papers.nips.cc/paper/5635-grammar-as-a-foreign-language.pdf
https://www.aclweb.org/anthology/D17-1013
https://www.aclweb.org/anthology/D17-1013
http://www.grantjenks.com/wiki/_media/ideas/simple_fast_algorithms_for_the_editing_distance_between_tree_and_related_problems.pdf
http://www.grantjenks.com/wiki/_media/ideas/simple_fast_algorithms_for_the_editing_distance_between_tree_and_related_problems.pdf
http://www.grantjenks.com/wiki/_media/ideas/simple_fast_algorithms_for_the_editing_distance_between_tree_and_related_problems.pdf
https://arxiv.org/pdf/1706.04223.pdf
https://arxiv.org/pdf/1706.04223.pdf
http://www.aclweb.org/anthology/P17-2092
http://www.aclweb.org/anthology/P17-2092


6018

A Hyperparameter Details

We list the hyperparaemters in Tables 5 and 6. Ev-
ery 500 batch, we save the model if it achieves a
lower evidence lower bound (ELBO) on the vali-
dation set.

B Case Study of Syntax Transfer

We provide a few examples in Table 7. We see in
all cases that a plain VAE “interpolates” two sen-
tences without the consideration of syntax and se-
mantics, whereas our DSS-VAE is able to transfer
the syntax without changing the meaning much.
In the first example, DSS-VAE successfully trans-
fer a “subject-be-predicative” sentence to a “there
is/are” sentence. For the second example, the se-
mantic reference has the same syntactic structure
as the syntax reference, and as a result, DSS-VAE
generates the same sentence as Refsem. For the last
example, we transfer a “there is/are“ sentence to
a “subject-be-predicative“ sentence, and our DSS-
VAE is also able to generate the desired syntax.



6019

Hyper-parameters Value
λKLsem 1.0
λKLsyn 1.0
λmulsem 0.5
λmulsyn 0.5
λadvsem 0.5
λadvsyn 0.5
λrecsem 0.5
λrecsyn 0.5

Batch size 32
GRU Dropout 0.1

Table 5: The hyper-parameters we used in PTB
dataset

Hyper-parameters Value
λKLsem 1/3
λKLsyn 2/3
λmulsem 5.0
λmulsyn 1.0
λadvsem 0.5
λadvsyn 0.5
λrecsem 1.0
λrecsyn 0.05

Batch size 50
GRU Dropout 0.3

Table 6: The hyper-parameters we used in Quora
dataset.

Semantic and Syntactic Providers Syntax-Transfer Output
Refsyn: There is an apple on the table.
Refsem: The airplane is in the sky.

VAE: The man is in the kitchen.
DSS-VAE: There is a airplane in the sky.

Refsyn: The shellfish was cooked in a wok.
Refsem: The stadium was packed with people.

VAE: The man was filled with people.
DSS-VAE: The stadium was packed with people.

Refsyn: The child is playing in the garden.
Refsem: There is a dog behind the door.

VAE: There is a person in the garden.
DSS-VAE: A dog is walking behind the door.

Table 7: Case studies of syntax transfer generation.


