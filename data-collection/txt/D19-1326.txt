



















































Let’s Ask Again: Refine Network for Automatic Question Generation


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 3314–3323,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

3314

Let’s Ask Again: Refine Network for Automatic Question Generation

Preksha Nema†‡∗ Akash Kumar Mohankumar†∗ Mitesh M. Khapra†‡
Balaji Vasan Srinivasan• Balaraman Ravindran†‡

†IIT Madras, India •Adobe Research
‡ Robert Bosch Center for Data Science and Artificial Intelligence, IIT Madras

{preksha,miteshk,ravi}@cse.iitm.ac.in
makashkumar99@gmail.com {balsrini}@adobe.com

Abstract
In this work, we focus on the task of Au-
tomatic Question Generation (AQG) where
given a passage and an answer the task is to
generate the corresponding question. It is de-
sired that the generated question should be
(i) grammatically correct (ii) answerable from
the passage and (iii) specific to the given an-
swer. An analysis of existing AQG mod-
els shows that they produce questions which
do not adhere to one or more of the above-
mentioned qualities. In particular, the gener-
ated questions look like an incomplete draft
of the desired question with a clear scope
for refinement. To alleviate this shortcoming,
we propose a method which tries to mimic
the human process of generating questions by
first creating an initial draft and then refin-
ing it. More specifically, we propose Re-
fine Network (RefNet) which contains two de-
coders. The second decoder uses a dual at-
tention network which pays attention to both
(i) the original passage and (ii) the question
(initial draft) generated by the first decoder.
In effect, it refines the question generated by
the first decoder, thereby making it more cor-
rect and complete. We evaluate RefNet on
three datasets, viz., SQuAD, HOTPOT-QA,
and DROP, and show that it outperforms exist-
ing state-of-the-art methods by 7-16% on all
of these datasets. Lastly, we show that we can
improve the quality of the second decoder on
specific metrics, such as, fluency and answer-
ability by explicitly rewarding revisions that
improve on the corresponding metric during
training. The code has been made publicly
available 1.

1 Introduction

Over the past few years, there has been a growing
interest in Automatic Question Generation (AQG)

∗* The first two authors have contributed equally to this
work.

1https://github.com/PrekshaNema25/RefNet-QG

Passage 1: Liberated by Napoleon’s army in 1806,
Warsaw was made the capital of the newly created
Duchy of Warsaw.
Generated Questions

Baseline What was the capital of the newly
duchy of Warsaw?

RefNet Who liberated Warsaw in 1806?
Reward-RefNet Whose army liberated Warsaw

in 1806?
Passage 2: To fix carbon dioxide into sugar molecules
in the process of photosynthesis, chloroplasts use an en-
zyme called rubisco
Generated Questions

Baseline What does chloroplasts use?
RefNet What does chloroplasts use to fix

carbon dioxide into sugar molecules?
Reward-RefNet What do chloroplasts use to fix

carbon dioxide into sugar molecules?

Table 1: Samples of generated questions from Base-
line, RefNet and Reward-RefNet model on the SQuAD
dataset. Answers are shown in blue
.

from text - the task of generating a question from
a passage and optionally an answer. AQG is used
in curating Question Answering datasets, enhanc-
ing user experience in conversational AI systems
(Shum et al., 2018) and for creating educational
materials (Heilman and Smith, 2010). For the
above applications, it is essential that the questions
are (i) grammatically correct (ii) answerable from
the passage and (iii) specific to the answer. Ex-
isting approaches focus on encoding the passage,
the answer and the relationship between them us-
ing complex functions and then generate the ques-
tion in one single pass. However, by carefully
analysing the generated questions, we observe that
these approaches tend to miss one or more of the
important aspects of the question. For instance, in
Table 1, the question generated by the single-pass
baseline model for the first passage is grammat-
ically correct but is not specific to the answer. In
the second example, the generated question is both
syntactically incorrect and incomplete.



3315

The above examples indicate that there is clear
scope of improving the general quality of the ques-
tions. Additionally, the quality can be specifically
improved in terms of aspects like: fluency (Exam-
ple 2) and answerability (Example 1). One way
to approach this is by re-visiting the passage and
answer with the aim to refine the initial draft by
generating a better question in the second pass and
then improving it with respect to a certain aspect.
We can draw a comparison between this process
and how humans tend to write a rough initial draft
first and then refine it over multiple passes, where
the later revisions focus on improving the draft
aiming at certain aspects like fluency or complete-
ness. With this motivation, we propose Refine
Network (RefNet), which examines the initially
generated question and performs a second pass to
generate a revised question. Furthermore, we pro-
pose Reward-RefNet which uses explicit reward
signals to achieve refinement focused on specific
properties of the question such as fluency and an-
swerability.

Our RefNet is a seq2seq based model that com-
prises of two decoders: Preliminary and Refine-
ment Decoder. The Refinement Decoder takes the
initial draft of the question generated by the Pre-
liminary decoder as an input along with passage
and answer, and generates the refined question
by attending onto both the passage and the initial
draft using a Dual Attention Network. The pro-
posed dual attention aids RefNet to generate the
final question by revisiting the appropriate parts of
the input passage and initial draft. From Table 1,
we can infer that our RefNet model is able to gen-
erate better questions in the second pass by fixing
the errors in the initial draft. Our Reward-RefNet
model uses REINFORCE with a baseline algo-
rithm to explicitly reward the Refinement Decoder
for generating a better question as compared to the
Preliminary Decoder based on certain desired pa-
rameters like fluency and answerability. This leads
to more answerable (see Reward-RefNet example
for passage 1 in Table 1) and fluent (see Reward-
RefNet example for passage 2 in Table 1) ques-
tions as compared to vanilla RefNet model.

Our experiments show that the proposed RefNet
model outperforms existing state-of-the-art mod-
els on the SQuAD dataset by 12.3% and 3.7% (on
BLEU) given the relevant sentence and passage re-
spectively. We also achieve state-of-the-art results
on HOTPOT-QA and DROP datasets with an im-

provement of 7.57% and 15.25% respectively over
the single-decoder baseline (on BLEU). Our hu-
man evaluations further validate these results. We
further analyze and explain the impact of includ-
ing the Refinement Decoder by examining the in-
teraction between both the decoders. Interestingly,
we observe that the inclusion of the Refinement
Decoder boosts the quality of the questions gener-
ated by the initial decoder also. Lastly, our human
evaluation of the questions generated by Reward-
RefNet corroborate empirical results, i.e., it im-
proves the question w.r.t. to fluency and answer-
ability as compared to RefNet questions.

2 Refine Networks (RefNet) Model

In this section, we discuss various components of
our proposed model as shown in Figure 1. For
a given passage P = {wp1, . . . , w

p
m} of length

m and answer A = {wa1 , . . . , wan} of length n,
we first obtain answer-aware latent representation,
U = {h̃p1, . . . , h̃

p
m}, for every word of the passage

and an answer representation ha (as described in
Section 2.1). We then generate an initial draft Q̃ =
{q̃1, . . . , q̃T } by computing q̃t as

q̃t = argmax
q̃

l∏
t=1

p̃(q̃t|q̃t−1, . . . , q̃1,U,ha)

Here p̃(.) is a probability distribution modeled
using the Preliminary Decoder. We then refine the
initial draft Q̃ using the Refinement Decoder to
obtain the refined draft Q = {q1, . . . qT }:

qt = argmax
q

l∏
t=1

p(qt|qt−1, . . . , q1, Q̃,U,ha)

We then use explicit rewards to enforce refinement
on a desired metric, such as, fluency or answer-
ability through our Reward-RefNet model. In the
following sub-sections, we describe the passage
encoder, preliminary and refinement decoders and
our reward mechanism.

2.1 Passage and Answer Encoder

We use a 3 layered encoder consisting of: (i) Em-
bedding, (ii) Contextual and (iii) Passage-Answer
Fusion layers as described below. To capture inter-
action between passage and answer, we ensure that
the passage and answer representations are fused
together at every layer.



3316

Preliminary	Decoder	-
Encoder	Attention

(A1)	

Attention	on	Encoder
(A2)

Attention	on	Preliminary
Decoder(A3)

Passage-Answer	
Fusion

Passage	Encoder Answer	Encoder

Preliminary	Decoder

Word Embedding

Char Embedding

Answer Tagging

Output from Module

Input to Module
Refinement	Decoder

Dual	Attention	Network

Figure 1: Our RefNet model with Preliminary and Refinement Decoder.

Embedding Layer: In this layer, we compute a
d-dimensional embedding for every word in the
passage and the answer. This embedding is ob-
tained by concatenating the word’s Glove embed-
ding (Pennington et al., 2014) with its charac-
ter based embedding as discussed in (Seo et al.,
2016). Additionally, for passage words, we also
compute a positional embedding based on the rel-
ative position of the word w.r.t. the answer span
as described in (Zhao et al., 2018). For every pas-
sage word, this positional embedding is also con-
catenated to the word and character based embed-
dings. We discuss the impact of character embed-
dings and answer tagging in Appendix A. In the
subsequent sections, we will refer to embedding
of the i-th passage word wpi as e(w

p
i ) and the j-th

answer word waj as e(w
a
j ).

Contextual Layer: In this layer, we compute a
contextualized representation for every word in
the passage by passing the word embeddings (as
computed above) through a bidirectional-LSTM
(Hochreiter and Schmidhuber, 1997):

−→
hpt = LSTM(e(w

p
t ),
−→
hpt−1) ∀t ∈ [1,m]

where
−→
hpt is the hidden state of the forward LSTM

at time t. We then concatenate the forward and
backward hidden states as hpt = [

−→
hpt ;
←−
hpt ].

The answer could correspond to a span in the
passage. Let j + 1 and j + n be the start and end
indices of the answer span in the passage respec-
tively. We can thus refer to {hpj+1, . . . ,h

p
j+n} as

the representation of the answer words in the con-
text of the passage. We then obtain contextualized
representations for the n answer words by passing
them through LSTM as follows:

−→
hat = LSTM([e(w

a
t ),h

p
j+t],

−→
hat−1) ∀t ∈ [1, n]

The final state ha = [
−→
han;
←−
han] of this Bi-LSTM

is used as the answer representation in the subse-
quent stages. When the answer is not present in
the passage, only e(wat ) is passed to the LSTM.

Passage-Answer Fusion Layer: In this layer, we
refine the representations of the passage words
based on the answer representation as follows:

h̃pi = tanh (Wu [h
p
i ; h

a; hpi � h
a]) ∀i ∈ [1,m]

Here Wu ∈ Rl×3l. l is the hidden size of LSTM.
This is similar to how (Seo et al., 2016) capture
interactions between passage and question for QA.
We use U = {h̃p1, . . . , h̃

p
m} as the fused passage-

answer representation which is then used by our
decoder(s) to generate the question Q.

2.2 Preliminary and Refinement Decoders

As discussed earlier, RefNet has two decoders,
viz., Preliminary Decoder and Refinement De-
coder, as described below:

Preliminary Decoder: This decoder generates an
initial draft of the question, one word at a time,



3317

using an LSTM as follows:

h̃dt = LSTM([ew(q̃t−1); c̃t−1;h
a], h̃dt−1)

c̃t =

m∑
i=1

αith̃
p
i (1)

Here h̃dt is the hidden state at time t, h
a is the

answer representation as computed above, c̃t−1 is
an attention weighted sum of the contextualized
passage word representations, αit are parameter-
ized and normalized attention weights (Bahdanau
et al., 2014). Let’s call this attention network as
A1. ew(q̃t) is the embedding of the word q̃t. We
obtain q̃t as:

q̃t = argmax
q̃

(softmax(Wo[Wc[h̃dt ; c̃t])), (2)

where Wc is a Rl×2l matrix and Wo is the output
matrix which projects the final representation to
RV where V is the vocabulary size.

Refinement Decoder: Once the preliminary
decoder generates the entire question, the refine-
ment decoder uses it to generate an updated ver-
sion of the question using a Dual Attention Net-
work. It first computes an attention weighted sum
of the embeddings of the words generated by the
first decoder as:

gt =
T∑
i=1

βtiew(q̃i)

where βti are parameterized and normalized atten-
tion weights computed by attention network A3.
Since the initial draft could be erroneous or in-
complete, we obtain additional information from
the passage instead of only relying on the output
of the first decoder. We do so by computing a con-
text vector ct as

ct =

m∑
i=1

γti h̃
p
i

where γti are parameterized and normalized atten-
tion weights computed by attention network A3.
The hidden state of the refinement decoder at time
t is computed as follows:

hdt = LSTM([e(qt−1); ct−1;gt−1;h
a],hdt−1)

Finally, qt is predicted using

qt = argmax
q

(softmax(Wo[W′c[hdt ; ct−1;gt−1]))

where W′c is a weight matrix and Wo is the out-
put matrix which is shared with the Preliminary
decoder (Equation 2). Note that RefNet generates
two variants of the question : initial draft Q̃ and
final draft Q. We compare these two versions of
the generated questions in Section 4.

2.3 Reward-RefNet

Next, we address the following question: Can the
refinement decoder be explicitly rewarded for gen-
erating a question which is better than that gener-
ated by the preliminary decoder on certain desired
parameters? For example, (Nema and Khapra,
2018) define fluency and answerability as desired
qualities in the generated question. They evalu-
ate fluency using BLEU score and answerability
using a score which captures whether the ques-
tion contains the required {named entities, im-
portant words, function words, question types}
(and is thus answerable). We use these fluency
and answerability scores proposed by (Nema and
Khapra, 2018) as reward signals. We first compute
the reward r(Q̃) and r(Q) for the question gen-
erated by the preliminary and refinement decoder
respectively. We then use “REINFORCE with a
baseline” algorithm (Williams, 1992) to reward
Refinement Decoder using the Preliminary De-
coder’s reward r(Q̃) as the baseline. More specif-
ically, given the Preliminary Decoder’s generated
word sequence Q̃ = {q̃1, q̃2, . . . , q̃T } and the
Refinement Decoder’s generated word sequence
Q = {q1, q2, . . . , qT } obtained from the distribu-
tion p(qt|qt−1, . . . , q1, Q̃,U,ha), the training loss
is defined as follows

L(Q) =(r(Q)− r(Q̃))·
T∑
t=1

log p(qt| qt−1, . . . , q1, Q̃,U,ha)

where r(Q) and r(Q̃) are the rewards obtained by
comparing with the reference question Q∗. As
mentioned, this reward r(.) can be the fluency
score or answerability score as defined by (Nema
and Khapra, 2018).

2.4 Copy Module

Along with the above-mentioned three modules,
we adopt the pointer-network and coverage mech-
anism from (See et al., 2017). We use it to (i) han-
dle Out-of-Vocabulary words and (ii) avoid repeat-
ing phrases in the generated questions.



3318

Dataset Model n-gram
BLEU-1 BLEU-2 BLEU-3 BLEU-4 ROUGE-L METEOR QBLEU4

SQuAD
(Sentence Level)

(Sun et al., 2018) 43.02 28.14 20.51 15.64 - - -
(Zhao et al., 2018) 44.51 29.07 21.06 15.82 44.24 19.67 -
(Kim et al., 2019) - - - 16.17 - - -
EAD 44.74 29.79 22.00 16.84 44.78 20.60 24.7
RefNet 47.27 31.88 23.65 18.16 47.14 23.40 27.4

SQuAD
(Passage Level)

(Zhao et al., 2018) 45.07 29.58 21.60 16.38 44.48 20.25 -
EAD 44.61 29.37 21.50 16.36 43.95 20.11 24.2
RefNet 46.41 30.66 22.42 16.99 45.03 21.10 26.6

HOTPOT
(Zhao et al., 2018)* 45.29 32.06 24.43 19.29 40.40 19.29 25.7
EAD 46.00 32.47 24.82 19.68 41.52 23.27 26.2
RefNet 45.45 33.13 26.05 21.17 43.12 25.81 28.7

DROP Dataset
(Zhao et al., 2018)* 39.56 29.19 22.53 18.07 45.01 19.68 31.4
EAD 39.21 29.10 22.65 18.42 45.07 19.56 31.8
RefNet 42.81 32.63 25.78 21.23 47.49 22.25 33.6

Table 2: Comparsion of RefNet model with existing approaches and EAD model. Here * denotes our implemen-
tation of the corresponding work.

3 Experimental Details

In this section, we discuss (i) the datasets for
which we tested our proposed model, (ii) imple-
mentation details and (iii) evaluation metrics used
to compare our model with the baseline and exist-
ing works.

3.1 Datasets

SQuAD (Rajpurkar et al., 2016): It contains
100K (question, answer) pairs obtained from 536
Wikipedia articles, where the answers are a span
in the passage. For SQuAD, AQG has been tried
from both sentences and passages. In the former
case, only the sentence which contains the answer
span is used as input, whereas in the latter case
the entire passage is used. We use the same train-
validation-test splits as used in (Zhao et al., 2018).
Hotpot QA (Yang et al., 2018) : Hotpot-QA is a
multi-document and multi-hop QA dataset. Along
with the triplet (P, A, Q), the authors also provide
supporting facts that potentially lead to the answer.
The answers here are either yes/no or answer span
in P. We concatenate these supporting facts to form
the passage. We use 10% of the training data for
validation and use the original dev set as test set.
DROP (Dua et al., 2019): The DROP dataset is a
reading comprehension benchmark which requires
discrete reasoning over passage. It contains 96K
questions which require discrete operations such
as addition, counting, or sorting to obtain the an-
swer. We use 10% of the original training data for
validation and use the original dev set as test set.

3.2 Implementation Details

We use 300 dimensional pre-trained Glove word
embeddings, which are fixed during training. For
character-level embeddings, we initially use a 20
dimensional embedding for the characters which
is then projected to 100 dimensions. For answer-
tagging, we use embedding size of 3. The hidden
size for all the LSTMs is fixed to 512. We use 2-
layer, 1-layer and 2-layer stacked BiLSTM for the
passage encoder, answer encoder and the decoders
(both) respectively. We take the top 30, 000 fre-
quent words as the vocabulary. We use Adam op-
timizer with a learning rate of 0.0004 and train our
models for 10 epochs using cross entropy loss. For
the Reward-RefNet model, we fine-tune the pre-
trained model with the loss function mentioned in
Section 2.3 for 3 epochs. The best model is chosen
based on the BLEU (Papineni et al., 2002) score
on the validation split. For all the results we use
beam search decoding with a beam size of 5.

3.3 Evaluation

We evaluate our models, based on n-gram sim-
ilarity metrics BLEU (Papineni et al., 2002),
ROUGE-L (Lin, 2004), and METEOR (Lavie and
Denkowski, 2009) using the package released
in (Sharma et al., 2017)2. We also quantify
the answerability of our models using QBLEU-
43(Nema and Khapra, 2018).

2https://github.com/Maluuba/nlg-eval
3https://github.com/PrekshaNema25/

Answerability-Metric

https://github.com/Maluuba/nlg-eval
https://github.com/PrekshaNema25/Answerability-Metric
https://github.com/PrekshaNema25/Answerability-Metric


3319

4 Results and Discussions

In this section, we present the results and analysis
of our proposed model RefNet. Throughout this
section, we refer to our models as follows:

Encode-Attend-Decode (EAD) model is our sin-
gle decoder model containing the encoder and
the Preliminary Decoder described earlier. Note
that the performance of this model is comparable
to our implementation of the model proposed in
(Zhao et al., 2018).

Refine Network (RefNet) model includes the en-
coder, the Preliminary Decoder and the Refine-
ment Decoder.
We will (i) compare RefNet’s performance with
EAD and existing models across all the mentioned
datasets (ii) report human evaluations to compare
RefNet and EAD (iii) analyze Refinement and Pre-
liminary Decoders iv) present the performance of
Reward RefNet with two different reward signal
(fluency and answerability).

4.1 RefNet’s performance across datasets
In Table 2, we compare the performance of
RefNet with existing single decoder architectures
across different datasets. On BLEU-4 metric,
RefNet beats the existing state-of-the-art model by
12.30%, 9.74%, 17.48%, and 3.71% respectively
on SQuAD (sentence), HOTPOT-QA, DROP and
SQuAD (passage) dataset. Also it outperforms
EAD by 7.83%, 7.57%, 15.25% and 3.85% re-
spectively on SQuAD (sentence), HOTPOT-QA,
DROP and SQuAD (passage). In general, RefNet
is consistently better than existing models across
all n-gram scores (BLEU, ROUGE-L and ME-
TEOR). Along with n-gram scores, we also ob-
serve improvements on Q-BLEU4 as well, which
as described earlier, gives a measure of both an-
swerability and fluency.

4.2 Human Evaluations
We conducted human evaluations to analyze the
quality of the questions produced by EAD and
RefNet. We randomly sampled 500 questions gen-
erated from the SQuAD (sentence level) dataset
and asked the annotators to compare the qual-
ity of the generated questions. The annotators
were shown a pair of questions, one generated by
EAD and one by RefNet from the same sentence,
and were asked to decide which one was better
in terms of Fluency, Completeness, and Answer-
ability. They were allowed to skip the question

Passage: Before the freeze ended in 1952, there were
only 108 existing television stations in the United
States; a few major cities (such as Boston) had only two
television stations, ...
Questions
EAD: how many television stations existed in boston ?
RefNet: how many television stations did boston have
in the united ?

Table 3: An example where EAD model was better
than RefNet. The ground truth answers are shown in
blue.

Model Decoder BLEU-4 QBLEU-4

without A3
RefNet 17.16 25.80
Initial Draft 17.59 26.00

with A3
RefNet 18.37 27.40
Initial Draft 17.89 26.00

Table 4: Comparison between Preliminary Decoder
and Refinement Decoder in RefNet Model for SQuAD
Sentence Level QG.

pairs where they could not make a clear choice.
Three annotators rated each question and the fi-
nal label was calculated based on majority vot-
ing. We observed that the RefNet model outper-
forms the EAD model across all three metrics.
Over 68.6%, 66.7% and 64.2% of the generated
questions from RefNet were respectively more flu-
ent, complete and answerable when compared to
the EAD model. However, there are some cases
where EAD does better than RefNet. For exam-
ple, in Table 3, we show that while trying to gen-
erate a more elaborate question, RefNet introduces
an additional phrase “in the united” which is not
required. Due to such instances, annotators pre-
ferred the EAD model in around 30% of the in-
stances.

4.3 Analysis of Refinement Decoder and
Preliminary Decoder

The two decoders impact each other through two
paths: (i) indirect path, where they share the en-
coder and the output projection to the vocabulary
V , (ii) direct path, via the dual attention network,
where the initial draft of the question is attended
by the Refinement Decoder. When RefNet has
only indirect path, we can infer from row 1 of
Table 4 that the performance of Preliminary De-
coder improves when compared to the EAD model
(16.84 v/s 17.59 BLEU). This suggests that gen-
erating two variants of the question improves the
performance of the first decoder pass as well. This
is perhaps due to the additional feedback that the



3320

Sample:

Sentence: For instance , the language { xx — x is any binary string } can be solved in
linear time on a multi-tape Turing machine , but necessarily requires
quadratic time in the model of single-tape Turing machines .
Reference Question: A multi-tape Turing machine requires what type of time for a solution ?

with A3
Refinement Decoder: in what time can the language be solved on a multi-tape turing machine ?
Preliminary Decoder: in what time can the language be solved ?

without A3
Refinement Decoder: in what time can the language { xx — x x x x is any binary string ?
Preliminary Decoder: in what time can the language — x x x x is solved ?

Table 5: Generated samples by Preliminary Decoder and Refinement Decoder in RefNet model.

Figure 2: Generated Question Length Distribution for
Preliminary Decoder (First Decoder) and Refinement
Decoder (Second Decoder).

shared encoder and output layer get from the Re-
finement Decoder. When we add the direct path
(attention network) between the two decoders, the
performance of the Refinement Decoder improves
as compared to the Preliminary Decoder as shown
in rows 3 and 4 of the Table 4
Comparison on Answerability: We also evaluate
both the initial and refined draft using QBLEU4.
As discussed earlier, Q-Metric measures Answer-
ability using four components, viz., Named Enti-
ties, Important Words, Function Words, and Ques-
tion Type. We observe that the increase in Q-
Metric for refined questions is because the RefNet
model can correct/add the relevant Named Enti-
ties in the question. In particular, we observe that
the Named Entity component score in Q-Metric
increases from 32.42 for the first draft to 37.81 for
the refined draft.

Qualitative Analysis: Figure 2 shows that the
RefNet model indeed generates more elaborate
questions when compared to the Preliminary De-
coder. As shown in Table 5, the quality of the re-
fined question is better than the initial draft of the
questions. Here RefNet adds the phrase “multi-
tape Turing Machine,” (row 2) which removes any

Model
BLEU

Reward Signal
Answerability
Reward Signal

BLEU4
%prefer-
ence

Ans.
%prefer
ence

RefNet 18.37 32.9% 36.9 30%
Reward-RefNet 18.52 67.1% 37.5 70%

Table 6: Impact of Reward-RefNet on fluency and an-
swerability. %preference denotes the percentage of
times annotators prefer the generated output from the
model for fluency in case of BLEU Reward signal and
answerability in case of Answerability Reward signal.

Passage: Cost engineers and estimators apply expertise
to relate the work and materials involved to a proper
valuation
Questions
Generated: Who apply expertise to relate the work and
materials involved to a proper valuation ?
True: Who applies expertise to relate the work and ma-
terials involved to a proper valuation ?

Table 7: An example of question with significant over-
lap with the passage. The answer is shown in blue.

ambiguity in the question.

4.4 Analysis of Reward-RefNet

In this section, we analyze the impact of employ-
ing different reward signals in Reward-RefNet. As
discussed earlier in section 2.3, we use fluency and
answerability scores as reward signals. As shown
in Table 6, when BLEU-4 (fluency) is used as a
reward signal, there is improvement in BLEU-4
scores of Reward-RefNet as compared to RefNet
model. We validated these results through human
evaluations across 200 samples. Annotators pre-
fer the Reward-RefNet model in 67% of the cases
for fluency. Similarly when we use Answerability
score as a reward signal, answerability improves
for the model and annotators prefer the Reward-
RefNet in 70% of the cases for answerability. The
performance of Reward-RefNet on fluency and an-
swerability is similar for other datasets (see Ap-
pendix B).
Case Study: Originality of the Questions



3321

Figure 3: Originality Analysis: Plot of Q-BLEU score
vs N - the number points selected.

We observe that current state-of-the-art models
perform very well in terms of BLEU/QBLEU
scores when the actual question has significant
overlap with the passage. For example, consider
a passage from the SQuAD dataset in Table 7,
where except the question word who, the model
sequentially copies everything from the passage
and achieves a QBLEU score of 92.4. However,
the model performs poorly in situations where the
true question is novel and does not contain a large
sequence of words from the passage itself. In or-
der to quantify this, we first sort the true questions
based on its BLEU-2 overlap with the passage in
ascending order. We then select the first N true
questions and compute the QBLEU score with the
generated questions. The results are shown in red
in Figure 3. Towards the left, where there are true
questions with low overlap with the passage, the
performance is poor, but it gradually improves as
the overlap increases.

The task of generating questions with high orig-
inality (where the model phrases the question in its
own words) is a challenging aspect of AQG since
it requires complete understating of the seman-
tics and syntax of the language. In order to im-
prove questions generated on originality, we ex-
plicitly reward our model for having low n-gram
score with the passage as compared to the initial
draft. As a result we observe that with Reward-
RefNet(Originality), there is an improvement in
the performance where the overlap with the pas-
sage was less (as shown in blue in Figure 3).As
shown in Table 8, although both questions are an-
swerable given the passage, the question generated
from Reward-RefNet(Originality) is better.

Passage: McLetchie was elected on the Lothian re-
gional list and the Conservatives suffered a net loss of
five seats , with leader Annabel Goldie claiming that
their support had held firm, nevertheless, she too an-
nounced she would step down as leader of the party.
Questions
True: Who announced she would step down as leader
of the Conservatives ?
RefNet: who claiming that their support had held firm ?
Reward-RefNet: who was the leader of the conserva-
tives?

Table 8: An example where Reward-
RefNet(Originality) is better than RefNet.

5 Related Work

Early works on Question Generation were essen-
tially rule based systems (Heilman and Smith,
2010; Mostow and Chen, 2009; Lindberg et al.,
2013; Labutov et al., 2015). Current models
for AQG are based on the encode-attend-decode
paradigm and they either generate questions from
the passage alone (Du and Cardie, 2017; Du et al.,
2017; Yao et al., 2018) or from the passage and
a given answer (in which case the generated ques-
tion must result in the given answer). Over the past
couple of years, several variants of the encode-
attend-decode model have been proposed. For ex-
ample, (Zhou et al., 2018) proposed a sequential
copying mechanism to explicitly select a sub-span
from the passage. Similarly, (Zhao et al., 2018)
mainly focuses on efficiently incorporating para-
graph level content by using Gated Self Attention
and Maxout pointer networks. Some works (Yuan
et al., 2017) even use Question Answering as a
metric to evaluate the generated questions. There
has also been some work on generating questions
from images (Jain et al., 2017; Li et al., 2017) and
from knowledge bases (Serban et al., 2016; Reddy
et al., 2017). The idea of multi pass decoding
which is central to our work has been used by (Xia
et al., 2017) for machine translation and text sum-
marization albeit with a different objective. Some
works have also augmented seq2seq models (Ren-
nie et al., 2017; Paulus et al., 2018; Song et al.,
2017) with external reward signals using REIN-
FORCE with baseline algorithm (Williams, 1992).
The typical rewards used in these works are BLEU
and ROUGE scores. Our REINFORCE loss is dif-
ferent from the previous ones as it uses the first
decoder’s reward as the baseline instead of reward
of the greedy policy.



3322

6 Conclusion and Future Work

In this work, we proposed Refine Networks
(RefNet) for Question Generation to focus on re-
fining and improving the initial version of the gen-
erated question. Our proposed RefNet model con-
sisting of a Preliminary Decoder and a Refine-
ment Decoder with Dual Attention Network out-
performs the existing state-of-the-art models on
the SQuAD, HOTPOT-QA and DROP datasets.
Along with automated evaluations, we also con-
ducted human evaluations to validate our findings.
We further showed that using Reward-RefNet im-
proves the initial draft on specific aspects like flu-
ency, answerability and originality. As a future
work, we would like to extend RefNet to have the
ability to decide whether a refinement is needed on
the generated initial draft.

Acknowledgements

We thank Amazon Web Services for providing
free GPU compute and Google for supporting
Preksha Nema’s contribution in this work through
Google Ph.D. Fellowship programme. We would
like to acknowledge Department of Computer Sci-
ence and Engineering, IIT Madras and Robert
Bosch Center for Data Sciences and Artificial In-
telligence, IIT Madras (RBC-DSAI) for provid-
ing us sufficient resources. We would also like to
thank Patanjali SLPSK, Sahana Ramnath, Rahul
Ramesh, Anirban Laha, Nikita Moghe and the
anonymous reviewers for their valuable and con-
structive suggestions.

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua

Bengio. 2014. Neural machine translation by
jointly learning to align and translate. CoRR,
abs/1409.0473.

Xinya Du and Claire Cardie. 2017. Identifying where
to focus in reading comprehension for neural ques-
tion generation. In EMNLP, pages 2067–2073. As-
sociation for Computational Linguistics.

Xinya Du, Junru Shao, and Claire Cardie. 2017. Learn-
ing to ask: Neural question generation for reading
comprehension. In ACL (1), pages 1342–1352. As-
sociation for Computational Linguistics.

Dheeru Dua, Yizhong Wang, Pradeep Dasigi, Gabriel
Stanovsky, Sameer Singh, and Matt Gardner. 2019.
DROP: A reading comprehension benchmark re-
quiring discrete reasoning over paragraphs. In Proc.
of NAACL.

Michael Heilman and Noah A. Smith. 2010. Good
question! statistical ranking for question genera-
tion. In HLT-NAACL, pages 609–617. The Associa-
tion for Computational Linguistics.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Comput., 9(8):1735–
1780.

Unnat Jain, Ziyu Zhang, and Alexander G. Schwing.
2017. Creativity: Generating diverse questions us-
ing variational autoencoders. In CVPR, pages 5415–
5424. IEEE Computer Society.

Yanghoon Kim, Hwanhee Lee, Joongbo Shin, and
Kyomin Jung. 2019. Improving neural ques-
tion generation using answer separation. CoRR,
abs/1809.02393.

Igor Labutov, Sumit Basu, and Lucy Vanderwende.
2015. Deep questions without deep understanding.
In ACL (1), pages 889–898. The Association for
Computer Linguistics.

Alon Lavie and Michael J. Denkowski. 2009. The
meteor metric for automatic evaluation of machine
translation. Machine Translation, 23(2-3):105–115.

Yikang Li, Nan Duan, Bolei Zhou, Xiao Chu, Wanli
Ouyang, and Xiaogang Wang. 2017. Visual ques-
tion generation as dual task of visual question an-
swering. CoRR, abs/1709.07192.

Chin-Yew Lin. 2004. Rouge: A package for automatic
evaluation of summaries. In Proc. ACL workshop on
Text Summarization Branches Out, page 10.

David Lindberg, Fred Popowich, John C. Nesbit, and
Philip H. Winne. 2013. Generating natural language
questions to support learning on-line. In ENLG,
pages 105–114. The Association for Computer Lin-
guistics.

Jack Mostow and Wei Chen. 2009. Generating instruc-
tion automatically for the reading strategy of self-
questioning. In AIED, volume 200 of Frontiers in
Artificial Intelligence and Applications, pages 465–
472. IOS Press.

Preksha Nema and Mitesh M. Khapra. 2018. Towards a
better metric for evaluating question generation sys-
tems. CoRR, abs/1808.10192.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. Bleu: a method for automatic eval-
uation of machine translation. In ACL, pages 311–
318. ACL.

Romain Paulus, Caiming Xiong, and Richard Socher.
2018. A deep reinforced model for abstractive sum-
marization. CoRR, abs/1705.04304.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. Glove: Global vectors for
word representation. In Empirical Methods in Nat-
ural Language Processing (EMNLP), pages 1532–
1543.



3323

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and
Percy Liang. 2016. Squad: 100, 000+ questions for
machine comprehension of text. In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing, EMNLP 2016, Austin,
Texas, USA, November 1-4, 2016, pages 2383–2392.

Sathish Reddy, Dinesh Raghu, Mitesh M. Khapra, and
Sachindra Josh. 2017. Generating natural language
question-answer pairs from a knowledge graph us-
ing a RNN based question generation model. In
EACL (1), pages 376–385. Association for Compu-
tational Linguistics.

Steven J. Rennie, Etienne Marcheret, Youssef Mroueh,
Jarret Ross, and Vaibhava Goel. 2017. Self-critical
sequence training for image captioning. 2017 IEEE
Conference on Computer Vision and Pattern Recog-
nition (CVPR), pages 1179–1195.

Abigail See, Peter J. Liu, and Christopher D. Manning.
2017. Get to the point: Summarization with pointer-
generator networks. In ACL.

Min Joon Seo, Aniruddha Kembhavi, Ali Farhadi,
and Hannaneh Hajishirzi. 2016. Bidirectional at-
tention flow for machine comprehension. CoRR,
abs/1611.01603.

Iulian Vlad Serban, Alberto Garcı́a-Durán, Çaglar
Gülçehre, Sungjin Ahn, Sarath Chandar, Aaron C.
Courville, and Yoshua Bengio. 2016. Generating
factoid questions with recurrent neural networks:
The 30m factoid question-answer corpus. In ACL
(1). The Association for Computer Linguistics.

Shikhar Sharma, Layla El Asri, Hannes Schulz, and
Jeremie Zumer. 2017. Relevance of unsupervised
metrics in task-oriented dialogue for evaluating nat-
ural language generation. CoRR, abs/1706.09799.

Heung-yeung Shum, Xiao-dong He, and Di Li. 2018.
From eliza to xiaoice: challenges and opportunities
with social chatbots. Frontiers of Information Tech-
nology & Electronic Engineering, 19(1):10–26.

Linfeng Song, Zhiguo Wang, and Wael Hamza. 2017.
A unified query-based generative model for ques-
tion generation and question answering. CoRR,
abs/1709.01058.

Xingwu Sun, Jing Liu, Yajuan Lyu, Wei He, Yan-
jun Ma, and Shi Wang. 2018. Answer-focused and
position-aware neural question generation. In Pro-
ceedings of the 2018 Conference on Empirical Meth-
ods in Natural Language Processing, pages 3930–
3939, Brussels, Belgium. Association for Computa-
tional Linguistics.

Ronald J. Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Mach. Learn., 8(3-4):229–256.

Yingce Xia, Fei Tian, Lijun Wu, Jianxin Lin, Tao Qin,
Nenghai Yu, and Tie-Yan Liu. 2017. Deliberation

networks: Sequence generation beyond one-pass de-
coding. In I. Guyon, U. V. Luxburg, S. Bengio,
H. Wallach, R. Fergus, S. Vishwanathan, and R. Gar-
nett, editors, Advances in Neural Information Pro-
cessing Systems 30, pages 1784–1794. Curran As-
sociates, Inc.

Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Ben-
gio, William W. Cohen, Ruslan Salakhutdinov, and
Christopher D. Manning. 2018. HotpotQA: A
dataset for diverse, explainable multi-hop question
answering. In Proceedings of the Conference on
Empirical Methods in Natural Language Processing
(EMNLP).

Kaichun Yao, Libo Zhang, Tiejian Luo, Lili Tao, and
Yanjun Wu. 2018. Teaching machines to ask ques-
tions. In IJCAI.

Xingdi Yuan, Tong Wang, Çaglar Gülçehre, Alessan-
dro Sordoni, Philip Bachman, Saizheng Zhang,
Sandeep Subramanian, and Adam Trischler. 2017.
Machine comprehension by text-to-text neural ques-
tion generation. In Rep4NLP@ACL, pages 15–25.
Association for Computational Linguistics.

Yao Zhao, Xiaochuan Ni, Yuanyuan Ding, and Qifa
Ke. 2018. Paragraph-level neural question gener-
ation with maxout pointer and gated self-attention
networks. In EMNLP.

Qingyu Zhou, Nan Yang, Furu Wei, and Ming Zhou.
2018. Sequential copying networks. In AAAI.


