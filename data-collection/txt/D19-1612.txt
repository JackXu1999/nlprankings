



















































Query-focused Sentence Compression in Linear Time


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 5969–5975,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

5969

Query-focused Sentence Compression in Linear Time

Abram Handler and Brendan O’Connor
College of Information and Computer Sciences

University of Massachusetts Amherst
{ahandler,brenocon}@cs.umass.edu

Abstract

Search applications often display shortened
sentences which must contain certain query
terms and must fit within the space constraints
of a user interface. This work introduces
a new transition-based sentence compression
technique developed for such settings. Our
query-focused method constructs length and
lexically constrained compressions in linear
time, by growing a subgraph in the depen-
dency parse of a sentence. This theoretically
efficient approach achieves an 11x empirical
speedup over baseline ILP methods, while bet-
ter reconstructing gold constrained shorten-
ings. Such speedups help query-focused ap-
plications, because users are measurably hin-
dered by interface lags. Additionally, our tech-
nique does not require an ILP solver or a GPU.

1 Introduction

Traditional study of extractive sentence com-
pression seeks to create short, readable, single-
sentence summaries which retain the most “im-
portant” information from source sentences. But
search user interfaces often require compressions
which must include a user’s query terms and must
not exceed some maximum length, permitted by
screen space. Figure 1 shows an example.

This study examines the English-language com-
pression problem with such length and lexical re-
quirements. In our constrained compression set-
ting, a source sentence S is shortened to a com-
pression C which (1) must include all tokens
in a set of query terms Q and (2) must be no
longer than a maximum budgeted character length,
b ∈ Z+. Formally, constrained compression maps
(S,Q, b) → C, such that C respects Q and b. We
describe this task as query-focused compression
because Q places a hard requirement on words
from S which must be included in C.

Gazprom the Russian state gas giant announced a 40 percent increase 
in the price of natural gas sold to Ukraine which is heavily dependent 
on Russia for its gas supply.

Gazprom announced increase in the price of gas sold to Ukraine
Ukraine’s dependence on Gazprom left the country vulnerable
Kremlin-backed Gazprom transports gas to Europe through Ukraine 

Gazprom Ukraine

S

Q

C

b = 75 char. max.

Figure 1: A search user interface (boxed, top) returns
a snippet consisting of three compressions which must
contain a users’ query Q (bold) and must not exceed
b = 75 characters in length. The third compression C
was derived from source sentence S (italics, bottom).

Existing techniques are poorly suited to con-
strained compression. While methods based on
integer linear programming (ILP) can trivially ac-
commodate such length and lexical restrictions
(Clarke and Lapata, 2008; Filippova and Altun,
2013; Wang et al., 2017), these approaches rely
on slow third-party solvers to optimize an NP-
hard integer linear programming objective, caus-
ing user wait time. An alternative LSTM tag-
ging approach (Filippova et al., 2015) does not al-
low practitioners to specify length or lexical con-
straints, and requires an expensive graphics pro-
cessing unit (GPU) to achieve low runtime latency
(access to GPUs is a barrier in fields like social
science and journalism). These deficits prevent
application of existing compression techniques in
search user interfaces (Marchionini, 2006; Hearst,
2009), where length, lexical and latency require-
ments are paramount. We thus present a new state-
ful method for query-focused compression.

Our approach is theoretically and empirically
faster than ILP-based techniques, and more accu-
rately reconstructs gold standard compressions.

2 Related work

Extractive compression shortens a sentence by
removing tokens, typically for summarization



5970

Approach Complexity Constrained
ILP exponential yes
LSTM tagger linear no
VERTEX ADDITION linear yes

Table 1: Our VERTEX ADDITION technique (§3) con-
structs constrained compressions in linear time. Prior
work (§2) has higher computational complexity (ILP)
or does not respect hard constraints (LSTM tagger).

(Knight and Marcu, 2000; Clarke and Lapata,
2008; Filippova et al., 2015; Wang et al., 2017).1

To our knowledge, this work is the first to consider
extractive compression under hard length and lex-
ical constraints.

We compare our VERTEX ADDITION approach
to ILP-based compression methods (Clarke and
Lapata, 2008; Filippova and Altun, 2013; Wang
et al., 2017), which shorten sentences using an
integer linear programming objective. ILP meth-
ods can easily accommodate lexical and budget re-
strictions via additional optimization constraints,
but require worst-case exponential computation.2

Finally, compression methods based on LSTM
taggers (Filippova et al., 2015) cannot currently
enforce lexical or length requirements. Future
work might address this limitation by apply-
ing and modifying constrained generation tech-
niques (Kikuchi et al., 2016; Post and Vilar, 2018;
Gehrmann et al., 2018).

3 Compression via VERTEX ADDITION

We present a new transition-based method for
shortening sentences under lexical and length
constraints, inspired by similar approaches in
transition-based parsing (Nivre, 2003). We de-
scribe our technique as VERTEX ADDITION be-
cause it constructs a shortening by growing a (pos-
sibly disconnected) subgraph in the dependency
parse of a sentence, one vertex at a time. This
approach can construct constrained compressions
with a linear algorithm, leading to 11x lower la-
tency than ILP techniques (§4). To our knowl-
edge, our method is also the first to construct

1Some methods compress via generation instead of dele-
tion (Rush et al., 2015; Mallinson et al., 2018). Our extrac-
tive method is intended for practical, interpretable and trust-
worthy search systems (Chuang et al., 2012). Users might
not trust abstractive summaries (Zhang and Cranshaw, 2018),
particularly in cases with semantic error.

2ILPs are exponential in |V | when selecting tokens
(Clarke and Lapata, 2008) and exponential in |E| when se-
lecting edges (Filippova et al., 2015).

compressions by adding vertexes rather than prun-
ing subtrees in a parse (Knight and Marcu, 2000;
Almeida and Martins, 2013; Filippova and Al-
fonseca, 2015). We assume a boolean relevance
model: S must contain Q. We leave more sophis-
ticated relevance models for future work.

3.1 Formal description
VERTEX ADDITION builds a compression by
maintaining a state (Ci, Pi) where Ci ⊆ S is a set
of added candidates, Pi ⊆ S is a priority queue of
vertexes, and i indexes a timestep during compres-
sion. Figure 2 shows a step-by-step example.

During initialization, we set C0 ← Q and P0 ←
S \Q. Then, at each timestep, we pop some candi-
date vi = h(Pi) from the head of Pi and evaluate
vi for inclusion in Ci. (Neighbors of Ci in Pi get
higher priority than non-neighbors; we break ties
in left-to-right order, by sentence position). If we
accept vi, then Ci+1 ← Ci∪vi; if not, Ci+1 ← Ci.
(Acceptance decisions are detailed in §4.3.) We
continue adding vertexes to C until either Pi is
empty or Ci is b characters long.3 The appendix
includes a formal algorithm.

VERTEX ADDITION is linear in the token length
of S because we pop and evaluate some vertex
from Pi at each timestep, after P0 ← S \ Q. Ad-
ditionally, because (1) we never accept vi if the
length of Ci ∪ vi is more than b, and (2) we set
C0 ← Q, our method respects Q and b.

A B

C
D

E FA B

C
D

E F A B

C
D

E F A B

C
D

E FA B

C
D

E F

Legend viCi Pi ¬Ci

Figure 2: A dependency parse of a sentence S, shown
across five timesteps of VERTEX ADDITION (from left
to right). Each node in the parse is a vertex in S.
Our stateful method produces the final compression
{A,C,B,E} (rightmost). At each timestep, each candi-
date vi is boxed; rejected candidates ¬Ci are unshaded.

4 Evaluation

We observe the latency, readability and token-level
F1 score of VERTEX ADDITION, using a standard
dataset (Filippova and Altun, 2013). We compare
our method to an ILP baseline (§2) because ILP
methods are the only known technique for con-
strained compression. All methods have similar

3We linearize C by left-to-right vertex position in S, com-
mon for compression in English (Filippova and Altun, 2013).



5971

compression ratios (shown in appendix), a well-
known evaluation requirement (Napoles et al.,
2011). We evaluate the significance of differ-
ences between VERTEX ADDITIONLR and the ILP
with bootstrap sampling (Berg-Kirkpatrick et al.,
2012). All differences are significant (p < .01).

4.1 Constrained compression experiment

In order to evaluate different approaches to con-
strained compression, we require a dataset of sen-
tences, constraints and known-good shortenings,
which respect the constraints. This means we need
tuples (S,Q, b, Cg), where Cg is a known-good
compression of S which respects Q and b (§1).

To support large-scale automatic evaluation, we
reinterpret a standard compression corpus (Filip-
pova and Altun, 2013) as a collection of input sen-
tences and constrained compressions. The original
dataset contains pairs of sentences S and compres-
sions Cg, generated using news headlines. For our
experiment, we set b equal to the character length
of the gold compression Cg. We then sample a
small number of nouns4 from Cg to form a query
set Q, approximating both the observed number of
tokens and observed parts of speech in real-world
search (Jansen et al., 2000; Barr et al., 2008). Sam-
pled Q include reasonable queries like “police,
Syracuse”, “NHS” and “Hughes, manager, QPR”.

By sampling queries and defining budgets in
this manner, we create 198,570 training tuples and
9949 test tuples, each of the form (S,Q, b, Cg).
Filippova and Altun (2013) define the train/test
split. We re-tokenize, parse and tag with CoreNLP
v3.8.0 (Manning et al., 2014). We reserve 25,000
training tuples as a validation set.

4.2 Model: ILP

We compare our system to a baseline ILP method,
presented in Filippova and Altun (2013). This ap-
proach represents each edge in a syntax tree with
a vector of real-valued features, then learns fea-
ture weights using a structured perceptron trained
on a corpus of (S,Cg) pairs.5 Learned weights
are used to compute a global compression objec-
tive, subject to structural constraints which ensure
C is a valid tree. This baseline can easily perform

41 to 3 nouns; cardinality chosen uniformly at random.
5Another ILP (Wang et al., 2017) sets weights using

a LSTM, achieving similar in-domain performance. This
method requires a multi-stage computational process (i.e. run
LSTM then ILP) that is poorly-suited to query-focused set-
tings, where low latency is crucial.

constrained compression: at test time, we add op-
timization constraints specifying that C must in-
clude Q, and not exceed length b.

To our knowledge, a public implementation of
this method does not exist. We reimplement from
scratch using Gurobi Optimization (2018), achiev-
ing a test-time, token-level F1 score of 0.76 on
the unconstrained compression task, lower than
the result (F1 = 84.3) reported by the original au-
thors. There are some important differences be-
tween our reimplementation and original approach
(described in detail in the appendix). Since VER-
TEX ADDITION requires Q and b, we can only
compare it to the ILP on the constrained (rather
than traditional, unconstrained) compression task.

4.3 Models: VERTEX ADDITION

Vertex addition accepts or rejects some candi-
date vertex vi at each timestep i. We learn such
decisions yi ∈ {0, 1} using a corpus of tuples
(S,Q, b, Cg) (§4.1). Given such a tuple, we can
always execute an oracle path shortening S to Cg
by first initializing VERTEX ADDITION and then,
at each timestep: (1) choosing vi = h(Pi) and (2)
adding vi to Ci iff vi ∈ Cg. We set yi = 1 if
vi ∈ Cg; we set yi = 0 if vi /∈ Cg. We then
use decisions from oracle paths to train two mod-
els of inclusion decisions, p(yi = 1|vi, Ci, Pi, S).
At test time, we accept vi if p(yi > .5).

Model One. Our VERTEX ADDITIONNN model
broadly follows neural approaches to transition-
based parsing (e.g. Chen and Manning (2014)):
we predict yi using a LSTM classifier with a stan-
dard max-pooling architecture (Conneau et al.,
2017), implemented with a common neural frame-
work (Gardner et al., 2017). Our classifier main-
tains four vocabulary embeddings matrixes, corre-
sponding to the four disjoint subsets Ci ∪ ¬Ci ∪
Pi∪{vi} = V . Each LSTM input vector xt comes
from the appropriate embedding for vt ∈ V , de-
pending on the state of the compression system at
timestep i. The appendix details network tuning
and optimization.

Model Two. Our VERTEX ADDITIONLR model
uses binary logistic regression,6 with 3 classes of
features.

Edge features describe the properties of the
edge (u, vi) between vi ∈ Pi and u ∈ Ci. We

6We implement with Python 3 using scikit-learn (Pe-
dregosa et al., 2011). We tune the inverse regularization con-
stant to c = 10 via grid search over powers of ten, to optimize
validation set F1.



5972

Approach F1 SLOR ∗Latency
RANDOM (lower bound) 0.653 0.377 0.5

ABLATED (edge only) 0.827 0.669 3.7

VERTEX ADDITIONNN 0.873 0.728 2929.1 (CPU)

ILP 0.852 0.756 44.0

VERTEX ADDITIONLR 0.881 0.745 4.1

Table 2: Test results for constrained compression. ∗Latency is the geometric mean of observed runtimes (in
milliseconds per sentence). VERTEX ADDITIONLR achieves the highest F1, and also runs 10.73 times faster than
the ILP. Differences between all scores for VERTEX ADDITIONLR and ILP are significant (p < .01).

use the edge-based feature function from Filip-
pova and Altun (2013), described in detail in the
appendix. This allows us to compare the perfor-
mance of a vertex addition method based on lo-
cal decisions with an ILP method that optimizes a
global objective (§4.5), using the same feature set.

Stateful features represent the relationship be-
tween vi and the compression Ci at timestep i.
Stateful features include information such as the
position of vi in the sentence, relative to the right-
most and left-most vertex in Ci, as well as history-
based information such as the fraction of the char-
acter budget used so far. Such features allow the
model to reason about which sort of vi should be
added, given Q, S and Ci.

Interaction features are formed by crossing all
stateful features with the type of the dependency
edge governing vi, as well as with indicators iden-
tifying if u governs vi, if vi governs u or if there is
no edge (u, vi) in the parse.

4.4 Metrics: F1, Latency and SLOR

We measure the token-level F1 score of each com-
pression method against gold compressions in the
test set. F1 is the standard automatic evaluation
metric for extractive compression (Filippova et al.,
2015; Klerke et al., 2016; Wang et al., 2017).

In addition to measuring F1, researchers of-
ten evaluate compression systems with human im-
portance and readability judgements (Knight and
Marcu, 2000; Filippova et al., 2015). In our setting
Q determines the “important” information from S,
so importance evaluations are inappropriate. To
check readability, we use the automated readabil-
ity metric SLOR (Lau et al., 2015), which corre-
lates with human judgements (Kann et al., 2018).

We evaluate theoretical gains from VERTEX
ADDITION (Table 1) by measuring empirical la-
tency. For each compression method, we sample
and compress N = 300, 000 sentences, and record

the runtime (in milliseconds per sentence). We
observe that runtimes are distributed log-normally
(Figure 3), and we thus summarize each sample
using the geometric mean. ILP and VERTEX AD-
DITIONLR share edge feature extraction code to
support to fair comparison. We test VERTEX AD-
DITIONNN using a CPU: the method is too slow
for use in search applications in areas without ac-
cess to specialized hardware (Table 2). The ap-
pendix further details latency and SLOR experi-
ments.

4.5 Analysis: ABLATED & RANDOM

For comparison, we implement an ABLATED ver-
tex addition method, which learns inclusion deci-
sions using only edge features from Filippova and
Altun (2013). ABLATED has a lower F1 score than
ILP, which uses the same edge-level information to
optimize a global objective: adding stateful and in-
teraction features (i.e. VERTEX ADDITIONLR) im-
proves F1 score. Nonetheless, strong performance
from ABLATED hints that edge-level information
alone (e.g. dependency type) can mostly guide ac-
ceptance decisions.

We also evaluate a RANDOM baseline, which
accepts each vi randomly in proportion to p(yi =
1) across training data. RANDOM achieves reason-
able F1 because (1) C0 = Q ∈ Cg and (2) F1
correlates with compression rate (Napoles et al.,
2011), and b is set to the length of Cg.

5 Future work: practical compression

This work presents a new method for fast query-
focused sentence compression, motivated by the
need for query-biased snippets in search en-
gines (Tombros and Sanderson, 1998; Marchion-
ini, 2006). While our approach shows promise
in simulated experiments, we expect that further
work will be required before the method can be
employed for practical, user-facing search.



5973

0.0
0.5
1.0
1.5

0.001 0.01 0.1 1 10
seconds (log scale)

d
en

si
ty method

ilp
vertex addition (lr)

Figure 3: Density plot of log transformed latencies for VERTEX ADDITIONLR (left) and ILP (right). Theoret-
ical gains (Table 1) create real speedups. The ILP shows greater runtime variance, possibly reflecting varying
approaches from Gurobi Optimization (2018).

To begin, both our technique and our evalua-
tion ignore the conventions of search user inter-
faces, which typically display missing words us-
ing ellipses. This convention is important, be-
cause it allows snippet systems to transparently
show users which words have been removed from
a sentence. However, we observe that some well-
formed compressions are difficult to read when
displayed in this format. For instance the sentence
“Aristide quickly fled Haiti in September 1991”
can be shortened to the well-formed compres-
sion “Aristide fled in 1991.” But this compression
does not read fluidly when using ellipses (“Aris-
tide...fled...in...1991”). Human experiments aimed
at enumerating the desirable and undesirable prop-
erties of compressions displayed in ellipse format
(e.g. compressions should minimize number of el-
lipses?) could help guide user-focused snippet al-
gorithms in future work.

Our method also assumes access to a reliable,
dependency parse, and ignores any latency penal-
ties incurred from parsing. In practical settings,
both assumptions are unreasonable. Like other
NLP tools, dependency parsers often perform
poorly on out-of-domain text (Bamman, 2017),
and users looking to quickly investigate a new cor-
pus might not wish to wait for a parser. Faster ap-
proaches based on low-latency part-of-speech tag-
ging, or more cautious approaches based on syn-
tactic uncertainty (Keith et al., 2018), each offer
exciting possibilities for additional research.

Our approach also assumes that a user already
knows a reasonable b and reasonable Q for a given
sentence S.7 However, in some cases, there is no
well-formed shortening of which respects the re-
quirements. For instance, if Q=“Kennedy” and
b=15 there is no reasonable shortening for the
toy sentence “Kennedy kept running”, because the
compressions “Kennedy kept” and “Kennedy run-
ning” are not well-formed. We look forward to

7Recall that we simulate b and Q based on the well-
formed shortening Cg , see §4.1.

investigating which (Q,S, b) triples will never re-
turn well-formed compressions in later work.

Finally, some shortened sentences will modify
the meaning of a sentence, but we ignore this im-
portant complication in this initial study. In the fu-
ture, we hope to apply ongoing research into tex-
tual entailment (Bowman et al., 2015; Pavlick and
Callison-Burch, 2016; McCoy and Linzen, 2018)
to develop semantically-informed approaches to
the task.

6 Conclusion

We introduce a query-focused VERTEX ADDI-
TIONLR method for search user interfaces, with
much lower theoretical complexity (and empirical
runtimes) than baseline techniques. In search ap-
plications, such gains are non-trivial: real users are
measurably hindered by interface lags (Nielsen,
1993; Liu and Heer, 2014). We hope that our fast,
query-focused method better enables snippet cre-
ation at the “pace of human thought” (Heer and
Shneiderman, 2012).

Acknowledgments

Thanks to Javier Burroni and Nick Eubank for
suggesting ways to optimize and measure perfor-
mance of Python code. Thanks to Jeffrey Flani-
gan, Katie Keith and the UMass NLP reading
group for feedback. This work was partially sup-
ported by IIS-1814955.

Appendix

The appendix is available with the arXiv version
of this paper: https://arxiv.org/abs/
1904.09051

References
Miguel Almeida and Andre Martins. 2013. Fast and ro-

bust compressive summarization with dual decom-
position and multi-task learning. In ACL.

https://arxiv.org/abs/1904.09051
https://arxiv.org/abs/1904.09051


5974

David Bamman. 2017. Natural language processing for
the long tail. In Digital Humanities.

Cory Barr, Rosie Jones, and Moira Regelson. 2008.
The linguistic structure of english web-search
queries. In EMNLP.

Taylor Berg-Kirkpatrick, David Burkett, and Dan
Klein. 2012. An empirical investigation of statistical
significance in NLP. In EMNLP.

James Bergstra and Yoshua Bengio. 2012. Random
search for hyper-parameter optimization. Journal of
Machine Learning Research, 13:281–305.

Samuel R. Bowman, Gabor Angeli, Christopher Potts,
and Christopher D. Manning. 2015. A large anno-
tated corpus for learning natural language inference.
In EMNLP.

Ted Briscoe, John Carroll, and Rebecca Watson. 2006.
The second release of the RASP system. In Pro-
ceedings of the COLING/ACL 2006 Interactive Pre-
sentation Sessions.

Danqi Chen and Christopher Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In EMNLP.

Jason Chuang, Daniel Ramage, Christopher D. Man-
ning, and Jeffrey Heer. 2012. Interpretation and
trust: Designing model-driven visualizations for text
analysis. In CHI.

James Clarke and Mirella Lapata. 2008. Global in-
ference for sentence compression: An integer linear
programming approach. Journal of Artificial Intelli-
gence Research, 31:399–429.

Alexis Conneau, Douwe Kiela, Holger Schwenk, Loı̈c
Barrault, and Antoine Bordes. 2017. Supervised
learning of universal sentence representations from
natural language inference data. In EMNLP.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
and stochastic optimization. Journal of Machine
Learning Research, 12(Jul):2121–2159.

Katja Filippova and Enrique Alfonseca. 2015. Fast
k-best sentence compression. arXiv preprint
arXiv:1510.08418.

Katja Filippova, Enrique Alfonseca, Carlos A Col-
menares, Lukasz Kaiser, and Oriol Vinyals. 2015.
Sentence compression by deletion with LSTMs. In
EMNLP.

Katja Filippova and Yasemin Altun. 2013. Over-
coming the lack of parallel data in sentence com-
pression. In EMNLP. https://github.com/google-
research-datasets/sentence-compression.

Katja Filippova and Michael Strube. 2008. Depen-
dency tree based sentence compression. In Proceed-
ings of the Fifth International Natural Language
Generation Conference.

Matt Gardner, Joel Grus, Mark Neumann, Oyvind
Tafjord, Pradeep Dasigi, Nelson F. Liu, Matthew
Peters, Michael Schmitz, and Luke S. Zettlemoyer.
2017. AllenNLP: A deep semantic natural language
processing platform.

Sebastian Gehrmann, Yuntian Deng, and Alexander
Rush. 2018. Bottom-up abstractive summarization.
In EMNLP.

LLC Gurobi Optimization. 2018. Gurobi optimizer
reference manual (v8).

Kenneth Heafield. 2011. KenLM: faster and smaller
language model queries. In EMNLP: Sixth Work-
shop on Statistical Machine Translation.

Marti Hearst. 2009. Search user interfaces. Cam-
bridge University Press, Cambridge New York.

Jeffrey Heer and Ben Shneiderman. 2012. Interactive
dynamics for visual analysis. Queue, 10(2).

Bernard J. Jansen, Amanda Spink, and Tefko Sarace-
vic. 2000. Real life, real users, and real needs: a
study and analysis of user queries on the web. Infor-
mation Processing and Management, 36:207–227.

Katharina Kann, Sascha Rothe, and Katja Filippova.
2018. Sentence-Level Fluency Evaluation: Refer-
ences Help, But Can Be Spared! In CoNLL 2018.

Katherine Keith, Su Lin Blodgett, and Brendan
O’Connor. 2018. Monte Carlo syntax marginals for
exploring and using dependency parses. In NAACL.

Yuta Kikuchi, Graham Neubig, Ryohei Sasano, Hiroya
Takamura, and Manabu Okumura. 2016. Control-
ling output length in neural encoder-decoders. In
EMNLP.

Sigrid Klerke, Yoav Goldberg, and Anders Søgaard.
2016. Improving sentence compression by learning
to predict gaze. In NAACL.

Kevin Knight and Daniel Marcu. 2000. Statistics-
based summarization - step one: Sentence compres-
sion. In AAAI.

Jey Han Lau, Alexander Clark, and Shalom Lap-
pin. 2015. Unsupervised prediction of acceptability
judgements. In ACL.

Zhicheng Liu and Jeffrey Heer. 2014. The effects of
interactive latency on exploratory visual analysis.
IEEE Transactions on Visualization and Computer
Graphics, 20:2122–2131.

Jonathan Mallinson, Rico Sennrich, and Mirella Lap-
ata. 2018. Sentence Compression for Arbitrary Lan-
guages via Multilingual Pivoting. In EMNLP.

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The Stanford CoreNLP natural lan-
guage processing toolkit. In ACL System Demon-
strations.



5975

Gary Marchionini. 2006. Exploratory search: From
finding to understanding. Commun. ACM, 49(4).

Marie-Catherine de Marneffe, Bill MacCartney, and
Christopher D. Manning. 2006. Generating typed
dependency parses from phrase structure parses. In
LREC.

Thomas R. McCoy and Tal Linzen. 2018. Non-entailed
subsequences as a challenge for natural language in-
ference. In Proceedings of the Society for Computa-
tion in Linguistics.

Courtney Napoles, Benjamin Van Durme, and Chris
Callison-Burch. 2011. Evaluating sentence com-
pression: Pitfalls and suggested remedies. In Pro-
ceedings of the Workshop on Monolingual Text-To-
Text Generation.

Jakob Nielsen. 1993. Usability Engineering. Mor-
gan Kaufmann Publishers Inc., San Francisco, CA,
USA.

Joakim Nivre. 2003. An efficient algorithm for projec-
tive dependency parsing. In International Confer-
ence on Parsing Technologies.

Joakim Nivre, Marie-Catherine de Marneffe, Filip
Ginter, Yoav Goldberg, Jan Hajic, Christopher D.
Manning, Ryan T. McDonald, Slav Petrov, Sampo
Pyysalo, Natalia Silveira, Reut Tsarfaty, and Daniel
Zeman. 2016. Universal Dependencies v1: A multi-
lingual treebank collection. In LREC.

Ellie Pavlick and Chris Callison-Burch. 2016. So-
called non-subsective adjectives. In *SEM.

Fabian Pedregosa, Gaël Varoquaux, Alexandre Gram-
fort, Vincent Michel, Bertrand Thirion, Olivier
Grisel, Mathieu Blondel, Peter Prettenhofer, Ron
Weiss, Vincent Dubourg, Jake Vanderplas, Alexan-
dre Passos, David Cournapeau, Matthieu Brucher,
Matthieu Perrot, and Édouard Duchesnay. 2011.
Scikit-learn: Machine learning in python. Journal
of Machine Learning Research, 12:2825–2830.

Matt Post and David Vilar. 2018. Fast lexically con-
strained decoding with dynamic beam allocation for
neural machine translation. In NAACL.

Alexander M. Rush, Sumit Chopra, and Jason Weston.
2015. A neural attention model for abstractive sen-
tence summarization. In EMNLP.

Sebastian Schuster and Christopher D. Manning. 2016.
Enhanced english universal dependencies: An im-
proved representation for natural language under-
standing tasks. In LREC.

Anastasios Tombros and Mark Sanderson. 1998. Ad-
vantages of query biased summaries in information
retrieval. In SIGIR.

Liangguo Wang, Jing Jiang, Hai Leong Chieu,
Chen Hui Ong, Dandan Song, and Lejian Liao.
2017. Can syntax help? Improving an LSTM-based
sentence compression model for new domains. In
ACL.

Amy X. Zhang and Justin Cranshaw. 2018. Making
sense of group chat through collaborative tagging
and summarization. Proceedings of the ACM on
Human-Computer Interaction, 2(CSCW).


