



















































Recurrent Memory Networks for Language Modeling


Proceedings of NAACL-HLT 2016, pages 321–331,
San Diego, California, June 12-17, 2016. c©2016 Association for Computational Linguistics

Recurrent Memory Networks for Language Modeling

Ke Tran Arianna Bisazza Christof Monz
Informatics Institute, University of Amsterdam

Science Park 904, 1098 XH Amsterdam, The Netherlands
{m.k.tran,a.bisazza,c.monz}@uva.nl

Abstract

Recurrent Neural Networks (RNNs) have ob-
tained excellent result in many natural lan-
guage processing (NLP) tasks. However, un-
derstanding and interpreting the source of this
success remains a challenge. In this paper, we
propose Recurrent Memory Network (RMN),
a novel RNN architecture, that not only am-
plifies the power of RNN but also facilitates
our understanding of its internal functioning
and allows us to discover underlying patterns
in data. We demonstrate the power of RMN
on language modeling and sentence comple-
tion tasks. On language modeling, RMN out-
performs Long Short-Term Memory (LSTM)
network on three large German, Italian, and
English dataset. Additionally we perform in-
depth analysis of various linguistic dimen-
sions that RMN captures. On Sentence Com-
pletion Challenge, for which it is essential to
capture sentence coherence, our RMN obtains
69.2% accuracy, surpassing the previous state
of the art by a large margin.1

1 Introduction

Recurrent Neural Networks (RNNs) (Elman, 1990;
Mikolov et al., 2010) are remarkably powerful mod-
els for sequential data. Long Short-Term Memory
(LSTM) (Hochreiter and Schmidhuber, 1997), a spe-
cific architecture of RNN, has a track record of suc-
cess in many natural language processing tasks such
as language modeling (Józefowicz et al., 2015), de-
pendency parsing (Dyer et al., 2015), sentence com-

1Our code and data are available at https://github.
com/ketranm/RMN

pression (Filippova et al., 2015), and machine trans-
lation (Sutskever et al., 2014).

Within the context of natural language process-
ing, a common assumption is that LSTMs are able to
capture certain linguistic phenomena. Evidence sup-
porting this assumption mainly comes from evaluat-
ing LSTMs in downstream applications: Bowman
et al. (2015) carefully design two artificial datasets
where sentences have explicit recursive structures.
They show empirically that while processing the in-
put linearly, LSTMs can implicitly exploit recursive
structures of languages. Filippova et al. (2015) find
that using explicit syntactic features within LSTMs
in their sentence compression model hurts the per-
formance of overall system. They then hypothesize
that a basic LSTM is powerful enough to capture
syntactic aspects which are useful for compression.

To understand and explain which linguistic di-
mensions are captured by an LSTM is non-trivial.
This is due to the fact that the sequences of input
histories are compressed into several dense vectors
by the LSTM’s components whose purposes with re-
spect to representing linguistic information is not ev-
ident. To our knowledge, the only attempt to better
understand the reasons of an LSTM’s performance
and limitations is the work of Karpathy et al. (2015)
by means of visualization experiments and cell acti-
vation statistics in the context of character-level lan-
guage modeling.

Our work is motivated by the difficulty in un-
derstanding and interpreting existing RNN architec-
tures from a linguistic point of view. We propose Re-
current Memory Network (RMN), a novel RNN ar-
chitecture that combines the strengths of both LSTM

321



and Memory Network (Sukhbaatar et al., 2015). In
RMN, the Memory Block component—a variant of
Memory Network—accesses the most recent input
words and selectively attends to words that are rel-
evant for predicting the next word given the current
LSTM state. By looking at the attention distribution
over history words, our RMN allows us not only to
interpret the results but also to discover underlying
dependencies present in the data.

In this paper, we make the following contribu-
tions:

1. We propose a novel RNN architecture that
complements LSTM in language modeling. We
demonstrate that our RMN outperforms com-
petitive LSTM baselines in terms of perplex-
ity on three large German, Italian, and English
datasets.

2. We perform an analysis along various linguis-
tic dimensions that our model captures. This
is possible only because the Memory Block al-
lows us to look into its internal states and its ex-
plicit use of additional inputs at each time step.

3. We show that, with a simple modification,
our RMN can be successfully applied to NLP
tasks other than language modeling. On the
Sentence Completion Challenge (Zweig and
Burges, 2012), our model achieves an impres-
sive 69.2% accuracy, surpassing the previous
state of the art 58.9% by a large margin.

2 Recurrent Neural Networks

Recurrent Neural Networks (RNNs) have shown im-
pressive performances on many sequential modeling
tasks due to their ability to encode unbounded input
histories. However, training simple RNNs is diffi-
cult because of the vanishing and exploding gradi-
ent problems (Bengio et al., 1994; Pascanu et al.,
2013). A simple and effective solution for explod-
ing gradients is gradient clipping proposed by Pas-
canu et al. (2013). To address the more challeng-
ing problem of vanishing gradients, several variants
of RNNs have been proposed. Among them, Long
Short-Term Memory (Hochreiter and Schmidhuber,
1997) and Gated Recurrent Unit (Cho et al., 2014)
are widely regarded as the most successful variants.
In this work, we focus on LSTMs because they have

been shown to outperform GRUs on language mod-
eling tasks (Józefowicz et al., 2015). In the follow-
ing, we will detail the LSTM architecture used in
this work.
Long Short-Term Memory
Notation: Throughout this paper, we denote matri-
ces, vectors, and scalars using bold uppercase (e. g.,
W), bold lowercase (e. g., b) and lowercase (e. g.,
α) letters, respectively.

The LSTM used in this work is specified as fol-
lows:

it = sigm(Wxixt + Whiht−1 + bi)
jt = sigm(Wxjxt + Whjht−1 + bj)
f t = sigm(Wxfxt + Whfht−1 + bf )
ot = tanh(Wxoxt + Whoht−1 + bo)
ct = ct−1 � f t + it � jt
ht = tanh(ct)� ot

where xt is the input vector at time step t, ht−1 is the
LSTM hidden state at the previous time step, W∗
and b∗ are weights and biases. The symbol � de-
notes the Hadamard product or element-wise multi-
plication.

Despite the popularity of LSTM in sequential
modeling, its design is not straightforward to justify
and understanding why it works remains a challenge
(Hermans and Schrauwen, 2013; Chung et al., 2014;
Greff et al., 2015; Józefowicz et al., 2015; Karpa-
thy et al., 2015). There have been few recent at-
tempts to understand the components of an LSTM
from an empirical point of view: Greff et al. (2015)
carry out a large-scale experiment of eight LSTM
variants. The results from their 5,400 experimental
runs suggest that forget gates and output gates are
the most critical components of LSTMs. Józefowicz
et al. (2015) conduct and evaluate over ten thousand
RNN architectures and find that the initialization of
the forget gate bias is crucial to the LSTM’s perfor-
mance. While these findings are important to help
choosing appropriate LSTM architectures, they do
not shed light on what information is captured by
the hidden states of an LSTM.

Bowman et al. (2015) show that a vanilla LSTM,
such as described above, performs reasonably well
compared to a recursive neural network (Socher et
al., 2011) that explicitly exploits tree structures on

322



two artificial datasets. They find that LSTMs can
effectively exploit recursive structure in the artifi-
cial datasets. In contrast to these simple datasets
containing a few logical operations in their exper-
iments, natural languages exhibit highly complex
patterns. The extent to which linguistic assumptions
about syntactic structures and compositional seman-
tics are reflected in LSTMs is rather poorly under-
stood. Thus it is desirable to have a more principled
mechanism allowing us to inspect recurrent architec-
tures from a linguistic perspective. In the following
section, we propose such a mechanism.

3 Recurrent Memory Network

It has been demonstrated that RNNs can retain in-
put information over a long period. However, exist-
ing RNN architectures make it difficult to analyze
what information is exactly retained at their hidden
states at each time step, especially when the data has
complex underlying structures, which is common in
natural language. Motivated by this difficulty, we
propose a novel RNN architecture called Recurrent
Memory Network (RMN). On linguistic data, the
RMN allows us not only to qualify which linguis-
tic information is preserved over time and why this
is the case but also to discover dependencies within
the data (Section 5). Our RMN consists of two com-
ponents: an LSTM and a Memory Block (MB) (Sec-
tion 3.1). The MB takes the hidden state of the
LSTM and compares it to the most recent inputs
using an attention mechanism (Gregor et al., 2015;
Bahdanau et al., 2014; Graves et al., 2014). Thus,
analyzing the attention weights of a trained model
can give us valuable insight into the information that
is retained over time in the LSTM.

In the following, we describe in detail the MB ar-
chitecture and the combination of the MB and the
LSTM to form an RMN.

3.1 Memory Block

The Memory Block (Figure 1) is a variant of Mem-
ory Network (Sukhbaatar et al., 2015) with one hop
(or a single-layer Memory Network). At time step t,
the MB receives two inputs: the hidden state ht of
the LSTM and a set {xi} of n most recent words
including the current word xt. We refer to n as
the memory size. Internally, the MB consists of

softmax

{xi}

hm

h

P

mi

ci

⇥

g

Figure 1: A graphical representation of the MB.

two lookup tables M and C of size |V | × d, where
|V | is the size of the vocabulary. With a slight
abuse of notation we denote Mi = M({xi}) and
Ci = C({xi}) as n × d matrices where each row
corresponds to an input memory embedding mi and
an output memory embedding ci of each element of
the set {xi}. We use the matrix Mi to compute an
attention distribution over the set {xi}:

pt = softmax(Miht) (1)

When dealing with data that exhibits a strong tem-
poral relationship, such as natural language, an ad-
ditional temporal matrix T ∈ Rn×d can be used to
bias attention with respect to the position of the data
points. In this case, equation 1 becomes

pt = softmax
(
(Mi + T)ht

)
(2)

We then use the attention distribution pt to compute
a context vector representation of {xi}:

st = CTi pt (3)

Finally, we combine the context vector st and the
hidden state ht by a function g(·) to obtain the out-
put hmt of the MB. Instead of using a simple addi-
tion function g(st,ht) = st + ht as in Sukhbaatar
et al. (2015), we propose to use a gating unit that
decides how much it should trust the hidden state
ht and context st at time step t. Our gating unit is
a form of Gated Recurrent Unit (Cho et al., 2014;
Chung et al., 2014):

zt = sigm(Wszst + Uhzht) (4)
rt = sigm(Wsrst + Uhrht) (5)

h̃t = tanh(Wst + U(rt � ht)) (6)
hmt = (1− zt)� ht + zt � h̃t (7)

323



where zt is an update gate, rt is a reset gate.
The choice of the composition function g(·) is

crucial for the MB especially when one of its in-
put comes from the LSTM. The simple addition
function might overwrite the information within the
LSTM’s hidden state and therefore prevent the MB
from keeping track of information in the distant past.
The gating function, on the other hand, can control
the degree of information that flows from the LSTM
to the MB’s output.

3.2 RMN Architectures
As explained above, our proposed MB receives the
hidden state of the LSTM as one of its input. This
leads to an intuitive combination of the two units by
stacking the MB on top of the LSTM. We call this
architecture Recurrent-Memory (RM). The RM ar-
chitecture, however, does not allow interaction be-
tween Memory Blocks at different time steps. To
enable this interaction we can stack one more LSTM
layer on top of the RM. We call this architecture
Recurrent-Memory-Recurrent (RMR).

MB

LSTM

LSTMLSTMLSTM

MB

LSTM

LSTM

MBMB

LSTMLSTM

LSTM

LSTM

MB

Figure 2: A graphical illustration of an unfolded
RMR with memory size 4. Dashed line indicates
concatenation. The MB takes the output of the bot-
tom LSTM layer and the 4-word history as its input.
The output of the MB is then passed to the second
LSTM layer on top. There is no direct connection
between MBs of different time steps. The last LSTM
layer carries the MB’s outputs recurrently.

4 Language Model Experiments

Language models play a crucial role in many NLP
applications such as machine translation and speech
recognition. Language modeling also serves as
a standard test bed for newly proposed models
(Sukhbaatar et al., 2015; Kalchbrenner et al., 2015).
We conjecture that, by explicitly accessing history
words, RMNs will offer better predictive power than

the existing recurrent architectures. We therefore
evaluate our RMN architectures against state-of-the-
art LSTMs in terms of perplexity.

4.1 Data

We evaluate our models on three languages: En-
glish, German, and Italian. We are especially inter-
ested in German and Italian because of their larger
vocabularies and complex agreement patterns. Ta-
ble 1 summarizes the data used in our experiments.

Lang Train Dev Test |s| |V |
En 26M 223K 228K 26 77K
De 22M 202K 203K 22 111K
It 29M 207K 214K 29 104K

Table 1: Data statistics. |s| denotes the average sen-
tence length and |V | the vocabulary size.

The training data correspond to approximately
1M sentences in each language. For English, we
use all the News Commentary data (8M tokens)
and 18M tokens from News Crawl 2014 for train-
ing. Development and test data are randomly drawn
from the concatenation of the WMT 2009-2014 test
sets (Bojar et al., 2015). For German, we use the
first 6M tokens from the News Commentary data
and 16M tokens from News Crawl 2014 for train-
ing. For development and test data we use the re-
maining part of the News Commentary data con-
catenated with the WMT 2009-2014 test sets. Fi-
nally, for Italian, we use a selection of 29M tokens
from the PAISÀ corpus (Lyding et al., 2014), mainly
including Wikipedia pages and, to a minor extent,
Wikibooks and Wikinews documents. For develop-
ment and test we randomly draw documents from
the same corpus.

4.2 Setup

Our baselines are a 5-gram language model
with Kneser-Ney smoothing, a Memory Network
(MemN) (Sukhbaatar et al., 2015), a vanilla single-
layer LSTM, and two stacked LSTMs with two and
three layers respectively. N-gram models have been
used intensively in many applications for their ex-
cellent performance and fast training. Chen et al.
(2015) show that n-gram model outperforms a pop-
ular feed-forward language model (Bengio et al.,

324



2003) on a one billion word benchmark (Chelba et
al., 2013). While taking longer time to train, RNNs
have been proven superior to n-gram models.

We compare these baselines with our two model
architectures: RMR and RM. For each of our mod-
els, we consider two settings: with or without tem-
poral matrix (+tM or –tM), and linear vs. gating
composition function. In total, we experiment with
eight RMN variants.

For all neural network models, we set the dimen-
sion of word embeddings, the LSTM hidden states,
its gates, the memory input, and output embeddings
to 128. The memory size is set to 15. The bias of the
LSTM’s forget gate is initialized to 1 (Józefowicz et
al., 2015) while all other parameters are initialized
uniformly in (−0.05, 0.05). The initial learning rate
is set to 1 and is halved at each epoch after the forth
epoch. All models are trained for 15 epochs with
standard stochastic gradient descent (SGD). During
training, we rescale the gradients whenever their
norm is greater than 5 (Pascanu et al., 2013).

Sentences with the same length are grouped into
buckets. Then, mini-batches of 20 sentences are
drawn from each bucket. We do not use truncated
back-propagation through time, instead gradients
are fully back-propagated from the end of each sen-
tence to its beginning. When feeding in a new mini-
batch, the hidden states of LSTMs are reset to zeros,
which ensures that the data is properly modeled at
the sentence level. For our RMN models, instead of
using padding, at time step t < n, we use a slice
T[1 : t] ∈ Rt×d of the temporal matrix T ∈ Rn×d.
4.3 Results
Perplexities on the test data are given in Table 2.
All RMN variants largely outperform n-gram and
MemN models, and most RMN variants also outper-
form the competitive LSTM baselines. The best re-
sults overall are obtained by RM with temporal ma-
trix and gating composition (+tM-g).

Our results agree with the hypothesis of mitigat-
ing prediction error by explicitly using the last n
words in RNNs (Karpathy et al., 2015). We further
observe that using a temporal matrix always bene-
fits the RM architectures. This can be explained by
seeing the RM as a principled way to combine an
LSTM and a neural n-gram model. By contrast,
RMR works better without temporal matrix but its

Model De It En
5-gram – 225.8 167.5 219.0

MemN 1 layer 169.3 127.5 188.2

LSTM
1 layer 135.8 108.0 145.1
2 layers 128.6 105.9 139.7
3 layers 125.1 106.5 136.6

RMR

+tM-l 127.5 109.9 133.3
–tM-l 126.4 106.1 134.5

+tM-g 126.2 99.5 135.2
–tM-g 122.0 98.6 131.2

RM

+tM-l 121.5 92.4 127.2
–tM-l 122.9 94.0 130.4

+tM-g 118.6 88.9 128.8
–tM-g 129.7 96.6 135.7

Table 2: Perplexity comparison including RMN
variants with and without temporal matrix (tM) and
linear (l) versus gating (g) composition function.

overall performance is not as good as RM. This sug-
gests that we need a better mechanism to address
the interaction between MBs, which we leave to fu-
ture work. Finally, the proposed gating composition
function outperforms the linear one in most cases.

For historical reasons, we also run a stacked three-
layer LSTM and a RM(+tM-g) on the much smaller
Penn Treebank dataset (Marcus et al., 1993) with the
same setting described above. The respective per-
plexities are 126.1 and 123.5.

5 Attention Analysis

The goal of our RMN design is twofold: (i) to obtain
better predictive power and (ii) to facilitate under-
standing of the model and discover patterns in data.
In Section 4, we have validated the predictive power
of the RMN and below we investigate the source of
this performance based on linguistic assumptions of
word co-occurrences and dependency structures.

5.1 Positional and lexical analysis

As a first step towards understanding RMN, we look
at the average attention weights of each history word
position in the MB of our two best model variants
(Figure 3). One can see that the attention mass tends
to concentrate at the rightmost position (the current

325



en
it

de

-15 -14 -13 -12 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1

en
it

de

0.08
0.12
0.16
0.20
0.24

Figure 3: Average attention per position of RMN
history. Top: RMR(–tM-g), bottom: RM(+tM-g).
Rightmost positions represent most recent history.

word) and decreases when moving further to the
left (less recent words). This is not surprising since
the success of n-gram language models has demon-
strated that the most recent words provide important
information for predicting the next word. Between
the two variants, the RM average attention mass is
less concentrated to the right. This can be explained
by the absence of an LSTM layer on top, meaning
that the MB in the RM architecture has to pay more
attention to the more distant words in the past. The
remaining analyses described below are performed
on the RM(+tM-g) architecture as this yields the best
perplexity results overall.

Beyond average attention weights, we are inter-
ested in those cases where attention focuses on dis-
tant positions. To this end, we randomly sample 100
words from test data and visualize attention distri-
butions over the last 15 words. Figure 4 shows the
attention distributions for random samples of Ger-
man and Italian. Again, in many cases attention
weights concentrate around the last word (bottom
row). However, we observe that many long distance
words also receive noticeable attention mass. Inter-
estingly, for many predicted words, attention is dis-
tributed evenly over memory positions, possibly in-

de

it

en

Figure 4: Attention visualization of 100 word sam-
ples. Bottom positions in each plot represent most
recent history. Darker color means higher weight.

dicating cases where the LSTM state already con-
tains enough information to predict the next word.

To explain the long-distance dependencies, we
first hypothesize that our RMN mostly memorizes
frequent co-occurrences. We run the RM(+tM-g)
model on the German development and test sen-
tences, and select those pairs of (most-attended-
word, word-to-predict) where the MB’s attention
concentrates on a word more than six positions to
the left. Then, for each set of pairs with equal dis-
tance, we compute the mean frequency of corre-
sponding co-occurrences seen in the training data
(Table 3). The lack of correlation between frequency
and memory location suggests that RMN does more
than simply memorizing frequent co-occurrences.

d 7 8 9 10 11 12 13 14 15

µ 54 63 42 67 87 47 67 44 24

Table 3: Mean frequency (µ) of (most-attended-
word, word-to-predict) pairs grouped by relative dis-
tance (d).

Previous work (Hermans and Schrauwen, 2013;
Karpathy et al., 2015) studied this property of
LSTMs by analyzing simple cases of closing brack-
ets. By contrast RMN allows us to discover more
interesting dependencies in the data. We manually
inspect those high-frequency pairs to see whether
they display certain linguistic phenomena. We ob-
serve that RMN captures, for example, separable
verbs and fixed expressions in German. Separable
verbs are frequent in German: they typically consist
of preposition+verb constructions, such ab+hängen
(‘to depend’) or aus+schließen (‘to exclude’), and
can be spelled together (abhängen) or apart as in
‘hängen von der Situation ab’ (‘depend on the sit-
uation’), depending on the grammatical construc-
tion. Figure 5a shows a long-dependency exam-
ple for the separable verb abhängen (to depend).
When predicting the verb’s particle ab, the model
correctly attends to the verb’s core hängt occurring
seven words to the left. Figure 5b and 5c show fixed
expression examples from German and Italian, re-
spectively: schlüsselrolle ... spielen (play a key role)
and insignito ... titolo (awarded title). Here too, the
model correctly attends to the key word despite its
long distance from the word to predict.

326



ab (-1.8)
und (-2.1)
, (-2.5)
. (-2.7)
von (-2.8)

(a)            wie wirksam die daraus resultierende strategie sein wird , hängt daher von der genauigkeit dieser annahmen

Gloss:  how effective   the  from-that   resulting        strategy     be     will,  depends therefore on the    accuracy     of-these measures
Translation: how effective the resulting strategy will be, therefore, depends on the accuracy of these measures

spielen (-1.9)
gewinnen (-3.0)
finden (-3.4)
haben (-3.4)
schaffen (-3.4)

         … die lage versetzen werden , eine schlüsselrolle bei der eindämmung der regionalen ambitionen chinas zu

Gloss: … the position place         will,            a       key-role            in   the       curbing      of-the   regional      ambitions     China’s  to 
Translation:  …which will put him in a position to play a key role in curbing the regional ambitions of China

(b)

sacro (-1.5)
titolo (-2.9)
re (-3.0)
<unk> (-3.1)
leone (-3.6)

        ...  che fu insignito  nel 1692  dall' Imperatore Leopoldo I del

Gloss: … who was  awarded   in 1692  by-the   Emperor   Leopold   I  of-the

Translation:  … who was awarded the title  by Emperor Leopold I in 1692 

(c)

Figure 5: Examples of distant memory positions attended by RMN. The resulting top five word predictions
are shown with the respective log-probabilities. The correct choice (in bold) was ranked first in sentences
(a,b) and second in (c).

Other interesting examples found by the RMN in
the test data include:

German: findet statt (takes place), kehrte zurück
(came back), fragen antworten (questions
answers), kämpfen gegen (fight against),
bleibt erhalten (remains intact), verantwortung
übernimmt (takes responsibility);

Italian: sinistra destra (left right), latitudine lon-
gitudine (latitude longitude), collegata tramite
(connected through), sposò figli (got-married
children), insignito titolo (awarded title).

5.2 Syntactic analysis

It has been conjectured that RNNs, and LSTMs in
particular, model text so well because they capture
syntactic structure implicitly. Unfortunately this has
been hard to prove, but with our RMN model we can
get closer to answering this important question.

We produce dependency parses for our test sets
using (Sennrich et al., 2013) for German and (At-
tardi et al., 2009) for Italian. Next we look at
how much attention mass is concentrated by the
RM(+tM-g) model on different dependency types.
Figure 6 shows, for each language, a selection of
ten dependency types that are often long-distance.2

Dependency direction is marked by an arrow: e.g.
→mod means that the word to predict is a modifier
of the attended word, while mod← means that the

2The full plots are available at https://github.com/
ketranm/RMN. The German and Italian tag sets are explained
in (Simi et al., 2014) and (Foth, 2006) respectively.

attended word is a modifier of the word to predict.3

White cells denote combinations of position and de-
pendency type that were not present in the test data.

While in most of the cases closest positions are
attended the most, we can see that some dependency
types also receive noticeably more attention than
the average (ALL) on the long-distance positions.
In German, this is mostly visible for the head of
separable verb particles (→avz), which nicely sup-
ports our observations in the lexical analysis (Sec-
tion 5.1). Other attended dependencies include: aux-
iliary verbs (→aux) when predicting the second el-
ement of a complex tense (hat . . . gesagt / has said);
subordinating conjunctions (konj←) when predict-
ing the clause-final inflected verb (dass sie sagen
sollten / that they should say); control verbs (→obji)
when predicting the infinitive verb (versucht ihr
zu helfen / tries to help her). Out of the Italian
dependency types selected for their frequent long-
distance occurrences (bottom of Figure 6), the most
attended are argument heads (→arg), complement
heads (→comp), object heads (→obj) and subjects
(subj←). This suggests that RMN is mainly captur-
ing predicate argument structure in Italian. Notice
that syntactic annotation is never used to train the
model, but only to analyze its predictions.

We can also use RMN to discover which complex
dependency paths are important for word prediction.
To mention just a few examples, high attention on

3Some dependency directions, like obj← in Italian, are al-
most never observed due to order constraints of the language.

327



[-15, -12] [-11, -8] [-7, -4] -3 -2 -1

[ALL]
subj←
→rel
→obji
→objc
obja←
konj←
→kon
→avz
→aux
adv←

0.0

0.1

0.2

0.3

0.4

0.5

[-15, -12] [-11, -8] [-7, -4] -3 -2 -1

[ALL]
subj←
→sub
→pred
→obj

mod←
→mod
→con

comp←
→comp
→arg

0.1

0.2

0.3

0.4

0.5

Figure 6: Average attention weights per position,
broken down by dependency relation type+direction
between the attended word and the word to predict.
Top: German. Bottom: Italian. More distant posi-
tions are binned.

the German path [subj←,→kon,→cj] indicates that
the model captures morphological agreement be-
tween coordinate clauses in non-trivial constructions
of the kind: spielen die Kinder im Garten und singen
/ the children play in the garden and sing. In Italian,
high attention on the path [→obj,→comp,→prep]
denotes cases where the semantic relatedness be-
tween a verb and its object does not stop at the ob-
ject’s head, but percolates down to a prepositional
phrase attached to it (passò buona parte della sua
vita / spent a large part of his life). Interestingly,
both local n-gram context and immediate depen-
dency context would have missed these relations.

While much remains to be explored, our analysis
shows that RMN discovers patterns far more com-
plex than pairs of opening and closing brackets, and
suggests that the network’s hidden state captures to
a large extent the underlying structure of text.

6 Sentence Completion Challenge

The Microsoft Research Sentence Completion Chal-
lenge (Zweig and Burges, 2012) has recently be-

come a test bed for advancing statistical language
modeling. We choose this task to demonstrate the
effectiveness of our RMN in capturing sentence co-
herence. The test set consists of 1,040 sentences se-
lected from five Sherlock Holmes novels by Conan
Doyle. For each sentence, a content word is removed
and the task is to identify the correct missing word
among five given candidates. The task is carefully
designed to be non-solvable for local language mod-
els such as n-gram models. The best reported re-
sult is 58.9% accuracy (Mikolov et al., 2013)4 which
is far below human accuracy of 91% (Zweig and
Burges, 2012).

As baseline we use a stacked three-layer LSTM.
Our models are two variants of RM(+tM-g), each
consisting of three LSTM layers followed by a
MB. The first variant (unidirectional-RM) uses n
words preceding the word to predict, the second
(bidirectional-RM) uses the n words preceding and
the n words following the word to predict, as MB
input. We include bidirectional-RM in the experi-
ments to show the flexibility of utilizing future con-
text in RMN.

We train all models on the standard training data
of the challenge, which consists of 522 novels from
Project Gutenberg, preprocessed similarly to (Mnih
and Kavukcuoglu, 2013). After sentence splitting,
tokenization and lowercasing, we randomly select
19,000 sentences for validation. Training and val-
idation sets include 47M and 190K tokens respec-
tively. The vocabulary size is about 64,000.

We initialize and train all the networks as de-
scribed in Section 4.2. Moreover, for regularization,
we place dropout (Srivastava et al., 2014) after each
LSTM layer as suggested in (Pham et al., 2014). The
dropout rate is set to 0.3 in all the experiments.

Table 4 summarizes the results. It is worth to
mention that our LSTM baseline outperforms a de-
pendency RNN making explicit use of syntactic in-
formation (Mirowski and Vlachos, 2015) and per-
forms on par with the best published result (Mikolov
et al., 2013). Our unidirectional-RM sets a new state
of the art for the Sentence Completion Challenge
with 69.2% accuracy. Under the same setting of d
we observe that using bidirectional context does not

4The authors use a weighted combination of skip-ngram and
RNN without giving any technical details.

328



The stage lost a fine , even as science lost an acute reasoner , when he became a specialist in crime
a) linguist b) hunter c) actor♣ d) estate e) horseman♦

What passion of hatred can it be which leads a man to in such a place at such a time
a) lurk♣ b) dine♦ c) luxuriate d) grow e) wiggle

My heart is already since i have confided my trouble to you
a) falling b) distressed♦ c) soaring d) lightened♣ e) punished

My morning’s work has not been , since it has proved that he has the very strongest motives for
standing in the way of anything of the sort
a) invisible b) neglected♦♣ c) overlooked d) wasted e) deliberate

That is his fault , but on the whole he’s a good worker
a) main b) successful c) mother’s♣ d) generous e) favourite♦

Figure 7: Examples of sentence completion. The correct option is in boldface. Predictions by the LSTM
baseline and by our best RMN model are marked by ♦ and ♣ respectively.

Model n d Accuracy
LSTM – 256 56.0

unidirectional-RM
15 256 64.3
15 512 69.2

bidirectional-RM
7 256 59.6

10 512 67.0

Table 4: Accuracy on 1,040 test sentences. We use
perplexity to choose the best model. Dimension of
word embeddings, LSTM hidden states, and gate g
parameters are set to d.

bring additional advantage to the model. Mnih and
Kavukcuoglu (2013) also report a similar observa-
tion. We believe that RMN may achieve further im-
provements with hyper-parameter optimization.

Figure 7 shows some examples where our best
RMN beats the already very competitive LSTM
baseline, or where both models fail. We can see
that in some sentences the necessary clues to predict
the correct word occur only to its right. While this
seems to conflict with the worse result obtained by
the bidirectional-RM, it is important to realize that
prediction corresponds to the whole sentence prob-
ability. Therefore a badly chosen word can have a
negative effect on the score of future words. This ap-
pears to be particularly true for the RMN due to its
ability to directly access (distant) words in the his-
tory. The better performance of unidirectional ver-

sus bidirectional-RM may indicate that the attention
in the memory block can be distributed reliably only
on words that have been already seen and summa-
rized by the current LSTM state. In future work,
we may investigate whether different ways to com-
bine two RMNs running in opposite directions fur-
ther improve accuracy on this challenging task.

7 Conclusion

We have proposed the Recurrent Memory Network
(RMN), a novel recurrent architecture for language
modeling. Our RMN outperforms LSTMs in terms
of perplexity on three large dataset and allows us
to analyze its behavior from a linguistic perspective.
We find that RMNs learn important co-occurrences
regardless of their distance. Even more interest-
ingly, our RMN implicitly captures certain depen-
dency types that are important for word prediction,
despite being trained without any syntactic informa-
tion. Finally RMNs obtain excellent performance at
modeling sentence coherence, setting a new state of
the art on the challenging sentence completion task.

Acknowledgments

This research was funded in part by the Netherlands
Organization for Scientific Research (NWO) under
project numbers 639.022.213 and 612.001.218.

329



References
Giuseppe Attardi, Felice Dell’Orletta, Maria Simi, and

Joseph Turian. 2009. Accurate dependency parsing
with a stacked multilayer perceptron. In Proceedings
of Evalita’09, Evaluation of NLP and Speech Tools for
Italian, Reggio Emilia, Italy.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. In ICLR 2015, San
Diego, CA, USA, May.

Yoshua Bengio, Patrice Simard, and Paolo Frasconi.
1994. Learning long-term dependencies with gradient
descent is difficult. Transaction on Neural Networks,
5(2):157–166, March.

Yoshua Bengio, Réjean Ducharme, Pascal Vincent, and
Christian Janvin. 2003. A neural probabilistic lan-
guage model. J. Mach. Learn. Res., 3:1137–1155,
March.

Ondřej Bojar, Rajen Chatterjee, Christian Federmann,
Barry Haddow, Matthias Huck, Chris Hokamp, Philipp
Koehn, Varvara Logacheva, Christof Monz, Matteo
Negri, Matt Post, Carolina Scarton, Lucia Specia, and
Marco Turchi. 2015. Findings of the 2015 workshop
on statistical machine translation. In Proceedings of
the Tenth Workshop on Statistical Machine Transla-
tion, pages 1–46, Lisbon, Portugal, September. Asso-
ciation for Computational Linguistics.

Samuel R. Bowman, Christopher D. Manning, and
Christopher Potts. 2015. Tree-structured composi-
tion in neural networks without tree-structured archi-
tectures. In Proceedings of Proceedings of the NIPS
2015 Workshop on Cognitive Computation: Integrat-
ing Neural and Symbolic Approaches, December.

Ciprian Chelba, Tomas Mikolov, Mike Schuster, Qi Ge,
Thorsten Brants, Phillipp Koehn, and Tony Robinson.
2013. One billion word benchmark for measuring
progress in statistical language modeling. Technical
report, Google.

Welin Chen, David Grangier, and Michael Auli. 2015.
Strategies for Training Large Vocabulary Neural Lan-
guage Models. ArXiv e-prints, December.

Kyunghyun Cho, Bart van Merrienboer, Dzmitry Bah-
danau, and Yoshua Bengio. 2014. On the proper-
ties of neural machine translation: Encoder–decoder
approaches. In Proceedings of SSST-8, Eighth Work-
shop on Syntax, Semantics and Structure in Statisti-
cal Translation, pages 103–111, Doha, Qatar, October.
Association for Computational Linguistics.

Junyoung Chung, Caglar Gulcehre, KyungHyun Cho,
and Yoshua Bengio. 2014. Empirical evaluation of
gated recurrent neural networks on sequence mod-
eling. In NIPS Deep Learning and Representation
Learning Workshop.

Chris Dyer, Miguel Ballesteros, Wang Ling, Austin
Matthews, and Noah A. Smith. 2015. Transition-
based dependency parsing with stack long short-term
memory. In Proceedings of the 53rd Annual Meet-
ing of the Association for Computational Linguistics
and the 7th International Joint Conference on Natural
Language Processing, pages 334–343, Beijing, China,
July. Association for Computational Linguistics.

Jeffrey L. Elman. 1990. Finding structure in time. Cog-
nitive Science, 14(2):179–211.

Katja Filippova, Enrique Alfonseca, Carlos A. Col-
menares, Lukasz Kaiser, and Oriol Vinyals. 2015.
Sentence compression by deletion with lstms. In Pro-
ceedings of the 2015 Conference on Empirical Meth-
ods in Natural Language Processing, pages 360–368,
Lisbon, Portugal, September. Association for Compu-
tational Linguistics.

Kilian A. Foth. 2006. Eine umfassende Constraint-
Dependenz-Grammatik des Deutschen. Fachbereich
Informatik.

Alex Graves, Greg Wayne, and Ivo Danihelka. 2014.
Neural turing machines. CoRR, abs/1410.5401.

Klaus Greff, Rupesh Kumar Srivastava, Jan Koutnı́k,
Bas R. Steunebrink, and Jürgen Schmidhuber.
2015. LSTM: A search space odyssey. CoRR,
abs/1503.04069.

Karol Gregor, Ivo Danihelka, Alex Graves,
Danilo Jimenez Rezende, and Daan Wierstra.
2015. DRAW: A recurrent neural network for image
generation. In Proceedings of the 32nd International
Conference on Machine Learning, ICML 2015, Lille,
France, 6-11 July 2015, pages 1462–1471.

Michiel Hermans and Benjamin Schrauwen. 2013.
Training and analysing deep recurrent neural net-
works. In C.J.C. Burges, L. Bottou, M. Welling,
Z. Ghahramani, and K.Q. Weinberger, editors, Ad-
vances in Neural Information Processing Systems 26,
pages 190–198. Curran Associates, Inc.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Computation, 9(8):1735–
1780, November.

Rafal Józefowicz, Wojciech Zaremba, and Ilya Sutskever.
2015. An empirical exploration of recurrent network
architectures. In Proceedings of the 32nd Interna-
tional Conference on Machine Learning, ICML 2015,
Lille, France, 6-11 July 2015, pages 2342–2350.

Nal Kalchbrenner, Ivo Danihelka, and Alex Graves.
2015. Grid long short-term memory. CoRR,
abs/1507.01526.

Andrej Karpathy, Justin Johnson, and Fei-Fei Li. 2015.
Visualizing and understanding recurrent networks.
CoRR, abs/1506.02078.

Verena Lyding, Egon Stemle, Claudia Borghetti, Marco
Brunello, Sara Castagnoli, Felice Dell’Orletta, Henrik

330



Dittmann, Alessandro Lenci, and Vito Pirrelli. 2014.
The PAISÀ corpus of italian web texts. In Proceedings
of the 9th Web as Corpus Workshop (WaC-9), pages
36–43, Gothenburg, Sweden, April. Association for
Computational Linguistics.

Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beat-
rice Santorini. 1993. Building a large annotated cor-
pus of english: The penn treebank. Comput. Linguist.,
19(2):313–330, June.

Tomas Mikolov, Martin Karafiát, Lukás Burget, Jan
Cernocký, and Sanjeev Khudanpur. 2010. Re-
current neural network based language model. In
INTERSPEECH 2010, 11th Annual Conference of
the International Speech Communication Association,
Makuhari, Chiba, Japan, September 26-30, 2010,
pages 1045–1048.

Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. 2013. Efficient estimation of word represen-
tations in vector space. In ICLR.

Piotr Mirowski and Andreas Vlachos. 2015. Depen-
dency recurrent neural language models for sentence
completion. In Proceedings of the 53rd Annual Meet-
ing of the Association for Computational Linguistics
and the 7th International Joint Conference on Natural
Language Processing (Volume 2: Short Papers), pages
511–517, Beijing, China, July. Association for Com-
putational Linguistics.

Andriy Mnih and Koray Kavukcuoglu. 2013. Learning
word embeddings efficiently with noise-contrastive es-
timation. In C.J.C. Burges, L. Bottou, M. Welling,
Z. Ghahramani, and K.Q. Weinberger, editors, Ad-
vances in Neural Information Processing Systems 26,
pages 2265–2273. Curran Associates, Inc.

Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio.
2013. On the difficulty of training recurrent neural net-
works. In ICML (3), volume 28 of JMLR Proceedings,
pages 1310–1318.

Vu Pham, Christopher Bluche, Théodore Kermorvant,
and Jérôme Louradour. 2014. Dropout improves re-
current neural networks for handwriting recognition.
In International Conference on Frontiers in Handwrit-
ing Recognition (ICFHR), pages 285–290, Sept.

Rico Sennrich, Martin Volk, and Gerold Schneider. 2013.
Exploiting synergies between open resources for ger-
man dependency parsing, pos-tagging, and morpho-
logical analysis. In Recent Advances in Natural Lan-
guage Processing (RANLP 2013), pages 601–609,
September.

Maria Simi, Cristina Bosco, and Simonetta Montemagni.
2014. Less is more? towards a reduced inventory of
categories for training a parser for the italian stanford
dependencies. In Proceedings of the Ninth Interna-
tional Conference on Language Resources and Evalu-

ation (LREC’14), Reykjavik, Iceland, may. European
Language Resources Association (ELRA).

Richard Socher, Jeffrey Pennington, Eric H. Huang, An-
drew Y. Ng, and Christopher D. Manning. 2011.
Semi-supervised recursive autoencoders for predicting
sentiment distributions. In Proceedings of the Confer-
ence on Empirical Methods in Natural Language Pro-
cessing, EMNLP ’11, pages 151–161, Stroudsburg,
PA, USA. Association for Computational Linguistics.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overfitting. J. Mach. Learn. Res., 15(1):1929–
1958, January.

Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston, and
Rob Fergus. 2015. End-to-end memory networks. In
C. Cortes, N.D. Lawrence, D.D. Lee, M. Sugiyama,
R. Garnett, and R. Garnett, editors, Advances in Neu-
ral Information Processing Systems 28, pages 2431–
2439. Curran Associates, Inc.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural networks.
In Z. Ghahramani, M. Welling, C. Cortes, N.D.
Lawrence, and K.Q. Weinberger, editors, Advances
in Neural Information Processing Systems 27, pages
3104–3112. Curran Associates, Inc.

Geoffrey Zweig and Chris J. C. Burges. 2012. A chal-
lenge set for advancing language modeling. In Pro-
ceedings of the NAACL-HLT 2012 Workshop: Will We
Ever Really Replace the N-gram Model? On the Fu-
ture of Language Modeling for HLT, WLM ’12, pages
29–36, Stroudsburg, PA, USA. Association for Com-
putational Linguistics.

331


