



















































NLProlog: Reasoning with Weak Unification for Question Answering in Natural Language


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 6151–6161
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

6151

NLProlog: Reasoning with Weak Unification for
Question Answering in Natural Language

Leon Weber
Humboldt-Universität

zu Berlin
weberple@hu-berlin.de

Pasquale Minervini
University College London

p.minervini@ucl.ac.uk

Jannes Münchmeyer
GFZ German Research Center

for Geoscience Potsdam
munchmej@gfz-potsdam.de

Ulf Leser
Humboldt-Universität

zu Berlin
leser@informatik.hu-berlin.de

Tim Rocktäschel
University College London

t.rocktaschel@cs.ucl.ac.uk

Abstract

Rule-based models are attractive for various
tasks because they inherently lead to inter-
pretable and explainable decisions and can eas-
ily incorporate prior knowledge. However,
such systems are difficult to apply to prob-
lems involving natural language, due to its lin-
guistic variability. In contrast, neural models
can cope very well with ambiguity by learn-
ing distributed representations of words and
their composition from data, but lead to mod-
els that are difficult to interpret. In this pa-
per, we describe a model combining neural net-
works with logic programming in a novel man-
ner for solving multi-hop reasoning tasks over
natural language. Specifically, we propose to
use a Prolog prover which we extend to utilize
a similarity function over pretrained sentence
encoders. We fine-tune the representations
for the similarity function via backpropagation.
This leads to a system that can apply rule-
based reasoning to natural language, and in-
duce domain-specific rules from training data.
We evaluate the proposed system on two dif-
ferent question answering tasks, showing that
it outperforms two baselines – BIDAF (Seo
et al., 2016a) and FASTQA (Weissenborn
et al., 2017b) on a subset of the WIKIHOP
corpus and achieves competitive results on the
MEDHOP data set (Welbl et al., 2017).

1 Introduction

We consider the problem of multi-hop reason-
ing on natural language data. For instance, con-
sider the statements “Socrates was born in Athens”
and “Athens belongs to Greece”, and the question
“Where was Socrates born?”. There are two possi-
ble answers following from the given statements,
namely “Athens” and “Greece”. While the answer
“Athens” follows directly from “Socrates was born
in Athens”, the answer “Greece” requires the reader
to combine both statements, using the knowledge

that a person born in a city X , located in a coun-
try Y , is also born in Y . This step of combin-
ing multiple pieces of information is referred to as
multi-hop reasoning (Welbl et al., 2017). In the
literature, such multi-hop reading comprehension
tasks are frequently solved via end-to-end differ-
entiable (deep learning) models (Sukhbaatar et al.,
2015; Peng et al., 2015; Seo et al., 2016b; Raison
et al., 2018; Henaff et al., 2016; Kumar et al., 2016;
Graves et al., 2016; Dhingra et al., 2018). Such
models are capable of dealing with the linguis-
tic variability and ambiguity of natural language
by learning word and sentence-level representa-
tions from data. However, in such models, explain-
ing the reasoning steps leading to an answer and
interpreting the model parameters to extrapolate
new knowledge is a very challenging task (Doshi-
Velez and Kim, 2017; Lipton, 2018; Guidotti et al.,
2019). Moreover, such models tend to require
large amounts of training data to generalise cor-
rectly, and incorporating background knowledge
is still an open problem (Rocktäschel et al., 2015;
Weissenborn et al., 2017a; Rocktäschel and Riedel,
2017; Evans and Grefenstette, 2017).

In contrast, rule-based models are easily inter-
pretable, naturally produce explanations for their
decisions, and can generalise from smaller quan-
tities of data. However, these methods are not ro-
bust to noise and can hardly be applied to domains
where data is ambiguous, such as vision and lan-
guage (Moldovan et al., 2003; Rocktäschel and
Riedel, 2017; Evans and Grefenstette, 2017).

In this paper, we introduce NLPROLOG, a sys-
tem combining a symbolic reasoner and a rule-
learning method with distributed sentence and en-
tity representations to perform rule-based multi-
hop reasoning on natural language input.1 NLPRO-
LOG generates partially interpretable and explain-

1NLPROLOG and our evaluation code is available at
https://github.com/leonweber/nlprolog.

https://github.com/leonweber/nlprolog


6152

able models, and allows for easy incorporation of
prior knowledge. It can be applied to natural lan-
guage without the need of converting it to an in-
termediate logic form. At the core of NLPROLOG
is a backward-chaining theorem prover, analogous
to the backward-chaining algorithm used by Pro-
log reasoners (Russell and Norvig, 2010b), where
comparisons between symbols are replaced by dif-
ferentiable similarity function between their dis-
tributed representations (Sessa, 2002). To this end,
we use end-to-end differentiable sentence encoders,
which are initialized with pretrained sentence em-
beddings (Pagliardini et al., 2017) and then fine-
tuned on a downstream task. The differentiable
fine-tuning objective enables us learning domain-
specific logic rules – such as transitivity of the rela-
tion is in – from natural language data. We evaluate
our approach on two challenging multi-hop Ques-
tion Answering data sets, namely MEDHOP and
WIKIHOP (Welbl et al., 2017).

Our main contributions are the following: i) We
show how backward-chaining reasoning can be
applied to natural language data by using a combi-
nation of pretrained sentence embeddings, a logic
prover, and fine-tuning via backpropagation, ii) We
describe how a Prolog reasoner can be enhanced
with a differentiable unification function based on
distributed representations (embeddings), iii) We
evaluate the proposed system on two different
Question Answering (QA) datasets, and demon-
strate that it achieves competitive results in compar-
ison with strong neural QA models while providing
interpretable proofs using learned rules.

2 Related Work

Our work touches in general on weak-unification
based fuzzy logic (Sessa, 2002) and focuses on
multi-hop reasoning for QA, the combination of
logic and distributed representations, and theorem
proving for question answering.

Multi-hop Reasoning for QA. One prominent
approach for enabling multi-hop reasoning in neu-
ral QA models is to iteratively update a query
embedding by integrating information from em-
beddings of context sentences, usually using an
attention mechanism and some form of recur-
rency (Sukhbaatar et al., 2015; Peng et al., 2015;
Seo et al., 2016b; Raison et al., 2018). These mod-
els have achieved state-of-the-art results in a num-
ber of reasoning-focused QA tasks. Henaff et al.
(2016) employ a differentiable memory structure

that is updated each time a new piece of informa-
tion is processed. The memory slots can be used
to track the state of various entities, which can be
considered as a form of temporal reasoning. Sim-
ilarly, the Neural Turing Machine (Graves et al.,
2016) and the Dynamic Memory Network (Ku-
mar et al., 2016), which are built on differentiable
memory structures, have been used to solve syn-
thetic QA problems requiring multi-hop reasoning.
Dhingra et al. (2018) modify an existing neural
QA model to additionally incorporate coreference
information provided by a coreference resolution
model. De Cao et al. (2018) build a graph con-
necting entities and apply Graph Convolutional
Networks (Kipf and Welling, 2016) to perform
multi-hop reasoning, which leads to strong results
on WIKIHOP. Zhong et al. (2019) propose a new
neural QA architecture that combines a combina-
tion of coarse-grained and fine-grained reasoning
to achieve very strong results on WIKIHOP.

All of the methods above perform reasoning im-
plicitly as a sequence of opaque differentiable oper-
ations, making the interpretation of the intermedi-
ate reasoning steps very challenging. Furthermore,
it is not obvious how to leverage user-defined infer-
ence rules during the reasoning procedure.

Combining Rule-based and Neural Models.
In Artificial Intelligence literature, integrating sym-
bolic and sub-symbolic representations is a long-
standing problem (Besold et al., 2017). Our work
is very related to the integration of Markov Logic
Networks (Richardson and Domingos, 2006) and
Probabilistic Soft Logic (Bach et al., 2017) with
word embeddings, which was applied to Recogniz-
ing Textual Entailment (RTE) and Semantic Tex-
tual Similarity (STS) tasks (Garrette et al., 2011,
2014; Beltagy et al., 2013, 2014), improving over
purely rule-based and neural baselines.

An area in which neural multi-hop reasoning
models have been investigated is Knowledge Base
Completion (KBC) (Das et al., 2016; Cohen, 2016;
Neelakantan et al., 2015; Rocktäschel and Riedel,
2017; Das et al., 2017; Evans and Grefenstette,
2018). While QA could be in principle modeled as
a KBC task, the construction of a Knowledge Base
(KB) from text is a brittle and error prone process,
due to the inherent ambiguity of natural language.

Very related to our approach are Neural Theorem
Provers (NTPs) (Rocktäschel and Riedel, 2017):
given a goal, its truth score is computed via a con-
tinuous relaxation of the backward-chaining rea-



6153

soning algorithm, using a differentiable unification
operator. Since the number of candidate proofs
grows exponentially with the length of proofs,
NTPs cannot scale even to moderately sized knowl-
edge bases, and are thus not applicable to natural
language problems in its current form. We solve
this issue by using an external prover and pretrained
sentence representations to efficiently discard all
proof trees producing proof scores lower than a
given threshold, significantly reducing the number
of candidate proofs.

Theorem Proving for Question Answering.
Our work is not the first to apply theorem prov-
ing to QA problems. Angeli et al. (2016) employ
a system based on Natural Logic to search a large
KB for a single statement that entails the candidate
answer. This is different from our approach, as we
aim to learn a set of rules that combine multiple
statements to answer a question.

Systems like Watson (Ferrucci et al., 2010) and
COGEX (Moldovan et al., 2003) utilize an inte-
grated theorem prover, but require a transformation
of the natural language sentences to logical atoms.
In the case of COGEX, this improves the accuracy
of the underlying system by 30%, and increases
its interpretability. While this work is similar in
spirit, we greatly simplify the preprocessing step
by replacing the transformation of natural language
to logic with the simpler approach of transforming
text to triples by using co-occurences of named
entities.

Fader et al. (2014) propose OPENQA, a system
that utilizes a mixture of handwritten and automati-
cally obtained operators that are able to parse, para-
phrase and rewrite queries, which allows them to
perform large-scale QA on KBs that include Open
IE triples. While this work shares the same goal
– answering questions using facts represented by
natural language triples – we choose to address the
problem of linguistic variability by integrating neu-
ral components, and focus on the combination of
multiple facts by learning logical rules.

3 Background

In the following, we briefly introduce the backward
chaining algorithm and unification procedure (Rus-
sell and Norvig, 2016) used by Prolog reasoners,
which lies at the core of NLPROLOG. We consider
Prolog programs that consists of a set of rules in

the form of Horn clauses:

h(fh1 , . . . , f
h
n ) ⇐

p1(f
1
1 , . . . , f

1
m) ∧ . . . ∧ pB(fB1 , . . . , fBl ),

where h, pi are predicate symbols, and f ij are ei-
ther function (denoted in lower case) or variable
(upper case) symbols. The domain of function sym-
bols is denoted by F , and the domain of predicate
symbols by P . h(fh1 , . . . , fhn ) is called the head
and p1(f11 , . . . , f

1
m) ∧ . . . ∧ pB(fB1 , . . . , fBl ) the

body of the rule. We call B the body size of the
rule and rules with a body size of zero are named
atoms (short for atomic formula). If an atom does
not contain any variable symbols it is termed fact.

For simplicity, we only consider function-free
Prolog in our experiments, i.e. Datalog (Gallaire
and Minker, 1978) programs where all function
symbols have arity zero and are called entities
and, similarly to related work (Sessa, 2002; Julián-
Iranzo et al., 2009), we disregard negation and dis-
junction. However, in principle NLPROLOG also
supports functions with higher arity.

A central component in a Prolog reasoner is
the unification operator: given two atoms, it
tries to find variable substitutions that make both
atoms syntactically equal. For example, the atoms
country(Greece, Socrates) and country(X,Y) re-
sult in the following variable substitutions after
unification: {X/Greece, Y/Socrates}.

Prolog uses backward chaining for proving as-
sertions. Given a goal atom g, this procedure first
checks whether g is explicitly stated in the KB –
in this case, it can be proven. If it is not, the al-
gorithm attempts to prove it by applying suitable
rules, thereby generating subgoals that are proved
next. To find applicable rules, it attempts to unify
g with the heads of all available rules. If this unifi-
cation succeeds, the resulting variable substitutions
are applied to the atoms in the rule body: each of
those atoms becomes a subgoal, and each subgoal
is recursively proven using the same strategy.

For instance, the application of the rule
country(X,Y ) ⇐ born_in(Y,X) to the goal
country(Greece, Socrates) would yield the subgoal
born_in(Socrates,Greece). Then the process is re-
peated for all subgoals until no subgoal is left to
be proven. The result of this procedure is a set
of rule applications and variable substitutions re-
ferred to as proof. Note that the number of possible
proofs grows exponentially with its depth, as every
rule might be used in the proof of each subgoal.



6154

Pseudo code for weak unification can be found in
Appendix A – we refer the reader to (Russell and
Norvig, 2010a) for an in-depth treatment of the
unification procedure.

4 NLProlog

Applying a logic reasoner to QA requires trans-
forming the natural language paragraphs to logical
representations, which is a brittle and error-prone
process.

Our aim is reasoning with natural language repre-
sentations in the form of triples, where entities and
relations may appear under different surface forms.
For instance, the textual mentions is located in and
lies in express the same concept. We propose re-
placing the exact matching between symbols in the
Prolog unification operator with a weak unification
operator (Sessa, 2002), which allows to unify two
different symbols s1, s2, by comparing their repre-
sentations using a differentiable similarity function
s1 ∼θ s2 ∈ [0, 1] with parameters θ.

With the weak unification operator, the compar-
ison between two logical atoms results in an uni-
fication score resulting from the aggregation of
each similarity score. Inspired by fuzzy logic t-
norms (Gupta and Qi, 1991), aggregation operators
are e.g. the minimum or the product of all scores.
The result of backward-chaining with weak uni-
fication is a set of proofs, each associated with a
proof score measuring the truth degree of the goal
with respect to a given proof. Similarly to back-
ward chaining, where only successful proofs are
considered, in NLPROLOG the final proof success
score is obtained by taking the maximum over the
success scores of all found proofs. NLPROLOG
combines inference based on the weak unification
operator and distributed representations, to allow
reasoning over sub-symbolic representations – such
as embeddings – obtained from natural language
statements.

Each natural language statement is first trans-
lated into a triple, where the first and third element
denote the entities involved in the sentence, and the
second element denotes the textual surface pattern
connecting the entities. All elements in each triple
– both the entities and the textual surface pattern
– are then embedded into a vector space. These
vector representations are used by the similarity
function ∼θ for computing similarities between
two entities or two textual surface patterns and,
in turn, by the backward chaining algorithm with

the weak unification operator for deriving a proof
score for a given assertion. Note that the resulting
proof score is fully end-to-end differentiable with
respect to the model parameters θ: we can train
NLPROLOG using gradient-based optimisation by
back-propagating the prediction error to θ. Fig. 1
shows an outline of the model, its components and
their interactions.

4.1 Triple Extraction
To transform the support documents to natural lan-
guage triples, we first detect entities by perform-
ing entity recognition with SPACY (Honnibal and
Montani, 2017). From these, we generate triples
by extracting all entity pairs that co-occur in the
same sentence and use the sentence as the predicate
blinding the entities. For instance, the sentence
“Socrates was born in Athens and his father was
Sophronicus” is converted in the following triples:
i) (Socrates, ENT1 was born in ENT2 and his father
was Sophronicus, Athens), ii) (Socrates, ENT1 was
born in Athens and his father was ENT2, Sophroni-
cus), and iii) (Athens, Socrates was born in ENT1
and his father was ENT2, Sophronicus). We also
experimented with various Open Information Ex-
traction frameworks (Niklaus et al., 2018): in our
experiments, such methods had very low recall,
which led to significantly lower accuracy values.

4.2 Similarity Computation
Embedding representations of the symbols in a
triple are computed using an encoder eθ : F∪P 7→
Rd parameterized by θ – where F ,P denote the
sets of entity and predicate symbols, and d de-
notes the embedding size. The resulting embed-
dings are used to induce the similarity function
∼θ: (F ∪ P)2 7→ [0, 1], given by their cosine simi-
larity scaled to [0, 1]:

s1 ∼θ s2 =
1

2

(
1 +

eθ(s1)
>eθ(s2)

||eθ(s1)|| · ||eθ(s2)||

)
(1)

In our experiments, for using textual sur-
face patterns, we use a sentence encoder com-
posed of a static pre-trained component – namely,
SENT2VEC (Pagliardini et al., 2017) – and a Multi-
Layer Perceptron (MLP) with one hidden layer and
Rectified Linear Unit (ReLU) activations (Jarrett
et al., 2009). For encoding predicate symbols and
entities, we use a randomly initialised embedding
matrix. During training, both the MLP and the em-
bedding matrix are learned via backpropagation,
while the sentence encoder is kept fixed.



6155

Additionally, we introduce a third lookup ta-
ble and MLP for the predicate symbols of rules
and goals. The main reason of this choice is that
semantics of goal and rule predicates may dif-
fer from the semantics of fact predicates, even if
they share the same surface form. For instance,
the query (X, parent,Y) can be interpreted either
as (X, is the parent of,Y) or as (X, has parent,Y),
which are semantically dissimilar.

4.3 Training the Encoders

We train the encoder parameters θ on a downstream
task via gradient-based optimization. Specifically,
we train NLPROLOG with backpropagation using
a learning from entailment setting (Muggleton and
Raedt, 1994), in which the model is trained to de-
cide whether a Prolog programR entails the truth
of a candidate triple c ∈ C, where C is the set
of candidate triples. The objective is a model that
assigns high probabilities p(c|R; θ) to true candi-
date triples, and low probabilities to false triples.
During training, we minimize the following loss:

L(θ) =− log p(a|R; θ)

− log
(
1− max

c∈C\{a}
p(c|R; θ)

)
,

(2)

where a ∈ C is the correct answer. For simplicity,
we assume that there is only one correct answer
per example, but an adaptation to multiple correct
answers would be straight-forward, e.g. by taking
the minimum of all answer scores.

To estimate p(c|R; θ), we enumerate all proofs
for the triple c up to a given depth D, where D is
a user-defined hyperparameter. This search yields
a number of proofs, each with a success score Si.
We set p(c|R; θ) to be the maximum of such proof
scores:

p(c|R; θ) = Smax = max
i
Si ∈ [0, 1].

Note that the final proof score p(c|R; θ) only
depends on the proof with maximum success score
Smax. Thus, we propose to first conduct the proof
search by using a prover utilizing the similarity
function induced by the current parameters ∼θt ,
which allows us to compute the maximum proof
score Smax. The score for each proof is given by
the aggregation – either using the minimum or the
product functions – of the weak unification scores,
which in turn are computed via the differentiable
similarity function ∼θ. It follows that p(c|R; θ)

is end-to-end differentiable, and can be used for
updating the model parameters θ via Stochastic
Gradient Descent.

4.4 Runtime Complexity of Proof Search
The worst case complexity vanilla logic program-
ming is exponential in the depth of the proof (Rus-
sell and Norvig, 2010a). However, in our case, this
is a particular problem because weak unification
requires the prover to attempt unification between
all entity and predicate symbols.

To keep things tractable, NLPROLOG only at-
tempts to unify symbols with a similarity greater
than some user-defined threshold λ. Furthermore,
in the search step for one statement q, for the rest
of the search, λ is set to max(λ, S) whenever a
proof for q with success score S is found. Due
to the monotonicity of the employed aggregation
functions, this allows to prune the search tree with-
out losing the guarantee to find the proof yielding
the maximum success score Smax, provided that
Smax ≥ λ. We found this optimization to be crucial
to make the proof search scale on the considered
data sets.

4.5 Rule Learning
In NLPROLOG, the reasoning process depends on
rules that describe the relations between predicates.
While it is possible to write down rules involving
natural language patterns, this approach does not
scale. Thus, we follow Rocktäschel and Riedel
(2017) and use rule templates to perform Induc-
tive Logic Programming (ILP) (Muggleton, 1991),
which allows NLPROLOG to learn rules from train-
ing data. In this setting, a user has to define a set
of rules with a given structure as input. Then, NL-
PROLOG can learn the rule predicate embeddings
from data by minimizing the loss function in Eq. (2)
using gradient-based optimization methods.

For instance, to induce a rule that can model
transitivity, we can use a rule template of the form
p1(X,Z) ⇐ p2(X,Y ) ∧ p3(Y, Z), and NLPRO-
LOG will instantiate multiple rules with randomly
initialized embeddings for p1, p2, and p3, and fine-
tune them on a downstream task. The exact number
and structure of the rule templates is treated as a
hyperparameter.

Unless explicitly stated otherwise, all exper-
iments were performed with the same set of
rule templates containing two rules for each of
the forms q(X,Y ) ⇐ p2(X,Y ), p1(X,Y ) ⇐
p2(Y,X) and p1(X,Z) ⇐ p2(X,Y ) ∧ p3(Y, Z),



6156

Figure 1: Overview of NLPROLOG – all components are depicted as ellipses, while inputs and outputs are drawn
as squares. Phrases with red background are entities and blue ones are predicates.

where q is the query predicate. The number
and structure of these rule templates can be
easily modified, allowing the user to incorpo-
rate additional domain-specific background knowl-
edge, such as born_in(X,Z)⇐ born_in(X,Y ) ∧
located_in(Y,Z)

5 Evaluation

We evaluate our method on two QA datasets,
namely MEDHOP, and several subsets of WIKI-
HOP (Welbl et al., 2017). These data sets are con-
structed in such a way that it is often necessary to
combine information from multiple documents to
derive the correct answer.

In both data sets, each data point consists of a
query p(e,X), where e is an entity, X is a variable
– representing the entity that needs to be predicted,
C is a list of candidates entities, a ∈ C is an answer
entity and p is the query predicate. Furthermore,
every query is accompanied by a set of support
documents which can be used to decide which of
the candidate entities is the correct answer.

5.1 MedHop

MEDHOP is a challenging multi-hop QA data set,
and contains only a single query predicate. The
goal in MEDHOP is to predict whether two drugs
interact with each other, by considering the inter-
actions between proteins that are mentioned in the
support documents. Entities in the support doc-
uments are mapped to data base identifiers. To
compute better entity representations, we reverse
this mapping and replace all mentions with the

drug and proteins names gathered from DRUG-
BANK (Wishart et al., 2006) and UNIPROT (Ap-
weiler et al., 2004).

5.2 Subsets of WikiHop
To further validate the effectiveness of our
method, we evaluate on different subsets of WIK-
IHOP (Welbl et al., 2017), each containing a sin-
gle query predicate. We consider the predicates
publisher, developer, country, and record_label,
because their semantics ensure that the annotated
answer is unique and they contain a relatively large
amount of questions that are annotated as requiring
multi-hop reasoning. For the predicate publisher,
this yields 509 training and 54 validation questions,
for developer 267 and 29, for country 742 and 194,
and for record_label 2305 and 283. As the test set
of WIKIHOP is not publicly available, we report
scores for the validation set.

5.3 Baselines
Following Welbl et al. (2017), we use two neural
QA models, namely BIDAF (Seo et al., 2016a)
and FASTQA (Weissenborn et al., 2017b), as base-
lines for the considered WIKIHOP predicates. We
use the implementation provided by the JACK 2

QA framework (Weissenborn et al., 2018) with
the same hyperparameters as used by Welbl et al.
(2017), and train a separate model for each pred-
icate.3 To ensure that the performance of the

2https://github.com/uclmr/jack
3We also experimented with the AllenNLP implemen-

tation of BIDAF, available at https://github.com/
allenai/allennlp/blob/master/allennlp/

https://github.com/uclmr/jack
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py


6157

baseline is not adversely affected by the relatively
small number of training examples, we also evalu-
ate the BIDAF model trained on the whole WIK-
IHOP corpus. In order to compensate for the
fact that both models are extractive QA models
which cannot make use of the candidate entities,
we additionally evaluate modified versions which
transform both the predicted answer and all can-
didates to vectors using the wiki-unigrams model
of SENT2VEC (Pagliardini et al., 2017). Conse-
quently, we return the candidate entity which has
the highest cosine similarity to the predicted en-
tity. We use the normalized version of MEDHOP
for training and evaluating the baselines, since we
observed that denormalizing it (as for NLPROLOG)
severely harmed performance. Furthermore on
MEDHOP, we equip the models with word embed-
dings that were pretrained on a large biomedical
corpus (Pyysalo et al., 2013).

5.4 Hyperparameter Configuration
On MEDHOP we optimize the embeddings of
predicate symbols of rules and query triples, as
well as of entities. WIKIHOP has a large num-
ber of unique entity symbols and thus, learning
their embeddings is prohibitive. Thus, we only
train the predicate symbols of rules and query
triples on this data set. For MEDHOP we use bi-
gram SENT2VEC embeddings trained on a large
biomedical corpus 4, and for WIKIHOP the wiki-
unigrams model5 of SENT2VEC. All experiments
were performed with the same set of rule tem-
plates containing two rules for each of the forms
p(X,Y ) ⇐ q(X,Y ), p(X,Y ) ⇐ q(Y,X) and
p(X,Z)⇐ q(X,Y ) ∧ r(Y,Z) and set the similar-
ity threshold λ to 0.5 and maximum proof depth
to 3. We use Adam (Kingma and Ba, 2014) with
default parameters.

5.5 Results
The results for the development portions of WIK-
IHOP and MEDHOP are shown in Table 1. For
all predicates but developer, NLPROLOG strongly
outperforms all tested neural QA models, while
achieving the same accuracy as the best performing
QA model on developer. We evaluated NLPRO-
LOG on the hidden test set of MedHop and obtained

models/reading_comprehension/bidaf.py,
obtaining comparable results.

4https://github.com/ncbi-nlp/
BioSentVec

5https://drive.google.com/open?id=
0B6VhzidiLvjSa19uYWlLUEkzX3c

an accuracy of 29.3%, which is 6.1 pp better than
FastQA and 18.5 pp worse than BiDAF.6. As the
test set is hidden, we cannot diagnose the exact
reason for the inconsistency with the results on the
development set, but observe that FastQA suffers
from a similar drop in performance.

5.6 Importance of Rules

Exemplary proofs generated by NLPROLOG for the
predicates record_label and country can be found
in Fig. 2.

To study the impact of the rule-based reasoning
on the predictive performance, we perform an ab-
lation experiment in which we train NLPROLOG
without any rule templates. The results can be
found in the bottom half of Table 1. On three of
the five evaluated data sets, performance decreases
markedly when no rules can be used and does not
change on the remaining two data sets. This indi-
cates that reasoning with logic rules is beneficial in
some cases and does not hurt performance in the
remaining ones.

5.7 Impact of Entity Embeddings

In a qualitative analysis, we observed that in many
cases multi-hop reasoning was performed via align-
ing entities and not by applying a multi-hop rule.
For instance, the proof of the statement coun-
try(Oktabrskiy Big Concert Hall, Russia) visual-
ized in Figure 2, is performed by making the em-
beddings of the entities Oktabrskiy Big Concert
Hall and Saint Petersburg sufficiently similar. To
gauge the extent of this effect, we evaluate an ab-
lation in which we remove the MLP on top of the
entity embeddings. The results, which can be found
in Table 1, show that fine-tuning entity embeddings
plays an integral role, as the performance degrades
drastically. Interestingly, the observed performance
degradation is much worse than when training with-
out rules, suggesting that much of the reasoning is
actually performed by finding a suitable transfor-
mation of the entity embeddings.

5.8 Error Analysis

We performed an error analysis for each of the
WIKIHOP predicates. To this end, we examined all
instances in which one of the neural QA models
(with SENT2VEC) produced a correct prediction

6Note, that these numbers are taken from Welbl et al.
(2017) and were obtained with different implementations of
BIDAF and FASTQA

https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/bidaf.py
https://github.com/ncbi-nlp/BioSentVec
https://github.com/ncbi-nlp/BioSentVec
https://drive.google.com/open?id=0B6VhzidiLvjSa19uYWlLUEkzX3c
https://drive.google.com/open?id=0B6VhzidiLvjSa19uYWlLUEkzX3c


6158

Model MedHop publisher developer country recordlabel

BiDAF 42.98 66.67 65.52 53.09 68.90
+ Sent2Vec — 75.93 68.97 61.86 75.62
+ Sent2Vec + wikihop — 74.07 62.07 66.49 78.09

FastQA 52.63 62.96 62.07 57.21 70.32
+ Sent2Vec — 75.93 58.62 64.95 78.09

NLProlog 65.78 83.33 68.97 77.84 79.51
- rules 64.33 83.33 68.97 74.23 74.91
- entity MLP 37.13 68.52 41.38 72.16 64.66

Table 1: Accuracy scores in percent for different predicates on the development set of the respective predicates. +/-
denote independent modifications to the base algorithm.

Figure 2: Example proof trees generated by NLPRO-
LOG, showing a combination of multiple rules. Entities
are shown in red and predicates in blue. Note, that en-
tities do not need to match exactly. The first and third
proofs were obtained without the entity MLP (as de-
scribed in Section 5.7), while the second one was ob-
tained in the full configuration of NLPROLOG.

and NLPROLOG did not, and labeled them with pre-
defined error categories. Of the 55 instances, 49%
of the errors were due to NLPROLOG unifying the
wrong entities, mainly because of an over-reliance
on heuristics, such as predicting a record label if
it is from the same country as the artist. In 25%
of the cases, NLPROLOG produced a correct pre-
diction, but another candidate was defined as the
answer. In 22% the prediction was due to an error
in predicate unification, i.e. NLPROLOG identified
the correct entities, but the sentence did not express
the target relation. Furthermore, we performed an
evaluation on all problems of the studied WIKI-

HOP predicates that were unanimously labeled as
containing the correct answer in the support texts
by Welbl et al. (2017). On this subset, the micro-
averaged accuracy of NLPROLOG shows an ab-
solute increase of 3.08 pp, while the accuracy of
BIDAF (FASTQA) augmented with SENT2VEC
decreases by 3.26 (3.63) pp. We conjecture that
this might be due to NLPROLOG’s reliance on ex-
plicit reasoning, which could make it less suscepti-
ble to spurious correlations between the query and
supporting text.

6 Discussion and Future Work

We proposed NLPROLOG, a system that is able
to perform rule-based reasoning on natural lan-
guage, and can learn domain-specific rules from
data. To this end, we proposed to combine a sym-
bolic prover with pretrained sentence embeddings,
and to train the resulting system using backprop-
agation. We evaluated NLPROLOG on two differ-
ent QA tasks, showing that it can learn domain-
specific rules and produce predictions which out-
perform those of the two strong baselines BIDAF
and FASTQA in most cases.

While we focused on a subset of First Order
Logic in this work, the expressiveness of NLPRO-
LOG could be extended by incorporating a different
symbolic prover. For instance, a prover for tem-
poral logic (Orgun and Ma, 1994) would allow
to model temporal dynamics in natural language.
We are also interested in incorporating future im-
provements of symbolic provers, triple extraction
systems and pretrained sentence representations to
further enhance the performance of NLPROLOG.
Additionally, it would be interesting to study the be-
havior of NLPROLOG in the presence of multiple
WIKIHOP query predicates.



6159

Acknowledgments

Leon Weber and Jannes Münchmeyer acknowledge
the support of the Helmholtz Einstein International
Berlin Research School in Data Science (HEIB-
RiDS). We would like to thank the anonymous
reviewers for the constructive feedback. We grate-
fully acknowledge the support of NVIDIA Corpo-
ration with the donation of a Titan X Pascal GPU
used for this research.

References
Gabor Angeli, Neha Nayak, and Christopher D Man-

ning. 2016. Combining natural logic and shallow
reasoning for question answering. In Proceedings
of the 54th Annual Meeting of the Association for
Computational Linguistics (Volume 1: Long Papers),
volume 1, pages 442–452.

Rolf Apweiler, Amos Bairoch, Cathy H Wu, Winona C
Barker, Brigitte Boeckmann, Serenella Ferro, Elis-
abeth Gasteiger, Hongzhan Huang, Rodrigo Lopez,
Michele Magrane, et al. 2004. Uniprot: the univer-
sal protein knowledgebase. Nucleic acids research,
32(suppl_1):D115–D119.

Stephen H. Bach, Matthias Broecheler, Bert Huang,
and Lise Getoor. 2017. Hinge-loss markov random
fields and probabilistic soft logic. Journal of Ma-
chine Learning Research, 18:109:1–109:67.

Islam Beltagy, Cuong Chau, Gemma Boleda, Dan
Garrette, Katrin Erk, and Raymond Mooney. 2013.
Montague meets markov: Deep semantics with prob-
abilistic logical form. In Second Joint Conference
on Lexical and Computational Semantics (* SEM),
Volume 1: Proceedings of the Main Conference and
the Shared Task: Semantic Textual Similarity, vol-
ume 1, pages 11–21.

Islam Beltagy, Katrin Erk, and Raymond Mooney.
2014. Probabilistic soft logic for semantic textual
similarity. In Proceedings of the 52nd Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers), volume 1, pages 1210–
1219.

Tarek R Besold, Artur d’Avila Garcez, Sebastian Bader,
Howard Bowman, Pedro Domingos, Pascal Hitzler,
Kai-Uwe Kühnberger, Luis C Lamb, Daniel Lowd,
Priscila Machado Vieira Lima, et al. 2017. Neural-
symbolic learning and reasoning: A survey and in-
terpretation. arXiv preprint arXiv:1711.03902.

William W Cohen. 2016. Tensorlog: A dif-
ferentiable deductive database. arXiv preprint
arXiv:1605.06523.

Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer,
Luke Vilnis, Ishan Durugkar, Akshay Krishna-
murthy, Alex Smola, and Andrew McCallum. 2017.
Go for a walk and arrive at the answer: Reasoning

over paths in knowledge bases using reinforcement
learning. arXiv preprint arXiv:1711.05851.

Rajarshi Das, Arvind Neelakantan, David Belanger,
and Andrew McCallum. 2016. Chains of reasoning
over entities, relations, and text using recurrent neu-
ral networks. arXiv preprint arXiv:1607.01426.

Nicola De Cao, Wilker Aziz, and Ivan Titov. 2018.
Question answering by reasoning across documents
with graph convolutional networks. arXiv preprint
arXiv:1808.09920.

Bhuwan Dhingra, Qiao Jin, Zhilin Yang, William W
Cohen, and Ruslan Salakhutdinov. 2018. Neural
models for reasoning over multiple mentions using
coreference. arXiv preprint arXiv:1804.05922.

Finale Doshi-Velez and Been Kim. 2017. Towards a
rigorous science of interpretable machine learning.
arXiv.

Richard Evans and Edward Grefenstette. 2017. Learn-
ing explanatory rules from noisy data. CoRR,
abs/1711.04574.

Richard Evans and Edward Grefenstette. 2018. Learn-
ing explanatory rules from noisy data. J. Artif. Intell.
Res., 61:1–64.

Anthony Fader, Luke Zettlemoyer, and Oren Etzioni.
2014. Open question answering over curated and ex-
tracted knowledge bases. In Proceedings of the 20th
ACM SIGKDD International Conference on Knowl-
edge Discovery and Data Mining, KDD ’14, pages
1156–1165, New York, NY, USA. ACM.

David Ferrucci, Eric Brown, Jennifer Chu-Carroll,
James Fan, David Gondek, Aditya A Kalyanpur,
Adam Lally, J William Murdock, Eric Nyberg, John
Prager, and Others. 2010. Building watson: An
overview of the DeepQA project. AI magazine,
31(3):59–79.

Hervé Gallaire and Jack Minker, editors. 1978. Logic
and Data Bases, Symposium on Logic and Data
Bases, Centre d’études et de recherches de Toulouse,
1977, Advances in Data Base Theory. Plemum Press,
New York.

Dan Garrette, Katrin Erk, and Raymond Mooney. 2011.
Integrating logical representations with probabilis-
tic information using markov logic. In Proceedings
of the Ninth International Conference on Computa-
tional Semantics, pages 105–114. Association for
Computational Linguistics.

Dan Garrette, Katrin Erk, and Raymond Mooney. 2014.
A formal approach to linking logical form and
vector-space lexical semantics. In Computing mean-
ing, pages 27–48. Springer.

Alex Graves, Greg Wayne, Malcolm Reynolds,
Tim Harley, Ivo Danihelka, Agnieszka Grabska-
Barwińska, Sergio Gómez Colmenarejo, Edward
Grefenstette, Tiago Ramalho, John Agapiou, et al.

https://arxiv.org/abs/1702.08608
https://arxiv.org/abs/1702.08608
http://arxiv.org/abs/1711.04574
http://arxiv.org/abs/1711.04574


6160

2016. Hybrid computing using a neural net-
work with dynamic external memory. Nature,
538(7626):471.

Riccardo Guidotti, Anna Monreale, Salvatore Ruggieri,
Franco Turini, Fosca Giannotti, and Dino Pedreschi.
2019. A survey of methods for explaining black box
models. ACM Comput. Surv., 51(5):93:1–93:42.

M. M. Gupta and J. Qi. 1991. Theory of T-norms and
Fuzzy Inference Methods. Fuzzy Sets and Systems,
40(3):431–450.

Mikael Henaff, Jason Weston, Arthur Szlam, Antoine
Bordes, and Yann LeCun. 2016. Tracking the world
state with recurrent entity networks. arXiv preprint
arXiv:1612.03969.

Matthew Honnibal and Ines Montani. 2017. spacy 2:
Natural language understanding with bloom embed-
dings, convolutional neural networks and incremen-
tal parsing. To appear.

Kevin Jarrett, Koray Kavukcuoglu, Marc’Aurelio Ran-
zato, and Yann LeCun. 2009. What is the best multi-
stage architecture for object recognition? In ICCV,
pages 2146–2153. IEEE Computer Society.

Pascual Julián-Iranzo, Clemente Rubio-Manzano, and
Juan Gallardo-Casero. 2009. Bousi prolog: a pro-
log extension language for flexible query answer-
ing. Electron. Notes Theor. Comput. Sci., 248(Sup-
plement C):131–147.

Diederik P Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980.

Thomas N Kipf and Max Welling. 2016. Semi-
supervised classification with graph convolutional
networks. arXiv preprint arXiv:1609.02907.

Ankit Kumar, Ozan Irsoy, Peter Ondruska, Mohit Iyyer,
James Bradbury, Ishaan Gulrajani, Victor Zhong,
Romain Paulus, and Richard Socher. 2016. Ask me
anything: Dynamic memory networks for natural
language processing. In International Conference
on Machine Learning, pages 1378–1387.

Zachary C. Lipton. 2018. The mythos of model inter-
pretability. Commun. ACM, 61(10):36–43.

Dan Moldovan, Christine Clark, Sanda Harabagiu, and
Steve Maiorano. 2003. COGEX: A logic prover
for question answering. In Proceedings of the 2003
Conference of the North American Chapter of the
Association for Computational Linguistics on Hu-
man Language Technology - Volume 1, NAACL ’03,
pages 87–93, Stroudsburg, PA, USA. Association
for Computational Linguistics.

Stephen Muggleton. 1991. Inductive logic program-
ming. New generation computing, 8(4):295–318.

Stephen Muggleton and Luc De Raedt. 1994. Inductive
logic programming: Theory and methods. J. Log.
Program., 19/20:629–679.

Arvind Neelakantan, Benjamin Roth, and Andrew Mc-
Callum. 2015. Compositional vector space mod-
els for knowledge base completion. arXiv preprint
arXiv:1504.06662.

Christina Niklaus, Matthias Cetto, André Freitas, and
Siegfried Handschuh. 2018. A survey on open infor-
mation extraction. In COLING, pages 3866–3878.
Association for Computational Linguistics.

Mehmet A Orgun and Wanli Ma. 1994. An overview
of temporal and modal logic programming. In Tem-
poral logic, pages 445–479. Springer.

Matteo Pagliardini, Prakhar Gupta, and Martin Jaggi.
2017. Unsupervised learning of sentence embed-
dings using compositional n-gram features. arXiv
preprint arXiv:1703.02507.

Baolin Peng, Zhengdong Lu, Hang Li, and Kam-Fai
Wong. 2015. Towards neural network-based reason-
ing. arXiv preprint arXiv:1508.05508.

Sampo Pyysalo, Filip Ginter, Hans Moen, Tapio
Salakoski, and Sophia Ananiadou. 2013. Distribu-
tional semantics resources for biomedical text pro-
cessing.

Martin Raison, Pierre-Emmanuel Mazaré, Rajarshi
Das, and Antoine Bordes. 2018. Weaver: Deep co-
encoding of questions and documents for machine
reading. arXiv preprint arXiv:1804.10490.

Matthew Richardson and Pedro M. Domingos. 2006.
Markov logic networks. Machine Learning, 62(1-
2):107–136.

Tim Rocktäschel and Sebastian Riedel. 2017. End-to-
end differentiable proving. In Advances in Neural
Information Processing Systems, pages 3788–3800.

Tim Rocktäschel, Sameer Singh, and Sebastian Riedel.
2015. Injecting logical background knowledge into
embeddings for relation extraction. In NAACL HLT
2015, The 2015 Conference of the North American
Chapter of the Association for Computational Lin-
guistics: Human Language Technologies, Denver,
Colorado, USA, May 31 - June 5, 2015, pages 1119–
1129.

Stuart J. Russell and Peter Norvig. 2010a. Artificial
Intelligence - A Modern Approach (3. internat. ed.).
Pearson Education.

Stuart J Russell and Peter Norvig. 2010b. Artificial In-
telligence: A Modern Approach.

Stuart J Russell and Peter Norvig. 2016. Artificial in-
telligence: a modern approach. Malaysia; Pearson
Education Limited,.

Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, and
Hannaneh Hajishirzi. 2016a. Bidirectional attention
flow for machine comprehension. arXiv preprint
arXiv:1611.01603.

https://doi.org/10.1016/0743-1066(94)90035-3
https://doi.org/10.1016/0743-1066(94)90035-3


6161

Minjoon Seo, Sewon Min, Ali Farhadi, and Han-
naneh Hajishirzi. 2016b. Query-reduction net-
works for question answering. arXiv preprint
arXiv:1606.04582.

Maria I Sessa. 2002. Approximate reasoning by
similarity-based sld resolution. Theoretical com-
puter science, 275(1-2):389–426.

Sainbayar Sukhbaatar, Jason Weston, Rob Fergus, et al.
2015. End-to-end memory networks. In Advances
in neural information processing systems, pages
2440–2448.

Dirk Weissenborn, Tomas Kocisky, and Chris Dyer.
2017a. Dynamic integration of background knowl-
edge in neural nlu systems. CoRR, abs/1706.02596.

Dirk Weissenborn, Pasquale Minervini, Isabelle Au-
genstein, Johannes Welbl, Tim Rocktäschel, Matko
Bosnjak, Jeff Mitchell, Thomas Demeester, Tim
Dettmers, Pontus Stenetorp, and Sebastian Riedel.
2018. Jack the reader - A machine reading frame-
work. In Proceedings of ACL 2018, Melbourne,
Australia, July 15-20, 2018, System Demonstrations,
pages 25–30.

Dirk Weissenborn, Georg Wiese, and Laura Seiffe.
2017b. Fastqa: A simple and efficient neural archi-
tecture for question answering. arxiv preprint. arXiv
preprint arXiv:1703.04816.

Johannes Welbl, Pontus Stenetorp, and Sebastian
Riedel. 2017. Constructing datasets for multi-hop
reading comprehension across documents. arXiv
preprint arXiv:1710.06481.

David S Wishart, Craig Knox, An Chi Guo, Savita
Shrivastava, Murtaza Hassanali, Paul Stothard, Zhan
Chang, and Jennifer Woolsey. 2006. Drugbank:
a comprehensive resource for in silico drug dis-
covery and exploration. Nucleic acids research,
34(suppl_1):D668–D672.

Victor Zhong, Caiming Xiong, Nitish Shirish Keskar,
and Richard Socher. 2019. Coarse-grain fine-grain
coattention network for multi-evidence question an-
swering. arXiv preprint arXiv:1901.00603.

Appendices
A Algorithms

fun unify(x, y, θ, S)
Input:
x: function f(. . .) | atom p(. . .) |
variable | list x1 :: x2 :: . . . :: xn
y: function f ′(. . .) | atom p′(. . .) |
variable | list y1 :: y2 :: . . . :: ym
θ: current substitutions, default = {}
S: current success score, default = 1.0
Output: (Unifying substitution θ′ or

failure, Updated success score
S′)

if θ = failure then return (failure, 0)
else if S < λ then return (failure, 0)
else if x = y then return (θ, S)
else if x is Var then return

unify_var(x, y, θ, S)
else if y is Var then return

unify_var(y, x, θ, S)
else if x is f(x1, . . . , xn), y is
f ′(y1, . . . , yn), and f ∼ f ′ ≥ λ then
S′ := S ∧ f ∼ f ′
return unify(x1 :: . . . :: xn, y1 ::
. . . :: yn, θ, S

′)
end
else if x is p(x1, . . . , xn), y is
p′(y1, . . . , yn), and p ∼ p′ ≥ λ then
S′ := S ∧ f ∼ f ′
return unify(x1 :: . . . :: xn, y1 ::
. . . :: yn, θ, S

′)
end
else if x is x1 :: . . . :: xn and y is
y1 :: . . . :: yn then
(θ′, S′) := unify(x1, y1, θ, S)
return unify(x2 :: . . . :: xn, y2 ::
. . . :: yn, θ

′, S′)
end
else if x is empty list and y is empty list

then return (θ, S)
else return (failure, 0)

fun unify_var(v, o, θ, S)
if {v/val} ∈ θ then return
unify(val, o, θ, S)

else if {o/val} ∈ θ then return
unify(var, val, θ, S)

else return ({v/o}+ θ, S)
Algorithm 1: The weak unification algorithm in
NLPROLOG without occurs check

http://arxiv.org/abs/1706.02596
http://arxiv.org/abs/1706.02596

