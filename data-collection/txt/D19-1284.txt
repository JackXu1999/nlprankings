



















































A Discrete Hard EM Approach for Weakly Supervised Question Answering


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 2851–2864,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

2851

A Discrete Hard EM Approach for
Weakly Supervised Question Answering

Sewon Min1, Danqi Chen2,3, Hannaneh Hajishirzi1,4, Luke Zettlemoyer1,3
1University of Washington, Seattle, WA

2Princeton University, Princeton, NJ
3Facebook AI Research, Seattle, WA

4Allen Institute for Artificial Intelligence, Seattle, WA
{sewon,hannaneh,lsz}@cs.washington.edu danqic@cs.princeton.edu

Abstract

Many question answering (QA) tasks only
provide weak supervision for how the answer
should be computed. For example, TRIVIAQA
answers are entities that can be mentioned
multiple times in supporting documents, while
DROP answers can be computed by deriving
many different equations from numbers in the
reference text. In this paper, we show it is
possible to convert such tasks into discrete la-
tent variable learning problems with a precom-
puted, task-specific set of possible solutions
(e.g. different mentions or equations) that con-
tains one correct option. We then develop a
hard EM learning scheme that computes gradi-
ents relative to the most likely solution at each
update. Despite its simplicity, we show that
this approach significantly outperforms previ-
ous methods on six QA tasks, including abso-
lute gains of 2–10%, and achieves the state-
of-the-art on five of them. Using hard updates
instead of maximizing marginal likelihood is
key to these results as it encourages the model
to find the one correct answer, which we show
through detailed qualitative analysis.1

1 Introduction

A natural setting in many question answering
(QA) tasks is to provide weak supervision to deter-
mine how the question should be answered given
the evidence text. For example, as seen in Fig-
ure 1, TRIVIAQA answers are entities that can
be mentioned multiple times in supporting doc-
uments, while DROP answers can be computed
by deriving many different equations from num-
bers in the reference text. Such weak supervi-
sion is attractive because it is relatively easy to
gather, allowing for large datasets, but complicates
learning because there are many different spurious
ways to derive the correct answer. It is natural to

1Our code is publicly available at https://github.
com/shmsw25/qa-hard-em.

Figure 1: Examples from two different question an-
swering tasks. (Top) Multi-mention reading compre-
hension. The answer text is mentioned five times in the
given document, however, only the fourth span actually
answers the question. (Bottom) Reading comprehen-
sion with discrete reasoning. There are many poten-
tial equations which execute the answer (‘4’), but only
one of them is the correct equation (‘40-36’) and the
others are false positives.

model such ambiguities with a latent variable dur-
ing learning, but most prior work on reading com-
prehension has rather focused on the model archi-
tecture and used heuristics to map the weak sig-
nal to full supervision (e.g. by selecting the first
answer span in TRIVIAQA (Joshi et al., 2017;
Tay et al., 2018; Talmor and Berant, 2019)). Some
models are trained with maximum marginal like-
lihood (MML) (Kadlec et al., 2016; Swayamdipta
et al., 2018; Clark and Gardner, 2018; Lee et al.,
2019), but it is unclear if it gives a meaningful im-
provement over the heuristics.

In this paper, we show it is possible to formulate
a wide range of weakly supervised QA tasks as
discrete latent-variable learning problems. First,
we define a solution to be a particular derivation
of a model to predict the answer (e.g. a span in

https://github.com/shmsw25/qa-hard-em
https://github.com/shmsw25/qa-hard-em


2852

Task & Dataset # Examples |Z|Train Dev Test Avg Median

1. Multi-mention reading comprehension

TRIVIAQA (Joshi et al., 2017) 61,888 7,993 7,701 2.7 2
NARRATIVEQA (Kočiskỳ et al., 2018) 32,747 3,461 10,557 4.3 5
TRIVIAQA-OPEN (Joshi et al., 2017) 78,785 8,837 11,313 6.7 4
NATURALQUESTIONS-OPEN (Kwiatkowski et al., 2019) 79,168 8,757 3,610 1.8 1

2. Reading comprehension with discrete reasoning

DROPnum (Dua et al., 2019) 46,973 5,850 - 8.2 3

3. Semantic Parsing

WIKISQL (Zhong et al., 2017) 56,355 8,421 15,878 346.1 5

Table 1: Six QA datasets in three different categories used in this paper (detailed in Section 5) along with the size
of each dataset. An average and median of the size of precomputed solution sets (denoted by Z) are also reported.
Details on how to obtain Z are given in Section 4.

the document or an equation to compute the an-
swer). We demonstrate that for many recently in-
troduced tasks, which we group into three cate-
gories as given in Table 1, it is relatively easy to
precompute a discrete, task-specific set of possible
solutions that contains the correct solution along
with a modest number of spurious options. The
learning challenge is then to determine which so-
lution in the set is the correct one, while estimating
a complete QA model.

We model the set of possible solutions as a dis-
crete latent variable, and develop a learning strat-
egy that uses hard-EM-style parameter updates.
This algorithm repeatedly (i) predicts the most
likely solution according to the current model
from the precomputed set, and (ii) updates the
model parameters to further encourage its own
prediction. Intuitively, these hard updates more
strongly enforce our prior beliefs that there is a
single correct solution. This method can be ap-
plied to any problem that fits our weak supervi-
sion assumptions and can be used with any model
architecture.

We experiment on six different datasets (Ta-
ble 1) using strong task-specific model architec-
tures (Devlin et al., 2019; Dua et al., 2019; Hwang
et al., 2019). Our learning approach significantly
outperforms previous methods which use heuristic
supervision and MML updates, including absolute
gains of 2–10%, and achives the state-of-the-art on
five datasets. It outperforms recent state-of-the-art
reward-based semantic parsing algorithms (Liang
et al., 2018; Agarwal et al., 2019) by 13% abso-
lute percentage on WIKISQL, strongly suggesting
that having a small precomputed set of possible
solutions is a key ingredient. Finally, we present a

detailed analysis showing that, in practice, the in-
troduction of hard updates encourages models to
assign much higher probability to the correct solu-
tion.

2 Related Work

Reading Comprehension. Large-scale reading
comprehension (RC) tasks that provide full super-
vision for answer spans (Rajpurkar et al., 2016)
have seen significant progress recently (Seo et al.,
2017; Xiong et al., 2018; Yu et al., 2018a; De-
vlin et al., 2019). More recently, the commu-
nity has moved towards more challenging tasks
such as distantly supervised RC (Joshi et al.,
2017), RC with free-form human generated an-
swers (Kočiskỳ et al., 2018) and RC requiring dis-
crete or multi-hop reasoning (Dua et al., 2019;
Yang et al., 2018). These tasks introduce new
learning challenges since the gold solution that is
required to answer the question (e.g. a span or an
equation) is not given.

Nevertheless, not much work has been done for
this particular learning challenge. Most work on
RC focuses on the model architecture and sim-
ply chooses the first span or a random span from
the document (Joshi et al., 2017; Tay et al., 2018;
Talmor and Berant, 2019), rather than model-
ing this uncertainty as a latent choice. Others
maximize the sum of the likelihood of multiple
spans (Kadlec et al., 2016; Swayamdipta et al.,
2018; Clark and Gardner, 2018; Lee et al., 2019),
but it is unclear if it gives a meaningful improve-
ment. In this paper, we highlight the learning chal-
lenge and show that our learning method, inde-
pendent of the model architecture, can give a sig-
nificant gain. Specifically, we assume that one of



2853

mentions are related to the question and others are
false positives because (i) this happens for most
cases, as the first example in Table 2, and (ii) even
in the case where multiple mentions contribute to
the answer, there is often a single span which fits
the question the best.

Semantic Parsing. Latent-variable learning has
been extensively studied in the literature of seman-
tic parsing (Zettlemoyer and Collins, 2005; Clarke
et al., 2010; Liang et al., 2013; Berant et al., 2013;
Artzi and Zettlemoyer, 2013). For example, a
question and an answer pair (x, y) is given but the
logical form that is used to compute the answer is
not. Two common learning paradigms are max-
imum marginal likelihood (MML) and reward-
based methods. In MML, the objective maximizes∑

z∈Ẑ P(z|x), where Ẑ is an approximation of
a set of logical forms executing y (Liang et al.,
2013; Berant et al., 2013; Krishnamurthy et al.,
2017). In reward-based methods, a reward func-
tion is defined as a prior, and the model param-
eters are updated with respect to it (Iyyer et al.,
2017; Liang et al., 2017, 2018). Since it is compu-
tationally expensive to obtain a precomputed set
in semantic parsing, these methods typically re-
compute the set of logical forms with respect to
the beam at every parameter update. In contrast,
our learning method targets tasks that a set of so-
lutions can be precomputed, which include many
recent QA tasks such as reading comprehension,
open-domain QA and a recent SQL-based seman-
tic parsing task (Zhong et al., 2017).

3 Method

In this section, we first formally define our general
setup, which we will instantiate for specific tasks
in Section 4 and then we describe our learning ap-
proach.

3.1 Setup
Let x be the input of a QA system (e.g. a ques-
tion and a document) and y be the answer text (e.g.
‘Robert Schumann’ or ‘4’). We define a solution
as a particular derivation that a model is supposed
to produce for the answer prediction (e.g. a span
in the document or an equation to compute the an-
swer, see Table 2). Let f denote a task-specific,
deterministic function which maps a solution to
the textual form of the answer (e.g. by simply re-
turning the string associated with a particular se-
lected mention or solving an equation to get the

final number, see Table 2). Our goal is to learn a
model (with parameters θ) which takes an input x
and outputs a solution z such that f(z) = y.

In a fully supervised scenario, a true solution z̄
is given, and θ is estimated based on a collection of
(x, z̄) pairs. In this work, we focus on a weakly su-
pervised scenario in which z̄ is not given. For this
setup, we define Ztot as a finite set of all the pos-
sible solutions. In the case that the search space is
very large or infinite, we can usually approximate
Ztot with a high coverage in practice. Then, we ob-
tain Z = {z ∈ Ztot : f(z) = y} by enumerating
all z ∈ Ztot. This results a set of all the possible
solutions that lead to the correct answer. We as-
sume it contains one solution that we want to learn
to produce, and potentially many other spurious
ones. In practice, Z is defined in a task-specific
manner, as we will see in Section 4.

At inference time, the model produces a solu-
tion z̃ ∈ Ztot from an input x with respect to θ and
predicts the final answer as f(z̃). Note that we
cannot compute Z at inference time because the
groundtruth y is not given.2

3.2 Learning Method
In a fully-supervised setting where z̄ is given, we
can learn θ by optimizing the negative log likeli-
hood of z̄ given the input x with respect to θ.

JSup(θ|x, z̄) = −log P(z̄|x; θ)

In our setup, the model has access to x and Z =
{z1, z2, . . . , zn}. In this scenario, the selection of
the best solution in Z can be modeled as a latent
variable. We can compute the maximum marginal
likelihood (MML) estimate, which marginalizes
the likelihood of each zi ∈ Z given the input x
with respect to θ. Formally,

P(y|x; θ) =
∑

zi∈Ztot

P(y|zi)P(zi|x; θ)

=
∑
zi∈Z

P(zi|x; θ)

is used to compute the objective as follows:

JMML(θ|x, Z) = −log
∑
zi∈Z

P(zi|x; θ)

However, there are two major problems in the
MML objective in our settings. First, MML can be

2 This is a main difference from multi-instance learning
(MIL) (Zhou et al., 2009), since a bag of input instances is
given at inference time in MIL.



2854

maximized by assigning high probabilities to any
subset of zi ∈ Z; whereas in our problems, in-
stances in Z other than one correct z are spurious
solutions which the model should ideally assign
very low probability. Second, in MML we opti-
mize the sum over probabilities of Z during train-
ing but typically predict the maximum probability
solution during inference, creating a discrepancy
between training and testing.

We introduce a learning strategy with a hard-
EM approach. First, the model computes the like-
lihood of each zi given the input x with respect to
θ, P(zi|x; θ), and picks one of Z with the largest
likelihood:

z̃ = argmaxzi∈ZP(zi|x; θ)

Then, the model optimizes on a standard negative
log likelihood objective, assuming z̃ is a true solu-
tion. The objective can be re-written as follows:

JHard(θ|x, Z) = −log P(z̃|x; θ)
= −log maxzi∈ZP(zi|x; θ)
= −maxzi∈Z log P(zi|x; θ)
= minzi∈ZJSup(θ|x, zi)

This loss can be seen as a variant of MML, where
the sum is replaced with a max.

4 Task Setup

We apply our approach to three different types of
QA tasks: multi-mention reading comprehension,
RC with discrete reasoning and a semantic parsing
task. In this section, we describe each task in de-
tail: how we define a solution z and pre-compute
a set Z based on input x and answer y. The statis-
tics of |Z| and examples on each task are shown in
Table 1 and Table 2 respectively.

4.1 Multi-Mention Reading Comprehension

Multi-mention reading comprehension naturally
occurs in several QA tasks such as (i) distantly-
supervised reading comprehension where a ques-
tion and answer are collected first before the ev-
idence document is gathered (e.g. TRIVIAQA),
(ii) abstractive reading comprehension which re-
quires a free-form text to answer the question
(e.g. NARRATIVEQA), and (iii) open-domain QA
where only question-answer pairs are provided.

Given a question Q = [q1, . . . , ql] and a docu-
ment D = [d1, . . . , dL], where qi and dj denote

the tokens in the question and document, the out-
put y is an answer text, which is usually mentioned
multiple times in the document.

Previous work has dealt with this setting by de-
tecting spans in the document through text match-
ing (Joshi et al., 2017; Clark and Gardner, 2018).
Following previous approaches, we define a solu-
tion z as a span in the document. We obtain a set
of possible solutions Z = {z1, . . . , zn} by find-
ing exact match or similar mentions of y, where
zi = (si, ei) is a span of text with start and end
token indices si and ei. Specifically,

gmax = max
1≤si≤ei≤L

g([dsi , . . . , dei ], y)

Z = {zi = (si, ei) s.t. g(si, ei) = gmax},

where g is a string matching function. If the an-
swer is guaranteed to be a span in the documentD,
g is a binary function which returns 1 if two strings
are the same, and 0 otherwise. If the answer is
free-form text, we choose g as the ROUGE-L met-
ric (Lin, 2004).

This complicates the learning because the given
document contains many spans matching to the
text, while most of them are not related to answer-
ing the question. As an example shown in Table 2,
only the fourth span out of six is relevant to the
question.

4.2 Reading Comprehension with Discrete
Reasoning

Some reading comprehension tasks require rea-
soning in several discrete steps by finding clues
from the document and aggregating them. One
such example is mathematical reasoning, where
the model must pick numbers from a document
and compute an answer through arithmetic oper-
ations (Dua et al., 2019).

In this task, the input is also a question Q and
a document D, and the output y is given as a nu-
meric value. We define a solution z to be an exe-
cutable arithmetic equation. Since there is an in-
finite set of potential equations, we approximate
Ztot as a finite set of arithmetic equations with two
numeric values and one operation, following Dua
et al. (2019).3 Specifically,

Ztot =
{
zi = (o1, n1, o2, n2) s.t.

o1, o2 ∈ {+,−,%},
n1, n2 ∈ ND ∪NQ ∪ S

}
,

3This approximation covers 93% of the examples in the
development set.



2855

1. Multi-Mention Reading Comprehension (TRIVIAQA, NARRATIVEQA, TRIVIAQA-OPEN & NATURALQUESTIONS-OPEN)

Question: Which composer did pianist Clara Wieck marry in 1840?
Document: Robert Schumann was a German composer and influential music critic. He is widely regarded as one of the greatest composers of the Romantic
era. (...) Robert Schumann himself refers to it as “an affliction of the whole hand”. (...) Robert Schumann is mentioned in a 1991 episode of Seinfeld “The
Jacket”. (...) Clara Schumann was a German musician and composer, considered one of the most distinguished pianists of the Romantic era. Her husband was
the composer Robert Schumann . <Childhood> (...) At the age of eight, the young Clara Wieck performed at the Leipzig home of Dr. Ernst Carus. There
she met another gifted young pianist who had been invited to the musical evening, named Robert Schumann , who was nine years older. Schumann admired
Clara’ s playing so much that he asked permission from his mother to discontinue his law studies. (...) In the spring of 1853, the then unknown 20-year-old
Brahms met Joachim in Hanover, made a very favorable impression on him, and got from him a letter of introduction to Robert Schumann .
Answer (y): Robert Schumann
f : Text match
Ztot: All spans in the document
Z: Spans which match ‘Robert schumann’ (red text)

2. Reading Comprehension with Discrete Reasoning (DROPnum)

Question: How many yards longer was Rob Bironas’ longest field goal compared to John Carney’s only field goal?
Document: (...) The Chiefs tied the game with QB Brodie Croyle completing a 10 yard td pass to WR Samie Parker. Afterwards the Titans responded with
Kicker Rob Bironas managing to get a 37 yard field goal. Kansas city would take the lead prior to halftime with croyle completing a 9 yard td pass to FB
Kris Wilson. In the third quarter Tennessee would draw close as Bironas kicked a 37 yard field goal. The Chiefs answered with kicker John Carney getting
a 36 yard field goal. Afterwards the Titans would retake the lead with Young and Williams hooking up with each other again on a 41 yard td pass.
(...) Tennessee clinched the victory with Bironas nailing a 40 yard and a 25 yard field goal. With the win the Titans kept their playoff hopes alive at 8 6 .
Answer (y): 4
f : Equation executor
Ztot: Equations with two numeric values and one arithmetic operation
Z: { 41-37, 40-36, 10-6, ... }

3. SQL Generation (WIKISQL)

Question: What player played guard for Toronto in 1996-1997?
Table Header: player, year, position, ...
Answer (y): John Long
f : SQL executor
Ztot: Non-nested SQL queries with up to 3 conditions
Z: Select player where position=guard and year in toronto=1996-97
Select max(player) where position=guard and year in toronto=1996-97
Select min(player) where position=guard
Select min(player) where year in toronto=1996-97
Select min(player) where position=guard and year in toronto=1996-97

Table 2: Examples of the input, answer text (y), f , Ztot and Z. First, in multi-mention reading comprehension, the
answer text ‘Robert Schumann’ is mentioned six times but only the fourth span is related to the question. Second,
in reading comprehension with discrete reasoning, many equations yield to the answer 4, but only ‘40-37’ answers
the question. Lastly, in SQL query generation, five SQL queries lead to the answer but only the first one is the
correct query. See Section 4 for more details.

where ND and NQ are all numeric values appear-
ing in D and Q, respectively, and S are a set of
predefined special numbers. Then

Z = {zi ∈ Ztot s.t. f(zi) = y}

where f is an execution function of equations.
Figure 1 shows an example Z given a question

and a document. We can see that one equation is
correct, while the others are false positives which
coincidentally lead to the correct answer.

4.3 SQL Query Generation

To evaluate if our training strategy generalizes to
other weak supervision problems, we also study a
semantic parsing task where a question and an an-
swer are given but the logical form to execute the
answer is not. In particular, we consider a task of
answering questions about a given table by gener-
ating SQL queries.

The input is a question Q = [q1, . . . , ql] and
a table header H = [h1, . . . , hnL ], where qi is a
token, hi is a multi-token title of each column, and

nL is the number of headers. The supervision is
given as the SQL query result y, which is always a
text string.

We define a solution to be an SQL query.
Since the set of potential queries is infinite, we
approximate Ztot as a set of non-nested SQL
queries with at most three conditions.4 Specifi-
cally, given A as a set of aggregating operators
{sum,mean,max,min, count} and C as a set of
possible conditions {(h, o, t) s.t. h ∈ [1, nL], o ∈
{=, <,>}, t ∈ spans in Q}, we define Ztot:

Ztot = {zi = (zseli , z
agg
i , {z

cond
i,j }3j=1} s.t.

zseli ∈ [1, nL]
z

agg
i ∈ {none} ∪A

zcondi,j ∈ {none} ∪ C for j ∈ [1, 3]},

then,

Z = {zi ∈ Ztot s.t. f(zi) = y},
4This approximation covers 99% of the examples in the

development set.



2856

where f is an SQL executor. The third example in
Table 2 shows Z may contain many spurious SQL
querie, e.g. the third query in Z coincidentally ex-
ecutes the answer because ‘John Long’ is ranked
first among all the guards in alphabetical order.

5 Experiments

We experiment on a range of question an-
swering tasks with varied model architectures
to demonstrate the effectiveness of our ap-
proach. Built on top of strong base mod-
els, our learning method is able to achieve
state-of-the-art on NARRATIVEQA, TRIVIAQA-
OPEN, NATURALQUESTIONS-OPEN, DROPnum
and WIKISQL.

5.1 Multi-mention Reading Comprehension
We experiment on two reading comprehension
datasets and two open-domain QA datasets. For
reading comprehension, we evaluate on TRIVI-
AQA (Wikipedia) (Joshi et al., 2017) and NAR-
RATIVEQA (summary) (Kočiskỳ et al., 2018).

For open-domain QA, we follow the settings in
Lee et al. (2019) and use the QA pairs from TRIV-
IAQA-unfiltered (Joshi et al., 2017) and NAT-
URAL QUESTIONS (Kwiatkowski et al., 2019)
with short answers and discard the given evi-
dence documents. We refer to these two datasets
as TRIVIAQA-OPEN and NATURALQUESTIONS-
OPEN.5

We experiment with three learning methods as
follows.

• First Only: J(θ) = −logP(z1|x; θ), where
z1 appears first in the given document among
all zi ∈ Z.
• MML: J(θ) = −logΣni=1P(zi|x; θ).
• Ours: J(θ) = −logmax1≤i≤nP(zi|x; θ).

P(zi|Q,D) can be obtained by any model
which outputs the start and end positions of the
input document. In this work, we use a modified
version of BERT (Devlin et al., 2019) for multi-
paragraph reading comprehension (Min et al.,
2019).

Training details. We use uncased version of
BERTbase. For all datasets, we split documents
into a set of segments up to 300 tokens because
BERT limits the size of the input. We use batch

5Datasets and their split can be downloaded from
https://bit.ly/2HK1Fqn.

size of 20 for two reading comprehension tasks
and 192 for two open-domain QA tasks. Fol-
lowing Clark and Gardner (2018), we filter a
subset of segments in TRIVIAQA through TF-
IDF similarity between a segment and a ques-
tion to maintain a reasonable length. For open-
domain QA tasks, we retrieve 50 Wikipedia arti-
cles through TF-IDF (Chen et al., 2017) and fur-
ther run BM25 (Robertson et al., 2009) to retrieve
20 (for train) or 80 (for development and test)
paragraphs. We try 10, 20, 40 and 80 paragraphs
on the development set to choose the number of
paragraphs to use on the test set.

To avoid local optima, we perform annealing: at
training step t, the model optimizes on MML ob-
jective with a probability of min(t/τ , 1) and oth-
erwise use our objective, where τ is a hyperparam-
eter. We observe that the performance is improved
by annealing while not being overly sensitive to
the hyperparameter τ . We include full hyperpa-
rameters and detailed ablations in Appendix B.

Results. Table 3 compares the results of base-
lines, our method and the state-of-the-art on four
datasets.6 First of all, we observe that First-
Only is a strong baseline across all the datasets.
We hypothesize that this is due to the bias in
the dataset that answers are likely to appear ear-
lier in the paragraph. Second, while MML
achieves comparable result to the First-Only base-
line, our learning method outperforms others by
2+ F1/ROUGE-L/EM consistently on all datasets.
Lastly, our method achieves the new state-of-
the-art on NARRATIVEQA, TRIVIAQA-OPEN and
NATURALQUESTIONS-OPEN, and is comparable
to the state-of-the-art on TRIVIAQA, despite our
aggressive truncation of documents.

5.2 Reading Comprehension with Discrete
Reasoning

We experiment on a subset of DROP (Dua et al.,
2019) with numeric answers (67% of the entire
dataset) focusing on mathematical reasoning. We
refer to this subset as DROPnum. The current
state-of-the-art model is an augmented version of
QANET (Yu et al., 2018a) which selects two nu-
meric values from the document or the question
and performs addition or subtraction to get the an-
swer. The equation to derive the answer is not

6For NARRATIVEQA, we compare with models trained
on NARRATIVEQA only. For open-domain QA, we only
compare with models using pipeline approach.

https://bit.ly/2HK1Fqn


2857

TRIVIAQA NARRATIVEQA TRIVIAQA NATURALQ DROPnum DROPnum-OPEN -OPEN w/ BERT w/ QANet
(F1) (ROUGE-L) (EM) (EM) (EM) (EM)

dev test dev test dev test dev test dev dev

First Only 64.4 64.9 55.3 57.4 48.6 48.1 23.6 23.6 42.9 36.1
MML 64.8 65.5 55.8 56.1 47.0 47.4 26.6 25.8 39.7 43.8
Ours 66.9 67.1 58.1 58.8 50.7 50.9 28.8 28.1 52.8 45.0

SOTA - 71.4 - 54.7 47.2 47.1 24.8 26.5 43.8

Table 3: Results on multi-mention reading comprehension & discrete reasoning tasks. We report performance
on five datasets with different base models. Note that we are not able to obtain the test result on the subset
DROPnum. Previous state-of-the-art are from Wang et al. (2018), Nishida et al. (2019), Lee et al. (2019), Lee et al.
(2019) and Dua et al. (2019), respectively. Our training method consistently outperforms the First-Only and MML
by a large margin in all the scenarios.

Model Accuracy
dev test

Weakly-supervised setting

REINFORCE (Williams, 1992) < 10
Iterative ML (Liang et al., 2017) 70.1
Hard EM (Liang et al., 2018) 70.2
Beam-based MML (Liang et al., 2018) 70.7
MAPO (Liang et al., 2018) 71.8 72.4
MAPOX (Agarwal et al., 2019) 74.5 74.2
MAPOX+MeRL (Agarwal et al., 2019) 74.9 74.8
MML 70.6 70.5
Ours 84.4 83.9

Fully-supervised setting

SQLNet (Xu et al., 2018) 69.8 68.0
TypeSQL (Yu et al., 2018b) 74.5 73.5
Coarse2Fine (Dong and Lapata, 2018) 79.0 78.5
SQLova (Hwang et al., 2019) 87.2 86.2
X-SQL (He et al., 2019) 89.5 88.7

Table 4: Results on WIKISQL. We compare accuracy
with weakly-supervised or fully-supervised settings.
Our method outperforms previous weakly-supervised
methods and most of published fully-supervised meth-
ods.

given and Dua et al. (2019) adopted the MML ob-
jective.
P(zi|Q,D) can take as any model which gen-

erates equations based on the question and doc-
ument. Inspired by Dua et al. (2019), we take a
sequence tagging approach on top of two compet-
itive models: (i) augmented QANET, the same
model as Dua et al. (2019) but only supporting
addition, subtraction and counting, and (ii) aug-
mented BERT, which supports addition, subtrac-
tion and percentiles.7

Training details. We truncate the document to
be up to 400 words. We use the batch size of 14
and 10 for QANET and BERT, respectively.

7As we use a different set of operations for the two mod-
els, they are not directly comparable. Details of the model
architecture are shown in Appendix A.

Results. Table 3 shows the results on DROPnum.
Our training strategy outperforms the First-Only
baseline and MML by a large margin, consistently
across two base models. In particular, with BERT,
we achieve an absolute gain of 10%.

5.3 SQL Query Generation

Finally, we experiment on the weakly-supervised
setting of WIKISQL (Zhong et al., 2017), in
which only the question & answer pair is used and
the SQL query (z) is treated as a latent variable.

P(zi|Q,H) can be computed by any query gen-
eration or semantic parsing models. We choose
SQLova (Hwang et al., 2019), a competitive model
on WIKISQL (designed for fully supervised set-
ting), as our base model. We modify the model to
incorporate either the MML objective or our hard-
EM learning approach for the weakly-supervised
setting.

We compare with both traditional and recently-
developed reward-based algorithms for weak su-
pervision, including beam-based MML (MML
which keeps a beam during training), conventional
hard EM8, REINFORCE (Williams, 1992), itera-
tive ML (Liang et al., 2017; Abolafia et al., 2018)
and a family of MAPO (Memory-augmented pol-
icy optimization) (Liang et al., 2018; Agarwal
et al., 2019). For a fair comparison, we only con-
sider single models without execution-guided de-
coding.

Training details. We adopt the same set of hy-
perparameters as in Hwang et al. (2019), except
that we change the batch size to 10 and truncate
the input to be up to 180 words for memory effi-
ciency.

8This method differs from ours in that it does not have a
precomputed set, and uses a beam of candidate predictions to
execute for each update.



2858

0

10

20

30

40

0
20
40
60
80

100

0 1 2 3 4 5 6 7 8 9 10+

%
 o

f d
at

a

A
cc

ur
ac

y

|Z|

% of data Ours MML

(a) DROPnum

0

10

20

30

40

0
20
40
60
80

100

0 2 4 6 8 10 12 14 16 18 20+

%
 o

f d
at

a

A
cc

ur
ac

y

|Z|

% of data Ours MML

(b) WikiSQL

Figure 2: Varying the size of solution set (|Z|) at test time. We compare the model trained on MML objec-
tive (blue) and our training strategy (orange). Our approach consistently outperforms MML on DROPnum and
WIKISQL, especially when |Z| is large.

Group Avg |Z| Median |Z| # train

3 3.0 3 10k
10 10.2 9 10k
30 30.0 22 10k
100 100.6 42 10k
300 300.0 66 10k

0

20

40

60

80

3 10 30 100 300

A
cc

ur
ac

y

Subset groups of the train set

Ours MML

Figure 3: Varying the size of solution set (|Z|) at training. (Left) Subsets of the train set on WIKISQL varying
in the size of solution set (|Z|). All subsets contain 10k training examples (total in the original train set is 55k).
All subsets are evaluated on the same, original development set for a fair comparison. (Right) Performance across
subsets of the training set with varying |Z|. Our method achieves substantial gains over MML.

Results. Table 4 shows that our training
method significantly outperforms all the weakly-
supervised learning algorithms, including 10%
gain over the previous state of the art. These
results indicate that precomputing a solution set
and training a model through hard updates play
a significant role to the performance. Given that
our method does not require SQL executions
at training time (unlike MAPO), it provides a
simpler, more effective and time-efficient strategy.
Comparing to previous models with full supervi-
sion, our results are still on par and outperform
most of the published results.

6 Analysis

In this section, we will conduct thorough analy-
ses and ablation studies, to better understand how
our model learns to find a solution from a precom-
puted set of possible solutions. We also provide
more examples and analyses in Appendix C.

Varying the size of solution set at inference
time. Figure 2 shows a breakdown of the model
accuracy with respect to the size of a solution set
(|Z|) at test time. We observe that the model
with our training method outperforms the model

with MML objective consistently across different
values of |Z|. The gap between MML and our
method is marginal when |Z| = 0 or 1, and grad-
ually increases as |Z| grows.

Varying the size of solution set at training. To
see how our learning method works with respect
to the size of a solution set (|Z|) of the training
data, particularly with large |Z|, we take 5 sub-
sets of the training set on WIKISQL with |Z| =
3, 10, 30, 100, 300. We train a model with those
subsets and evaluate it on the original develop-
ment set, both with our training method and MML
objective. Figure 3 shows statistics of each sub-
set and results. We observe that (i) our learning
method outperforms MML consistently over dif-
ferent values of |Z|, and (ii) the gain is particularly
large when |Z| > 3.

Model predictions over training. We analyze
the top 1 prediction and the likelihood of z ∈ Z
assigned by the model on DROPnum with differ-
ent number of training iterations (steps from 1k to
32k). Table 5 shows one example on DROPnum
with the answer text ‘4’, along with the model’s
top 1 prediction and a subset ofZ. We observe that



2859

Q: How many yards longer was Rob Bironas’ longest field goal compared
to John Carney’s only field goal? (Answer: 4)
P: ... The Titans responded with Kicker Rob Bironas managing to get a 37
yard field goal. ...Tennessee would draw close as Bironas kicked a 37 yard
field goal. The Chiefs answered with kicker John Carney getting a 36 yard
field goal. The Titans would retake the lead with Young and Williams hook-
ing up with each other again on a 41 yard td pass. ...Tennessee clinched the
victory with Bironas nailing a 40 yard and a 25 yard field goal.

t Pred Z (ordered by P(z|x; θt))
1k 10-9 10-6 41-37 40-36 41-37‡

2k 37-36 40-36 41-37 41-37‡ 10-6
4k 40-36 40-36 41-37‡ 41-37 10-6
8k 40-36 40-36 41-37‡ 41-37 10-6
16k 37-36 40-36 41-37 41-37‡ 10-6
32k 40-36 40-36 41-37 41-37‡ 10-6

Table 5: An example from DROPnum (same as Figure 1 and Table 2), with its answer text ‘4’ and a subset of
the solution set (Z), containing two of ‘41-38’ (which ‘41’ come from different mentions; one denoted by ‡ for
distinction), ‘40-36’ and ‘10-4’. For each training step t, the top 1 prediction and Z ordered by P (z|x; θt), a
probability of z ∈ Z with respect to the model at t through training procedure are shown. Note that at inference
time Z is not given, so top 1 prediction is not necessarily an element of Z.

the model first begins by assigning a small, uni-
form probability distribution to Z, but gradually
learns to favor the true solution. The model some-
times gives the wrong prediction—for example,
at t = 16k, and changes its prediction from the
true solution to the wrong solution, ‘37-36’—but
again changes its prediction to be a true solution
afterward. In addition, its intermediate wrong so-
lution, ‘37-36’ indicates the model was confused
with distinguishing the longest field goal of Rob
Bironas (40 vs. 37), which is an understandable
mistake.

We also compare the predictions from the
model with our method to those from the model
with MML, which is shown in Appendix C.

Quality of the predicted solution. We ana-
lyze if the model outputs the correct solution,
since the solution executing the correct answer
could be spurious. First, on NARRATIVEQA and
DROPnum, we manually analyze 50 samples from
the development set and find that 98% and 92%
of correct cases produce the correct solution re-
spectively. Next, on WIKISQL, we compare the
predictions from the model to the annotated SQL
queries on the development set. This is possi-
ble because gold SQL queries are available in the
dataset for the full supervision. Out of 8,421 ex-
amples, 7,110 predictions execute the correct an-
swers. Among those, 88.5% of the predictions are
exactly same as the annotated queries. Others are
the cases where (i) both queries are correct, (ii) the
model prediction is correct but the annotated query
is incorrect, and (iii) the annotated query is correct
and the model prediction is spurious. We show a
full analysis in Appendix C.

Robustness to the noise in |Z|. Sometimes
noise arises during the construction of |Z|, such as
|Z| constructed based on ROUGE-L for NARRA-
TIVEQA. To explore the effect of noise in Z, we

experiment with more noisy solution set by pick-
ing all the spans with scores that is equal to or
larger than the 5th highest. The new construction
method increases |Z| from 4.3 to 7.1 on NARRA-
TIVEQA. The result by MML objective drops sig-
nificantly (56.07→ 51.14) while the result by ours
drops marginally (58.77→ 57.97), suggesting that
MML suffers more with a noisier Z while ours is
more robust.

7 Conclusion

In this paper, we demonstrated that, for many QA
tasks which only provide the answer text as su-
pervision, it is possible to precompute a discrete
set of possible solutions that contains one correct
option. Then, we introduced a discrete latent vari-
able learning algorithm which iterates a procedure
of predicting the most likely solution in the pre-
computed set and further increasing the likelihood
of that solution. We showed that this approach sig-
nificantly outperforms previous approaches on six
QA tasks including reading comprehension, open-
domain QA, discrete reasoning task and seman-
tic parsing, achieving absolute gains of 2–10%
and setting the new state-of-the-art on five well-
studied datasets.

Acknowledgements

This research was supported by ONR (N00014-
18-1-2826, N00014-17-S-B001), DARPA
N66001-19-2-403, NSF (IIS-1616112, IIS-
1252835, IIS-1562364), ARO (W911NF-16-1-
0121), an Allen Distinguished Investigator Award,
Samsung GRO and gifts from Allen Institute for
AI, Google and Amazon.

The authors would like to thank the anonymous
reviewers, Eunsol Choi, Christopher Clark, Victor
Zhong and UW NLP members for their valuable
feedback.



2860

References
Daniel A Abolafia, Mohammad Norouzi, Jonathan

Shen, Rui Zhao, and Quoc V Le. 2018. Neural pro-
gram synthesis with priority queue training. arXiv
preprint arXiv:1801.03526.

Rishabh Agarwal, Chen Liang, Dale Schuurmans, and
Mohammad Norouzi. 2019. Learning to generalize
from sparse and underspecified rewards. In ICML.

Chris Alberti, Kenton Lee, and Michael Collins. 2019.
A BERT baseline for the Natural Questions. arXiv
preprint arXiv:1901.08634.

Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-
pervised learning of semantic parsers for mapping
instructions to actions. In ACL.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on Freebase from
question-answer pairs. In EMNLP.

Danqi Chen, Adam Fisch, Jason Weston, and Antoine
Bordes. 2017. Reading Wikipedia to answer open-
domain questions. In ACL.

Christopher Clark and Matt Gardner. 2018. Simple
and effective multi-paragraph reading comprehen-
sion. In ACL.

James Clarke, Dan Goldwasser, Ming-Wei Chang, and
Dan Roth. 2010. Driving semantic parsing from the
world’s response. In CoNLL.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and
Kristina Toutanova. 2019. BERT: Pre-training of
deep bidirectional transformers for language under-
standing. In NAACL.

Li Dong and Mirella Lapata. 2018. Coarse-to-fine de-
coding for neural semantic parsing. In ACL.

Dheeru Dua, Yizhong Wang, Pradeep Dasigi, Gabriel
Stanovsky, Sameer Singh, and Matt Gardner. 2019.
DROP: A reading comprehension benchmark re-
quiring discrete reasoning over paragraphs. In
NAACL.

Pengcheng He, Yi Mao, Kaushik Chakrabarti, and
Weizhu Chen. 2019. X-SQL: reinforce schema
representation with context. arXiv preprint
arXiv:1908.08113.

Niall Hurley and Scott Rickard. 2009. Comparing
measures of sparsity. IEEE Transactions on Infor-
mation Theory.

Wonseok Hwang, Jinyeung Yim, Seunghyun Park, and
Minjoon Seo. 2019. A comprehensive exploration
on WikiSQL with table-aware word contextualiza-
tion. arXiv preprint arXiv:1902.01069.

Mohit Iyyer, Wen-tau Yih, and Ming-Wei Chang. 2017.
Search-based neural structured learning for sequen-
tial question answering. In ACL.

Mandar Joshi, Eunsol Choi, Daniel S Weld, and Luke
Zettlemoyer. 2017. TriviaQA: A large scale dis-
tantly supervised challenge dataset for reading com-
prehension. In ACL.

Rudolf Kadlec, Martin Schmid, Ondrej Bajgar, and Jan
Kleindienst. 2016. Text understanding with the at-
tention sum reader network. In ACL.

Tomáš Kočiskỳ, Jonathan Schwarz, Phil Blunsom,
Chris Dyer, Karl Moritz Hermann, Gábor Melis, and
Edward Grefenstette. 2018. The NarrativeQA read-
ing comprehension challenge. TACL.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gard-
ner. 2017. Neural semantic parsing with type con-
straints for semi-structured tables. In EMNLP.

Tom Kwiatkowski, Jennimaria Palomaki, Olivia Red-
field, Michael Collins, Ankur Parikh, Chris Al-
berti, Danielle Epstein, Illia Polosukhin, Jacob De-
vlin, Kenton Lee, Kristina Toutanova, Llion Jones,
Matthew Kelcey, Ming-Wei Change, Andrew M.
Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov.
2019. Natural questions: a benchmark for question
answering research. TACL.

Kenton Lee, Ming-Wei Chang, and Kristina Toutanova.
2019. Latent retrieval for weakly supervised open
domain question answering. In ACL.

Chen Liang, Jonathan Berant, Quoc Le, Kenneth D
Forbus, and Ni Lao. 2017. Neural symbolic ma-
chines: Learning semantic parsers on Freebase with
weak supervision. In ACL.

Chen Liang, Mohammad Norouzi, Jonathan Berant,
Quoc V Le, and Ni Lao. 2018. Memory augmented
policy optimization for program synthesis and se-
mantic parsing. In NIPS.

Percy Liang, Michael I Jordan, and Dan Klein. 2013.
Learning dependency-based compositional seman-
tics. Computational Linguistics, 39(2):389–446.

Chin-Yew Lin. 2004. ROUGE: A package for auto-
matic evaluation of summaries. Text Summarization
Branches Out.

Sewon Min, Eric Wallace, Sameer Singh, Matt Gard-
ner, Hannaneh Hajishirzi, and Luke Zettlemoyer.
2019. Compositional questions do not necessitate
multi-hop reasoning. In ACL.

Kyosuke Nishida, Itsumi Saito, Kosuke Nishida, Kazu-
toshi Shinoda, Atsushi Otsuka, Hisako Asano, and
Junji Tomita. 2019. Multi-style generative reading
comprehension. In ACL.

Adam Paszke, Sam Gross, Soumith Chintala, Gre-
gory Chanan, Edward Yang, Zachary DeVito, Zem-
ing Lin, Alban Desmaison, Luca Antiga, and Adam
Lerer. 2017. Automatic differentiation in PyTorch.

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and
Percy Liang. 2016. SQuAD: 100,000+ questions for
machine comprehension of text. In EMNLP.



2861

Stephen Robertson, Hugo Zaragoza, et al. 2009. The
probabilistic relevance framework: BM25 and be-
yond. Foundations and Trends R© in Information Re-
trieval.

Minjoon Seo, Aniruddha Kembhavi, Ali Farhadi, and
Hannaneh Hajishirzi. 2017. Bidirectional attention
flow for machine comprehension. In ICLR.

Swabha Swayamdipta, Ankur P Parikh, and Tom
Kwiatkowski. 2018. Multi-mention learning for
reading comprehension with neural cascades. In
ICLR.

Alon Talmor and Jonathan Berant. 2019. MultiQA: An
empirical investigation of generalization and trans-
fer in reading comprehension. In ACL.

Yi Tay, Anh Tuan Luu, Siu Cheung Hui, and Jian Su.
2018. Densely connected attention propagation for
reading comprehension. In NIPS.

Wei Wang, Ming Yan, and Chen Wu. 2018. Multi-
granularity hierarchical attention fusion networks
for reading comprehension and question answering.
In ACL.

Ronald J Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine learning, 8(3-4):229–256.

Caiming Xiong, Victor Zhong, and Richard Socher.
2018. DCN+: Mixed objective and deep residual
coattention for question answering. In ICLR.

Xiaojun Xu, Chang Liu, and Dawn Song. 2018. SQL-
Net: Generating structured queries from natural lan-
guage without reinforcement learning. In ICLR.

Zhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Ben-
gio, William W Cohen, Ruslan Salakhutdinov, and
Christopher D Manning. 2018. HotpotQA: A
dataset for diverse, explainable multi-hop question
answering. In EMNLP.

Adams Wei Yu, David Dohan, Quoc Le, Thang Luong,
Rui Zhao, and Kai Chen. 2018a. Fast and accurate
reading comprehension by combining self-attention
and convolution. In ICLR.

Tao Yu, Zifan Li, Zilin Zhang, Rui Zhang, and
Dragomir Radev. 2018b. TypeSQL: Knowledge-
based type-aware neural text-to-sql generation. In
NAACL.

Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In UAI.

Victor Zhong, Caiming Xiong, and Richard Socher.
2017. Seq2SQL: Generating structured queries
from natural language using reinforcement learning.
arXiv preprint arXiv:1709.00103.

Zhi-Hua Zhou, Yu-Yin Sun, and Yu-Feng Li. 2009.
Multi-instance learning by treating instances as non-
i.i.d. samples. In ICML.



2862

A Model details

We describe the detailed model architecture used
as a base model. In other words, we describe how
we obtain P(z|x; θ).

The following paragraphs describe (i) BERT
extractive model used for multi-mention RC (Sec-
tion 5.1) and (ii) BERT sequence tagging model
for discrete reasoning task (Section 5.2), respec-
tively. For QANET for discrete reasoning and the
model for SQL generation (Section 5.3), we use
the open-sourced code of the original implementa-
tion9 of Dua et al. (2019) and Hwang et al. (2019)
and do not make any modification except the ob-
jective function, so we refer to original papers.

All implementations are done in Py-
torch (Paszke et al., 2017). For BERT, we
modify the open-sourced implementation in
PyTorch10 and use the uncased version of
BERTbase.

Extractive QA model for multi-mention RC
The model architecture is closed to that of Min
et al. (2019) and Alberti et al. (2019), where the
model operates independently on each paragraph,
and selects the best matching paragraph and its as-
sociated answer span.

The input is a question Q and a set of para-
graphs {P1, . . . , PN}, and the desired output is a
span from one of paragraphs. Since our goal is to
compute a probability of a specific span, z, let’s
say z is s-th through e-th word in k-th paragraph.

The model receives a question Q and a single
paragraph Pi in parallel. Then, Si = Q : [SEP] :
P , a list of m + ni + 1 words, where : indicates
a concatenation, [SEP] is a special token, m is the
length of Q, and ni is the length of Pi. This Si is
fed into BERT:

S̄i = BERT(S) ∈ Rh×(m+ni+1)

where h is the hidden dimension of BERT. Then,

pi,start = Softmax
(
S̄Ti W1

)
∈ Rm+ni+1

pi,end = Softmax
(
S̄Ti W2

)
∈ Rm+ni+1

where W1,W2 ∈ Rh are learnable vectors.
9https://github.com/allenai/allennlp/

blob/master/allennlp/models/reading_
comprehension/naqanet.py and https:
//github.com/naver/sqlova

10https://github.com/huggingface/
pytorch-pretrained-BERT

Finally, the probability of z, s-th through e-th
word in i-th paragraph, is obtained by:

P(z|Q,Pi) = psi,start × pei,end

where pd denotes d-th element of the vector p.
Separately, a paragraph selector is trained

through pi,exit = Softmax
(
W3maxpool(S̄i)

)
∈

R2 where W3 ∈ Rh×2 is learnable vector. At in-
ference time, k = argmaxip

1
i,exit is computed and

P(z|Q,Pk) is only considered to output a span.

Sequence Tagging model for discrete reasoning
The basic idea of the model is closed to that of Dua
et al. (2019). The input is a question Q and a
paragraph P . Our goal is to compute a proba-
bility of an equation, z = (o1, n1, o2, n2), where
o1, o2 ∈ {+,−, ∗0.01} and n1, n2 ∈ NP∪NQ∪S,
NP and NQ are all numeric values appearing in P
and Q, and S are a set of predefined special num-
bers.11.

First, BERT encodings of the question and the
paragraph is obtained via

S̄ = BERT(Q : [SEP] : P ) ∈ Rh×(m+n+1)

where : indicates a concatenation, [SEP] is a spe-
cial token, m is the length of Q, n is the length of
P , and h is the hidden dimension of BERT. Then,

pinput = Softmax
(
S̄TW1

)
∈ R(m+n+1)×4

pspecial = Softmax
(
maxpool(S̄)W2

)
∈ R|S|×4

where W1 ∈ Rh×4 and W2 ∈ Rh×|S|×4 are learn-
able matrices. Then,

P(z|x) = Πm+n+1i=1 p
g(i)
inputΠ

|S|
j=1p

h(j)
special

where

g(i) =


α(o1) if [Q : [SEP] : P ]i = n1
α(o2) if [Q : [SEP] : P ]i = n2
0 o.w.

h(j) =


α(o1) if Sj = n1
α(o2) if Sj = n2
0 o.w.

α(o) =


1 if o = ‘+’
2 if o = ‘-’
3 if o = ‘*0.01’

Here, subscript i of the vector or the sequence in-
dicate i-th dimension of the vector or i-th element
of the sequence, respectively.

11S = {1, 2, 3, 4, 5, 7, 10, 12, 100, 1000}

https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/naqanet.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/naqanet.py
https://github.com/allenai/allennlp/blob/master/allennlp/models/reading_comprehension/naqanet.py
https://github.com/naver/sqlova
https://github.com/naver/sqlova
https://github.com/huggingface/pytorch-pretrained-BERT
https://github.com/huggingface/pytorch-pretrained-BERT


2863

τ TRIVIAQA F1

None 55.83
20k 58.05
30k 57.99
40k 56.66

τ DROPnum EM

None 52.31
5k 51.98
10k 52.82
20k 51.74

Dataset batch size τ

TRIVIAQA 20 15K
NARRATIVEQA 20 20K
TRIVIAQA-OPEN 192 4K
NATURALQUESTIONS-OPEN 192 8K
DROPnum with BERT 14 10K
DROPnum with QANET 14 None
WIKISQL 10 None

Table 6: (Left) Ablations with varying values of τ on TRIVIAQA. (Middle) Ablations with varying values of τ on
DROPnum with BERT. (Right) Final τ chosen for the main results on each dataset. Note that for DROPnum with
QANET and WIKISQL, we just report the number without annealing.

B Annealing

To prevent the model to be optimized on early
decision of the model, we perform annealing: at
training step t, the model optimizes on MML ob-
jective with a probability of min(t/τ , 1) and oth-
erwise use our objective, where τ is a hyperpa-
rameter. We observe that the performance is im-
proved by annealing while not being sensitive to
the hyperparameter τ . Ablations and chosen τ for
each dataset are shown in Table 6. Note that for
DROPnum with QANET and WIKISQL, we do
not ablate with varying τ and just report the num-
ber without annealing.

C Examples

To see if the prediction from the model is the cor-
rect solution to derive the answer, we analyze out-
puts from the model.

TRIVIAQA. Table 7 shows one example from
TRIVIAQA where the answer text (Montgomery)
is mentioned in the paragraph multiple times. Pre-
dictions from the model with our training method
and that with MML objective are shown in the red
text and the blue text, respectively. The span pre-
dicted by the model with our method actually an-
swers to the question, while other spans with the
answer text is not related to the question.

DROPnum. Table 8 shows predictions from the
model with our method and that with MML ob-
jective over training procedure. We observe that
the model with our method learns to assign a high
probability to the best solution (‘34-24’), while the
model with MML objective fails to do so. An-
other notable observation is that the model with
our method assign sparse distribution of likelihood
over Z, compared to the model with MML objec-

tive. We quantitatively define sparsity as

|{z ∈ Z s.t. P(z|x; θ) < �}|
|Z|

(Hurley and Rickard, 2009) and show that the
model with our method gives higher sparsity than
the model with MML (59 vs. 36 with � = 10−3,
54 vs. 17 with � = 10−4 on DROP).

WIKISQL. WIKISQL provides the annotated
SQL queries, makes it easy to compare the predic-
tions from the model to the annotated queries. Out
of 8421 examples from the development set, 7110
predictions execute the correct answers. Among
those, 6296 predictions are exactly same as the
annotated queries. For cases where the predic-
tions execute the correct answers but are not ex-
actly same as the groundtruth queries, we show
four examples in Table 9. In the first example,
both the annotated query and the prediction are
correct, because the selected column does not mat-
ter for counting. Similarly in the second exam-
ple, both queries are correct because Capital
(exonym) and Capital (endonym) both
indicate the capital city. In the third example,
the prediction makes more sense than the anno-
tated query because the question does not imply
anything about min. In the last example, the an-
notated query makes more sense than the predic-
tion because the prediction misses Ship Type
= battleship. We conjecture that the model
might learn to ignore some information in the
question if the table header implies the table is spe-
cific about that information, hence does not need
to condition on that information.



2864

Question & Document
Q: What is the state capital of Alabama? (Groundtruth: Montgomery)
D: Alabama is nicknamed the Yellowhammer State, after the state bird. Alabama is also known as the “Heart of Dixie” and
the “Cotton State”. The state tree is the longleaf pine, and the state flower is the camellia. Alabama’s capital is Montgomery.
(...) From 1826 to 1846, Tuscaloosa served as Alabama’s capital. On January 30, 1846, the Alabama legislature announced
it had voted to move the capital city from Tuscaloosa to Montgomery. The first legislative session in the new capital met in
December 1847. A new capitol building was erected under the direction of Stephen Decatur Button of Philadelphia. The first
structure burned down in 1849, but was rebuilt on the same site in 1851. This second capitol building in Montgomery remains
to the present day.

Table 7: An example from TRIVIAQA with multiple spans of the answer text (underlined). The model trained with
self-training technique outputs the correct answer (red) and the model trained on MML objective does not (blue).

Question & Passage
Q: How many sports are not olympic sports but are featured in the asian games ? (A: 10)
P: The first 30 sports were announced by the singapore national olympic council on 10 december 2013 on the sidelines of
the 27th sea games in myanmar. It announced then that there was room for as many as eight more sports. On 29 april 2014
the final six sports namely boxing equestrian floorball petanque rowing and volleyball were added to the programme.
Floorball will feature in the event for the first time after being a demonstration sport in the 2013 edition. In its selection of
events the organising committee indicated their desire to set a model for subsequent games in trimming the number of ‘trad-
itional’ sports to refocus on the seag’ s initial intent to increase the level of sporting excellence in key sports. Hence despite
room for up to eight traditional sports only two floorball and netball were included in the programme. Amongst the other 34
sports 24 are olympic sports and all remaining sports are featured in the asian games.

Ours
t Pred Z (ordered by P(z|x; θt))
1k 10+two eight+two eight+two‡ 34-24 10
2k 30-24 34-24 eight+two eight+two‡ 10
4k 34+24 34-24 eight+two eight+two‡ 10
8k 34+24 34-24 eight+two 10 eight+two‡

16k 34-24 34-24 eight+two eight+two‡ 10
32k 34-24 34-24 eight+two eight+two‡ 10

MML
t Pred Z (ordered by P(z|x; θt))
1K 10+two eight+two eight+two‡ 10 34-24
2k eight+two eight+two eight+two‡ 34-24 10
4k 24+5 eight+two eight+two‡ 34-24 10
8k 24+5 eight+two eight+two‡ 34-24 10
16k 34-24 34-24 eight+two eight+two‡ 10
32k 24+5 34-24 eight+two eight+two‡ 10

Table 8: An example from DROPnum, with its answer text ‘10’ and a subset of Z, containing ‘10’, two of
‘eight+two’ (which ‘eight’ come from different mentions; one denoted by ‘‡’ for distinction) and ‘34-24’. The
below tables are predictions from the model with our training strategy (left) and MML (right). For each training
step t, the top 1 prediction and Z ordered by P (z|x; θt), a probability of z ∈ Z with respect to the model at t are
shown. Note that at inference time Z cannot be obtained, so top 1 prediction is not necessarily in Z.

Q How many times was the # of total votes 2582322?
H Election, # of candidates nominated, # of seats won, # of total votes, % of popular vote
A Select count(# of seats won) where # of total votes = 2582322
P Select count(Election) where # of total votes = 2582322

Q What official or native languages are spoken in the country whose capital city is Canberra?
H Country (exonym), Capital (exonym), Country (endonym) Capital (endonym), Official or native language
A Select Official or native languages where Capital (exonym) = Canberra
P Select Official or native languages where Capital (endonym) = Canberra

Q What is the episode number that has production code 8abx15?
H No. in set, No. in series, Title, Directed by, Written by, Original air date, Production code
A Select min(No.in series) where Production code = 8ABX15
P Select No.in series where Production code = 8abx15

Q what is the name of the battleship with the battle listed on May 13, 1915?
H Estimate, Name, Nat., Ship Type, Principal victims, Date
A Select Name where Ship Type = battleship and Date = may 13, 1915
P Select Name where Date = may 13, 1915

Table 9: Four examples from WIKISQL where the prediction from the model is different from annotated SQL
query, although the executed answers are the same. Q, H, A and P indicate the given question, the given table
header, annotated SQL query and predicted SQL query. First two example shows the case where both queries are
correct. Next example shows the case that the model prediction makes more sense than the annotated query. The
last example shows the cases that the annotated query makes more sense than the model prediction.


