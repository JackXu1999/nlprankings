








































Learnability and Overgeneration in Computational Syntax

Yiding Hao
Department of Linguistics

Department of Computer Science
Yale University

yiding.hao@yale.edu

Abstract

This paper addresses the hypothesis that un-
natural patterns generated by grammar for-
malisms can be eliminated on the grounds that
they are unlearnable. I consider three ex-
amples of formal languages thought to rep-
resent dependencies unattested in natural lan-
guage syntax, and show that all three can be
learned by grammar induction algorithms fol-
lowing the Distributional Learning paradigm
of Clark and Eyraud (2007). While learnable
language classes are restrictive by necessity
(Gold, 1967), these facts suggest that learn-
ability alone may be insufficient for addressing
concerns of overgeneration in syntax.

1 Introduction

A longstanding debate in linguistics concerns the
division of labor in language acquisition between
innate universal assumptions about natural lan-
guage and the learner’s ability to recognize pat-
terns in data. The rationalist position, famously
championed by the Principles and Parameters
framework, follows the Poverty of the Stimulus ar-
gument (POS, Chomsky, 1965, 1968, 1971, 1980)
in assuming a rich Universal Grammar (UG) that
allows individual languages to vary along a nar-
row range of dimensions. On the other hand, the
Distributional Learning paradigm of grammatical
inference (Clark and Eyraud, 2007) has shown that
it is possible to create empiricist representations of
grammar optimized for extracting generalizations
from data with theoretical guarantees of conver-
gence.

Recent advances in mathematical linguistics
have suggested that the rationalist–empiricist de-
bate may be of interest to the program of
formally characterizing the typology of syntax.
Shieber’s (1985) argument that Swiss German is
not context-free shows that substantial expressive
power is needed in order to adequately describe

syntactic phenomena. At the same time, the class
of context-free languages and its extensions in-
clude pathological dependencies unattested in nat-
ural language. Kobele (2011), for instance, shows
that the context-free Merge operation allows Min-
imalist Grammars (MGs) to define languages that
require every syntactically well-formed sentence
to have at least one semantic type conflict. In light
of this overgeneration problem, learnability has
been proposed as a possible way to refine exist-
ing language classes so as to better align with em-
pirical facts. Under such an approach, UG spec-
ifies the formalism in which grammars are repre-
sented, while language acquisition is modelled by
a grammar induction algorithm that correctly con-
verges on a subset of the possible grammars. Since
no strict superclass of the finite languages admits
a general learning procedure (Gold, 1967), there
necessarily exist languages that are permitted by
UG but that cannot be learned by the language ac-
quisition algorithm.

This paper takes some preliminary steps toward
evaluating the potential of learnability to produce
restricted language classes that exclude unnatu-
ral patterns. Recent work in Distributional Learn-
ing has produced a hierarchy of context-free and
multiple context-free language classes defined by
learning algorithms. I examine three examples
of unnatural patterns—structure-independent con-
straints on sentence length, free word order with
unbounded crossing dependencies, and unlimited
copying of deep context-free structure—and show
that these patterns appear in small classes of the
learnable hierarchy. This suggests that current ap-
proaches to grammar induction for syntax may
fail to yield learnability-based accounts for the ab-
sence of these patterns in syntactic typology.

After basic definitions and notation are pre-
sented in Section 2, Section 3 introduces the learn-
able language classes considered in this paper.

124
Proceedings of the Society for Computation in Linguistics (SCiL) 2019, pages 124-134.

New York City, New York, January 3-6, 2019



The three unnatural patterns, drawn from Graf’s
(2013) discussion of overgeneration in MGs, are
defined in Section 4. There, it will be shown that
the three patterns exist within the language classes
from Section 3. Section 5 concludes with a discus-
sion of these facts and their relationship with the
rationalist–empiricist debate.

2 Preliminaries

As usual, N denotes the set of nonnegative inte-
gers, and for any set A, P(A) denotes the power
set of A. Unless otherwise specified, the letter Σ
denotes a finite alphabet. The length of a string x
is denoted by |x|, and ε denotes the empty string.
For each a ∈ Σ, |x|a denotes the number of occur-
rences of a in x. Alphabet symbols are identified
with strings of length 1. For strings a and b, ab de-
notes the concatenation of a and b. As usual, this
notation is extended elementwise to sets of strings.
For k ∈ N, αk denotes α concatenated with itself
k-many times; α≤k denotes

⋃k
i=0 α

i; α∗ denotes⋃∞
i=0 α

i; and α+ denotes α∗\{ε}. This notation
does not apply to (Σ∗)k, which denotes the carte-
sian product

∏k
i=1 Σ

∗. The length of a tuple x =
⟨x1, x2, . . . , xk⟩ is defined as |x| :=

∑k
i=1 |xi|.

For a ∈ Σ, |x|a denotes |x1x2 . . . xk|a.
For k ∈ N, a k-context over Σ is a (k + 1)-

tuple of strings ⟨c0, c1, . . . , ck⟩ ∈ (Σ∗)k, denoted
c0!c1! . . . !ck. For sets L1, L2, . . . , Lk ⊆ Σ∗,
L0!L1! . . . !Lk denotes the cartesian product∏k

i=0 Li. The wrapping operation ⊙ between k-
contexts and k-tuples of strings is defined by

c0!c1! . . . !ck ⊙ ⟨x1, x2, . . . , xk⟩
:= c0x1c1x2c2 . . . xkck

and extended elementwise to sets of contexts and
sets of strings. For α ∈ (Σ∗)k ∪ P

(
(Σ∗)k

)
and

L ⊆ Σ∗, the contexts of α with respect to L are
defined to be the set

α|L⟩ :=
{
c ∈ (Σ∗)k+1

∣∣∣c⊙ α ⊆ L
}

,

with the “⊆” above replaced by “∈” when α ∈
(Σ∗)k. For γ ∈ (Σ∗)k+1∪P

(
(Σ∗)k+1

)
, we define

the set

γ⟨L| :=
{
x ∈ (Σ∗)k

∣∣∣γ ⊙ x ⊆ L
}

,

with the “⊆” above replaced by “∈” when γ ∈
(Σ∗)k+1. When the identity of the language L is
clear from context, we may denote α|L⟩ by α◃ and
γ⟨L| by γ▹.

1-MCFL (CFL)

2-MCFL

3-MCFL

...

2-MCFLwn (TAL)

3-MCFLwn

...

Figure 1: The MCFL hierarchy.

2.1 Multiple Context-Free Grammars
This paper considers multiple context-free gram-
mars (MCFGs, Seki et al., 1991), a mildly
context-sensitive (MCS) formalism equivalent to
MGs (Harkema, 2001; Michaelis, 2001). MCFGs
are a generalization of context-free grammars
(CFGs) in which nonterminals derive tuples of
strings. Whereas CFG rules concatenate strings
derived from nonterminals on their right-hand
sides, MCFGs interleave nonterminal-derived tu-
ples. Let us consider an example to illustrate how
MCFGs generate strings.
Example 1. The following four rules define an
MCFG generating the copy language L = {ww |
w ∈ {a, b}∗}. The start symbol is S.

S(xy)← T (x, y) (2a)
T (ax, ay)← T (x, y) (2b)
T (bx, by)← T (x, y) (2c)

T (ε, ε)← (2d)
A rule of the form

A(y)← B1(x1)B2(x2) . . . Bn(xn)
is interpreted as an axiom stating that if each non-
terminal Bi on the right-hand side generates the
tuple xi, then the nonterminal A on the left-hand
side generates the tuple y. In rule (2d), the right-
hand side is empty; this means that we assume T
to generate the tuple ⟨ε, ε⟩.

The string abab ∈ L is derived as follows. By
rule (2d), T generates ⟨ε, ε⟩. By (2c), T generates
⟨b, b⟩. By (2b), T generates ⟨ab, ab⟩. By (2a), the
start symbol S generates abab.

An MCFG rule may be thought of as a function
that describes how tuples generated by nontermi-
nals on the right-hand side may be combined with

125



one another. These functions must satisfy a condi-
tion known as linearity, which asserts that MCFG
rules cannot copy their inputs.1

Definition 3. Fix k ∈ N. Consider a function
f :

∏k
i=1(Σ

∗)di → (Σ∗)d0 . For each i, write
xi = ⟨xi,1, xi,2, . . . , xi,di⟩. We say that f is a lin-
ear function if it is of the form

f(x1,x2, . . . ,xk) = ⟨α1, α2, . . . , αd0⟩,

where the concatenated string α = α1α2 . . . αd0
satisfies the following criteria:

• α contains exactly one occurrence of each
variable xi,j ; and

• for each i and j, xi,j occurs to the left of
xi,j+1 in α.2

Furthermore, we say that f is well-nested if there
are no indices i, j, i′, j′, and j′′, with i ̸= i′ and
j′ ̸= j′′, such that the variable xi′,j′ occurs be-
tween xi,j and xi,j+1 in α, but xi′,j′′ does not.
Definition 4. A multiple context-free gram-
mar (MCFG) is an ordered quadruple G =
⟨N, Σ, R, I⟩, where

• N is a finite set of nonterminals;

• Σ is a finite set of terminals;

• I ⊆ N is the set of start symbols; and

• letting F be the set of all linear functions,
R ⊆ N × F ×N∗ is a finite set of rules.

We always assume that N and Σ are disjoint. Each
nonterminal A ∈ N is associated with a number
dim(A) known as its dimension. All start symbols
must have dimension 1. We denote each rule r =
⟨A, f, B1B2 . . . Bk⟩ by

A(y)← B1(x1)B2(x2) . . . Bk(xk),

where each xi is a dim(Bi)-tuple of variables and
y = f(x1,x2, . . . ,xk). We say that r is well-
nested if f is well-nested.

1While individual MCFG rules cannot copy, Example 1
shows that MCFGs can perform copying by combining sev-
eral different rules.

2Technically, the definition of linear functions only re-
quires that α contain at least one occurrence of each xi,j .
Seki et al. (1991) and Kracht (2003) show that the other as-
sumptions can be made without changing the generative ca-
pacity of MCFGs.

SUBST

CONG CDET

CONG-CDET

FKP FCP

PRIMAL-DUAL

MCFL

IIL

MAT

MQ

Figure 2: The hierarchy of Distributionally Learnable
MCFLs (see Clark and Yoshinaka 2016).

We say that G is a k-multiple context free gram-
mar (k-MCFG) if every nonterminal has dimen-
sion at most k. We say that G is well-nested if ev-
ery rule in R is well-nested. For each nonterminal
A, we define L(G, A) ⊆ (Σ∗)dim(A) as follows.
For each rule A(y) ← B1(x1)B2(x2) . . . Bk(xk)
with y = f(x1,x2, . . . ,xk), if zi ∈ L(G, Bi)
for each i, then f(z1, z2, . . . , zk) ∈ L(G, A).
Identifying 1-tuples with strings, the language
generated by G is the language L(G) :=⋃

S∈I L(G, S). We say that a language L ⊆ Σ∗
is a k-multiple context-free language (k-MCFL) if
it is generated by a k-MCFG. We say that L is
well-nested if G is well-nested.

MCFLs naturally subsume other common lan-
guage classes: the class of context-free languages
(CFLs) is the same as the class of 1-MCFLs, while
the class of tree-adjoining languages (TALs) is
the same as the class of well-nested 2-MCFLs
(Kanazawa, 2009b). Seki et al. (1991) and Ram-
bow and Satta (1999) prove a separation re-
sult showing that k-MCFLs are strictly contained
within the class of (k + 1)-MCFLs. This MCFL
hierarchy, along with its well-nested counterpart
(Kanazawa, 2009a), is shown in Figure 1.

3 Learnable Classes of Languages

The theory of learnability considered here is based
on the Identification in the Limit (IIL) model of
Gold (1967). Under this paradigm, the learner re-
ceives an infinite data stream containing all pos-
sible strings drawn from a target language L, ar-
ranged in an unspecified order. After observing

126



each string, the learner must guess a grammar for
L. We consider a class of languages C ⊆ P(Σ∗)
to be learnable if there is a learner whose guesses
converge to a correct grammar for L for any target
L ∈ C and any presentation of the strings of L.

IIL-learning of formal languages was pioneered
by Angluin (1982), who gave an algorithm that
learns the class of regular languages satisfying a
criterion known as reversibility. While the full
class of regular languages is not learnable un-
der the IIL paradigm, Angluin (1987) showed
that learner can learn all regular languages if it
is equipped with a minimally adequate teacher
(MAT): a black-box oracle that answers certain
questions about the target language. These al-
gorithms were extended to CFLs by Clark and
Eyraud (2007) and Clark (2010), respectively, and
to MCFLs by Yoshinaka (2011a) and Yoshinaka
and Clark (2012), respectively. Since the MAT-
learning algorithm fails to learn the full classes of
CFLs and MCFLs, further results by Yoshinaka
(2011b), Yoshinaka (2012), and Clark and Yoshi-
naka (2012) expand the MAT-learnable classes
via algorithms using membership queries (MQs).
These learnable language classes are visually sum-
marized in Figure 2.

The remainder of this section formally defines
several classes of MCFLs. Subsection 3.1 defines
the IIL-learnable substitutable MCFLs (“SUBST”
in Figure 2), the MCFL analogue of Angluin’s re-
versible regular languages. Subsection 3.2 defines
the MAT-learnable congruential MCFLs (“CONG”
in Figure 2). Subsection 3.3 defines two MQ-
learnable classes of MCFLs: those generated by
MCFGs with the finite kernel property (“FKP” in
Figure 2) and those generated by MCFGs with the
finite context property (“FCP” in Figure 2).

3.1 Substitutable Languages

The IIL algorithms of Clark and Eyraud (2007)
and Yoshinaka (2011a) rely upon the strong as-
sumption that whenever two k-tuples x and y ap-
pear in the same context—i.e., x◃ ∩ y◃ ̸= ∅—
they must be generated by the same k-dimensional
nonterminal. This property is known as substi-
tutability.
Definition 5. For k ∈ N, a language L ⊆ Σ∗ is
k-substitutable if for all k-tuples x,y ∈ (Σ∗)k,
either x|L⟩ = y|L⟩ or x|L⟩ ∩ y|L⟩ = ∅.

For each k, a language L induces an equiva-
lence relation ≡kL on (Σ∗)k in which x ≡kL y

if and only if x◃ = y◃. The grammar G con-
structed by the algorithm identifies each nonter-
minal A with an equivalence class [a] of ≡dim(A)L ,
so that a ∈ L(G, A) ⊆ [a]. It turns out that lin-
ear functions map tuples of subsets of equivalence
classes to subsets of equivalence classes, allow-
ing nonterminals to combine with one another via
MCFG rules.

When L is a k-substitutable k-MCFL, the
learner determines whether or not x and y are
equivalent based on whether or not a common con-
text in x◃ ∩ y◃ has been observed so far, with
the understanding that such a context must ap-
pear in the data eventually. At each time step, the
learner finds all equivalence classes seen so far,
and constructs all rules such that a representative
from the equivalence class on the left-hand side
has been observed in the data. The learner con-
verges when the data contain enough equivalence
classes to construct a correct grammar for L.

3.2 Congruential Languages

In Clark (2010) and Yoshinaka and Clark (2012),
the learner again identifies each nonterminal A
with an equivalence class of ≡dim(A)L and seeks
to find all equivalence classes needed to construct
the grammar. Without the assumption of substi-
tutability, the learner relies on the minimally ade-
quate teacher to determine which tuples are equiv-
alent. To do this, the learner asks the teacher
two types of questions: membership queries (Is
x ∈ L?) and equivalence queries (What is an ex-
ample of a string in L\L(G)?). At each time step,
an equivalence query is used to identify an equiv-
alence class not covered by an existing nontermi-
nal, and membership queries are used to construct
all possible rules involving the new nonterminal.
Note that training data are not needed, since the
learner asks the teacher for data through equiv-
alence queries. MCFGs constructed through this
procedure are known as congruential MCFGs.
Definition 6. A k-MCFG G is congruential if for
every nonterminal A, L(G, A) is completely con-
tained within an equivalence class of ≡dim(A)

L(G) . A
k-MCFL is congruential if it is generated by a
congruential k-MCFG.

3.3 The FKP and the FCP

The learning algorithms for the substitutable and
congruential CFLs and MCFLs attempt to find
equivalence classes of≡kL. Yoshinaka (2011b) and

127



Clark and Yoshinaka (2012) generalize beyond
this approach by dropping the requirement that
nonterminals correspond to equivalence classes.
Instead, each nonterminal A is identified with a
finite set of strings or contexts with the same dis-
tribution as A.
Definition 7. Fix k ∈ N. An MCFG G has the k-
finite kernel property (k-FKP) if for every nonter-
minal A of G, there exists KA ⊆ (Σ∗)dim A such
that |KA| ≤ k and L(G, A)◃ = K◃A . G has the
k-finite context property (k-FCP) if for every non-
terminal A, there exists CA ⊆ (Σ∗)dim(A)+1 such
that |CA| ≤ k and L(G, A)◃▹ = C▹A .3

At each time step, the learner constructs non-
terminals by considering all possible size-k sets
of tuples or contexts. The learner constructs rules
r = A(y)← B1(x1)B2(x2) . . . Bn(xn) by deter-
mining whether or not the right-hand side and the
left-hand side have the same distribution. This is
done heuristically by asking membership queries
for strings of the form c ⊙ f(b1,b2, . . . ,bn),
where f is the linear function associated with r.
When L is assumed to have the k-FKP, c is drawn
from the contexts in K◃A observed so far, and for
each i, bi ∈ KBi . When L is assumed to have the
k-FCP, c ∈ CA, while each bi is drawn from the
substrings in C▹Bi observed so far.

4 Overgeneration

The formal problem of overgeneration has a
long history in linguistics, starting from Peters
and Ritchie’s (1973) proof that Transformational
Grammars can generate all recursively enumer-
able languages. Recent interest in the overgener-
ation problem arises from the model-theoretic ap-
proach pioneered by Rogers (1994, 1998) for the
formalization of syntactic theories. Relying upon
the equivalence of monadic second-order (MSO)
logic over trees with tree automata (Thatcher and
Wright, 1968), Rogers constructs a context-free
implementation of Rizzi’s (1990) constraint-based
Relativized Minimality theory by stating the con-
straints in MSO logic. Morawietz (2008) extends
the model-theoretic approach to MCS formalisms
by combining MSO constraints on derivation trees
with MSO-definable transductions from derivation
trees to derived structures. Considering the case
of MGs, Kobele (2011) and Graf (2011) show

3The definition presented here is for the weak versions of
the FKP and the FCP. Other versions of these properties are
discussed in Kanazawa and Yoshinaka (2017).

that MG derivation trees are closed under inter-
section with arbitrary MSO constraints, and Graf
(2012) shows that complex movement operations
can be added to MGs by enhancing the transduc-
tion from derivation trees to derived trees. These
closure properties allow Graf (2013) to develop
a full MG-based treatment of Minimalist syntax
within Morawietz’s framework, showing that Min-
imalist constraints on derivation trees and derived
trees, as well as transderivational constraints, can
be implemented using Merge by carefully choos-
ing categories and selection features for lexical
items.

These findings have highlighted the relevance
of overgeneration to mainstream Minimalist syn-
tax. As discussed in Graf (2017), existing con-
straints on movement can be circumvented by us-
ing Merge to create non-local dependencies. On
the other hand, any pathological pattern is a logi-
cally possible MG as long as it is MSO-definable.
Illustrating the latter point, Graf (2013, pp. 117–
118) identifies three kinds of unnatural dependen-
cies that can be generated by MGs:

(8) a. patterns sensitive to “non-linguistic”
information, such as the number of
words in a sentence;

b. languages with completely free word
order, subject to no restrictions; and

c. creating arbitrarily many copies of
context-free structure.

In Subsections 4.1 and 4.2, I show that the pat-
terns described in (8a) and (8b), respectively, can
be represented as substitutable MCFLs. In Sub-
section 4.3, we will see that the arbitrary copying
of (8c) is not congruential, but it can be generated
by an MCFG with both the 2-FKP and the 1-FCP.

4.1 Structure-Independent Patterns
One of the earliest motivations for the rationalist
position is the observation that syntactic depen-
dencies are universally sensitive to constituency
structure. Chomsky (1968) argues:

. . . grammatical transformations are
invariably structure-dependent in the
sense that they apply to a string of
words by virtue of the organization of
these words into phrases. It is easy
to imagine structure-independent oper-
ations that apply to a string of ele-
ments quite independently of its ab-

128



stract structure as a system of phrases.
. . . Yet no human language contains
structure-independent operations . . . .
The language-learner knows that [such
operations] need not be considered as
tentative hypotheses.

Examples of “structure-independent” patterns
typically consist of operations whose targets are
based on arithmetic criteria. One such example ap-
pears in the passage quoted above, where Chom-
sky imagines an auxiliary-fronting operation tar-
geting the first auxiliary in a sentence. This pro-
duces the ungrammatical question (9b) from the
corresponding declarative (9a).

(9) a. The subjects who will act as con-
trols will be paid.

b. * Will the subjects who t act as con-
trols will be paid?

c. Will the subjects who will act as
controls t be paid?

Along these lines, Graf imagines a requirement
that the length of a sentence or phrase be a mul-
tiple of some fixed number n.
Definition 10. For each n > 0, let us define

MODn := {x | |x| ≡ 0 mod n}.
Despite its structure-independence, MODn is

easily shown to be substitutable.
Proposition 11. MODn is k-substitutable for ev-
ery k ∈ N and n > 0.
Proof. For any k-tuple x and k-context c, c⊙x ∈
MODn if and only if |c| + |x| is a multiple of n.
Therefore,

x◃ = {c | |c| ≡ −|x| mod n} .
It is clear that for any x,y ∈ (Σ∗)k, x◃ and
y◃ are either equal or disjoint, so MODn is k-
substitutable for every k.

4.2 Free Word Order
Following Shieber’s (1985) argument that Swiss
German is not context-free, Joshi (1985) pro-
posed the MCS languages as a characterization
of the possible natural languages. This class
is defined by grammar formalisms that admit a
polynomial-time parsing algorithm, exhibit con-
stant growth, and express limited cross-serial de-
pendencies. The notion of “limited cross-serial de-
pendencies” was left vague, but Joshi et al. (1990,
1991) provide some elaboration:

[MCS grammars] capture only certain
kinds of dependencies, e.g., nested de-
pendencies and certain limited kinds of
crossing dependencies (e.g., in the sub-
ordinate clause constructions in Dutch
or some variations of them, but perhaps
not in the so-called MIX (or Bach) lan-
guage . . . [).]

The language MIX mentioned above is the focus
of this subsection.
Definition 12. The language MIX is defined as

MIX := {x ∈ {a, b, c}∗ | |x|a = |x|b = |x|c} .

According to Joshi (1985), MIX “represents the
extreme case of the degree of free word order
permitted in a language,” and is therefore “lin-
guistically not relevant.” The fact that MIX is
a 2-MCFL but not a TAL (Salvati, 2011, 2015;
Kanazawa and Salvati, 2012) has been used to ar-
gue that the TALs are a more suitable formaliza-
tion of the MCS languages than the MCFLs. This
kind of reasoning may be seen as a rationalist po-
sition asserting that MIX is not a possible natural
language because UG requires natural languages
to be TALs. An empiricist account for the absence
of MIX-like natural languages might claim that
the learners fail to converge on MIX even though
MIX is allowed by UG. However, it turns out that
MIX is substitutable, so such an account would
not be supported by Distributional Learning as a
model of language acquisition.
Proposition 13 (Clark and Yoshinaka, 2016).
MIX is k-substitutable for every k ∈ N.
Proof. Suppose c ⊙ x, c ⊙ y,d ⊙ x ∈ MIX.
We want to show that d ⊙ y ∈ MIX. To that
end, observe that for any context γ and symbol
i ∈ {a, b, c},

|γ ⊙ y|i = |γ ⊙ x|i − |x|i + |y|i. (14)

Taking γ = c, we obtain

−|x|i + |y|i = |c⊙ y|i − |c⊙ x|i.

Next, we take γ = d and substitute the above into
(14), giving us

|d⊙ y|i = |d⊙ x|i + |c⊙ y|i − |c⊙ x|i.

Since the terms on the right-hand side have the
same value for all i, so must the left-hand side.
This means that d⊙ y ∈ MIX, as desired.

129



4.3 Copying
The third unnatural dependency that Graf consid-
ers is represented by the double-copying language
COPY3(D1).
Definition 15. For L ⊆ Σ∗ and n ∈ N, define

COPYn(L) := {(x#)n | x ∈ L},

where # /∈ Σ.4
Definition 16. The language D1 is the language
generated by the following 1-MCFG.

S(xy)← S(x)S(y)
S([x])← S(x)

S(ε)←

Copy languages have two interpretations in
mathematical linguistics. On the one hand,
COPY2({a, b}∗) represents the cross-serial de-
pendencies found in Swiss German, since it is
a homomorphic image of the embedded-clause
verb–argument sequences that Shieber shows is
not context-free. On the other hand, the idea of
copying structure often appears explicitly in syn-
tactic analyses. Kobele (2006), for instance, ar-
gues that Yoruba has a relative clause construction
that involves copying VPs. Apart from overtly
attested instances of copying, Merchant (1999,
2001) develops a theory of sluicing in which CPs
are copied and their TP complements are deleted.
It turns out that Distributional Learning can distin-
guish between these two interpretations of copy-
ing.
Proposition 17. COPYn(L) is a congruential n-
MCFL if and only if L is regular.5

If we consider non-regular Ls to represent copy-
ing of structure, then only the former interpreta-
tion is captured by the congruential n-MCFLs.
Lemma 18. Let x = ⟨x1, x2, . . . , xm⟩, with m ≤
n. If |x|# < n, then either |xi|# ≥ 2 for some i,
x| COPYn(L)⟩ = ∅, or x belongs to a finite equiv-
alence class of ≡mCOPYn(L).

Proof. Suppose x◃ ̸= ∅, |xi|# ≤ 1 for all i,
and |x|# ≤ n − 2. Then, x has a context c =
c0!c1! . . . !cn such that |ci|# ≥ 2 for some i.
Writing ci = l#w#r, observe that every y ∈ c▹
satisfies c ⊙ y = (w#)n. There are only finitely

4The language considered in Graf (2013) does not have a
final #. However, adding the final # allows COPYn(L) to
be congruential when L is regular (Proposition 17).

5However, it is easy to show that COPYn({aibi | i ≥
0}) is a congruential (n + 1)-MCFL.

many such ys, so only finitely many strings may
share the context c with x.

Next, suppose that x◃ ̸= ∅, |xi|# ≤ 1 for all i,
and |x|# = n − 1. Then, we have |xp|# = 0 for
some p, and for i ̸= p we can write xi = yi#zi
with |yi|# = |zi|# = 0. Let y be the longest yi
and z be the longest zi, and let ym+1 = z0 := ε.
Observe that c ∈ x◃ if and only if c⊙x = (w#)n
for some w ∈ zΣ∗y ∩ zp−1Σ∗xpΣ∗yp+1. Thus, if
x′◃ = x◃, then x′ = ⟨x′1, x′2, . . . , x′m⟩, where
x′q = xp for some q, x

′
i = y

′
i#z

′
i for i ̸= q, y is the

longest y′i, z is the longest z
′
i, y

′
q+1 = yq+1, and

z′q−1 = zp−1. There are only finitely many such
x′, so the lemma follows.

Proof of Proposition 17. First, suppose L is reg-
ular. Let M be the minimal right-to-left deter-
ministic finite-state automaton recognizing L. We
can construct an MCFG G for COPYn(L) as fol-
lows. The nonterminals of G are the states of
M . If A is the start state of M , then G has the
rule A(#, #, . . . , #) ←. If M transitions from
state B to state A after reading a, then G has a
rule A(ax1, ax2, . . . , axn) ← B(x1, x2, . . . , xn).
Finally, for each accept state S of M , G has a
start symbol IS and a rule IS(x1x2 . . . xn) ←
S(x1, x2, . . . , xn). It is clear that for each x ∈
L(G, IS), x◃ = {!}. Observe that for each non-
terminal A of G, L(G, A) is the set of strings
(w#)n such that M is in state A after reading w.
Thus, elements of L(G, A) are of the form (w#)n.
For each such (w#)n, we have

((w#)n)◃ = {c!c! . . . !c | cw ∈ L}.

Since M is minimal, if (u#)n, (v#)n ∈ L(G, A),
then by the Myhill–Nerode Theorem we must
have

{c | cu ∈ L} = {c | cv ∈ L},
thus

((u#)n)◃ = {c!c! . . . !c | cu ∈ L}
= {c!c! . . . !c | cv ∈ L}
= ((v#)n)◃ .

This means that G is congruential.
Now, suppose COPYn(L) is generated by a

congruential n-MCFG G. By Lemma 18, with-
out loss of generality each copy of w ∈ L in
(w#)n ∈ COPYn(L) is generated exclusively
using rules of the form

A(l1x1r1, l2x2r2, . . . , lnxnrn)

130



← B(x1, x2, . . . , xn),

where li, ri ∈ Σ∗ for each i and L(G, B) ⊆
(Σ∗#Σ∗)n. Since x1 must already contain a #,
such rules can only append a constant string to the
left of the first copy of w, so the set of possible ws
must be regular.

Graf argues that COPY3(D1) is unnatural
because “embeddings of unbounded depth are
copied and fully realized in three distinct posi-
tions in the utterance.” According to Proposi-
tion 17, the property of unbounded depth disqual-
ifies COPY3(D1) from congruentiality, but the
existence of more than two copies does not, as
long as COPY3(D1) is generated by a 3-MCFG.
COPY3(D1) is still learnable, however, because
it belongs to the class of 3-MCFLs defined by the
FKP and the FCP.
Proposition 19. COPY3(D1) is generated by a
3-MCFG G with the 2-FKP and the 1-FCP.

Proof. G is defined as follows.

S(x#y#z#)← T (x, y, z)
T (x1x2, y1y2, z1z2)← T (x1, y1, z1)

T (x2, y2, z2)

T ([x],[y],[z])← T (x, y, z)
T (ε, ε, ε)←

We have

L(G, S)◃ = COPY3(D1)
◃ = {!} = {###}◃

L(G, T )◃ = {⟨w, w, w⟩ | w ∈ D1}◃

=
{

l!r#l!r#l!r#
∣∣∣l!r ∈ D⟨D1|1

}

= {⟨[[]],[[]],[[]]⟩,
⟨[][],[][],[][]⟩}◃,

so G has the 2-FKP.6 We also have

L(G, S)◃▹ = {!}▹
L(G, T )◃▹ = {!#!#!#}▹,

so G has the 1-FCP.

5 Conclusion

We have seen that MODn and MIX are k-
substitutable for every k, while COPY3(D1) is
generated by a 3-MCFG with the 2-FKP and the

6G does not have the 1-FKP because for any ⟨x, x, x⟩ ∈
L(G, T )◃▹, x!#!x#x!# ∈ ⟨x, x, x⟩◃\L(G, T )◃.

1-FCP. If the Distributional Learning hierarchy of
Figure 2 is taken to be a measure of complex-
ity, then we may conclude from these facts that
MODn and MIX are very simple from the per-
spective of learnability. Proposition 17 gives us
the interesting result that in general, the com-
plexity of COPYn(L) with respect to learnabil-
ity is related to the language-theoretic complexity
of L, so that COPY3(D1) is slightly more com-
plex than the congruential languages. Since natu-
ral language grammars are not congruential,7 any
class in the learnable hierarchy that might plau-
sibly include natural language syntax would also
likely include MODn, MIX, and COPY3(D1).

The discussions in Subsections 4.2 and 4.3
should be contrasted with language-theoretic anal-
yses of MIX and COPY3(D1), respectively.
As mentioned previously, MIX falls outside the
TALs, which is identical to the well-nested 2-
MCFLs. Similarly, Kanazawa and Salvati (2010)
show that COPY3(D1) is not a well-nested n-
MCFL for any n. The criterion of well-nestedness,
then, provides an elegant rationalist explanation
for the absence of MIX- or COPY3(D1)-like nat-
ural languages. Such a criterion could also be jus-
tified on functionalist grounds, since well-nested
MCFGs admit a more efficient parsing algorithm
than MCFGs in general (Gómez-Rodrı́guez et al.,
2010). While the well-nestedness requirement
does not eliminate MODn, an anonymous re-
viewer observes that intersecting the language of
a CFG with MODn increases the size of that CFG
by a factor of n2. Thus, when n is large, languages
with MODn-like dependencies may be eliminated
by functionalist considerations regarding grammar
size.

The case of MODn shows that the regular
languages capture many patterns that do not re-
semble natural language dependencies. Although
the inclusion of the regular languages in nat-
ural language has traditionally been taken for
granted,8 recent work on the subregular hierarchy
has shown that markedness constraints in phono-
tactics and morphotactics typically belong to re-
stricted, IIL-learnable subclasses of the regular
languages (Heinz et al., 2011; Aksënova et al.,

7For example, congruentiality would preclude the possi-
bility of a single word such as effect or affect having the distri-
bution of both a noun and a verb if nonterminals are identified
with syntactic categories.

8Additionally, Joshi et al. (1990, 1991) mention strict in-
clusion of the CFLs as a fourth defining property of the MCS
languages.

131



2016) that formalize notions of locality. It may
be the case that a refinement of the regular lan-
guages is needed for syntax as well. While the
study of the equivalence relation ≡kL may be seen
as an algebraic treatment of the notion of structure
(Clark, 2015), the learnability of MODn may re-
veal a point of divergence between the algebraic
approach and the intuitive notion of syntactic con-
stituencies.

In conclusion, this paper has shown that the
restricted language classes in the Distributional
Learning hierarchy are rich enough to raise the
very questions of overgeneration that they were
hypothesized to solve. While Distributional
Learning does not provide a learnability-based ac-
count for the typological absence of patterns mod-
elled by MODn, MIX, or COPY3(D1), all three
patterns can plausibly be eliminated on rationalist
or functionalist grounds. These findings suggest
that learnability may play a smaller role in deter-
mining natural language typology than once ex-
pected.

References
Alëna Aksënova, Thomas Graf, and Sedigheh Moradi.

2016. Morphotactics as Tier-Based Strictly Local
Dependencies. In Proceedings of the 14th SIG-
MORPHON Workshop on Computational Research
in Phonetics, Phonology, and Morphology, pages
121–130, Berlin, Germany. Association for Compu-
tational Linguistics.

Dana Angluin. 1982. Inference of Reversible Lan-
guages. Journal of the Association for Computing
Machinery, 29(3):741–765.

Dana Angluin. 1987. Learning Regular Sets from
Queries and Counterexamples. Information and
Computation, 75(2):87–106.

Noam Chomsky. 1965. Aspects of the Theory of Syn-
tax, 1 edition. MIT Press, Cambridge, MA.

Noam Chomsky. 1968. Language and Mind, 1 edition.
Harcourt, Brace & World, New York, NY.

Noam Chomsky. 1971. Problems of Knowledge and
Freedom: The Russell Lectures, 1 edition. Pantheon
Books, New York, NY.

Noam Chomsky. 1980. On Cognitive Structures and
their Development: A Reply to Piaget. In Pi-
atelli M. Palmerini, editor, Language and Learning:
The Debate Between Jean Piaget and Noam Chom-
sky, pages 35–54. Routledge & Kegan Paul, London,
United Kingdom.

Alexander Clark. 2010. Distributional Learning of
Some Context-Free Languages with a Minimally
Adequate Teacher. In Grammatical Inference: The-
oretical Results and Applications, pages 24–37, Va-
lencia, Spain. Springer Berlin Heidelberg.

Alexander Clark. 2015. The syntactic concept lat-
tice: Another algebraic theory of the context-free
languages? Journal of Logic and Computation,
25(5):1203–1229.

Alexander Clark and Rémi Eyraud. 2007. Polynomial
Identification in the Limit of Substitutable Context-
free Languages. Journal of Machine Learning Re-
search, 8(Aug):1725–1745.

Alexander Clark and Ryo Yoshinaka. 2012. Beyond
Semilinearity: Distributional Learning of Parallel
Multiple Context-free Grammars. In Proceedings of
the Eleventh International Conference on Grammat-
ical Inference, PMLR 21:1-3, 2012, volume 21 of
Proceedings of Machine Learning Research, pages
84–96, College Park, MD. PMLR.

Alexander Clark and Ryo Yoshinaka. 2016. Dis-
tributional Learning of Context-Free and Multiple
Context-Free Grammars. In Jeffrey Heinz and
José M. Sempere, editors, Topics in Grammatical In-
ference, pages 143–172. Springer Berlin Heidelberg,
Berlin, Germany.

E Mark Gold. 1967. Language identification in the
limit. Information and Control, 10(5):447–474.

Carlos Gómez-Rodrı́guez, Marco Kuhlmann, and Gior-
gio Satta. 2010. Efficient Parsing of Well-Nested
Linear Context-Free Rewriting Systems. In Human
Language Technologies: The 2010 Annual Confer-
ence of the North American Chapter of the Asso-
ciation for Computational Linguistics, pages 276–
284, Los Angeles, CA. Association for Computa-
tional Linguistics.

Thomas Graf. 2011. Closure Properties of Minimalist
Derivation Tree Languages. In Logical Aspects of
Computational Linguistics: 6th International Con-
ference, LACL 2011, Montpellier, France, June 29
– July 1, 2011. Proceedings, pages 96–111, Berlin,
Germany. Springer Berlin Heidelberg.

Thomas Graf. 2012. Movement-Generalized Mini-
malist Grammars. In 7th International Confer-
ence, LACL 2012, Nantes, France, July 2-4, 2012.
Proceedings, volume 7351 of Lecture Notes in
Computer Science, pages 58–73, Berlin, Germany.
Springer Berlin Heidelberg.

Thomas Graf. 2013. Local and Transderivational Con-
straints in Syntax and Semantics. PhD Dissertation,
University of California, Los Angeles, Los Angeles,
CA.

Thomas Graf. 2017. A computational guide to the di-
chotomy of features and constraints. Glossa: a jour-
nal of general linguistics, 2(1):18.1–36.

132



Henk Harkema. 2001. A Characterization of Minimal-
ist Languages. In Logical Aspects of Computational
Linguistics: 4th International Conference, LACL
2001 Le Croisic, France, June 27–29, 2001 Proceed-
ings, pages 193–211, Berlin, Germany. Springer
Berlin Heidelberg.

Jeffrey Heinz, Chetan Rawal, and Herbert G. Tan-
ner. 2011. Tier-based Strictly Local Constraints
for Phonology. In Proceedings of the 49th Annual
Meeting of the Association for Computational Lin-
guistics: Human Language Technologies, pages 58–
64, Portland, OR. Association for Computational
Linguistics.

Aravind K. Joshi. 1985. Tree adjoining grammars:
How much context-sensitivity is required to provide
reasonable structural descriptions? In Arnold M.
Zwicky, David R. Dowty, and Lauri Karttunen, ed-
itors, Natural Language Parsing: Psychological,
Computational, and Theoretical Perspectives, Stud-
ies in Natural Language Processing, pages 206–250.
Cambridge University Press, Cambridge, United
Kingdom.

Aravind K. Joshi, K. Vijay Shanker, and David Weir.
1990. The Convergence of Mildly Context-Sensitive
Grammar Formalisms. Technical Report MS-CIS-
90-01, University of Pennsylvania Department of
Computer and Information Science, Philadelphia,
PA.

Aravind K. Joshi, K. Vijay Shanker, and David Weir.
1991. The Convergence of Mildly Context-Sensitive
Grammar Formalisms. In Stuart M. Shieber, Peter
Sells, and Thomas Wasow, editors, Foundational Is-
sues in Natural Language Processing, System De-
velopment Foundation Benchmark Series, pages 31–
81. MIT Press, Cambridge, MA.

Makoto Kanazawa. 2009a. The Convergence of Well-
Nested Mildly Context-Sensitive Grammar For-
malisms.

Makoto Kanazawa. 2009b. The Pumping Lemma for
Well-Nested Multiple Context-Free Languages. In
Developments in Language Theory: 13th Interna-
tional Conference, DLT 2009, Stuttgart, Germany,
June 30-July 3, 2009. Proceedings, volume 5583 of
Lecture Notes in Computer Science, pages 312–325,
Berlin, Germany. Springer Berlin Heidelberg.

Makoto Kanazawa and Sylvain Salvati. 2010. The
Copying Power of Well-Nested Multiple Context-
Free Grammars. In Language and Automata The-
ory and Applications: 4th International Conference,
LATA 2010, Trier, Germany, May 24-28, 2010. Pro-
ceedings, volume 6031 of Lecture Notes in Com-
puter Science, pages 344–355, Berlin, Germany.
Springer Berlin Heidelberg.

Makoto Kanazawa and Sylvain Salvati. 2012. MIX
Is Not a Tree-Adjoining Language. In Proceedings
of the 50th Annual Meeting of the Association for

Computational Linguistics, volume 1, pages 666–
674, Jeju, South Korea. Association for Computa-
tional Linguistics.

Makoto Kanazawa and Ryo Yoshinaka. 2017. The
Strong, Weak, and Very Weak Finite Context and
Kernel Properties. In Language and Automata
Theory and Applications: 11th International Con-
ference, LATA 2017, Umeå, Sweden, March 6-9,
2017, Proceedings, pages 77–88, Cham, Switzer-
land. Springer International Publishing.

Gregory M. Kobele. 2006. Generating Copies: An In-
vestigation into Structural Identity in Language and
Grammar. PhD Dissertation, University of Califor-
nia, Los Angeles, Los Angeles, CA.

Gregory M. Kobele. 2011. Minimalist Tree Languages
Are Closed Under Intersection with Recognizable
Tree Languages. In Logical Aspects of Compu-
tational Linguistics: 6th International Conference,
LACL 2011, Montpellier, France, June 29 – July
1, 2011. Proceedings, pages 129–144, Berlin, Ger-
many. Springer Berlin Heidelberg.

Marcus Kracht. 2003. The Mathematics of Language.
Number 63 in Studies in Generative Grammar. De
Gruyter Mouton, Berlin, Germany.

Jason Merchant. 1999. The Syntax of Silence: Sluic-
ing, Islands, and Identity in Ellipsis. PhD Disser-
tation, University of California, Santa Cruz, Santa
Cruz, CA.

Jason Merchant. 2001. The Syntax of Silence: Sluicing,
Islands, and the Theory of Ellipsis, 1 edition. Ox-
ford Studies in Theoretical Linguistics. Oxford Uni-
versity Press, Oxford, United Kingdom.

Jens Michaelis. 2001. Derivational Minimalism Is
Mildly Context–Sensitive. In Logical Aspects
of Computational Linguistics: Third International
Conference, LACL’98 Grenoble, France, Decem-
ber 14–16, 1998 Selected Papers, pages 179–198,
Berlin, Germany. Springer Berlin Heidelberg.

Frank Morawietz. 2008. Two-Step Approaches to Nat-
ural Language Formalism, 1 edition. Number 64 in
Studies in Generative Grammar. De Gruyter Mou-
ton, Berlin, Germany.

P. Stanley Peters and R. W. Ritchie. 1973. On the gen-
erative power of transformational grammars. Infor-
mation Sciences, 6(Supplement C):49–83.

Owen Rambow and Giorgio Satta. 1999. Independent
parallelism in finite copying parallel rewriting sys-
tems. Theoretical Computer Science, 223(1):87–
120.

Luigi Rizzi. 1990. Relativized Minimality. Number 16
in Linguistic Inquiry Monographs. MIT Press, Cam-
bridge, MA.

James Rogers. 1994. Studies in the Logic of Trees with
Applications to Grammar Formalisms. PhD Disser-
tation, University of Delaware, Newark, DE.

133



James Rogers. 1998. A Descriptive Approach to
Language-Theoretic Complexity. Studies in Logic,
Language, and Information. CSLI Publications,
Stanford, CA.

Sylvain Salvati. 2011. MIX is a 2-MCFL and the word
problem in Z2 is solved by a third-order collapsible
pushdown automaton.

Sylvain Salvati. 2015. MIX is a 2-MCFL and the word
problem in Z2 is captured by the IO and the OI hier-
archies. Journal of Computer and System Sciences,
81(7):1252–1277.

Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii,
and Tadao Kasami. 1991. On multiple context-
free grammars. Theoretical Computer Science,
88(2):191–229.

Stuart M. Shieber. 1985. Evidence against the context-
freeness of natural language. Linguistics and Phi-
losophy, 8(3):333–343.

J. W. Thatcher and J. B. Wright. 1968. Generalized Fi-
nite Automata Theory with an Application to a Deci-
sion Problem of Second-Order Logic. Mathematical
systems theory, 2(1):57–81.

Ryo Yoshinaka. 2011a. Efficient learning of multiple
context-free languages with multidimensional sub-
stitutability from positive data. Theoretical Com-
puter Science, 412(19):1821–1831.

Ryo Yoshinaka. 2011b. Towards Dual Approaches for
Learning Context-Free Grammars Based on Syntac-
tic Concept Lattices. In Developments in Language
Theory: 15th International Conference, DLT 2011,
Milan, Italy, July 19-22, 2011. Proceedings, pages
429–440, Berlin, Germany. Springer Berlin Heidel-
berg.

Ryo Yoshinaka. 2012. Integration of the Dual Ap-
proaches in the Distributional Learning of Context-
Free Grammars. In 6th International Conference,
LATA 2012, A Coruña, Spain, March 5-9, 2012. Pro-
ceedings, volume 7183 of Lecture Notes in Com-
puter Science, pages 538–550, Berlin, Germany.
Springer Berlin Heidelberg.

Ryo Yoshinaka and Alexander Clark. 2012. Polyno-
mial Time Learning of Some Multiple Context-Free
Languages with a Minimally Adequate Teacher. In
Formal Grammar: 15th and 16th International Con-
ferences, FG 2010, Copenhagen, Denmark, August
2010, FG 2011, Ljubljana, Slovenia, August 2011,
Revised Selected Papers, Lecture Notes in Computer
Science, pages 192–207, Berlin, Germany. Springer
Berlin Heidelberg.

134


