



















































CLUTRR: A Diagnostic Benchmark for Inductive Reasoning from Text


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 4506–4515,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

4506

CLUTRR: A Diagnostic Benchmark for Inductive Reasoning from Text

Koustuv Sinha 1,3,4, Shagun Sodhani 2,3, Jin Dong 1,3,
Joelle Pineau 1,3,4 and William L. Hamilton 1,3,4

1 School of Computer Science, McGill University, Canada
2 Université de Montréal, Canada

3 Montreal Institute of Learning Algorithms (Mila), Canada
4 Facebook AI Research (FAIR), Montreal, Canada

{koustuv.sinha, sshagunsodhani, jin.dong, jpineau, wlh}
@{mail.mcgill.ca, gmail.com, mail.mcgill.ca, cs.mcgill.ca, cs.mcgill.ca}

Abstract

The recent success of natural language under-
standing (NLU) systems has been troubled by
results highlighting the failure of these mod-
els to generalize in a systematic and robust
way. In this work, we introduce a diagnostic
benchmark suite, named CLUTRR, to clarify
some key issues related to the robustness and
systematicity of NLU systems. Motivated by
classic work on inductive logic programming,
CLUTRR requires that an NLU system infer
kinship relations between characters in short
stories. Successful performance on this task
requires both extracting relationships between
entities, as well as inferring the logical rules
governing these relationships. CLUTRR al-
lows us to precisely measure a model’s abil-
ity for systematic generalization by evaluat-
ing on held-out combinations of logical rules,
and it allows us to evaluate a model’s robust-
ness by adding curated noise facts. Our em-
pirical results highlight a substantial perfor-
mance gap between state-of-the-art NLU mod-
els (e.g., BERT and MAC) and a graph neu-
ral network model that works directly with
symbolic inputs—with the graph-based model
exhibiting both stronger generalization and
greater robustness.

1 Introduction

Natural language understanding (NLU) systems
have been extremely successful at reading compre-
hension tasks, such as question answering (QA)
and natural language inference (NLI). An array of
existing datasets are available for these tasks. This
includes datasets that test a system’s ability to ex-
tract factual answers from text (Rajpurkar et al.,
2016; Nguyen et al., 2016; Trischler et al., 2016;
Mostafazadeh et al., 2016; Su et al., 2016), as well
as datasets that emphasize commonsense inference,
such as entailment between sentences (Bowman
et al., 2015; Williams et al., 2018).

Figure 1: CLUTRR inductive reasoning task.

However, there are growing concerns regarding
the ability of NLU systems—and neural networks
more generally—to generalize in a systematic and
robust way (Bahdanau et al., 2019; Lake and Ba-
roni, 2018; Johnson et al., 2017). For instance,
recent work has highlighted the brittleness of NLU
systems to adversarial examples (Jia and Liang,
2017), as well as the fact that NLU models tend to
exploit statistical artifacts in datasets, rather than
exhibiting true reasoning and generalization capa-
bilities (Gururangan et al., 2018; Kaushik and Lip-
ton, 2018). These findings have also dovetailed
with the recent dominance of large pre-trained lan-
guage models, such as BERT, on NLU benchmarks
(Devlin et al., 2018; Peters et al., 2018), which sug-
gest that the primary difficulty in these datasets is
incorporating the statistics of the natural language,
rather than reasoning.

An important challenge is thus to develop NLU
benchmarks that can precisely test a model’s capa-
bility for robust and systematic generalization. Ide-
ally, we want language understanding systems that
can not only answer questions and draw inferences
from text, but that can also do so in a systematic,
logical, and robust way. While such reasoning ca-
pabilities are certainly required for many existing
NLU tasks, most datasets combine several chal-
lenges of language understanding into one, such as
co-reference/entity resolution, incorporating world
knowledge, and semantic parsing—making it diffi-
cult to isolate and diagnose a model’s capabilities
for systematic generalization and robustness.



4507

Our work. Inspired by the classic AI challenge
of inductive logic programming (Quinlan, 1990)—
as well as the recently developed CLEVR dataset
for visual reasoning (Johnson et al., 2017)—we
propose a semi-synthetic benchmark designed to
explicitly test an NLU model’s ability for system-
atic and robust logical generalization.

Our benchmark suite—termed CLUTRR
(Compositional Language Understanding and
Text-based Relational Reasoning)—contains
a large set of semi-synthetic stories involving
hypothetical families. Given a story, the goal
is to infer the relationship between two family
members, whose relationship is not explicitly
mentioned (Figure 1). To solve this task, a learning
agent must extract the relationships mentioned
in the text, induce the logical rules governing
the kinship relationships (e.g., the transitivity of
the sibling relation), and use these rules to infer
the relationship between a given pair of entities.
Crucially, the CLUTRR benchmark allows us
to test a learning agent’s ability for systematic
generalization by testing on stories that contain
unseen combinations of logical rules. CLUTRR
also allows us to precisely test for the various
forms of model robustness by adding different
kinds of superfluous noise facts to the stories.

We compare the performance of several state-
of-the-art NLU systems on this task—including
Relation Networks (Santoro et al., 2017), Compo-
sitional Attention Networks (Hudson and Manning,
2018) and BERT (Devlin et al., 2018). We find that
the generalization ability of these NLU systems
is substantially below that of a Graph Attention
Network (Veličković et al., 2018), which is given
direct access to symbolic representations of the sto-
ries. Moreover, we find that the robustness of the
NLU systems generally does not improve by train-
ing on noisy data, whereas the GAT model is able
to effectively learn robust reasoning strategies by
training on noisy examples. Both of these results
highlight important open challenges for closing the
gap between machine reasoning models that work
with unstructured text and models that are given
access to more structured input.

2 Related Work

We draw inspiration from the classic work on induc-
tive logic programming (ILP), a long line of read-
ing comprehension benchmarks in NLP, as well as
work combining language and knowledge graphs.

Reading comprehension benchmarks. Many
datasets have been proposed to test the reading com-
prehension ability of NLP systems. This includes
the SQuAD (Rajpurkar et al., 2016), NewsQA
(Trischler et al., 2016), and MCTest (Richardson
et al., 2013) benchmarks that focus on factual
questions; the SNLI (Bowman et al., 2015) and
MultiNLI (Williams et al., 2018) benchmarks for
sentence understanding; and the bABI tasks (We-
ston et al., 2015), to name a few. Our primary
contribution to this line of work is the development
of a carefully designed diagnostic benchmark to
evaluate model robustness and systematic general-
ization in the context of NLU.
Question-answering with knowledge graphs.
Our work is also related to the domain of ques-
tion answering and reasoning in knowledge graphs
(Das et al., 2018; Xiong et al., 2018; Hamilton
et al., 2018; Wang et al., 2018; Xiong et al., 2017;
Welbl et al., 2018; Kartsaklis et al., 2018), where
either the model is provided with a knowledge
graph to perform inference over or where the model
must infer a knowledge graph from the text it-
self. However, unlike previous benchmarks in this
domain—which are generally transductive and fo-
cus on leveraging and extracting knowledge graphs
as a source of background knowledge about a fixed
set of entities—CLUTRR requires inductive logical
reasoning, where every example requires reasoning
over a new set of previously unseen entities.

3 Benchmark Design

In order to design an NLU benchmark that explic-
itly tests inductive reasoning and systematic gen-
eralization, we build upon the classic ILP task of
inferring family (i.e., kinship) relations (Hinton
et al., 1986; Muggleton, 1991; Lavrac and Dze-
roski, 1994; Kok and Domingos, 2007; Rocktäschel
and Riedel, 2017). For example, given the facts
that “Alice is Bob’s mother” and “Jim is Alice’s
father”, one can infer with reasonable certainty
that “Jim is Bob’s grandfather.” While this exam-
ple may appear trivial, it is a challenging task to
design models that can learn from data to induce
the logical rules necessary to make such inferences,
and it is even more challenging to design models
that can systematically generalize by composing
these induced rules.

Inspired by this classic task of logical induction
and reasoning, the CLUTRR benchmark requires
an NLU system to infer and reason about kinship



4508

Figure 2: Data generation pipeline. Step 1: generate
a kinship graph. Step 2: sample a target fact. Step 3:
Use backward chaining to sample a set of facts. Step 4:
Convert sampled facts to a natural language story.

relations by reading short stories. Requiring that
the models learn directly from natural language
makes this task much more challenging than the
purely symbolic ILP setting. However, we lever-
age insights from traditional ILP to generate these
stories in a semi-synthetic manner, providing pre-
cise control over the complexity of the reasoning
required to solve the task.

In its entirety, the CLUTRR benchmark suite al-
lows researchers to generate diverse semi-synthetic
short stories to test different aspects of inductive
reasoning capabilities. We publicly release the en-
tire benchmark suite, including code to generate
the semi-synthetic examples, the specific datasets
that we introduce here, and the different baselines
that we compare with.1

3.1 Overview of data generation process

The core idea behind the CLUTRR benchmark
suite is the following: Given a natural language
story describing a set of kinship relations, the goal
is to infer the relationship between two entities,
whose relationship is not explicitly stated in the
story. To generate these stories, we first design a
knowledge base (KB) with rules specifying how
kinship relations resolve, and we use the following
steps to create semi-synthetic stories based on this
knowledge base:

Step 1. Generate a random kinship graph that sat-
isfies the rules in our KB.

Step 2. Sample a target fact (i.e., relation) to pre-
dict from the kinship graph.

1Benchmark suite code can be obtained from
https://github.com/facebookresearch/clutrr. Generated
datasets are available to view in this link.

Step 3. Apply backward chaining to sample a set
of facts that can prove the target relation
(and optionally sample a set of “distracting”
or “irrelevant” noise facts).

Step 4. Convert the sampled facts into a natural
language story through pre-specified text
templates and crowd-sourced paraphrasing.

Figure 2 provides a high-level overview of this
idea, and the following subsections describe the
data generation process in detail, as well as the
diagnostic flexibility afforded by CLUTRR.

3.2 Story generation

The short stories in CLUTRR are essentially narra-
tivized renderings of a set of logical facts. In this
section, we describe how we sample the logical
facts that make up a story by generating random
kinship graphs and using backward chaining to
produce logical reasoning chains. The conversion
from logical facts to natural language narratives is
then described in Section 3.3.
Terminology and background. Following
standard practice in formal semantics, we use the
term atom to refer to a predicate symbol and a
list of terms, such as [grandfatherOf, X, Y ],
where the predicate grandfatherOf denotes
the relation between the two variables, X and Y .
We restrict the predicates to have an arity of 2, i.e.,
binary predicates. A logical rule in this setting
is of the form H ` B, where B is the body of the
rule, i.e., a conjunction of two atoms ([α1, α2])
and H is the head, i.e., a single atom (α) that
can be viewed as the goal or query. For instance,
given a knowledge base (KB) R that contains
the single rule [grandfatherOf, X, Y ] `
[[fatherOf, X, Z], [fatherOf, Z, Y ]],
the query [grandfatherOf, X, Y ] eval-
uates to true if and only if the body
B = [[fatherOf, X, Z], [fatherOf, Z, Y ]]
is also true in a given world. A rule is called a
grounded rule if all atoms in the rule are themselves
grounded, i.e., all variables are replaced with con-
stants or entities in a world. A fact is a grounded
binary predicate. A clause is a conjunction of two
or more atoms (C = (HC ` BC = ([α1, ..., αn])))
which can be built using a set of rules.

In the context of our data generation process,
we distinguish between the knowledge base, R,
which contains a finite number of predicates and
rules specifying how kinship relations in a family
resolve, and a particular kinship graph G, which

https://github.com/facebookresearch/clutrr
https://drive.google.com/file/d/1SEq_e1IVCDDzsBIBhoUQ5pOVH5kxRoZF/view?usp=sharing


4509

contains a grounded set of atoms specifying the
particular kinship relations that underlie a single
story. In other words, R contains the logical rules
that govern all the generated stories in CLUTRR,
while G contains the grounded facts that underlie a
specific story.
Graph generation. To generate the kinship graph
G underlying a particular story, we first sample a
set of gendered2 entities and kinship relations using
a stochastic generation process. This generation
process contains a number of tunable parameters—
such as the maximum number of children at each
node, the probability of an entity being married to
another entity, etc.—and is designed to produce a
valid, but possibly incomplete “backbone graph”.
For instance, this backbone graph generation pro-
cess will specify “parent”/“child” relations between
entities but does not add “grandparent” relations.
After this initial generation process, we recursively
apply the logical rules in R to the backbone graph
to produce a final graph G that contains the full set
of kinship relations between all the entities.
Backward chaining. The resulting graph G pro-
vides the background knowledge for a specific story,
as each edge in this graph can be treated as a
grounded predicate (i.e., fact) between two entities.
From this graph G, we sample the facts that make
up the story, as well as the target fact that we seek
to predict: First, we (uniformly) sample a target re-
lationHC , which is the fact that we want to predict
from the story. Then, from this target relationHC ,
we run a simple variation of the backward chaining
(Gallaire and Minker, 1978) algorithm for k itera-
tions starting fromHC , where at each iteration we
uniformly sample a subgoal to resolve and then uni-
formly sample a KB rule that resolves this subgoal.
Crucially, unlike traditional backward chaining, we
do not stop the algorithm when a proof is obtained;
instead, we run for a fixed number of iterations k
in order to sample a set of k facts BC that imply the
target relationHC .

3.3 Adding natural language

So far, we have described the process of generat-
ing a conjunctive logical clause C = (HC ` BC),
whereHC = [α∗] is the target fact (i.e., relation) we
seek to predict and BC = [α1, ..., αk] is the set of
supporting facts that imply the target relation. We
now describe how we convert this logical represen-

2Kinship and gender roles are oversimplified in our data
(compared to the real world) to maintain tractability.

Figure 3: Illustration of how a set of facts can split and
combined in various ways across sentences.

tation to natural language through crowd-sourcing.
Paraphrasing using Amazon Mechanical Turk.
The basic idea behind our approach is that we show
Amazon Mechanical Turk (AMT) crowd-workers
the set of facts BC corresponding to a story and ask
the workers to paraphrase these facts into a narra-
tive. Since workers are given a set of facts BC to
work from, they are able to combine and split mul-
tiple facts across separate sentences and construct
diverse narratives (Figure 3). Appendix 1.6 con-
tains further details on our AMT interface (based
on the ParlAI framework (Miller et al., 2017)), data
collection, and the quality controls we employed.
Reusability and composition. One challenge for
data collection via AMT is that the number of possi-
ble stories generated by CLUTRR grows combina-
torially as the number of supporting facts increases,
i.e., as k = |BC | grows. This combinatorial ex-
plosion for large k—combined with the difficulty
of maintaining the quality of the crowd-sourced
paraphrasing for long stories—makes it infeasible
to obtain a large number of paraphrased examples
for k > 3. To circumvent this issue and increase
the flexibility of our benchmark, we reuse and com-
pose AMT paraphrases to generate longer stories.
In particular, we collected paraphrases for stories
containing k = 1, 2, 3 supporting facts and then
replaced the entities from these collected stories
with placeholders in order to re-use them to gener-
ate longer semi-synthetic stories. An example of
a story generated by stitching together two shorter
paraphrases is provided below:

[Frank] went to the park with his father, [Brett].

[Frank] called his brother [Boyd] on the phone.

He wanted to go out for some beers. [Boyd] went

to the baseball game with his son [Jim].

Q: What is [Brett] and [Jim]’s relationship?

Thus, instead of simply collecting paraphrases for a
fixed number of stories, we instead obtain a diverse



4510

Table 1: Statistics of the AMT paraphrases. Jaccard
word overlap is calculated within the templates of each
individual clause of length k.

Number of Paraphrases # clauses

k = 1 1,868 20
k = 2 1,890 58
k = 3 2,258 236

Total 6,016

Unique Word Count 3,797

Jaccard Word Overlap Unigrams 0.201
Bigrams 0.0385

collection of natural language templates that can be
programmatically recombined to generate stories
with various properties.
Dataset statistics. At the time of submission, we
have collected 6,016 unique paraphrases with an
average of 19 paraphrases for every possible logical
clause of length k = 1, 2, 3. Table 1 contains sum-
mary statistics of the collected paraphrases. Over-
all, we found high linguistic diversity in the col-
lected paraphrases. For instance, the average Jac-
card overlap in unigrams between pairs paraphrases
corresponding to the same logical clause was only
0.201 and only 0.0385 for bigrams. The Appendix
contains further examples of the paraphrases.
Human performance. To get a sense of the data
quality and difficulty involved in CLUTRR, we
asked human annotators to solve the task for ran-
dom examples of length k = 2, 3, ..., 6. We found
that time-constrained AMT annotators performed
well (i.e.,> 70%) accuracy for k ≤ 3 but struggled
with examples involving longer stories, achieving
40-50% accuracy for k > 3. However, trained an-
notators with unlimited time were able to solve
100% of the examples (Appendix 1.7), highlight-
ing the fact that this task requires attention and
involved reasoning, even for humans.

3.4 Query representation and inference

Representing the question. The AMT paraphras-
ing approach described above allows us to convert
the set of supporting facts BC to a natural language
story, which can be used to predict the target rela-
tion/queryHC . However, instead of converting the
target query,HC = [α∗], to a natural language ques-
tion, we instead opt to represent the target query as
a K-way classification task, where the two entities
in the target relation are provided as input and the
goal is to classify the relation that holds between

these two entities. This representation avoids the
pitfall of revealing information about the answer in
the question (Kaushik and Lipton, 2018).
Representing entities. When generating stories,
entity names are randomly drawn from a set of 300
common gendered English names. Thus, depend-
ing on each run, the entities are never the same.
This ensures that the entity names are simply place-
holders and uncorrelated from the task.

3.5 Variants of CLUTRR

The modular nature of CLUTRR provides rich di-
agnostic capabilities for evaluating the robustness
and generalization abilities of neural language un-
derstanding systems. We highlight some key diag-
nostic capabilities available via different variations
of CLUTRR below. These diagnostic variations
correspond to the concrete datasets that we gener-
ated in this work, and we describe the results on
these Datasets in Section 4.
Systematic generalization. Most prominently,
CLUTRR allows us to explicitly evaluate a model’s
ability for systematic generalization. In particular,
we rely on the following hold-out procedures to
test systematic generalization:

• During training, we hold out a subset of the col-
lected paraphrases, and we only use this held-out
subset of paraphrases when generating the test
set. Thus, to succeed on CLUTRR, an NLU sys-
tem must exhibit linguistic generalization and be
robust to linguistic variation at test time.

• We also hold out a subset of the logical clauses
during training (for clauses of length k > 2).3 In
other words, during training, the model sees all
logical rules but does not see all combinations of
these logical rules. Thus, in addition to linguistic
generalization, success on this task also requires
logical generalization.

• Lastly, as a more extreme form of both logical
and linguistic generalization, we consider the
setting where the models are trained on stories
generated from clauses of length ≤ k and evalu-
ated on stories generated from larger clauses of
length > k. Thus, we explicitly test the ability
for models to generalize on examples that re-
quire more steps of reasoning that any example
they encountered during training.

3One should not holdout clauses from length k = 2 in
order to allow models to learn the compositionality of all
possible binary predicates.



4511

Figure 4: Noise generation procedures of CLUTRR.

Robust Reasoning. In addition to evaluating
systematic generalization, the modular setup of
CLUTRR also allows us to diagnose model robust-
ness by adding noise facts to the generated narra-
tives. Due to the controlled semi-synthetic nature
of CLUTRR, we are able to provide a precise tax-
onomy of the kinds of noise facts that can be added
(Figure 4). In order to structure this taxonomy, it is
important to recall that any set of supporting facts
BC generated by CLUTRR can be interpreted as
a path, pC , in the corresponding kinship graph G
(Figure 2). Based on this interpretation, we view
adding noise facts from the perspective of sampling
three different types of noise paths, pn, from the
kinship graph G:
• Irrelevant facts: We add a path pn, which has

exactly one shared end-point with pc. In this way,
this is a distractor path, which contains facts that
are connected to one of the entities in the target
relation,HC , but do not provide any information
that could be used to help answer the query.
• Supporting facts: We add a path pn, whose two

end-points are on the path pC . The facts on this
path pn are noise because they are not needed to
answer the query, but they are supporting facts
because they can, in principle, be used to con-
struct alternative (longer) reasoning paths that
connect the two target entities.
• Disconnected facts: We add paths which neither

originate nor end in any entity on pc. These
disconnected facts involve entities and relations
that are completely unrelated to the target query.

4 Experiments

We evaluate several neural language understanding
systems on the proposed CLUTRR benchmark to
surface the relative strengths and shortcomings of
these models in the context of inductive reason-
ing and combinatorial generalization.4 We aim to
answer the following key questions:

4Code to reproduce all the results in this section will be
released at https://github.com/facebookresearch/clutrr/.

(Q1) How do state-of-the-art NLU models com-
pare in terms of systematic generalization?
Can these models generalize to stories with
unseen combinations of logical rules?

(Q2) How does the performance of neural lan-
guage understanding models compare to a
graph neural network that has full access to
graph structure underlying the stories?

(Q3) How robust are these models to the addition
of noise facts to a given story?

4.1 Baselines

Our primary baselines are neural language under-
standing models that take unstructured text as in-
put. We consider bidirectional LSTMs (Hochreiter
and Schmidhuber, 1997; Cho et al., 2014) (with
and without attention), as well as recently pro-
posed models that aim to incorporate inductive
biases towards relational reasoning: Relation Net-
works (RN) (Santoro et al., 2017) and Composi-
tional Memory Attention Network (MAC) (Hud-
son and Manning, 2018). We also use the large
pretrained language model, BERT (Devlin et al.,
2018), as well as a modified version of BERT hav-
ing a trainable LSTM encoder on top of the pre-
trained BERT embeddings. All of these models
(except BERT) were re-implemented in PyTorch
1.0 (Paszke et al., 2017) and adapted to work with
the CLUTRR benchmark.

Since the underlying relations in the stories gen-
erated by CLUTRR inherently form a graph, we
also experiment with a Graph Attention Network
(GAT) (Veličković et al., 2018). Rather than taking
the textual stories as input, the GAT baseline re-
ceives a structured graph representation of the facts
that underlie the story.
Entity and query representations. We use the
various baseline models to encode the natural lan-
guage story (or graph) into a fixed-dimensional em-
bedding. With the exception of the BERT models,
we do not use pre-trained word embeddings and
learn the word embeddings from scratch using end-
to-end backpropagation. An important note, how-
ever, is that we perform Cloze-style anonymization
(Hermann et al., 2015) of the entities (i.e., names)
in the stories, where each entity name is replaced
by a @entity-k placeholder, which is randomly sam-
pled from a small, fixed pool of placeholder tokens.
The embeddings for these placeholders are ran-
domly initialized and fixed during training.5

5See Appendix 1.5 for a comparison of placeholder em-

https://github.com/facebookresearch/clutrr/


4512

2 3 4 5 6 7 8 9 10
Relation Length

0.2

0.4

0.6

0.8

1.0
Ac

cu
ra

cy
Systematic Generalization - Trained on k=2 and k=3

BERT
BERT - LSTM
GAT
MAC
RN
BiLSTM Mean
BiLSTM Attention

2 3 4 5 6 7 8 9 10
Relation Length

0.2

0.4

0.6

0.8

1.0

Ac
cu

ra
cy

Systematic Generalization - Trained on k=2,3 and 4
BERT
BERT - LSTM
GAT
MAC
RN
BiLSTM Mean
BiLSTM Attention

Figure 5: Systematic generalization performance of different models when trained on clauses of length k = 2, 3
(Left) and k = 2, 3, 4 (Right).

To make a prediction about a target query given
a story, we concatenate the embedding of the story
(generated by the baseline model) with the embed-
dings of the two target entities and we feed this
concatenated embedding to a 2-layer feed-forward
neural network with a softmax prediction layer.

4.2 Experimental Setup

Hyperparameters. We selected hyperparameters
for all models using an initial grid search on the sys-
tematic generalization task (described below). All
models were trained for 100 epochs with Adam op-
timizer and a learning rate of 0.001. The Appendix
provides details on the selected hyperparameters.
Generated datasets. For all experiments, we gen-
erated datasets with 10-15k training examples. In
many experiments, we report training and testing re-
sults on stories with different clause lengths k. (For
brevity, we use the phrase “clause length” through-
out this section to refer to the value k = |BC |, i.e.,
the number of steps of reasoning that are required
to predict the target query.) In all cases, the training
set contains 5000 train stories per k value, and, dur-
ing testing, all experiments use 100 test stories per
k value. All experiments were run 10 times with
different randomly generated stories, and means
and standard errors over these 10 runs are reported.
As discussed in Section 3.5, during training we
holdout 20% of the paraphrases, as well as 10% of
the possible logical clauses.

4.3 Results and Discussion

With our experimental setup in place, we now ad-
dress the three key questions (Q1-Q3) outlined at
the beginning of Section 4.

bedding approaches.

Q1: Systematic Generalization
We begin by using CLUTRR to evaluate the abil-
ity of the baseline models to perform systematic
generalization (Q1). In this setting, we consider
two training regimes: in the first regime, we train
all models with clauses of length k = 2, 3, and in
the second regime, we train with clauses of length
k = 2, 3, 4. We then test the generalization of these
models on test clauses of length k = 2, ..., 10.

Figure 5 illustrates the performance of different
models on this generalization task. We observe that
the GAT model is able to perform near-perfectly on
the held-out logical clauses of length k = 3, with
the BERT-LSTM being the top-performer among
the text-based models but still significantly be-
low the GAT. Not surprisingly, the performance
of all models degrades monotonically as we in-
crease the length of the test clauses, which high-
lights the challenge of “zero-shot” systematic gen-
eralization (Lake and Baroni, 2018; Sodhani et al.,
2018). However, as expected, all models improve
on their generalization performance when trained
on k = 2, 3, 4 rather than just k = 2, 3 (Figure 5,
right). The GAT, in particular, achieves the biggest
gain by this expanded training.

Q2: The Benefit of Structure
The empirical results on systematic generalization
also provide insight into how the text-based NLU
systems compare against the graph-based GAT
model that has full access to the logical graph struc-
ture underlying the stories (Q2). Indeed, the rela-
tively strong performance of the GAT model (Fig-
ure 5) suggests that the language-based models fail
to learn a robust mapping from the natural language
narratives to the underlying logical facts.

To further confirm this trend, we ran experiments



4513

Table 2: Testing the robustness of the various models when training and testing on stories containing various types
of noise facts. The types of noise facts (supporting, irrelevant, and disconnected) are defined in Section 3.5.

Models Unstructured models (no graph) Structured model (with graph)

Training Testing BiLSTM - Attention BiLSTM - Mean RN MAC BERT BERT-LSTM GAT

Clean Clean 0.58 ±0.05 0.53 ±0.05 0.49 ±0.06 0.63 ±0.08 0.37 ±0.06 0.67 ±0.03 1.0 ±0.0
Supporting 0.76 ±0.02 0.64 ±0.22 0.58 ±0.06 0.71 ±0.07 0.28 ±0.1 0.66 ±0.06 0.24 ±0.2
Irrelevant 0.7 ±0.15 0.76 ±0.02 0.59 ±0.06 0.69 ±0.05 0.24 ±0.08 0.55 ±0.03 0.51 ±0.15

Disconnected 0.49 ±0.05 0.45 ±0.05 0.5 ±0.06 0.59 ±0.05 0.24 ±0.08 0.5 ±0.06 0.8 ±0.17

Supporting Supporting 0.67 ±0.06 0.66 ±0.07 0.68 ±0.05 0.65 ±0.04 0.32 ±0.09 0.57 ±0.04 0.98 ±0.01

Irrelevant Irrelevant 0.51 ±0.06 0.52 ±0.06 0.5 ±0.04 0.56 ±0.04 0.25 ±0.06 0.53 ±0.06 0.93 ±0.01

Disconnected Disconnected 0.57 ±0.07 0.57 ±0.06 0.45 ±0.11 0.4 ±0.1 0.17 ±0.05 0.47 ±0.06 0.96 ±0.01

Average 0.61 ±0.08 0.59 ±0.08 0.54 ±0.07 0.61 ±0.06 0.30 ±0.07 0.56 ±0.05 0.77 ±0.09

with modified train and test splits for the text-based
models, where the same set of natural language
paraphrases were used to construct the narratives in
both the train and test splits (see Appendix 1.3 for
details). In this simplified setting, the text-based
models must still learn to reason about held-out log-
ical patterns, but the difficulty of parsing the natural
language is essentially removed, as the same nat-
ural language paraphrases are used during testing
and training. We found that the text-based models
were competitive with the GAT model in this sim-
plified setting (Appendix Figure 1), confirming that
the poor performance of the text-based models on
the main task is driven by the difficulty of parsing
the unseen natural language narratives.

Q3: Robust Reasoning
Finally, we use CLUTRR to systematically eval-
uate how various baseline neural language under-
standing systems cope with noise (Q3). In all the
experiments we provide a combination of k = 2
and k = 3 length clauses in training and testing,
with noise facts being added to the train and/or test
set depending on the setting (Table 2). We use the
different types of noise facts defined in Section 3.5.

Overall, we find that the GAT baseline outper-
forms the unstructured text-based models across
most testing scenarios (Table 2), which showcases
the benefit of a structured feature space for robust
reasoning. When training on clean data and testing
on noisy data, we observe two interesting trends
that highlight the benefits and shortcomings of the
various model classes:
1. All the text-based models excluding BERT ac-

tually perform better when testing on examples
that have supporting or irrelevant facts added.
This suggests that these models actually benefit
from having more content related to the enti-
ties in the story. Even though this content is
not strictly useful or needed for the reasoning

task, it may provide some linguistic cues (e.g.,
about entity genders) that the models exploit. In
contrast, the BERT-based models do not benefit
from the inclusion of this extra content, which
is perhaps due to the fact that they are already
built upon a strong language model (e.g., that
already adequately captures entity genders.)

2. The GAT model performs poorly when support-
ing facts are added but has no performance drop
when disconnected facts are added. This sug-
gests that the GAT model is sensitive to changes
that introduce cycles in the underlying graph
structure but is robust to the addition of noise
that is disconnected from the target entities.

Moreover, when we trained on noisy examples, we
found that only the GAT model was able to consis-
tently improve its performance (Table 2). Again,
this highlights the performance gap between the
unstructured text-based models and the GAT.

5 Conclusion

In this paper we introduced the CLUTRR bench-
mark suite to test the systematic generalization
and inductive reasoning capababilities of NLU sys-
tems. We demonstrated the diagnostic capabilities
of CLUTRR and found that existing NLU systems
exhibit relatively poor robustness and systematic
generalization capabilities—especially when com-
pared to a graph neural network that works directly
with symbolic input. These results highlight the
gap that remains between machine reasoning mod-
els that work with unstructured text and models that
are given access to more structured input. We hope
that by using this benchmark suite, progress can
be made in building more compositional, modular,
and robust NLU systems.



4514

6 Acknowledgements

The authors would like to thank Jack Urbanek,
Stephen Roller, Adina Williams, Dzmitry Bah-
danau, Prasanna Parthasarathy, Harsh Satija for
useful discussions and technical help. The authors
would also like to thank Abhishek Das, Carlos Ed-
uardo Lassance, Gunshi Gupta, Milan Aggarwal,
Rim Assouel, Weiping Song, and Yue Dong for
feedback on the draft. The authors also like to thank
the many anonymous Mechanical Turk participants
for providing paraphrases, and thank Sumana Basu,
Etienne Denis, Jonathan Lebensold, and Komal
Teru for providing human performance measures.
The authors would also like to thank Sanghyun Yoo,
Jehun Jeon and Dr Young Sang Choi of Samsung
Advanced Institute of Technology (SAIT) for sup-
porting the previous workshop version of this work.
The authors are grateful to Facebook AI Research
(FAIR) for providing extensive compute and GPU
resources and support. This research was supported
by the Canada CIFAR Chairs in AI program.

References
Dzmitry Bahdanau, Shikhar Murty, Michael

Noukhovitch, Thien Huu Nguyen, Harm de Vries,
and Aaron Courville. 2019. Systematic generaliza-
tion: What is required and can it be learned? In
International Conference on Learning Representa-
tions.

Samuel R Bowman, Gabor Angeli, Christopher Potts,
and Christopher D Manning. 2015. A large anno-
tated corpus for learning natural language inference.
In Proceedings of the 2015 Conference on Empiri-
cal Methods in Natural Language Processing, pages
632–642.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using rnn encoder–decoder
for statistical machine translation. In Proceedings of
the 2014 Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP), pages 1724–
1734.

Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer,
Luke Vilnis, Ishan Durugkar, Akshay Krishna-
murthy, Alex Smola, and Andrew McCallum. 2018.
Go for a walk and arrive at the answer: Reasoning
over paths in knowledge bases using reinforcement
learning. In International Conference on Learning
Representations.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and
Kristina Toutanova. 2018. Bert: Pre-training of deep
bidirectional transformers for language understand-
ing. arXiv preprint arXiv:1810.04805.

Herve Gallaire and Jack Minker. 1978. Logic and Data
Bases. Perseus Publishing.

Suchin Gururangan, Swabha Swayamdipta, Omer
Levy, Roy Schwartz, Samuel Bowman, and Noah A
Smith. 2018. Annotation artifacts in natural lan-
guage inference data. In Proceedings of the 2018
Conference of the North American Chapter of the
Association for Computational Linguistics: Human
Language Technologies, Volume 2 (Short Papers),
pages 107–112.

Will Hamilton, Payal Bajaj, Marinka Zitnik, Dan Juraf-
sky, and Jure Leskovec. 2018. Embedding logical
queries on knowledge graphs. In S. Bengio, H. Wal-
lach, H. Larochelle, K. Grauman, N. Cesa-Bianchi,
and R. Garnett, editors, Advances in Neural Informa-
tion Processing Systems 31, pages 2026–2037. Cur-
ran Associates, Inc.

Karl Moritz Hermann, Tomas Kocisky, Edward Grefen-
stette, Lasse Espeholt, Will Kay, Mustafa Suleyman,
and Phil Blunsom. 2015. Teaching machines to read
and comprehend. In Advances in Neural Informa-
tion Processing Systems, pages 1693–1701.

Geoffrey E Hinton et al. 1986. Learning distributed
representations of concepts. In Proceedings of the
eighth annual conference of the cognitive science so-
ciety, volume 1, page 12. Amherst, MA.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Drew Arad Hudson and Christopher D. Manning. 2018.
Compositional attention networks for machine rea-
soning. In International Conference on Learning
Representations.

Robin Jia and Percy Liang. 2017. Adversarial exam-
ples for evaluating reading comprehension systems.
In Proceedings of the 2017 Conference on Empiri-
cal Methods in Natural Language Processing, pages
2021–2031.

Justin Johnson, Bharath Hariharan, Laurens van der
Maaten, Li Fei-Fei, C Lawrence Zitnick, and Ross
Girshick. 2017. Clevr: A diagnostic dataset for com-
positional language and elementary visual reason-
ing. In Computer Vision and Pattern Recognition
(CVPR), 2017 IEEE Conference on, pages 1988–
1997. IEEE.

Dimitri Kartsaklis, Mohammad Taher Pilehvar, and
Nigel Collier. 2018. Mapping text to knowl-
edge graph entities using multi-sense lstms. arXiv
preprint arXiv:1808.07724.

Divyansh Kaushik and Zachary C Lipton. 2018. How
much reading does reading comprehension require?
a critical investigation of popular benchmarks. In
Proceedings of the 2018 Conference on Empirical
Methods in Natural Language Processing, pages
5010–5015.

https://openreview.net/forum?id=HkezXnA9YX
https://openreview.net/forum?id=HkezXnA9YX
https://openreview.net/forum?id=Syg-YfWCW
https://openreview.net/forum?id=Syg-YfWCW
https://openreview.net/forum?id=Syg-YfWCW
http://papers.nips.cc/paper/7473-embedding-logical-queries-on-knowledge-graphs.pdf
http://papers.nips.cc/paper/7473-embedding-logical-queries-on-knowledge-graphs.pdf
https://openreview.net/forum?id=S1Euwz-Rb
https://openreview.net/forum?id=S1Euwz-Rb


4515

Stanley Kok and Pedro Domingos. 2007. Statistical
predicate invention. In Proceedings of the 24th Inter-
national Conference on Machine Learning, ICML
’07, pages 433–440, New York, NY, USA. ACM.

Brenden Lake and Marco Baroni. 2018. Generalization
without systematicity: On the compositional skills
of sequence-to-sequence recurrent networks. In In-
ternational Conference on Machine Learning, pages
2879–2888.

Nada Lavrac and Saso Dzeroski. 1994. Inductive logic
programming. In WLP, pages 146–160. Springer.

Alexander Miller, Will Feng, Dhruv Batra, Antoine
Bordes, Adam Fisch, Jiasen Lu, Devi Parikh, and
Jason Weston. 2017. Parlai: A dialog research soft-
ware platform. In Proceedings of the 2017 Con-
ference on Empirical Methods in Natural Language
Processing: System Demonstrations, pages 79–84.

Nasrin Mostafazadeh, Nathanael Chambers, Xiaodong
He, Devi Parikh, Dhruv Batra, Lucy Vanderwende,
Pushmeet Kohli, and James Allen. 2016. A cor-
pus and cloze evaluation for deeper understanding
of commonsense stories. In Proceedings of NAACL-
HLT, pages 839–849.

Stephen Muggleton. 1991. Inductive logic program-
ming. New Generation Computing, 8(4):295–318.

Tri Nguyen, Mir Rosenberg, Xia Song, Jianfeng Gao,
Saurabh Tiwary, Rangan Majumder, and Li Deng.
2016. Ms marco: A human generated machine
reading comprehension dataset. arXiv preprint
arXiv:1611.09268.

Adam Paszke, Sam Gross, Soumith Chintala, Gregory
Chanan, Edward Yang, Zachary DeVito, Zeming
Lin, Alban Desmaison, Luca Antiga, and Adam
Lerer. 2017. Automatic differentiation in pytorch.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word repre-
sentations. In NAACL.

J R Quinlan. 1990. Learning logical definitions from
relations. Mach. Learn., 5(3):239–266.

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and
Percy Liang. 2016. Squad: 100,000+ questions for
machine comprehension of text. In Proceedings of
the 2016 Conference on Empirical Methods in Natu-
ral Language Processing, pages 2383–2392.

Matthew Richardson, Christopher JC Burges, and Erin
Renshaw. 2013. Mctest: A challenge dataset for
the open-domain machine comprehension of text.
In Proceedings of the 2013 Conference on Empiri-
cal Methods in Natural Language Processing, pages
193–203.

Tim Rocktäschel and Sebastian Riedel. 2017. End-to-
end differentiable proving. In Advances in Neural
Information Processing Systems, pages 3788–3800.

Adam Santoro, David Raposo, David G Barrett, Ma-
teusz Malinowski, Razvan Pascanu, Peter Battaglia,
and Timothy Lillicrap. 2017. A simple neural net-
work module for relational reasoning. In Advances
in neural information processing systems, pages
4967–4976.

Shagun Sodhani, Sarath Chandar, and Yoshua. Bengio.
2018. On Training Recurrent Neural Networks for
Lifelong Learning. arXiv e-prints.

Yu Su, Huan Sun, Brian Sadler, Mudhakar Srivatsa,
Izzeddin Gur, Zenghui Yan, and Xifeng Yan. 2016.
On generating characteristic-rich question sets for qa
evaluation. In Proceedings of the 2016 Conference
on Empirical Methods in Natural Language Process-
ing, pages 562–572.

Adam Trischler, Tong Wang, Xingdi Yuan, Justin Har-
ris, Alessandro Sordoni, Philip Bachman, and Ka-
heer Suleman. 2016. NewsQA: A machine compre-
hension dataset. arXiv preprint, pages 1–12.

Petar Veličković, Guillem Cucurull, Arantxa Casanova,
Adriana Romero, Pietro Liò, and Yoshua Bengio.
2018. Graph attention networks. In International
Conference on Learning Representations.

Z. Wang, L. Li, D. D. Zeng, and Y. Chen. 2018.
Attention-based multi-hop reasoning for knowledge
graph. In 2018 IEEE International Conference on
Intelligence and Security Informatics (ISI), pages
211–213.

Johannes Welbl, Pontus Stenetorp, and Sebastian
Riedel. 2018. Constructing datasets for multi-hop
reading comprehension across documents. Transac-
tions of the Association of Computational Linguis-
tics, 6:287–302.

Jason Weston, Antoine Bordes, Sumit Chopra, Alexan-
der M Rush, Bart van Merriënboer, Armand Joulin,
and Tomas Mikolov. 2015. Towards AI-Complete
question answering: A set of prerequisite toy tasks.

Adina Williams, Nikita Nangia, and Samuel Bowman.
2018. A broad-coverage challenge corpus for sen-
tence understanding through inference. In Proceed-
ings of the 2018 Conference of the North American
Chapter of the Association for Computational Lin-
guistics: Human Language Technologies, Volume 1
(Long Papers), volume 1, pages 1112–1122.

Wenhan Xiong, Thien Hoang, and William Yang Wang.
2017. Deeppath: A reinforcement learning method
for knowledge graph reasoning. In Proceedings of
the 2017 Conference on Empirical Methods in Natu-
ral Language Processing, pages 564–573.

Wenhan Xiong, Mo Yu, Shiyu Chang, Xiaoxiao Guo,
and William Yang Wang. 2018. One-shot relational
learning for knowledge graphs. In Proceedings of
the 2018 Conference on Empirical Methods in Natu-
ral Language Processing, pages 1980–1990.

https://doi.org/10.1145/1273496.1273551
https://doi.org/10.1145/1273496.1273551
https://doi.org/10.1007/BF03037089
https://doi.org/10.1007/BF03037089
https://doi.org/10.1007/BF00117105
https://doi.org/10.1007/BF00117105
http://arxiv.org/abs/1811.07017
http://arxiv.org/abs/1811.07017
https://doi.org/10.1016/B978-0-12-800077-9/00020-7
https://doi.org/10.1016/B978-0-12-800077-9/00020-7
https://openreview.net/forum?id=rJXMpikCZ
https://doi.org/10.1109/ISI.2018.8587330
https://doi.org/10.1109/ISI.2018.8587330
https://doi.org/10.1016/j.jpowsour.2014.09.131
https://doi.org/10.1016/j.jpowsour.2014.09.131

