



















































Semantic Expressive Capacity with Bounded Memory


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 65–79
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

65

Semantic expressive capacity with bounded memory

Antoine Venant and Alexander Koller
Department of Language Science and Technology

Saarland University
{venant|koller}@coli.uni-saarland.de

Abstract
We investigate the capacity of mechanisms for
compositional semantic parsing to describe re-
lations between sentences and semantic repre-
sentations. We prove that in order to represent
certain relations, mechanisms which are syn-
tactically projective must be able to remem-
ber an unbounded number of locations in the
semantic representations, where nonprojective
mechanisms need not. This is the first result
of this kind, and has consequences both for
grammar-based and for neural systems.

1 Introduction

Semantic parsers which translate a sentence into
a semantic representation compositionally must
recursively compute a partial semantic represen-
tation for each node of a syntax tree. These
partial semantic representations usually contain
placeholders at which arguments and modifiers
are attached in later composition steps. Ap-
proaches to semantic parsing differ in whether
they assume that the number of placeholders is
bounded or not. Lambda calculus (Montague,
1974; Blackburn and Bos, 2005) assumes that the
number of placeholders (lambda-bound variables)
can grow unboundedly with the length and com-
plexity of the sentence. By contrast, many meth-
ods which are based on unification (Copestake
et al., 2001) or graph merging (Courcelle and En-
gelfriet, 2012; Chiang et al., 2013) assume a fixed
set of placeholders, i.e. the number of placeholders
is bounded.

Methods based on bounded placeholders are
popular both in the design of hand-written gram-
mars (Bender et al., 2002) and in semantic parsing
for graphs (Peng et al., 2015; Groschwitz et al.,
2018). However, it is not clear that all relations be-
tween language and semantic representations can
be expressed with a bounded number of place-
holders. The situation is particularly challenging

when one insists that the compositional analysis
is projective in the sense that each composition
step must combine adjacent substrings of the in-
put sentence. In this case, it may be impossible to
combine a semantic predicate with a distant argu-
ment immediately, forcing the composition mech-
anism to use up a placeholder to remember the ar-
gument position. If many predicates have distant
arguments, this may exceed the bounded “memory
capacity” of the compositional mechanism.

In this paper, we show that there are relations
between sentences and semantic representations
which can be described by compositional mech-
anisms which are bounded and non-projective, but
not by ones which are bounded and projective. To
our knowledge, this is the first result on expressive
capacity with respect to semantics – in contrast to
the extensive literature on the expressive capacity
of mechanisms which describe just the string lan-
guages.

More precisely, we prove that tree-adjoining
grammars can describe string-graph relations us-
ing the HR graph algebra (Courcelle and En-
gelfriet, 2012) with two sources (bounded, non-
projective) which cannot be described using linear
monadic context-free tree grammars and the HR
algebra with k sources, for any fixed k (bounded,
projective). This result is especially surprising be-
cause TAG and linear monadic CFTGs describe
the same string languages; thus the difference lies
only in the projectivity of the syntactic analysis.

We further prove that given certain assump-
tions on the alignment between tokens in the sen-
tence and edges in the graph, no generative de-
vice for projective syntax trees can simulate TAG
with two sources. This has practical consequences
for the design of transition-based semantic parsers
(whether grammar-based or neural).

Plan of the paper. We will first explain the lin-
guistic background in Section 2 and lay the formal

{venant|koller}@coli.uni-saarland.de


66

foundations in Section 3. We will then prove the
reduced semantic expressive capacity for aligned
generative devices in Section 4 and for CFTGs in
Section 5. We conclude with a discussion of the
practical impact of our findings (Section 6).

2 Compositional semantic construction

The Principle of Compositionality, which is
widely accepted in theoretical semantics, states
that the meaning of a natural-language expression
can be determined from the meanings of its im-
mediate subexpressions and the way in which the
subexpressions were combined. Implementations
of this principle usually assume that there is some
sort of syntax tree which describes the grammat-
ical structure of a sentence. A semantic repre-
sentation is then calculated by bottom-up evalua-
tion of this syntax tree, starting with semantic rep-
resentations of the individual words and then re-
cursively computing a semantic representation for
each node from those of its children.

2.1 Compositional mechanisms

Mechanisms for semantic composition will usu-
ally keep track of places at which semantic ar-
guments are still missing or modifiers can still
be attached. For instance, when combining the
semantic representations for “John” and “sleeps”
in a derivation of “John sleeps”, the “subject”
argument of “sleeps” is filled with the meaning
of “John”. The compositional mechanism there-
fore assigns a semantic representation to “sleeps”
which has an unfilled placeholder for the subject.

The exact nature of the placeholder depends on
the compositional mechanism. There are two ma-
jor classes in the literature. Lambda-style compo-
sitional mechanisms use a list of placeholders. For
instance, lambda calculus, as used e.g. in Mon-
tague Grammar (Montague, 1974), CCG (Steed-
man, 2001), or linear-logic-based approaches in
LFG (Dalrymple et al., 1995) might represent
“sleeps” as λx.sleep(x). Placeholders are lambda-
bound variables (here: x).

By contrast, unification-style compositional
mechanisms use names for placeholders. For ex-
ample, a simplified form of the Semantic Al-
gebra used in HPSG (Copestake et al., 2001)
might represent “sleeps” as the feature structure
[subj: 1 , sem:[pred:sleep, agent: 1 ]]. This is uni-
fied with [subj:John]. The placeholders are holes
with labels from a fixed set of argument names

d' chind

< >

em Hans

< >

es huus

< >

lönd

<o1, v>

hälfed

<o2, v>

aastriiche

<o3>
< >

<o2>
< >

<o1>
< >(a)

d' chind

< >

em Hans

< >

es huus

< >

lönd

<o1, v>

hälfed

<o2, v>

aastriiche

<o3>

<o1, o2, v>

<o1, o2, o3>

<o1, o2>

<o1>
< >(b)

Figure 1: (a) Nonprojective and (b) projective analysis.

(e.g. subj). Named placeholders are also used in
the HR algebra (Courcelle and Engelfriet, 2012)
and its derivatives, like Hyperedge Replacement
Grammars (Drewes et al., 1997; Chiang et al.,
2013) and the AM algebra (Groschwitz et al.,
2018).

2.2 Boundedness and projectivity

A fundamental difference between lambda-style
and unification-style compositional mechanisms
is in their “memory capacity”: the number of
placeholders in a lambda-style mechanism can
grow unboundedly with the length and complex-
ity of the sentence (e.g. by functional composition
of lambda terms), whereas in a unification-style
mechanism, the placeholders are fixed in advance.

There is an informal intuition that unbounded
memory is needed especially when an unbounded
number of semantic predicates can be far away
from their arguments in the sentence, and the syn-
tax formalism does not allow these predicates to
combine immediately with the arguments. For
illustration, consider the two derivations of the
following Swiss German sentence from Shieber
(1985) in Fig. 1:

(1) (dass)
(that)

(mer)
(we)

d’ chind
the-children-ACC

em Hans
Hans-DAT

es huus
the-house-ACC

lönd
let

hälfed
help

aastriiche
paint

‘(that we) let the children help Hans paint
the house’

The lexical semantic representation of each verb
comes with a placeholder for its object (o1, o2, o3)
and, in the case of “lönd” and “hälfed”, also one
for its verb complement (v). The derivation in
Fig. 1a immediately combines each verb with its
complements; the placeholders that are used at
each node never grow beyond the ones the verbs



67

originally had. However, this derivation combines
verbs with nouns which are not adjacent in the
string, which is not allowed in many grammar for-
malisms. If we limit ourselves to combining only
adjacent substrings (projectively, see Fig. 1b), we
must remember the placeholders for all the verbs
at the same time if we want to obtain the correct
predicate-argument structure. Thus, the number
of placeholders grows with the length of the sen-
tence; this is only possible with a lambda-style
compositional mechanism.

There is scattered evidence in the literature
for this tension between bounded memory and
projectivity. Chiang et al. (2013) report (of a
compositional mechanism based on the HR al-
gebra, unification-style) that a bounded num-
ber of placeholders suffices to derive the graphs
in the AMR version of the Geoquery corpus,
but Groschwitz et al. (2018) find that this re-
quires non-projective derivations in 37% of the
AMRBank training data (Banarescu et al., 2013).
Approaches to semantic construction with tree-
adjoining grammar either perform semantic com-
position along the TAG derivation tree using unifi-
cation (non-projective, unification-style) (Gardent
and Kallmeyer, 2003) or along the TAG derived
tree using linear logic (projective, lambda-style)
(Frank and van Genabith, 2001). Bender (2008)
discusses the challenges involved in modeling the
predicate-argument structure of a language with
very free word order (Wambaya) with projective
syntax. While the Wambaya noun phrase does not
seem to require the projective grammar to collect
unbounded numbers of unfilled arguments as in
Fig. 1b, Bender notes that her projective analysis
still requires a more flexible handling of seman-
tic arguments than the HPSG Semantic Algebra
(unification-style) supports.

In this paper, we define a notion of semantic
expressive capacity and prove the first formal re-
sults about the relationship between projectivity
and bounded memory.

3 Formal background

Let N0 = {0, 1, . . .} be the nonnegative integers.
A signature is a finite set Σ of function symbols
f , each of which has been assigned a nonnega-
tive integer called its rank. We write Σn for the
symbols of rank n. Given a signature Σ, we say
that all constants a ∈ Σ0 are trees over Σ; further,
if f ∈ Σn and t1, . . . , tn are trees over Σ, then

f(t1, . . . , tn) is also a tree. We write TΣ for the
set of all trees over Σ. We define the height ht(t)
of a tree t = f(t1, . . . , tn) to be 1 + max ht(ti),
and ht(c) = 1 for c ∈ Σ0.

Let X /∈ Σ, and let ΣX = Σ ∪ {X} (with X
as a constant of rank 0). Then we call a tree C ∈
TΣX a context if it contains exactly one occurrence
of X , and write CΣ for the set of all contexts. A
context can be seen as a tree with exactly one hole.
If t ∈ TΣ, we write C[t] for the tree in TΣ that is
obtained by replacing X with t.

Given a string w ∈ W ∗, we write |w|a for the
number of times that a ∈W occurs in w.

3.1 Grammars for strings and trees

We take a very general view on how semantic rep-
resentations for strings are constructed composi-
tionally. To this end, we define a notion of “gram-
mar” which encompasses more devices for de-
scribing languages than just traditional grammars,
such as transition-based parsers.

We say that a tree grammar G over the sig-
nature Σ is any finite device that defines a lan-
guage L(G) ⊆ TΣ. For instance, regular tree
grammars (Comon et al., 2007) are tree grammars,
and context-free grammars can also be seen as tree
grammars defining the language of parse trees.

We say that a string grammar G = (G, yd) over
the signature Σ and the alphabet W is a pair con-
sisting of a tree grammar G over Σ and a yield
function yd : TΣ → W ∗ which maps trees to
strings over W (Weir, 1988). A string grammar
defines a language L(G) = {yd(t) | t ∈ L(G)} ⊆
W ∗. We call the trees t ∈ L(G) derivations.

A particularly common yield function is the
function ydpr, defined as ydpr(f(t1, . . . , tn)) =
ydpr(t1) · . . . · ydpr(tn) if n > 0 and ydpr(c) = c
if c has rank 0. This yield function simply con-
catenates the words at the leaves of t. Applied
to the phrase-structure tree t in Fig. 2c, ydpr(t)
is the Swiss German sentence in (1). Context-free
grammars can be characterized as string grammars
that combine a regular tree grammar with ydpr.
By contrast, we can model tree-adjoining gram-
mars (TAG, Joshi and Schabes, 1997) by choosing
a tree grammarG that describes derivation trees as
in Fig. 2b. The yd function could then substitute
and adjoin the elementary trees as specified by the
derivation tree (see Fig. 2a) and then read off the
words from the resulting derived tree in Fig. 2c.

We say that a string grammar is projective if



68

(a) (b) (d)S

NP↓ VP
lönd

NP

d' chind

VP

VP*

NP↓

hälfedNP

em Hans

VP

VP

VP*

NP↓

aastriicheNP

es huus

VP

(e)

help

AR
G

1 ARG2

paint

AR
G

1

let

AR
G

1

ARG2

<o1> <o2> <o3>

<rt>

help

AR
G1

ARG2 paint
(f)

AR
G1

(c) S

lönd

NP

d' chind

VP

VP hälfed

NP

em Hans

VP

VP aastriiche

NP

es huus

VP
(→ e)

hälfed

Hans aastriiche

huus

lönd

chind (→ f)
(→ g)

Hans house

children

<rt>(g)
<rt>

help

AR
G

1 ARG2

paint

AR
G

1

let

AR
G

1

ARG2

children Hans house

Figure 2: Semantic construction with TAG: (a) TAG derivation, (b) derivation tree, (c) derived tree, (d) semantic
graph. (e) s-graph interpretations of the boxed node in (c); (f,g) s-graph interpretations at the boxed nodes in (b).

its yield function is ydpr. Context-free grammars
as construed above are clearly projective. Tree-
adjoining grammars are not projective: For in-
stance, the yield of the subtree below “aastriiche”
in Fig. 2b consists of the two separate strings “es
Huus” and “aastriiche”, which are then wrapped
around “lönd hälfed” further up in the derivation.

If the grammar is projective, then for any con-
text C there exist two strings left(C) and right(C)
such that for any tree t, yd(C[t]) = left(C) ·yd(t) ·
right(C).

3.2 Context-free tree languages

Below, we will talk about linear monadic context-
free tree grammars (LM-CFTGs; Rounds (1969),
Comon et al. (2007)). An LM-CFTG is a quadru-
ple G = (N,Σ, R, S), where N is a ranked sig-
nature of nonterminals of rank at most one, Σ is a
ranked signature of terminals, S ∈ N0 is the start
symbol, and R is a finite set of production rules of
one of the forms
• A→ t with A ∈ N0 and t ∈ TV
• A(t)→ C[t] with A ∈ N1 and C ∈ CV ,

where V = N ∪ Σ. The trees in L(G) ⊆ TΣ are
obtained by expanding S with production rules.
Nonterminals of rank zero are expanded by replac-
ing them with trees. Nonterminals of rank one
must have exactly one child in the tree; they are
replaced by a context, and the variable in the con-
text is replaced by the subtree below the child.

We can extend an LM-CFTG G to a string
grammar G = (G, ydpr). Then LM-CFTG is
weakly equivalent to TAG (Kepser and Rogers,
2011); that is, LM-CFTG and TAG generate the
same class of string languages. Intuitively, the
weakly equivalent LM-CFTG directly describes
the language of derived trees of the TAG grammar
(cf. Fig. 2c). Notice that LM-CFTG is projective.

Below, we will make crucial use of the follow-
ing pumping lemma for LM-CFTLs:

Lemma 1 (Maibaum (1978)). Let G be an LM-
CFTG. There exists a constant p ∈ N0 such that
for any t ∈ L(G) with ht(t) > p, there ex-
ists a decomposition t = C1[C2[C3[C4[t5]]]] with
ht(C2[C3[C4[X]]]) ≤ p and ht(C2) + ht(C4) > 0
such that for any i ∈ N0, C1[vi[t5]] ∈ L(G),
where we let v0 = C3 and vi+1 = C2[vi[C4[X]]].

We call p the pumping height of L(G).

3.3 The HR algebra

The specific unification-style semantic algebra we
use in this paper is the HR algebra (Courcelle and
Engelfriet, 2012). This choice encompasses much
of the recent literature on compositional semantic
parsing with graphs, based e.g. on Hyperedge Re-
placement Grammars (Chiang et al., 2013; Peng
et al., 2015; Koller, 2015) and the AM algebra
(Groschwitz et al., 2018).

The values of the HR algebra are s-graphs: di-
rected, edge-labeled graphs, some of whose nodes
may be designated as sources, written in angle
brackets. S-graphs can be combined using the
forget, rename, and merge operations. Rename
rena→b changes an a-source node into a b-source
node. Forget fa makes it so the a-source node in
the s-graph is no longer a source node. Merge ||
combines two s-graphs while unifying nodes with
the same source annotation. For instance, the s-
graphs 〈rt〉 ARG1−−→ 〈o〉 and 〈o〉 Hans are merged into
〈rt〉 ARG0−−→ 〈o〉 Hans.

The HR algebra uses operation symbols from a
ranked signature ∆ to describe s-graphs syntacti-
cally. ∆ contains symbols for merge (rank 2) and
the forget and rename operations (rank 1). It also
contains constants (symbols of rank 0) which de-
note s-graphs of the form 〈a〉 f−→ 〈b〉 and 〈a〉 f ,
where a, b are sources and f is an edge label.
Terms t ∈ T∆ over this signature evaluate recur-
sively to s-graphs JtK, as usual in an algebra. Each
instance of the HR algebra uses a fixed, finite set
of k source names which can be used in the con-



69

stant s-graphs and the rename and forget opera-
tions. The class of graphs which can be expressed
as values of terms over the algebra increases with
k. We write Hk for the HR algebra with k source
names (and some set of edge labels).

Let G be an s-graph, and let G′ be a subgraph
of G, i.e. a subset of its edges. We call a node
a boundary node of G′ if it is incident both to an
edge in G′ and to an edge that is not in G′. For
instance, the s-graph in Fig. 2e is a subgraph of
the one in Fig. 2d; the boundary nodes are drawn
shaded in (d). The following lemma holds:

Lemma 2. Let G = JC[t]K be an s-graph, and let
G′ be a subgraph of G such that the s-graph JtK
contains the same edges as G′. Then every bound-
ary node in G′ is a source in JtK.

3.4 Grammars with semantic interpretations
Finally, we extend string grammars to composi-
tionally relate strings with semantic representa-
tions. Let G = (G, yd) be a string grammar. The
tree grammar G generates a language L(G) ⊆ TΣ
of trees. We will map each tree t ∈ L(G) into
a term h(t) over some algebra A over a signa-
ture ∆ using a linear tree homomorphism (LTH)
h : TΣ → T∆ (Comon et al., 2007), i.e. by compo-
sitional bottom-up evaluation. This defines a rela-
tion between strings and values of A:

REL(G, h,A) = {(yd(t), Jh(t)KA) | t ∈ L(G)}

For instance, A could be some HR algebra Hk;
then REL(G, h,Hk) will be a binary relation be-
tween strings and s-graphs. In this case, we abbre-
viate Jh(t)K as graph(t).

If we look at an entire class G of string gram-
mars and a fixed algebra, this defines a class of
such relations:

L(G,A) = {REL(G, h,A) | G ∈ G, h LTH }.

In the example in Fig. 2, we can define a linear
homomorphism h to map the derivation tree t in
(b) to a term h(t) which evaluates to the s-graph
shown in (d). At the top of this term, the s-graphs
at the “chind” and “hälfed” (f,g) nodes are com-
bined into (d) by h(lönd):

h(lönd) =〈rt〉 let

|| fo(〈rt〉
ARG1−−→ 〈o〉 || renrt→o(G(f)))

|| fo(〈rt〉
ARG2−−→ 〈o〉 || renrt→o(G(g)))

This non-projective derivation produces the s-
graph in (d) using only two sources, rt and o. By

a b b

c d d

a
a

c

b

Figure 3: The CSD graph for ((2), (1, 0), (1), (0, 0));
blocks indicated by gray boxes.

contrast, a homomorphic interpretation of the pro-
jective tree (c) has to use at least four sources, as
the intermediate result in (e) illustrates.

4 Projective cross-serial dependencies

We will now investigate the ability of projec-
tive grammar formalisms (G,Hk) to express
L(TAG,H2). We will define a relation CSD ∈
L(TAG,H2) and prove that CSD cannot be gen-
erated by projective grammar formalisms with
bounded k. We show this first for arbitrary projec-
tive G, under certain assumptions on the alignment
of words and graph edges. In Section 5, we drop
these assumptions, but focus on G = LM-CFTG.

4.1 The relation CSD

To construct CSD, consider the string language
CSDs = {AnBmCnDm | m,n ≥ 1}, where

A = {a 〈k ak 〉k | k ≥ 0},

and analogously for B,C,D. An example string
in CSDs is a〈〈aa〉〉 b〈b〉 b c〈c〉 d d. Note that k
can be chosen independently for each segment.

Every string w ∈ CSDs can be uniquely
described by m, n, and a sequence K(w) =
(K(a),K(b),K(c),K(d)) of numbers specifying
the k’s used in each segment, where K(a),K(c)

each contain n numbers and K(b),K(d) contain m
numbers. In the example, we have n = 1, m = 2,
and K(w) = ((2), (1, 0), (1), (0, 0)).

We associate a graph Gw with each string w ∈
CSDs by the construction illustrated in Fig. 3. For
each 1 ≤ i ≤ n, we define the i-th a-block to be
the graph consisting of nodes u c−→ v with a further
outgoing a-edge from u. In addition, u connects
to a linear chain of K(a)i edges with label a, and v
to a linear chain of K(c)i c-edges. Gw consists of
a linear chain of the n a-blocks, followed by the
m b-blocks (defined analogously). We let CSD =
{(w,Gw) | w ∈ CSDs}.



70

*1

a

b

*1

b! *0

*0

*0
c d

d

→ (a)

b<rt>

d G0

<rt>

d

b

d

b

a<rt>

c d

b

d

b

→ (b)

→ (c)

→ (c)
→ (d)

(a)

(b)

(c) (d)

Figure 4: An derivation of ((0), (0,0), (0), (0,0)).

Note that CSD is a more intricate version of the
cross-serial dependency language. CSD can be
generated by a TAG grammar along the lines of
the one from Section 3.4, using a HR algebra with
two sources; thus CSD ∈ L(TAG,H2).

4.2 CSD with bounded blocks

The characteristic feature of CSD is that edges
which are close together in the graph (e.g. the a
and c edge in an a-block) correspond to symbols
that can be distant in the string (e.g. a and c to-
kens). Projective grammars cannot combine pred-
icates (a) and arguments (c) directly because of
their distance in the string; intuitively, they must
keep track of either the c’s or the a’s for a long
time, which cannot be done with a bounded k.

Before we go into exploiting this intuition, we
first note that its correctness depends on the details
of the construction of CSD, in particular the abil-
ity to select arbitrary and independentK(x) for the
different x ∈ {a, b, c, d}. Consider the derivation
t on the left of Fig. 4 with its projective yield
abbcdd; this is the case ((0), (0, 0), (0), (0, 0)) of
CSD, corresponding to the CSD graph G1 shown
in Fig. 4 (a). We can map t to this graph by
applying the following linear tree homomorphism
h intoH2:
h(∗1) = fs(x1 || renrt→s(x2)) h(∗0) = x1
h(b) = d←− b〈rt〉 −→ 〈s〉 h(b!) = d←− b〈rt〉
h(a) = c←− a〈rt〉 −→ 〈s〉

A derivation of the form ∗0(t1, t2) evaluates to the
same graph as t1; the graph value of t2 is ignored.
Thus if we assume that the subtree of t for cdd
evaluates to some arbitrary graphG0, the complete
derivation t evaluates to G1. Some intermediate
results are shown on the right of Fig. 4.

If we let CSD0 be the subset of CSD where all
K(x) are zero, we can generalize this construction
into an LM-CFTG which generates CSD0. Thus,

CSD0 can be generated by a projective grammar
that is interpreted into H2. But note that the
derivation in Fig. 4 is unnatural in that the symbols
in the string are not generated by the same deriva-
tion steps that generate the graph nodes that intu-
itively correspond to them; for instance, the graphs
generated for the d tokens are completely irrele-
vant. Below, we prevent unnatural constructions
like this in two ways. We will first assume that
string symbols and graph nodes must be aligned
(Thm. 1). Then we will assume that the K(x) can
be arbitary, which allows us to drop the alignment
assumption (Thm. 2).

4.3 k-distant trees
Let R ⊇ CSD0 be some relation containing at
least the string-graph pairs of CSD0, e.g. CSD it-
self. Assume that R is generated by a projec-
tive grammar (G, h) with G = (G, ydpr) and a
fixed number k of sources, i.e. we have R =
REL(G, h,Hk). We will prove a contradiction.

Given a pair (w,Gw) ∈ R, we say that two
edges e, f in Gw are equivalent, e ≡ f , if they be-
long to the same block. We call a derivation tree
t ∈ T = L(G) k-distant if t has a subtree t′ such
that we can find k edges e1, . . . , ek ∈ graph(t′)
with ei 6≡ ej for all i 6= j and k further edges
e′1, . . . , e

′
k ∈ Gw\ graph(t′) such that ei ≡ e′i for

all i. For such trees, we have the following lemma.
Lemma 3. A k-distant tree has a subtree t′ such
that graph(t′) has at least k sources.
Proof. Let BKi be the i-th block in Gw; we let
1 ≤ i ≤ m + n and do not distinguish between
a- and b-blocks. Let t′ be the subtree of t claimed
by the definition of distant trees. For each i, let
E′i = BKi ∩ graph(t′) be the edges in the i-th
block generated by t′, and let Ei = BKi\E′i.

By definition,Ei andE′i are both non-empty for
at least k blocks. Each of these blocks is weakly
connected, and thus contains at least one node ui
which is incident both to an edge in Ei and in E′i.
This node is a boundary node of graph(t′). Be-
cause u1, . . . , uk are all distinct, it follows from
Lemma 2 that graph(t′) has at least k sources.

We also note the following lemma about deriva-
tions of projective string grammars, which fol-
lows from the inability of projective grammars
to combine distant tokens. We write Sep =
{a/c, c/a, b/d, d/b}.
Lemma 4. Let G = (G, yd) be a projective string
grammar. For any r ∈ N0 there exists s ∈ N0 such



71

that any t ∈ L(G) with yd(t) ∈ a∗bscsd∗ has a
subtree t′ such that yd(t′) contains r occurrences
of x and no occurrences of y, for some x/y ∈ Sep.

4.4 Projectivity and alignments
A consequence of Lemma 3 is that if certain
string-graph pairs in CSD0 can only be expressed
with k+1-distant trees, then R (which contains
these pairs as well) is not in L(G,Hk), because
Hk only admits k sources.

However, as we saw in Section 4.2, pairs in
CSD0 can have unexpected projective derivations
which make do with a low number of sources.
So let’s assume for now that the string grammar
G and the tree homomorphism h produce tokens
and edge labels that fit together. Let us call G, h
aligned if for all constants c ∈ Σ0, graph(c) is a
graph containing a single edge with label yd(c).
The derivation in Fig. 4 cannot be generated by
an aligned grammar because the graph for the to-
ken b contains a d-edge. We write L↔(G,A) =
{REL(G, h,A) | G ∈ G and G, h aligned} for the
class of string-semantics relations which can be
generated with aligned grammars.

Under this assumption, it is easy to see that any
relation including CSD0 (hence, CSD) cannot be
expressed with a projective grammar.

Theorem 1. Let G be any class of projective
string grammars and R ⊇ CSD0. For any k,
R 6∈ L↔(G,Hk).
Proof. Assume that there is a G = (G, ydpr) ∈
G and an LTH h such that R = REL(G, h,Hk).
Given k, choose s ∈ N0 such that every tree t ∈
T = L(G) with yd(t) = asbscsds has a subtree
t′ such that yd(t′) contains k + 1 occurrences of
x and no occurrences of y, for some x/y ∈ Sep.
Such an s exists according to Lemma 4. We can
choose t such that (yd(t), graph(t)) ∈ CSD0.

Because G, h are aligned, graph(t′) contains no
y-edge and at least k + 1 x-edges. Each of these
x-edges is non-equivalent to all the others, and
equivalent to a y-edge in graph(t)\ graph(t′), so
t is k+1-distant. It follows from Lemma 3 that
graph(t′) has k+1 sources, in contradiction to the
assumption that G, h uses only k sources.

5 Expressive capacity of LM-CFTG

Thm. 1 is a powerful result which shows that CSD
cannot be generated by any device for generating
projective derivations using bounded placeholder

memory – if we can assume that tokens and edges
are aligned. We will now drop this assumption and
prove that CSD cannot be generated using a fixed
set of placeholders using LM-CFTG, regardless of
alignment. The basic proof idea is to enforce a
weak form of alignment through the interaction of
the pumping lemma with very long x-chains. The
result is remarkable in that LM-CFTG and TAG
are weakly equivalent; they only differ in whether
they must derive the strings projectively or not.

Theorem 2. CSD 6∈ L(LM-CFTG,Hk), for any
k.

5.1 Asynchronous derivations
Assume that CSD = REL(G, h,Hk), for some
k, with G = (G, yd) an LM-CFTG. Proving that
this is a contradiction hinges on a somewhat tech-
nical concept of asynchronous derivations, which
have to do with how the nodes generating edge la-
bels such as a are distributed over a derivation tree.
We prove that all asynchronous derivations of cer-
tain elements of CSD are distant (Lemma 5), and
that all LM-CFTG derivations of CSD are asyn-
chronous (Lemma 6), which proves Thm. 2.

In what follows, Let T = L(G). let us write
for any tree or context t and symbol x, ntx as a
shorthand for | yd(t)|x, etx for the number of x-
edges in graph(t) andmtx for the maximum length
of a string in x∗ which is also substring of yd(t).

Definition 1 (x, y, l-asynchronous derivation). Let
x/y ∈ Sep, l > 0, t ∈ T, We call t an x, y, l-
asynchronous derivation iff there is a decomposi-
tion t = C[t′] such that

et
′
y ≥ nty − ntxl −mty
et

′
x ≤ ntxl +mtx(l + 1).

We call the pair (C, t′) an x, y, l-asynchronous
split of t.

Lemma 5. For any k, l > 0, there is a pair
ok,l = (wk,l, Gk,l) ∈ CSD such that every x, y, l-
asynchronous t with ok,l = (yd(t), graph(t)) is k-
distant.

Proof. For x ∈ {a, b, c, d} and m ∈ N0, let x(m)
denote the word 〈m xm 〉m. Let r = s = 3l+k+1
and ok,l = (wk,l, Gk,l) be the unique element of
CSD such that

wk,l = (aa
(s))r(bb

(s)
)r(cc(s))r(dd

(s)
)r.

Let t be an a, c, l-asynchronous derivation of
ok,l; other choices of x/y ∈ Sep are analogous.



72

By definition, we can split t = C[t′] such that
graph(t′) has at most qa = lr+(l+1)s = (2l+1)s
a-edges and at least qc = rs−rl−s = (2l+k+1)s
c-edges. Notice first that graph(t′) contains at
most 2l + 1 different complete a-blocks of Gk,l,
because each a-block contains s a-edges. Having
2l + 2 of them would require (2l + 2)s a-edges,
which is more than the qa a-edges that graph(t′)
can contain.

Next, consider 2l + k distinct a-blocks of Gk,l.
These blocks contain a total of (2l + k)s < (2l +
k + 1)s = qc c-edges. Hence, the c-edges of
graph(t′) cannot be contained within only 2l + k
distinct blocks.

So we can find at least 2l + k + 1 c-edges
in graph(t′) which are pairwise non-equivalent.
There are at least k edges among these which are
equivalent to an edge in Gk,l \ graph(t′), because
graph(t′) contains at most l complete a-blocks of
Gk,l. Thus, t is k-distant.

5.2 LM-CFTG derivations are asynchronous

So far, we have not used the assumption that T
is an LM-CFTL. We will now exploit the pump-
ing lemma to show that all derivation trees of an
LM-CFTG for CSD must be asynchronous.

Lemma 6. If T is an LM-CFTL, then there exists
l0 ∈ N0 such that for every t ∈ T, there exists
x/y ∈ Sep such that t is x, y, l0-asynchronous.

We prove this lemma by appealing to a class of
derivation trees in which predicate and argument
tokens are generated in separate parts.

Definition 2 (x, y, l-separated derivation). Let
x/y ∈ Sep. A tree t ∈ T∆ is x, y, l-separated if we
can write t = Cx[C0[ty]] such that | yd(ty)|x = 0
and | yd(Cx)|y = 0 and | yd(C0)|x ≤ l. The
triple (Cx, C0, ty) is called an l-separation of t.
We call an l-separation minimal if there is no other
l-separation of t with a smaller C0.

Intuitively, we can use the pumping lemma to
systematically remove some contexts from a t ∈
T. From the shape of CSD, we can conclude
certain alignments between the strings and graphs
generated by these contexts and establish bounds
on the number of x- and y-edges generated by the
lower part of a separated derivation. The full proof
is in the appendix; we sketch the main ideas here.

Let p denote the pumping height of T. There is
a maximal number of string tokens and edges that
a context of height at most p can generate under

a given yield and homomorphism. We call this
number l0 in the rest of the proof.
Lemma 7. For t ∈ T, let rty be the length of the
maximal substring of yd(t) consisting in only y-
tokens and containing the rightmost occurrence of
y in yd(t). If t is x, y, l0-separated, there exists
a minimal x, y, l0-separation Dx[D0[ty]] of t such
that, letting t0 = D0[ty], et0y ≥ nty − ntxl0 − rty.

Moreover, for any x, y, l0-separation t =
Ex[E0[t

1
y]], letting t1 = E0[t

1
y], e

t1
x ≤ n

t1
x + n

t
xl0.

Proof (sketch). Both statements must be
achieved in separated inductions on the height
of t, although they mostly follow similar steps.
We therefore focus here only on the crucial
parts of the (slightly trickier) bound on et0y . Let
Dx[D0[ty]] be a minimal x, y, l0-separation of t
and t0 = D0[ty].

Base Case If ht(t) ≤ p, we have nty ≤ l0. We
also have ntx > 0, so n

t
y − ntxl0 − rty ≤ 0 ≤ e

t0
ȳ .

Induction step If h(t) > p, we apply
Lemma 1 to t to yield a decomposition t =
C1[C2[C3[C4[t5]]]], where t′ = C1[C3[t5]] ∈ T,
ht(t′) < ht(t) and ht(C2[[C3]C4]) ≤ p. We first
observe that t′ is x, y, l0-separated. By induction,
there exists a minimal separation t′ = Cx[C0[t′y]]

with t′0 = C0[t
′
y] validating the bound on e

t′0
y . Be-

cause of pumping considerations, we need to dis-
tinguish only three configurations of C2 and C4.
We present only the most difficult case here.

In this case C2 and C4 generate only one kind
of bar symbol, y, and brackets. One needs to ex-
amine all possible ways C2, C4 and t0 may over-
lap. We detail the reasoning in the case where t0
does not overlap with C2 or C4. Then, since all
y-tokens are generated by t0, projectivity of the
yield and the definition of CSD impose that the
generated y-tokens contribute to the rightmost y-
chain i.e. rty = r

t′
y + n

C2[C4]
y . Hence e

t0
y ≥ e

t′0
y ≥

nty − n
C2[C4]
y + n

t
xl0 − r

t0
y + n

C2[C4]
y .

Lemma 8. For any t ∈ T, if t is x, y, l0-separated
then t is x, y, l0-asynchronous.
Proof. By Lemma 7 there is a minimal x, y, l0-
separation t = Dx[D0[ty]] such that, for t0 =
D0[ty], the bound on et0y and the bound on e

t0
x both

obtain. Observe that rty ≤ mty by definition, and
since t0 generates at most l0 x-tokens, by projec-
tivity it generates at most (l0+1)mtx x-tokens (one
sequence ofmtx between each occurrence of x and
the next, plus possibly one before the first and one
after the last). Thus t is x, y, l0-asynchronous.



73

Lemma 9. For any t ∈ T, t is x, y, l0-separated
for some x/y ∈ Sep.
Proof (sketch). The proof proceeds by induction
on the height of t.

If ht(t) ≤ p, then | yd(t)|z ≤ l0 for any z ∈
{a, b, c, d}, hence t is trivially x, y, l0-separated
for some x/y ∈ Sep.

If h(t) > p, Lemma 1 yields a decomposition
t = C1[C2[C3[C4[t5]]]], where t′ = C1[C3[t5]] ∈
T, ht(t′) < ht(t) and ht(C2[C3[C4]]) ≤ p. By
induction t′ is x, y, l0-separated for some x/y ∈
Sep. Let us assume x/y = a/c, other cases are
analoguous. The challenge is to conclude to the
x, y, l separation of t, after reinsertion of C2 and
C4 in t′.

If C2 and C4 generate no a- or c-token, the dis-
tribution of a- and c-tokens in the tree is not af-
fected, hence t is a, c, l0-separated. Otherwise,
due to pumping considerations, we need to distin-
guish three possible configurations regarding the
shape of the yields of C2 and C4. We present one
here, see the appendix for the others; they are in
the same spirit.

We consider the case where left(C2) contains
some a-token and no b, c, d-tokens, and yd(C4)
contains some c-token. Assume left(C4) contains
some c. It follows that all b-tokens are generated
by C3. So t has less than l0 b-tokens, by defini-
tion of CSD it has then also less than l0 d-tokens,
so (C1, C2[C3[C4]], t5) is a d, b, l0-separation. As-
sume now that right(C4) contains some c. It fol-
lows that t5 generate no d-token and C1 gener-
ate no b-token. Hence (C1, C2[C3[C4]], t5) is a
b, d, l0-separation.

This concludes the proof of Lemma 6 and Thm. 2.

6 Conclusion

We have established a notion of expressive capac-
ity in compositional semantic parsing. We have
proved that non-projective grammars can express
sentence-meaning relations with bounded memory
that projective ones cannot. This answers an old
question in the design of compositional systems:
assuming projective syntax, lambda-style com-
positional mechanisms can be more expressive
than unification-style ones, which have bounded
“memory” for unfilled arguments.

From a theoretical perspective, the stronger re-
sult of this paper is perhaps Thm. 2, which shows
without further assumptions that weakly equiva-
lent grammar formalisms can differ in their se-

mantic expressive capacity. However, Thm. 1 may
have a clearer practical impact on the development
of compositional semantic parsers. Consider, for
instance, the case of CCG, a lexicalized grammar
formalism that has been widely used in seman-
tic parsing (Bos, 2008; Artzi et al., 2015; Lewis
et al., 2016). While a potentially infinite set of
syntactic categories can be used in the parses of
a single CCG grammar, CCG derivations are still
projective in our sense. Thus, if one assumes that
derivations should be aligned (which is natural for
a lexicalized grammar), Thm. 1 implies that CCG
with lambda-style semantic composition is more
semantically expressive than with unification-style
composition. Indeed, lambda-style compositional
mechanisms are the dominant approach in CCG
(Steedman, 2001; Baldridge and Kruijff, 2002;
Artzi et al., 2015).

Furthermore, under the alignment assumptions
of Section 4, no unification-style compositional
mechanism can describe string-meaning relations
like CSD. This includes neural models. For in-
stance, most transition-based parsers (Nivre, 2008;
Andor et al., 2016; Dyer et al., 2016) are projec-
tive, in that the parsing operations can only con-
catenate two substrings on the top of the stack if
they are adjacent in the string. Such transition sys-
tems can therefore not be extended to transition-
based semantic parsers (Damonte et al., 2017)
without (a) losing expressive capacity, (b) giving
up compositionality, (c) adding mechanisms for
non-projectivity (Gómez-Rodrı́guez et al., 2018),
or (d) using a lambda-style semantic algebra. Thus
our result clarifies how to build an effective and
accurate semantic parser.

We have focused on whether a grammar formal-
ism is projective or not, while holding the seman-
tic algebra fixed. In the future, it would be inter-
esting to explore how a unification-style composi-
tional mechanism can be converted to a lambda-
style mechanism with unbounded placeholders.
This would allow us to specify and train semantic
parsers using such abstractions, while benefiting
from the efficiency of projective parsers.

Acknowledgments

We are grateful to Emily Bender, Guy Emerson,
Meaghan Fowlie, Jonas Groschwitz, and the par-
ticipants of the DELPH-IN workshop 2018 for
fruitful discussions, and to the anonymous review-
ers for their insightful feedback.



74

References
Daniel Andor, Chris Alberti, David Weiss, Aliaksei

Severyn, Alessandro Presta, Kuzman Ganchev, Slav
Petrov, and Michael Collins. 2016. Globally nor-
malized transition-based neural networks. In Pro-
ceedings of ACL.

Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.
Broad-coverage CCG Semantic Parsing with AMR.
In Proceedings of the 2015 Conference on Empirical
Methods in Natural Language Processing.

Jason Baldridge and Geert-Jan M. Kruijff. 2002. Cou-
pling CCG and Hybrid Logic Dependency Seman-
tics. In Proceedings of the 40th ACL.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract Meaning Representation
for Sembanking. In Proceedings of the 7th Linguis-
tic Annotation Workshop and Interoperability with
Discourse.

Emily M. Bender. 2008. Radical non-
configurationality without shuffle operators:
An analysis of Wambaya. In Proceedings of the
15th International Conference on HPSG.

Emily M. Bender, Dan Flickinger, and Stephan Oepen.
2002. The Grammar Matrix: An open-source
starter-kit for the rapid development of cross-
linguistically consistent broad-coverage precision
grammars. In Proceedings of the COLING Work-
shop on Grammar Engineering and Evaluation.

Patrick Blackburn and Johan Bos. 2005. Represen-
tation and Inference for Natural Language. CSLI
Publications.

Johan Bos. 2008. Wide-coverage semantic analy-
sis with Boxer. In Semantics in Text Processing.
STEP 2008 Conference Proceedings. College Pub-
lications.

David Chiang, Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, Bevan Jones, and Kevin
Knight. 2013. Parsing graphs with hyperedge
replacement grammars. In Proceedings of the 51st
ACL.

Hubert Comon, Max Dauchet, Rémi Gilleron, Flo-
rent Jacquemard, Denis Lugiez, Sophie Tison, Marc
Tommasi, and Christof Löding. 2007. Tree Au-
tomata techniques and applications. Published on-
line at http://tata.gforge.inria.fr/.

Ann Copestake, Alex Lascarides, and Dan Flickinger.
2001. An algebra for semantic construction in
constraint-based grammars. In Proceedings of the
39th ACL.

Bruno Courcelle and Joost Engelfriet. 2012. Graph
Structure and Monadic Second-Order Logic, a Lan-
guage Theoretic Approach. Cambridge University
Press.

Mary Dalrymple, John Lamping, Fernando C. N.
Pereira, and Vijay Saraswat. 1995. Linear logic for
meaning assembly. In Proceedings of the Workshop
on Computational Logic for Natural Language Pro-
cessing.

Marco Damonte, Shay B. Cohen, and Giorgio Satta.
2017. An incremental parser for Abstract Meaning
Representation. In Proceedings of the 15th EACL.

Frank Drewes, Hans-Jörg Kreowski, and Annegret Ha-
bel. 1997. Hyperedge replacement graph gram-
mars. In G. Rozenberg, editor, Handbook of Graph
Grammars and Computing by Graph Transforma-
tion, pages 95–162. World Scientific.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In Proceedings of NAACL.

Anette Frank and Josef van Genabith. 2001. GlueTag:
Linear logic based semantics for LTAG. In Proceed-
ings of the LFG Conference.

Claire Gardent and Laura Kallmeyer. 2003. Semantic
construction in feature-based TAG. In Proceedings
of EACL.

Jonas Groschwitz, Matthias Lindemann, Meaghan
Fowlie, Mark Johnson, and Alexander Koller. 2018.
AMR dependency parsing with a typed semantic al-
gebra. In Proceedings of ACL.

Carlos Gómez-Rodrı́guez, Tianze Shi, and Lillian Lee.
2018. Global transition-based non-projective depen-
dency parsing. In Proceedings of ACL.

Aravind K. Joshi and Yves Schabes. 1997. Tree-
Adjoining Grammars. In G. Rozenberg and A. Salo-
maa, editors, Handbook of Formal Languages, vol-
ume 3. Springer-Verlag.

Stephan Kepser and James Rogers. 2011. The equiva-
lence of tree adjoining grammars and monadic linear
context-free tree grammars. Journal of Logic, Lan-
guage and Information, 20(3):361–384.

Alexander Koller. 2015. Semantic construction with
graph grammars. In Proceedings of the 11th Inter-
national Conference on Computational Semantics,
pages 228–238.

Mike Lewis, Kenton Lee, and Luke Zettlemoyer. 2016.
LSTM CCG Parsing. In Proceedings of the 2016
Conference of the North American Chapter of the
Association for Computational Linguistics: Human
Language Technologies.

T. Maibaum. 1978. Pumping lemmas for term lan-
guages. Journal of Computer and System Sciences,
pages 319–330.

Richard Montague. 1974. The proper treatment of
quantification in ordinary English. In R. Thoma-
son, editor, Formal philosophy: Selected papers
of Richard Montague. Yale University Press, New
Haven.

http://tata.gforge.inria.fr/
http://tata.gforge.inria.fr/
http://tata.gforge.inria.fr/


75

Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Computational Lin-
guistics, 34(4):513–553.

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A synchronous hyperedge replacement gram-
mar based approach for AMR parsing. In Proceed-
ings of the 19th Conference on Computational Lan-
guage Learning.

William Rounds. 1969. Context-free grammars on
trees. In Proceedings of the First Annual ACM Sym-
posium on Theory of Computing (STOC).

Stuart M. Shieber. 1985. Evidence against the context-
freeness of natural language. Linguistics and Phi-
losophy, 8(3):333–343.

Mark Steedman. 2001. The Syntactic Process. MIT
Press, Cambridge, MA.

David Weir. 1988. Characterizing mildly context-
sensitive grammar formalisms. Ph.D. thesis, Uni-
versity of Pennsylvania.

A Details of the proof of Theorem 1

Lemma 4. Let G = (G, yd) be a projective string
grammar. For any r ∈ N0 there exists s ∈ N0 such
that any t ∈ L(G) with yd(t) ∈ a∗bscsd∗ has a
subtree t′ such that yd(t′) contains r occurrences
of x and no occurrences of y, for some x/y ∈ Sep.
Proof. Depending on yd, one can always choose
s > r such that any t with | yd(t)| > 2s has at
least one strict subtree t′ with | yd(t′)| ≥ 2r.

The lemma follows by induction over the height
of t. It is trivially true for height 1. For the induc-
tion step, consider that w′ = yd(t′) must have at
least r occurrences of some letter because of pro-
jectivity and the shape of yd(t); assume it is a,
the other cases are analogous. If w′ has no occur-
rences of c, we are done. Otherwise, by projec-
tivity, w′ contains all the b’s, i.e. w′ ∈ a∗bsc+d∗.
In this case, either w′ contains s > r occurrences
of b and no occurrences of d, in which case we
are again done. Or it contains an occurrence of d;
then w′ ∈ a∗bscsd∗ is in the shape required by the
lemma, and we can apply the induction hypothesis
to identify a subtree t′′ of t′ with r occurrences of
some x and none of the corresponding y; and t′′ is
also a subtree of t.

B Details of the proof of Theorem 2

In all of the following, we assume that for some
k ∈ N0 we have CSD = REL(G, h,Hk), where
G = (G, yd) is an LM-CFTG (hence projective,
i.e. yd = ydpr). We let T = L(G) and p be the
pumping height of T.

B.1 Terminology
Let us extend the domain of yd to contexts: for a
context C, we let yd(C) = left(C) · right(C).

We say that a string s is balanced if, for any z ∈
{a, b, c, d} and any position i in s such that si = z
there are two encompassing positions k ≤ i ≤ l
such that s[k,l] ∈ {〈nz〉n | n ∈ N0}. We say that a
tree or a context is balanced if its yield is balanced.
By construction, all trees of T are balanced.

For t ∈ T, a pumping decomposition of t
is a 5-tuple (C1, C2, C3, C4, t5), consisting in
4 contexts C1-C4 and one tree t5 such that
t = C1[C2[C3[C4[t5]]]], ht(C2[C3[C4]]) ≤ p,
ht(C2) + ht(C4) > 0 and for any i ∈ N0,
C1[v

i[t5]] ∈ T, where we let v0 = C3 and
vi+1 = C2[v

i[C4[X]]].

B.2 Pumping considerations
Lemma 10. Let t ∈ T with ht(t) > p,
and consider a pumping decomposition t =
C1[C2[C3[C4[t5]]]]. Let s = left(C2) · left(C4) ·
right(C4) · right(C2) = yd(C2[C4]). The two fol-
lowing propositions obtain:
• For any (x, y) ∈ {(a, c), (b, d)}, |s|x = |s|y.
• Let t′ = C1[C3[t5]]. For u ∈ T∆ and z ∈
{a, b, c, d, a, b, c, d} let euz denote the number
of z-edges in graph(u). It holds for any z ∈
{a, b, c, d, a, b, c, d} that etz = et

′
z + |s|z .

Proof. Let (x, y) ∈ {(a, c), (b, d)}. t ∈ T so
yd(t) ∈ CSDs which entails

| yd(t)|x = | yd(t)|y. (1)

since t′ ∈ T by construction, we have
〈yd(t′), graph(t′)〉 ∈ CSD. From there

| yd(t′)|x = | yd(t′)|y. (2)

But | yd(t)|x,y = | yd(t′)|x,y+|s|x,y. Plugging this
into (1) yields

| yd(t′)|x + |s|x = | yd(t′)|y + |s|y.

Simplifying using (2) we find |s|x = |s|y which
establishes the first point. For the second point, we
have from 〈yd(t), graph(t)〉 ∈ CSD and by defini-
tion of CSD etz = | yd(t)|z = | yd(t′)|z+|s|z . Sim-
ilarily since 〈yd(t′), graph(t′)〉 ∈ CSD we have
et

′
z = | yd(t′)|z . Hence etz = et

′
z + |s|z .

We will now present a pair of lemmas stat-
ing, in formal terms, that decompositions t =
C1[C2[C3[C4[t5]]]] provided by the pumping
lemma all fall within a small number of config-
urations:

https://doi.org/10.1162/coli.07-056-R1-07-027
https://doi.org/10.1162/coli.07-056-R1-07-027
https://doi.org/10.1007/BF00630917
https://doi.org/10.1007/BF00630917


76

• First, in the case where the ’pumpable’ con-
texts C2 and C4 generate only ‘bar’ tokens
and brackets in {a, b, c, d, 〈, 〉}∗, we show
that yd(C2) ∈ {〈, 〉}∗, so that only C4 is
actually pumping ‘bar’ tokens of some kind.
Moreover, t5 generates only ’bar’ tokens and
brackets as well.
• Second, we explore the alternative, where

the ’pumpable’ contexts generate some of the
‘core’ tokens in {a, b, c, d}, say – for the
sake of this informal presentation – some a-
tokens. By lemma 10, they must generate as
many c-tokens, for which we can again dis-
tinguish three possible configurations: 1. a’s
and c’s are respectively generated on differ-
ent sides of a single context (C2 and/or C4),
but then neither C2 nor C4 generate any b or
d-tokens. 2. C2 generate both a and d-tokens
(on the left and right sides respectively) and
no b and c-tokens, while C4 ensures genera-
tion of corresponding b and c-tokens (on the
left and right sides respectively). 3. Or else,
one of C2, C4 generates the a-tokens and no
c,b or d while the other generates the corre-
sponding c-tokens and no a, b or d.

Below follows the formal presentation of these
lemmas:

Lemma 11. Let t ∈ T with ht(t) > p,
and consider a pumping decomposition t =
C1[C2[C3[C4[t5]]]] such that for all z ∈
{a, b, c, d}, | yd(C2[C4])|z = 0. There is x ∈
{a, b, c, d} such that all of the following holds:

1. yd(C2) ∈ {〈, 〉}∗ and yd(C4) ∈ {〈, x, 〉}∗.
2. Either left(C4) ∈ {x}∗ and | left(C3)|z =

0 for any z ∈ {a, b, c, d}, or symmetrically,
right(C4) ∈ {x}∗ and | right(C3)|z = 0 for
any z ∈ {a, b, c, d}.

3. | yd(t5)|z = 0 for any z ∈ {a, b, c, d}
Proof. First point: Let s = left(C1) and n0 =
|s|〈. Let y ∈ {a, b, c, d} and assume y ∈
left(C2). Pumping C2-C4 n0 + 1-times yields
a tree tn0+1 ∈ T such that s · left(C2)n0+1 is
a prefix of yd(tn0+1). We thus see that tn0+1
is not balanced, which is in contradiction with
tn0+1 ∈ T. A symmetric argument establishes
that y /∈ right(C2).

Assume now that there are two distinct x, y ∈
{a, b, c, d} such that x ∈ yd(C4) and y ∈ yd(C4).
Notice that, since C4 does not contain non-bar to-
kens, if x and y occur on the same side of C4
(for instance left(C4) = 〈x〉〈y〉) then t /∈ T be-

cause no string in CSDS admits left(C4) as a sub-
string, whereas yd(t) does. So x and y must oc-
cur on distinct sides. It follows that C4 does not
generate tokens in {〈, 〉} either: if for instance
left(C4) = u · 〈 · x · v for some strings u and v in
{x〈, 〉}∗, u·〈·x·v ·u·〈·x·v would be a substring of
C1[C2[C2[C3[C4[C4[t5]]]]]] ∈ T which again is a
contradiction. Let now n1 = | yd(t5)|〉. Pumping
C2-C4 n1 + 1 times yields a tree tn1+1 ∈ T with
a substring of the form xn1+1 yd(t5)yn1+1 (up to
x/y symmetry) which cannot be balanced, yield-
ing a final contradiction.

Second point: yd(C4) /∈ {〈, 〉}∗, because oth-
erwise pumping C2 and C4 more times than the
maximum number of occurrences of a bar to-
ken in yd(t) would yield an unbalanced tree. So
there is a x such that x ∈ left(C4) or x ∈
right(C4). Assume for contradiction that any dif-
ferent token occurs on the same side of C4 then
C1[C2[C2[C3[C4[C4[t5]]]]]] ∈ T contains a sub-
string that cannot be found in any string of CSD
yielding a contradiction. So left(C4) ∈ {x}∗ or
right(C4) ∈ {x}∗. Assume left(C4) ∈ {x}∗, the
other case is symmetric. Assume for contradiction
that | left(C3)|z > 0 for some z ∈ {a, b, c, d}. Let
n2 = | yd(C3)|〈. Pumping C2-C4 n2 + 1 times
yields a tree tn2+1 ∈ T such that (by projectivity)
yd(tn2+1) has a substring of the form z · u · xn2+1
where |u|〈 ≤ n2. Hence tn2+1 ∈ T is not bal-
anced, yielding a contradiction.

Third point: Assume for contradiction that
| yd(t5)|z > 0. Assume that left(C4) ∈ {x}∗, the
case right(C4) ∈ {x}∗ is symmetric, and point 2
ensures that these two cases are exhaustive. Let
n3 = |t5|〉 and consider the tree tn3+1 ∈ T ob-
tained by pumping C2-C4 n3 + 1 times. By pro-
jectivity, yd(tn3+1) has a substring of the form
xk ·u · z · v with k ≥ n3 + 1 and |u|〉 ≤ n3. Hence
tn3+1 is not balanced and tn3+1 /∈ T, yielding a
contradiction.

Lemma 12. let t ∈ T with ht(t) > p,
and consider a pumping decomposi-
tion t = C1[C2[C3[C4[t5]]]]. Let
(x, y,X, Y ) ∈ {(a, c, A,C), (b, d,B,D)}
such that | yd(C2[C4])|x 6= 0. One of the
following obtains:

1. For some (i, j) ∈ {(2, 4), (4, 2)}, left(Ci) ∈
X+, right(Ci) ∈ Y +, left(Cj) ∈ X∗ and
right(Cj) ∈ Y ∗.

2. left(C2) ∈ A+, right(C2) ∈ D+, left(Cj) ∈



77

B+ and right(Cj) ∈ C+.
3. Either left(C2) ∈ X+, right(C2) = � and

left(C4) · right(C4) ∈ Y +, or symmetrically
left(C2) = �, right(C2) ∈ Y + and left(C4) ·
right(C4) ∈ X+.

Proof. All these observations follow easily from
the first point of Lemma 10 (governing the rela-
tive number of occurrences of a, c-tokens on one
hand and b, d-tokens on the other hand), projectiv-
ity, and the following observation: only one side
of C2 or C4 cannot generate two different kinds of
tokens in {a, b, c, d} or be unbalanced. Otherwise
pumping would (from projectivity) ensure that the
resulting tree has a substring of a shape impossible
for CSD (for example, if both a and b-tokens occur
on the same side of C2, pumping once produces a
substring a · u · b · v · a · u · b · v).

B.3 Separation
Lemma 13. Let t = C1[C2[C3[C4[t5]]]] ∈ T and
t′ = C1[C3[t5]] ∈ T. If t is x, y, l-separated then
so is t′.

Proof. Consider an x, y, l-separation of t: t =
Dx[D0[ty]]. Let Cx, C0 and t′y be respectively
obtained by removing all nodes from C2 or C4
from Dx, D0 and ty. One easily checks that
t′ = Cx[C0[t

′
y]].

Moreover, | yd(Cx)|y ≤ | yd(Dx)|y = 0,
| yd(C0)|x ≤ | yd(D0)|x ≤ l and | yd(t′y)|x ≤
| yd(ty)|x = 0. Hence t′ is x, y, l-separated.

B.4 Minimality argument
Lemma 14. Let t = C1[C2[C3[C4[t5]]]] ∈ T
and t′ = C1[C3[t5]] ∈ T such that t is x, y, l-
separated. By Lemma 13, t′ is separated. Let
Dx[D0[ty]] be a minimal separation of t and
Cx[C0[t

′
y]] be a minimal separation of t

′. D0[ty]
contains all nodes of C0[t′y].

Proof. Assume for contradiction that a node π
of C0 is not in D0. It must then be in Dx or
ty. Assume that it is in Dx, the case where it
is in ty is analoguous. Since π is not in D0,
there is a non-trivial subcontext D′x of Dx rooted
at π, i.e. Dx = D′′x[D

′
x] with ht(D

′
x) > 0.

Let C ′′x , C
′
x be obtained by removing all nodes

from C2 or C4 from D′′x and D
′
x respectively.

By definition of Dx, | yd(D′′x[D′x])|y = 0, hence
| yd(C ′′x [C ′x])|y = 0. Further observe that we have
Cx[C0] = C

′′
x [C

′
x[C
′
0]] for some subcontext C

′
0

of C0. Since π is not in C2 or C4, ht(C ′x) > 0

thus ht(C ′0) < ht(C0). But letting Ex = C
′′
x [C

′
x],

Ex[C
′
0[t
′
y]] is then an x, y, l-separation of t which

contredicts the assumed minimality of Cx[C0[t′y]].

B.5 Inductive bounds
For any tree or context t and symbol x, let us write
ntx as a shorthand for | yd(t)|x, etx for the number
of x-edges generated by t and rtx the length of the
rightmost maximal substring of yd(t) consisting in
only x-tokens (more formally, rtx = |s|x, where s
is the unique substring such that yd(t) = u · s · v
where s ∈ x∗, if u is non empty its last token is
not x, and |v|x = 0).

There is a maximal number of string tokens and
edges that a context of height at most p can gen-
erate under the considered yield and homomor-
phism. We call l0 this number and focus from now
on l0-separated and l0-asynchronous derivations.

Below are the proofs of the two statements of
Lemma 7 of the main paper (respectively, 7-1 and
7-2).

Lemma 7-1. If t ∈ T is x, y, l0-separated and
t = Dx[D0[ty]] is an x, y, l0-separation of t, then
for t0 = D0[ty] we have

et0x ≤ n
t0
x + n

t
xl0. (x bound)

Proof. We prove the result by induction over the
pair (ht(t0), ht(t)) (with lexicographic ordering).

Base Case Assume ht(t0) ≤ p. Then et0 ≤ l0.
Since yd(t) ∈ CSDs, ntx > 0, thus n

t0
x +n

t
xl0 ≥ l0

which ensures the bound.
Induction step If h(t0) > p then h(t) ≥

h(t0) > p. We apply Lemma 1 to t to yield
a decomposition t = C1[C2[C3[C4[t5]]]], where
t′ = C1[C3[t5]] ∈ T, ht(t′) < ht(t) and
ht(C2[C3[C4]]]) ≤ p. Notice that t0 cannot over-
lap with C2[C3[C4] without overlapping with C1
or t5 as well, for otherwise h(t0) ≤ p.

As in the proof of Lemma 13, letting Cx, C0, t′y
be obtained by removing all nodes from C2 and
C4 from Dx, D0 and ty respectively, we obtain an
x, y, l-separation t′ = Cx[C0[t′y]]. We let t

′
0 =

C0[t
′
y] and distinguish between possible configu-

rations for C2 and C4:
Case 0 If neither C2 or C4 generate any x-

token, we find by induction

e
t′0
x ≤ n

t′0
x + n

t′
x l0.

Moreover, we have et
′
0
x = e

t0
x , n

t′0
x = n

t0
x and n

t′
x ≤

ntx which concludes.



78

Case 1 In this case Lemma 11 applies i.e. C2
and C4 generate only some z-tokens and brackets.
The only subcase not already covered by Case 0 is
the one where z = x. Notice that nt

′
x = n

t
x. By

induction,
e
t′0
x ≤ n

t′0
x + n

t′
x l0.

If t0 does not overlap with C2 or C4, we have
e
t′0
x = e

t0
x and n

t′0
x = n

t0
x which ensures the bound.

Otherwise t0 overlaps with C4. If all nodes of
t0 are contained in C4[t5], then by Lemma 11, t0
generate no y-token. By separation, neither does
t which contradicts t ∈ CSD. Hence t0 con-
tains all nodes of C4. Then by lemma 11 again,
n
C2[C4]
x = n

C4
x , hence n

t0
x = n

t′0
x + n

C2[C4]
x and

et0x ≤ e
t′0
x + n

C2[C4]
x which yields

et0x ≤ e
t′0
x + n

C2[C4]
x ≤ n

t0
x + n

t
xl0.

Case 2 In this case Lemma 12 applies and at
least one of C2-C4 generate some token z ∈
{a, b, c, d}. The only subcase not already dealt
with in Case 0 is the one where we can set z = x.
We thus get inductively:

e
t′0
x ≤ n

t′0
x + n

t′
x l0.

Since C2 or C4 generate at least some x-token, we
have ntx ≥ nt

′
x + 1. Moreover e

t0
x ≤ e

t′0
x + l0 since

C2[C4] generate at most l0 x-edges, and nt0x ≥
n
t′0
x . So we have e

t0
x ≤ n

t′0
x +n

t′
x l0+l0 ≤ n

t0
x +n

t
xl0

concluding the proof.

Lemma 7-2. If t ∈ T is x, y, l0-separated
then t there exists a minimal x, y, l0-separation
Dx[D0[ty]] of t is such that, letting t0 = D0[ty],
we have

et0y ≥ n
t
y − ntxl0 − rty (y bound)

Proof. We prove the result by induction over the
height of t.
t is x, y, l0-separated so let us consider

Dx[D0[ty]] a minimal x, y, l0-separation of t. Let
t0 = D0[ty].

Base Case Assume ht(t) ≤ p. Then. nty ≤ l0.
Since yd(t) ∈ CSDs, ntx > 0. Moreover, 0 ≤ e

t0
y

and nty ≤ l0. So nty − ntxl0 − rty ≤ 0 ≤ e
t0
ȳ which

ensures the bound.
Induction step If h(t) > p, we apply

Lemma 1 to t to yield a decomposition t =
C1[C2[C3[C4[t5]]]], where t′ = C1[C3[t5]] ∈ T,
ht(t′) < ht(t) and ht(C2[C3[C4]]) ≤ p. By

Lemma 13, t′ is x, y, l0-separated. We let t′ =
Cx[C0[t

′
y]] be a minimal separation of t

′ verifying
the bound and t′0 = C0[t

′
y]. In other words, we

have:
e
t′0
y ≥ n

t′
y − nt

′
x l0 − rt

′
y . (3)

By Lemma 14, t0 = D0[ty] contains all nodes
of t′0. We distinguish cases according to Lem-
mas 11 and 12.

Case 1 Consider first the case where Lemma 11
applies i.e. C2 and C4 generate only one kind of
bar token, z, and brackets. We now distinguish
cases depending on the value of z. Before this, we
emphasize that in all subcases it holds that ntx =
nt

′
x .
subcase i) z 6= y. Since all nodes of t′0 are

contained in t0, we have et0x ≥ e
t′0
x . Since C2 and

C4 generate no y-token, we have nty = n
t′
y and

rty = r
t′
y . Injecting into inequation (3) concludes.

subcase ii) z = y. We distinguish the differ-
ent possible overlap of C2 and C4 with t0. No-
tice first that, by minimality, if any Ci, i ∈ {2, 4}
overlaps with t0 then t0 contains all nodes of Ci,
for otherwise we would have D0 = D′0[D

′′
0 ] with

D′0 a subcontext of Ci such that ht(D
′
0 > 0), and

in that case (Dx[D′0], D
′′
0 , ty) would be a smaller

x, y, l-separation of t sinceCi (henceD′0) does not
generate y-tokens.

Hence, in the case where t0 overlaps with C2,
t0 contains all nodes of C2 and C4. Since t0 also
contains all nodes of t′0, e

t0 ≥ et′0 + eC2[C4] =
et

′
0 + nty − nt

′
y . Moreover, r

t
y ≥ rt

′
y . We can then

conclude using inequation 3.
Consider now the case where t0 does not over-

lap withC2 orC4. Since all y-tokens are generated
by t0, projectivity of the yield and the definition
of CSD impose that rty = r

t′
y + n

C2[C4]
y . We fur-

ther have et0y ≥ e
t′0
y , and injecting into inequation 3

yields et0y ≥ nty − n
C2[C4]
y + n

t
xl0 − r

t0
y + n

[C2[C4]
y

which simplifies into the desired y bound.
Finally, in the case where C2 does not overlap

with t0 but C4 does, all nodes of C2 are contained
in Dx and all nodes of C4 are contained in t0. We
must then have | yd(C3)|y > 0. Otherwise, there
would exist an x, y, l-separation Ex[E0[ty]] with
Ex = C1[C2[C3[C4]]], and ht(E0) < ht(D0). As-
sume | yd(C3)|x > 0. Lemma 11, point 2, ensures
that | left(C3)|x,y = 0 or | right (C3)|x,y = 0. As-
sume | right(C3)|x,y = 0 (the other case is sym-
metric). We then have both a x and a y gen-
erated on the left of C3. Since neither C1[C2]



79

nor t5 generate any y-token, projectivity imposes
rty = r

t′
y + n

C2[C4]
y and we can conclude as

in the previous case. The only remaining sub-
case is when | yd(C3)|x = 0, in which case t
is 0-separated, and considering the (minimal) 0-
separation (C1, X,C2[C3[C4]]) we can use the
same argument as in the case where t0 encom-
passes all nodes of C2 and C4.

Case 2 Consider now the remaining case where
Lemma 12 applies. If neither C2 or C4 generate
some x or y-token, they don’t generate x or y-
tokens either, and the same reasoning as Case 1
subcase i) applies. Otherwise C2[C4] generate at
least some x-token. We then have ntx ≥ nt

′
x + 1.

Since t0 contains all nodes from t′0 we further have
et0y ≥ e

t′0
y . Finally n

t
y ≤ nt

′
y + l0. We conclude us-

ing inequation 3.

B.6 Conclusion
Lemma 8. For any t ∈ T, if t is x, y, l0-separated
then t is x, y, l0-asynchronous.

Proof. By Lemma 7-2, there is a minimal
x, y, l0-separation t = Dx[D0[ty]] such that the
y bound obtains for t0 = D0[ty]. By lemma 7-1
the x bound obtains for t0 as well. Observe fi-
nally, that rty ≤ mty and since t0 generates at most
l0 x-tokens, by projectivity and definition of CSD,
it generates at most (l0 + 1)mtx x-tokens (one se-
quence of mtx between each occurrence of x and
the next, plus possibly one in front of the first and
one after the last). Hence,

et0y ≥ n
t
y − ntxl0 −mty

et0x ≤ n
t
xl +m

t
x(l0 + 1).

and t is x, y, l0-asynchronous.

Lemma 9. For any t ∈ T, t is x, y, l0-separated
for some x/y ∈ Sep.
Proof. The proof proceeds by induction on the
height of t.

If ht(t) ≤ p. Then | yd(t)|z ≤ l0 for any z ∈
{a, b, c, d}, hence t is trivially x, y, l0-separated
for some x/y ∈ Sep.

If h(t) > p, Lemma 1 yields a decomposition
t = C1[C2[C3[C4[t5]]]], where t′ = C1[C3[t5]] ∈
T, ht(t′) < ht(t) and ht(C2[C4]) ≤ p. By induc-
tion t′ is x, y, l0-separated for some x/y ∈ Sep.
For sake of succintness, let us present the induc-
tive step for x/y = a/c, the reasoning for other
cases is analoguous. Let us examine the different
possible configurations of C2 and C4.

Case 1 If Lemma 11 applies i.e. C2 andC4 gen-
erate only one kind of bar token, z, and brackets,
one checks easily that inserting C2 and C4 does
not change the distribution of a and c-tokens in
the tree, hence t is a, c, l0-separated.

Case 2 If Lemma 12 applies, note first that ifC2
and C4 generate no a or c-token, we can conclude
as in Case 1 as the distribution of a and c-tokens
in the tree is not changed either. Otherwise, we as-
sume thatC2 orC4 generate some a or c-token and
distinguish between subcases 1-3 of Lemma 12:

Subcase 1 in this case for some i ∈ {2, 4}
left(Ci) contains an a-token and no b, c or d-
token while right(Ci) contains some c-token and
no a, b or d-token. Assume i = 2, the case where
i = 4 is similar. By projectivity and definition
of CSDs follows that all b-tokens are generated in
C3[C4[t5]] and all c-tokens in C1. t is therefore
b, d, 0-separated, hence b, d, l0-separated.

Subcase 2 in this case, left(C2) contains some
a-token and no b, c, d-token, right(C3) contains
some d-token and no a, c, d-token, left(C4) con-
tains some b-token and no a, c, d-token, right(C4)
contains some c-token and no a, b, d-token. It fol-
lows that t5 generate no occurrence of a andC1 no
occurrence of c. Since | yd(C2[C3[C4]])|a ≤ l0,
(C1, C2[C3[C4]], t5) is an a, c, l0-separation.

Subcase 3 Assume left(C2) contains some a-
token and no b, c, d-token and that left(C4) con-
tains some c-token. It follows that all b-tokens
are generated by C3. So yd(t) contains less than
l0 b-tokens, by definition of CSD it also contains
less than l0 d-tokens, so (C1, C2[C3[C4]], t5) is a
d, b, l0-separation.

Assume now left(C2) contains some a-token
and no b, c, d-token and that right(C4) contains
some c-token. It follows that t5 generate no
d-token and C1 generate no b-token. Hence
(C1, C2[C3[C4]], t5) is b, d, l0-separation.

The remaining cases are symmetric exchanging
c with a, d with b, and left with right everywhere.


