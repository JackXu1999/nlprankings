



















































Evaluating the Ability of LSTMs to Learn Context-Free Grammars


Proceedings of the 2018 EMNLP Workshop BlackboxNLP: Analyzing and Interpreting Neural Networks for NLP, pages 115–124
Brussels, Belgium, November 1, 2018. c©2018 Association for Computational Linguistics

115

Evaluating the Ability of LSTMs to Learn Context-Free Grammars

Luzi Sennhauser
Federal Institute of Technology

Zurich, Switzerland
Massachusetts Institute of Technology

Cambridge, MA, USA
luzis@student.ethz.ch

Robert C. Berwick
LIDS, Room 32-D728

Massachusetts Institute of Technology
Cambridge, MA, USA

berwick@csail.mit.edu

Abstract

While long short-term memory (LSTM) neu-
ral net architectures are designed to capture se-
quence information, human language is gener-
ally composed of hierarchical structures. This
raises the question as to whether LSTMs can
learn hierarchical structures. We explore this
question with a well-formed bracket prediction
task using two types of brackets modeled by an
LSTM.

Demonstrating that such a system is learnable
by an LSTM is the first step in demonstrating
that the entire class of CFLs is also learnable.
We observe that the model requires exponen-
tial memory in terms of the number of charac-
ters and embedded depth, where a sub-linear
memory should suffice.

Still, the model does more than memorize the
training input. It learns how to distinguish be-
tween relevant and irrelevant information. On
the other hand, we also observe that the model
does not generalize well.

We conclude that LSTMs do not learn the rele-
vant underlying context-free rules, suggesting
the good overall performance is attained rather
by an efficient way of evaluating nuisance vari-
ables. LSTMs are a way to quickly reach good
results for many natural language tasks, but to
understand and generate natural language one
has to investigate other concepts that can make
more direct use of natural language’s structural
nature.

1 Introduction

Composing hierarchical structure for natural lan-
guage is an extremely powerful tool for human
language generation. These structures are of great
importance in order to extract semantic interpreta-
tion (Berwick and Chomsky, 2016) and enable us
to produce a vast repertoire of sentences via a very
small set of rules. Having acquired such a set of

rules, it is easy to construct new structures without
having previously seen similar examples.

For purposes of external communication, the
syntactic structures generated by grammars must
be “flattened” or linearized into a sequential out-
put form (e.g. written, signed, or spoken). When
reading such a (linearized) text, hearing a spoken
sentence or observing a signed language, the struc-
ture has to be recovered implicitly to recover the
original meaning (i.e., parsing).

In this study, we investigate whether Long
Short-Term Memory (LSTM) models (Hochreiter
and Schmidhuber, 1997) possess this same ability
as humans do: inferring rule-based structure from
a linear representation. Everaert et al. (2015) show
clearly that there are phenomena in human lan-
guage that can only be understood by taking the
underlying hierarchical structure into account. For
neural networks to do the same, it is therefore es-
sential to acquire the underlying structure of sen-
tences.

Recurrent neural networks are often used for
tasks like language modeling (Mikolov et al.,
2010; Sundermeyer et al., 2012), parsing (Vinyals
et al., 2015; Kiperwasser and Goldberg, 2016;
Dyer et al., 2016), machine translation (Bahdanau
et al., 2014), and morphological compositions
(Kim et al., 2016). LSTMs are inherently sequen-
tial models. Since the hierarchical structures ap-
pearing in natural language often correlate with
sequential statistical features, it can be difficult to
evaluate whether an LSTM learns the underlying
rules of the sentence’s syntax or alternatively sim-
ply learns sequential statistical correlations. In this
paper we carry out experiments to determine this.

We set up our experiments by posing the LSTM
with a bracket completion problem having two
possible bracket types, a so-called Dyck Lan-
guage. A model which recognizes this language
has to infer rules of the underlying structure.



116

Furthermore, a system that can solve this task
is able to recognize every context-free grammar
(see section 3 regarding Dyck Languages via the
Chomsky-Schützenberger theorem for why this is
so).

By analyzing the intermediate states of the cor-
responding LSTM networks, observing general-
ization behaviours, and evaluating the memory
demands of the model we investigate whether
LSTMs acquire rules as opposed to statistical reg-
ularities.

2 Related work

It has been shown that LSTMs are able to count
and partly acquire for context-free languages like
anbn and simple context-sensitive languages (Gers
and Schmidhuber, 2001; Rodriguez, 2001). We
note that in contrast to the language we investi-
gate here, anbn may be considered the “simplest”
context-free language, since it can be generated by
a grammar with just one transition.

The question as to whether LSTMs can in-
fer rules on a natural language corpus, e.g., for
subject-verb agreement, was initially explored by
others such as (Linzen et al., 2016). Liska et al.
(2018) investigated the memorization vs. general-
ization issue for LSTMs for function composition:
they showed that if an LSTM learns the mapping
from a string-set A to B and from B to C, then the
direct mapping from A to C can partly be learned.
We use the same method and model for a different
task – instead of function composition we evaluate
it for bracket matching.

Since most of the time it is challenging to deter-
mine what is actually going on with respect to the
neural network’s internal state, several attempts
have been made to visualize a neural network’s
intermediate states with the goal of making them
interpretable (Rauber et al., 2017; Karpathy et al.,
2015; Krakovna and Doshi-Velez, 2016). For sev-
eral simple copy and palindrome language tasks,
it has been shown that RNNs learn a fractal en-
coding similar to a binary expansion of the input
(Tabor, 2000; Grüning, 2006; Kirov and Frank,
2012). With the same objective we use another,
recently introduced method to investigate the in-
ternal states.

While here we investigate the ability of how
well structural information can be stored in origi-
nally sequential models, other approaches are cur-
rently being taken to move from sequential mod-

els to structural ones, e.g. to hardwire structural
properties into the model’s architecture (Tai et al.,
2015; Kiperwasser and Goldberg, 2016; Joulin
and Mikolov, 2015); to make a larger external
memory available to the network (Graves et al.,
2014; Sukhbaatar et al., 2015); or to make the net-
work architecture dynamic (Looks et al., 2017).

Finally, we note that thanks to careful review-
ing, we were made aware of Bernardy’s work
(2018), that addresses essentially the same task
as the one we tackle: He investigated also the
generalization behaviour of LSTMs for a Dyck-
language corpus with several bracket types. He
investigated generalization for sentences by con-
catenating several training sentences; or embed-
ding training sentences in a centrally embedded
bracket string. In contrast, we evaluate general-
ization by training sentences on a certain feature
(number of characters, embedded depth) and test-
ing the resulting model on the out-of-sample sen-
tences. By this method, we strive to reduce the
probability of similar sub-strings in the training
versus the test set.

3 Corpus

When dealing with natural language, there are
many side effects or nuisance variables – e.g.
words occurring more often in certain correlative
contexts or clusters than others. These can influ-
ence any classification and experimental result. To
minimize such effects, we conducted all experi-
ments on artificial corpora.

The Chomsky-Schützenberger theorem (Chom-
sky and Schützenberger, 1963; Autebert et al.,
1997) about representing context-free language
(CFL) states the following: “For each context-free
language L, there is a positive integer n, a reg-
ular language R, and a homomorphism h such
that L = h(Dn ∪ R).” where Dn is a Dyck
language with n different bracket pairs. As de-
scribed by Forišek (2018), it follows that the Dyck
language D2 essentially covers the entire class of
CFLs. Every model which recognizes or gener-
ates well-formed Dyck words with two types of
brackets should be powerful enough to handle any
CFL when intersected with a relabeling (homo-
morphism of a constructed regular language).

The synthetic corpus we use consists of such a
Dyck language with two types of brackets ([] and
{}). Sentences are generated according to the fol-



117

lowing grammar:

S -> S1 S | S1
S1 -> B | T
B -> [ S ] | { S }
T -> [ ] | { }

The probabilities of the rules are defined in a
way that the entropy – in terms of the number of
characters between an opening and its correspond-
ing closing bracket and the depth of embedding at
which a bracket appears – is larger than if the rules
had all equal probabilities. Formally, the branch-
ing probability Pb = P [S1 -> B] and the con-
catenation probability Pc = P [S -> S1 S] are
defined as follows:

s(l) = min(1,−3 · l
n
+ 3)

Pb = rb · s(l) where rb ∼ U(0.4, 0.8)
Pc = rc · s(l) where rc ∼ U(0.4, 0.8)

(1)

where rb and rc are sampled once per sentence
and l is the number of already generated characters
in the sentence. All 1M generated sentences have
a length n of 100 characters.

In this paper, we check whether an LSTM can
be trained to recognize this grammar.

0 20 40 60 80 100
0

2

4

·105

distance

fr
eq

ue
nc

y

0 20 40 60
0

1

2

3

4
·105

depth

fr
eq

ue
nc

y

Figure 1: Corpus frequencies

4 Model

To check if we can train a neural network to accept
the language generated by the grammar above, an
LSTM is used.

4.1 Long Short-Term Memory

Long-Short-Term-Memory networks (LSTM)
(Hochreiter and Schmidhuber, 1997) are a variant
of recurrent neural networks (RNNs). Both of
them possess a memory state that is updated in
the process of reading a time series. Many RNNs
suffer from the problem of vanishing gradients
(Hochreiter and Schmidhuber, 1997): The recur-
rent activation functions of RNNs are often set
to be tanh or the sigmoid function. Since their
gradients are most of the times smaller than 1 (for
tanh it is upper bounded by 1, and for the sigmoid
function even by 0.25), the gradient cannot be
conserved during extense backpropagation and
approaches 0. LSTMs deal with this issue by
containing three multiplicative gates controlling
what proportion of the input to pass to the memory
cell (input gate), what proportion of the previous
memory cell information to discard (forget gate)
and what proportion of the memory cell to output
(output gate). In the recurrency of the LSTM the
activation function is the identity function, which
has gradient 1.0. This means that if the forget gate
is open, the gradient is fully passed on to previous
time steps, and long term dependencies can be
learned.

The LSTM reads each input xi consecutively
and updates its memory state ci accordingly. Af-
ter each step, an output hi is generated based on
the updated memory state. More specifically, the
LSTM solves the following equations in a forward
pass:

it = σ(Wixxt +Wihht−1 + bi)

ft = σ(Wfxxt +Wfhht−1 + bf )

ct = ft � ct−1
+ it � tanh(Wcxxt +Wchht−1 + bc)

ot = σ(Woxxt +Wohht−1 + bo)

ht = ot � tanh(ct)
(2)

4.2 Basic Model

Now let us turn to the details of the model imple-
mentation. We begin with the basic formulation.

Let Bopen and Bclose be the sets of opening and
closing brackets and B = Bopen ∪ Bclose the set
of all brackets. Given the beginning of a sentence
w1, w2, ..., wk−1, wk with w1, ..., wk−1 ∈ B and
wk ∈ Bclose, the LSTMs tries approximate the



118

xt

tanh

⊙
⊕

ct

tanh

⊙ht

it

⊙ft
ot

xt−1

...

ht−1

ct−1. . .

...

...

xt+1

...

. . .

...

Figure 2: schematic model of an LSTM-cell.
⊙

stands for element-wise multiplication and
⊕

for
vector addition.

function:

F : Bk−1 → Bclose
w1, w2, ..., wk−1 7→ wk.

The substring (clause) between the corresponding
opening bracket of wi and wi will be referred to
as the relevant clause in the remainder of this pa-
per. Likewise, by distance we denote the number
of characters of the relevant clause. Note that this
distance is always a multiple of 2, since the rele-
vant clause is well-balanced. The depth at a cer-
tain position i is the number of unclosed brackets
in the first i characters. The embedded depth of a
sentence is the maximum depth when processing
the relevant clause.

To read the input characters, an embedding
layer with 5 output dimensions precedes the
LSTM. Together they build the encoder, which
will read the input sequentially. The decoder, map-
ping the internal representation to a probability of
predicting } or ] is a dense layer with one output
variable.

We have compared different initialization meth-
ods. It turns out that the initialization of the
model is crucial to avoid bad local minima. The
following initialization method results in consis-
tently good solutions: To initialize the weights,
the model is trained with sentences of length 50
and only afterwards on the actual corpus with sen-
tence length 100.

For backpropagation, the Adam (Kingma and
Ba, 2014) optimizer was used. Furthermore, to en-

sure faster and more consistent convergence, at the
beginning of the training, the batch size is grad-
ually increased, which has a similar effect as re-
ducing the learning rate (Smith et al., 2017). In
all experiments (and for all models), the corpus
is split into 50% training sentences and 50% test
sentences. The reported results always refer to the
results on the test set.

4.3 Analysis Model

The analysis model is used to analyze what in-
formation is stored in the internal representation
of the LSTM. In a Push-Down-Automaton model,
this internal representation would conceptually
correspond to the entire stack.

To analyze the internal representation [hi, ci] of
the LSTM after having read the input or part of it,
we use a method already developed by Shi et al.
(2016) and Belinkov et al. (2017): After having
trained the basic model, the weights of the encoder
are fixed and the labels (previously y) are replaced
by some feature zi of the input x1, . . . , xi.

This feature zi can either be a scalar or a vector.
If zi is a scalar, a dense layer (scalar analysis
decoder) is trained to predict zi. On the other
hand, if zi is a vector (sequence analysis decoder),
another LSTM is trained to predict zi,1, . . . , zi,j .

Analyzing the performance of the analysis net-
work shows us how accurately a feature zi is pre-
served in [hi, ci]. One can assume that the LSTM
uses its limited memory “efficiently” and therefore
discards irrelevant information. Hence, the perfor-
mance of the analysis decoder shows whether zi is
contained in the information that is relevant for the
original classification task.

To begin, two of the experiments which were
conducted are presented in the following section
to test the trained model performance. For the first
experiment zi is the depth (nesting level) after i
characters.

Example: For the sequence {[{}[[], z is
(1, 2, 3, 2, 3, 4, 3).

For the second experiment we note that theo-
retically, at any time t, no information about a
closed clause in w1, . . . , wt has to be stored, since
it is irrelevant for any eventual future prediction
of wt+1, wt+2, . . .. When reading from left to
right, as soon as a closing bracket is processed, the
corresponding clause becomes irrelevant. There-



119

x1

Embedding

LSTM
cell

xi

Embedding

LSTM
cell

Dense

yi

Dense

zi

LSTM
cell

Dense

zi,1

LSTM
cell

Dense

zi,j

. . .
h1
c1

hi−1
ci−1

hi hi, ci

hi
ci

. . .
h′1

c′1

h′j−1

c′j−1

h′1 h
′
jencoder

basic
decoder

scalar analysis
decoder sequence analysis decoder

Figure 3: Network architecture of the model. The basic end-to-end model consists of the encoder and the
basic decoder. The analysis model fixes the weights for the encoder and uses the scalar (if zi is a scalar)
or sequence analysis decoder (if zi is a sequence).

fore, the relevant information is simply the list of
bracket types of unclosed clauses. In this experi-
ment we investigate how well the previous charac-
ters are preserved in the intermediate representa-
tion and evaluate if this correlates with the recov-
ered characters being relevant or not.

Example: after having processed {[{}][,
only the first and the last characters are relevant,
since they are the only ones that could matter for
a future classification task. On the other hand, the
sub-string [{}] is irrelevant. In this example we
would evaluate whether the first and last character
are better preserved in the intermediate state than
the irrelevant sub-string.

To set up the experiment, we set zi,k to be equal
to xi−k+1, corresponding to predicting the previ-
ous characters of a given intermediate state.

4.4 Varying hidden units

The basic model is evaluated with 2, 4, 6, ..., 50
hidden units. The error rate with 50 hidden units
is 0.38% and an error rate of 1% is reached around
20 hidden units. Thus, the error seems to con-
verge with increasing hidden units to a fairly small
value. As a result, in all further experiments, the
maximum number of hidden units the models are
tested against was set to 50.

4.5 Memory demand

In this section we evaluate how “difficult” sen-
tences can be with respect to the memory demand
of the model, while still reaching an error toler-

0 10 20 30 40 50

10−2

10−1

units

er
ro

rr
at

e

Figure 4: Overall error rate of the basic model
with respect to the number of hidden units of the
LSTM.

ance of 5%. We have to work with tolerances, be-
cause 100% accuracy is not reached. Since it can
be challenging measuring how difficult a sentence
is to predict, we use the distance and the embedded
depth of a sentence as defined above as metrics.

The resulting values (figure 5) demonstrate that
memory demand grows exponentially with respect
to the distance of sentences that can be predicted.
The same behaviour can be observed with respect
to the embedded depth.

4.6 Generalization

To evaluate the model’s generalization perfor-
mance, training was done only on a systematically
chosen subset of sentences (in-sample). To avoid
adding additional nuisance variables in this selec-
tion, the training sentences are selected according



120

0 10 20 30 40 50

0

50

100

hidden units

di
st

an
ce

0 10 20 30 40 50

5

10

15

hidden units

em
be

dd
ed

de
pt

h

Figure 5: Distances (left figure) and embedded depth (right figure) that can be predicted with a given
number of hidden units and 5% error tolerance. The dashed line is a logarithmic approximation.

0 20 40 60 80 100

0

0.1

0.2

0.3

0.4

0.5 out-of-sample

in-sample

distance

er
ro

rr
at

e

Figure 6: Generalization behaviour of a model with
10 hidden units with respect to the distance for 100
runs. Half of the corpus is systematically selected
for training (in-sample) – for testing also the left
out distances are considered (out-of-sample). The
bold dashed line is the minimal out-of-sample er-
ror out of all 100 runs.

to one of the following rules:

regular interpolation: the sentence has distance
2, 6, 10, 14, . . . / odd embedded depth.

random interpolation: the distance / embedded
depth of the relevant clause belongs to a set
D. D is a random subset consisting of half
of all distances / embedded depths present in
the corpus.

extrapolation: the distance / embedded depth of
the relevant clause is smaller than a certain
threshold (11 for distance and 13 for embed-
ded depth).

Running the experiment 100 times – each one
with a different random weight initialization – has
shown (figure 6) that the results are consistent with
respect to the weight initialization. The best out-

of-sample accuracy is still worse than almost all
in-sample accuracies.

The results (figure 7) demonstrate a large dis-
crepancy between the performance on in-sample
(training) and the out-of-sample (testing) accu-
racy. The experiment was evaluated for different
numbers of hidden units. On the one hand, with
a large number of hidden units, the generaliza-
tion error is similarly large (the out-of-sample er-
ror rate for interpolation was already between 8.1
and 14.3 times larger than the in-sample error). On
the other hand, models with a small number of hid-
den units did not even converge. The reason for
no convergence can be reasonably be explained by
the sparse data set, that might lead to more local
minima. The maximum generality – especially for
smaller distances – is observed at around 10 hid-
den units.

Generalization was evaluated with respect to
distance and with respect to the embedded depth.

For regular interpolation the out-of-sample er-
ror for 10 hidden units was on average 5.4 (dis-
tance) and 5.9 (embedded depth) times higher than
the in-sample error. Figure 7 shows also that for
random interpolation and extrapolation, the model
generalizes much worse or not at all.

4.7 Intermediate State Analysis

For the first experiment analyzing intermediate
states, recovering the depth as defined in section
4.2 from intermediate states shows that the depth
is only marginally conserved in the intermediate
state (figure 8). For a small number of units, the
model is only able to distinguish whether a depth
is either close to 0 or close to the mean depth (see
figure 8 with two hidden units). When increas-
ing the number of hidden units, the distribution of



121

distance embedded depth
re

gu
la

ri
nt

er
po

la
tio

n

0 20 40 60 80 100

0

0.1

0.2

0.3

0.4

0.5 out-of-sample

in-sample

distance

er
ro

rr
at

e

0 5 10 15 20

0

0.1

0.2

0.3

0.4

0.5 out-of-sample

in-sample

embedded depth

er
ro

rr
at

e

ra
nd

om
in

te
rp

ol
at

io
n

0 20 40 60 80 100

0

0.1

0.2

0.3

0.4

0.5 out-of-sample

in-sample

distance

er
ro

rr
at

e

0 5 10 15 20

0

0.1

0.2

0.3

0.4

0.5
out-of-sample

in-sample

embedded depth

er
ro

rr
at

e

ex
tr

ap
ol

at
io

n

0 10 20 30 40 50

0

0.1

0.2

0.3

0.4

0.5

out-of-samplein-sample

distance

er
ro

rr
at

e

0 5 10 15 20 25

0

0.1

0.2

0.3

0.4

0.5

out-of-sample

in-sample

embedded depth

er
ro

rr
at

e

Figure 7: Test for generalization: The error rate of the model with 10 hidden units if only half of the
corpus is systematically selected for training (in-sample), while during testing also the left out distances
/ embedded depths were considered (out-of-sample).

predictions gets closer to the real distribution of
depths.

While for two hidden units the prediction of the
depth is on average off by 7.04, it decreases until
it reaches a value of 1.34 for 50 hidden units.

Figure 9 shows how accurately a past charac-
ter can be recovered from an intermediate state.
There is a large discrepancy between the accuracy
of relevant and irrelevant characters: If the 4th-
to-last character is an irrelevant one, the model
is only able to recover the type of bracket with a
33% error rate; whereas if it is a relevant charac-
ter, it reaches an error below 1.8%. As the num-
ber of past characters k approaches 10, the irrel-
evant information cannot be recovered anymore.
Note that an error rate of 0.5 amounts to a random
guess, since we evaluate only if it can predict the
type of bracket (square or curly) correctly, and not
whether it was an opening or a closing one.

5 Discussion

We now consider the results of the various experi-
ments, some of which might be considered as con-
troversial on first sight. On the one hand, we see
that the LSTM exhibits an exponential memory
demand as sentences grow longer, while theoret-
ically, a sub-linear memory ought to be sufficient
(Magniez et al., 2014). On the other hand, we see
that the model has successfully sorted out irrele-
vant information: the intermediate state analysis
shows that irrelevant characters are very quickly
forgotten. So, the exponential memory space is
not needed for storing irrelevant information for
the original classification task.

The strength of structural rules is that they gen-
eralize well. In human language this enables hu-
mans to create new sentences which have never
been heard before. But also for the Dyck lan-
guage being used, the 4 rules defining the language
are enough to generate sentences of arbitrary dis-



122

0 10 20 30 40 50

0

10

20

30

40

depth

er
ro

r
2 hidden units
8 hidden units
50 hidden units
predicting mean depth

Figure 8: Error rates of predicting the depth given
an intermediate state of the basic model. It is eval-
uated for 2, 8, 50 hidden units. The dashed line
indicates the baseline always predicting the mean
depth. The error indicates how far the prediction
is off from the true depth.

0 20 40 60 80 100

0

0.1

0.2

0.3

0.4

0.5

k-to-last symbol

er
ro

rr
at

e

relevant symbols
irrelevant symbols

Figure 9: Error rate of predicting the previous
characters given an intermediate state of the ba-
sic model with 20 hidden units. Characters are
grouped as being either relevant or irrelevant for
the basic classification task.

tance and (embedded) depth. The only constraint
is the memory to store intermediate results while
streaming the input. Assuming the model had in
fact learned the underlying grammatical rules cor-
rectly, an upper bound for the memory required
is 50 bits. The model we are using has up to 50
hidden units which corresponds to 11,200 train-
able parameters. Collins et al. (2016) showed that
LSTMs can store up to 5 bits of information per
parameter and one real number per hidden unit.
So we can assume that memory to store the values
to process the corpus-defining rules sequentially
is not an issue. To partially answer the question of
whether LSTM can learn rules we follow a proof
by contradiction: if the LSTM learns rules and if
these rules are the correct ones, the model would
generalize. What we observe is that the LSTM

generalizes poorly. Therefore we conclude that the
model is not able to learn the right rules.

Combining the generalization results and the in-
termediate state analysis reveals that the model de-
termines each character’s relevance – but it has
learned this without resorting to hierarchical rules.
As LSTMs are known to have the ability to cap-
ture statistical contingencies, it suggests instead
that rather than the “perfect” rule-based solution,
what the LSTM has in fact acquired is a sequential
statistical approximation to this solution.

The large effect of initialization to a good lo-
cal minimum suggests that the underlying function
may well have many local minima as on reviewers
noted. Indeed, Collins et al. (2016) has already
concluded that the memory in LSTMs is mainly
used for training effectiveness rather than to in-
crease the storage capacity. Therefore, the large
memory demand in our experiments suggests that
the LSTM memory is needed to avoid such local
minima.

6 Conclusion

At heart, neural networks are statistical models,
performing well at capturing and combining cor-
relations of the output variable values and the cor-
responding component values in the training in-
put. In particular, LSTMs are constructed such
that they capture sequential information. Hence,
due to the design of their architecture, LSTMs per-
form very well on statistically-oriented, sequential
tasks.

As a result, in experiments like this one that
examine whether LSTMs can acquire hierarchical
knowledge, one has to pay close attention to nui-
sance variables like sequential statistical correla-
tions that might be hard to detect and confounded
with true hierarchical information.

The bottom line that emerges from this experi-
ment is that the range of rules that an LSTM can
learn is very restricted: even a context-free gram-
mar with four simple rules apparently cannot be
appropriately learned by an LSTM.

According to most linguistic accounts, natu-
ral language syntax relies heavily on hierarchical
rules. It enables humans to compose new sen-
tences with relatively little memory capacity and
training data. Furthermore, there are sentences
that have the same linear representation but differ
in structure – syntactically ambiguous sentences.
From this perspective, it seems not only more ef-



123

ficient to directly infer structures and rules, but
also useful to use rules to understand sentences
correctly. The bracket completion task presented
here can be understood by a human after only a
few training sentences, though online processing
of the rules themselves may be difficult. This re-
sult invites the conclusion that it will be very chal-
lenging for LSTMs to understand natural language
as humans do. While LSTMs remain good engi-
neering tools to approximate certain language fea-
tures based on statistical correlations, the explo-
ration of fundamentally new models and architec-
tures seems a valuable direction to explore on the
way to developing methods for understanding hu-
man language in the way that people do.

Acknowledgments

We want to thank Beracah Yankama for his help,
valuable discussions and the machines to run the
experiments on. We thank Prof. Thomas Hof-
mann for the fast and easy administrative process
at ETH Zurich and also for granting access to
high-computing clusters. Additionally we are very
grateful for the financial support provided by the
Zeno Karl Schindler Foundation.

References
Jean-Michel Autebert, Jean Berstel, and Luc Boasson.

1997. Context-free languages and pushdown au-
tomata. In Handbook of formal languages, pages
111–174. Springer.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. arXiv preprint
arXiv:1409.0473.

Yonatan Belinkov, Nadir Durrani, Fahim Dalvi, Hassan
Sajjad, and James Glass. 2017. What do neural ma-
chine translation models learn about morphology?
arXiv preprint arXiv:1704.03471.

Jean-Philippe Bernardy. 2018. Can recurrent neural
networks learn nested recursion? LiLT (Linguistic
Issues in Language Technology), 16(1).

Robert C Berwick and Noam Chomsky. 2016. Why
only us: Language and evolution. MIT press.

Noam Chomsky and Marcel P Schützenberger. 1963.
The algebraic theory of context-free languages. In
Studies in Logic and the Foundations of Mathemat-
ics, volume 35, pages 118–161. Elsevier.

Jasmine Collins, Jascha Sohl-Dickstein, and David
Sussillo. 2016. Capacity and trainability in recurrent
neural networks. arXiv preprint arXiv:1611.09913.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A Smith. 2016. Recurrent neural network
grammars. arXiv preprint arXiv:1602.07776.

Martin BH Everaert, Marinus AC Huybregts, Noam
Chomsky, Robert C Berwick, and Johan J Bolhuis.
2015. Structures, not strings: linguistics as part of
the cognitive sciences. Trends in cognitive sciences,
19(12):729–743.

Michal Forišek. 2018. What is the significance of the
chomsky-schützenberger theorem about represent-
ing context-free languages?

Felix A Gers and E Schmidhuber. 2001. Lstm recur-
rent networks learn simple context-free and context-
sensitive languages. IEEE Transactions on Neural
Networks, 12(6):1333–1340.

Alex Graves, Greg Wayne, and Ivo Danihelka. 2014.
Neural turing machines. CoRR, abs/1410.5401.

André Grüning. 2006. Stack-like and queue-like dy-
namics in recurrent neural networks. Connection
Science, 18(1):23–42.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Armand Joulin and Tomas Mikolov. 2015. Inferring
algorithmic patterns with stack-augmented recurrent
nets. In Advances in neural information processing
systems, pages 190–198.

Andrej Karpathy, Justin Johnson, and Fei-Fei Li. 2015.
Visualizing and understanding recurrent networks.
CoRR, abs/1506.02078.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2016. Character-aware neural language
models. In AAAI, pages 2741–2749.

Diederik P Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional lstm feature representations. arXiv preprint
arXiv:1603.04351.

Christo Kirov and Robert Frank. 2012. Processing of
nested and cross-serial dependencies: an automaton
perspective on srn behaviour. Connection Science,
24(1):1–24.

Viktoriya Krakovna and Finale Doshi-Velez. 2016. In-
creasing the interpretability of recurrent neural net-
works using hidden markov models. arXiv preprint
arXiv:1606.05320.

Tal Linzen, Emmanuel Dupoux, and Yoav Gold-
berg. 2016. Assessing the ability of lstms to
learn syntax-sensitive dependencies. arXiv preprint
arXiv:1611.01368.



124

Adam Liska, Germán Kruszewski, and Marco Ba-
roni. 2018. Memorize or generalize? searching
for a compositional RNN in a haystack. CoRR,
abs/1802.06467.

Moshe Looks, Marcello Herreshoff, DeLesley
Hutchins, and Peter Norvig. 2017. Deep learn-
ing with dynamic computation graphs. CoRR,
abs/1702.02181.

F. Magniez, C. Mathieu, and A. Nayak. 2014.
Recognizing well-parenthesized expressions in the
streaming model. SIAM Journal on Computing,
43(6):1880–1905.

Tomáš Mikolov, Martin Karafiát, Lukáš Burget, Jan
Černockỳ, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In
Eleventh Annual Conference of the International
Speech Communication Association.

P. E. Rauber, S. G. Fadel, A. X. Falcão, and A. C. Telea.
2017. Visualizing the hidden activity of artificial
neural networks. IEEE Transactions on Visualiza-
tion and Computer Graphics, 23(1):101–110.

Paul Rodriguez. 2001. Simple recurrent networks
learn context-free and context-sensitive languages
by counting. Neural Computation, 13(9):2093–
2118.

Xing Shi, Inkit Padhi, and Kevin Knight. 2016. Does
string-based neural mt learn source syntax? In Pro-
ceedings of the 2016 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1526–
1534.

Samuel L Smith, Pieter-Jan Kindermans, and Quoc V
Le. 2017. Don’t decay the learning rate, increase the
batch size. arXiv preprint arXiv:1711.00489.

Sainbayar Sukhbaatar, arthur szlam, Jason Weston,
and Rob Fergus. 2015. End-to-end memory net-
works. In C. Cortes, N. D. Lawrence, D. D. Lee,
M. Sugiyama, and R. Garnett, editors, Advances in
Neural Information Processing Systems 28, pages
2440–2448. Curran Associates, Inc.

Martin Sundermeyer, Ralf Schlüter, and Hermann Ney.
2012. Lstm neural networks for language model-
ing. In Thirteenth Annual Conference of the Inter-
national Speech Communication Association.

Whitney Tabor. 2000. Fractal encoding of context-free
grammars in connectionist networks. Expert Sys-
tems, 17(1):41–56.

Kai Sheng Tai, Richard Socher, and Christopher D.
Manning. 2015. Improved semantic representations
from tree-structured long short-term memory net-
works. CoRR, abs/1503.00075.

Oriol Vinyals, Łukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey Hinton. 2015. Gram-
mar as a foreign language. In Advances in Neural
Information Processing Systems, pages 2773–2781.


