

















































Harmonic Serialism and Finite-State Optimality Theory

Yiding Hao
Department of Linguistics

Yale University
New Haven, CT, USA

yiding.hao@yale.edu

Abstract

This paper presents a new finite-state
model of Optimality Theory (OT). In
this model, two assumptions are imposed
on the OT framework. Firstly, I adopt
the Harmonic Serialism version of OT,
in which output forms are derived from
input forms via a series of incremental
changes. Secondly, constraints are as-
sumed to be strictly local in the sense that
each markedness constraint specifies a set
of banned sequences, each occurrence of
which is penalized. I show that these two
assumptions suffice to reduce the power of
OT to rational relations.

1 Introduction

The seminal paper of Frank and Satta (1998)
showed that grammars in the Optimality Theory
(OT) framework can generate non-rational rela-
tions, but that a finite-state implementation is pos-
sible if each grammar specifies a bound on the
number of violations that can be assigned by a
constraint. Since then, various finite-state approx-
imations of OT have been developed that achieve
rationality by modifying the framework to reduce
its computational power. Karttunen (1998), for ex-
ample, implemented Frank and Satta’s violation-
bounded proposal by composing constraints using
an operation called lenient composition. Improv-
ing upon this, Gerdemann and Van Noord (2000)
and Gerdemann and Hulden (2012) developed a
technique called matching that compares candi-
dates based on the locations where violations are
assigned. Eisner (2000) and Eisner (2002) pro-
pose a model called directional OT that prefers
candidates whose violations are incurred as close
as possible to the left or right boundary of the
string. Finally, Riggle (2004) presents an algo-

rithm, called the Optimality Transducer Construc-
tion Algorithm (OTCA), that takes an OT grammar
as input and produces a finite-state transducer that
correctly computes the grammar if and only if the
grammar defines a rational relation.

In this paper, I present a new formalization of
OT that limits the generative capacity of OT in
two ways. Firstly, I adopt the Harmonic Serialism
(HS) version of OT. Whereas the standard version
of OT simply maps each input to the candidate that
best satisfies a sequence of constraints, HS pro-
duces outputs by effecting a series of incremental
changes to the input. Secondly, I assume that all
constraints are strictly local, in the sense that each
constraint designates a set of marked sequences
and assigns a violation for each occurrence of a
marked sequence. I show that these two assump-
tions suffice to reduce the power of OT to rational
relations.

The structure of this paper is as follows. In Sec-
tion 2, I introduce technical definitions and termi-
nology used in this paper. Section 3 motivates the
use of strictly local constraints and HS as restric-
tions on OT. Section 4 presents a formalization of
HS, and Section 5 presents a finite-state model of
HS. Section 6 concludes.

2 Preliminaries

As usual, Z is the set of integers, and N ⊆ Z is
the set of non-negative integers. Unless otherwise
specified, Σ denotes a finite alphabet, Σ∗ denotes
the set of all strings over Σ, and Σ+ denotes the
set of all nonempty strings over Σ. The special
symbols o and n are assumed not to be elements
of Σ. When used, these symbols represent the left
and right boundaries of a string, respectively. The
length of a string x is denoted |x|, and λ denotes
the empty string, the string of length 0. Symbols
from Σ are identified with strings of length 1, and

20

Proceedings of the 13th International Conference on Finite State Methods and Natural Language Processing, pages 20–29,
Umeå, Sweden, 4–6 September 2017. c© 2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/W17-4003

https://doi.org/10.18653/v1/W17-4003


for any k, Σk denotes the set of strings of length
k over Σ. For any strings a, b ∈ Σ∗, ab is the
concatenation of a and b. If A,B ⊆ Σ∗, then
AB = {ab|a ∈ A, b ∈ B}. If a ∈ Σ∗ and
B ⊆ Σ∗, then aB = {a}B and Ba = B{a}.
A string a is a substring or a subsequence of b if
one can write b = lar for some l, r ∈ Σ∗.

For any sets A and B, A × B denotes the set
{〈a, b〉|a ∈ A, b ∈ B}. A relation over A and B
is a subset R ⊆ A × B. The transitive closure of
a relation R ⊆ A×A is the smallest relation R̂ ⊆
A × A such that R ⊆ R̂ and if 〈x, y〉, 〈y, z〉 ∈ R̂,
then 〈x, z〉 ∈ R̂. For any relations R and S, the
composition of R and S is the relation

R ◦ S = {〈x, z〉|∃y[〈x, y〉 ∈ S, 〈y, z〉 ∈ R]}.

A finite-state transducer is a 6-tuple T =
〈Q,Σ,Γ, I, F, δ〉, where

• Q is a finite set of states;

• Σ is an alphabet called the input alphabet;

• Γ is an alphabet called the output alphabet;

• I ⊆ Q is the set of initial states;

• F ⊆ Q is the set of final states; and

• δ ⊆ Q × (Σ ∪ {λ}) × (Γ ∪ {λ}) ×Q is the
transition relation.

The extended transition relation of T is the small-
est set δ̂ ⊆ Q×Σ∗×Γ∗×Q such that δ ⊆ δ∗; for
every q ∈ Q, 〈q, λ, λ, q〉 ∈ δ̂; and if 〈q, x, y, r〉 ∈
δ̂ and 〈r, a, b, s〉 ∈ δ, then 〈q, xa, yb, s〉 ∈ δ̂.
The behavior of T is the relation [T ] such that
〈x, y〉 ∈ T if and only if for some q ∈ I and
r ∈ F , 〈q, x, y, r〉 ∈ δ̂. A relation is rational if
it is the behavior of a finite-state transducer.

A language L is k-strictly local if, for some set
S ⊆ (Σ∪{o,n})k, oLn is the set of strings such
that every substring of length k is in S.

3 Restrictions on Constraints

Finite-state models of OT have typically achieved
finite-stateness by imposing limitations on the
power of constraints. The standard assumption,
due to Ellison (1994), is that markedness con-
straints are finite-state mappings from strings to
sequences of violation marks. The violation bound
of Frank and Satta (1998) and Karttunen (1998)
and the directional evaluation mechanism of Eis-
ner (2000) and Eisner (2002) both refine the class

aaabb DEP ID AGR MAX
a. aaabb ∗!
b. aaacbb ∗!
c. aaaaa ∗!

� d. aaa ∗∗
e. bb ∗∗∗!

Figure 1: Tableau for a non-rational OT grammar

of possible constraints to a strict subclass of ratio-
nal functions from Σ∗ to N.

In this paper, I propose to restrict constraints
to a proper subclass of rational functions moti-
vated by recent work on the subregular hierarchy.
The subregular hierarchy consists of subclasses of
regular languages and rational relations that char-
acterize empirically attested patterns in phonol-
ogy. Among these are the strictly local languages
of McNaughton and Papert (1971), the tier-based
strictly local languages of Heinz et al. (2011),
and the input strictly local and output strictly lo-
cal functions of Chandlee (2014). All four sub-
classes formalize the observation that markedness
constraints in phonology generally designate a set
of undesirable sequences as marked, and penal-
ize strings that contain such sequences. Based on
this intuition, I define a class of constraints called
strictly local constraints.
Definition 1. A strictly local constraint is a func-
tion c : Σ∗ → N such that for some finite set
Sc ⊆ (Σ∪{o,n})∗, c(x) is the number of unique
decompositions oxn = wyz such that y ∈ Sc.
We say that c bans the sequence y if y ∈ Sc.

A strictly local constraint is a constraint of the
form “assign one violation for every instance of
s1, s2, . . . , or sn,” where each si is a marked se-
quence. It can be easily shown that strictly local
constraints are input strictly local functions from
Σ∗ to N.

Unfortunately, strict locality of markedness
constraints is not a sufficient condition for finite-
stateness. Gerdemann and Hulden (2012) con-
struct a non-finite-state OT grammar using only
strictly local constraints as follows. The sole
markedness constraint is AGR, which penalizes
occurrences of the sequences ab and ba. AGR is
outranked by the standard faithfulness constraints
DEP and ID, which penalize insertion and sub-
stitution of symbols, respectively, while MAX,
which penalizes deletion, ranks below all other
constraints. This constraint ranking requires that

21



aaabb DEP ID AGR MAX

� a. aaabb ∗
b. aaacbb ∗!
c. aaaab ∗! ∗
d. aaab ∗ ∗!
e. aabb ∗ ∗!

Figure 2: HS version of Figure 1

ab and ba sequences be destroyed by deleting seg-
ments. In order to remove all instances of ab or
ba, either all as must be deleted, or all bs must be
deleted. Between these two options, MAX favors
the one that involves less deletion. Thus, if the in-
put has more as than bs, then the bs will be deleted;
otherwise, the as will be deleted. To illustrate, the
tableau in Figure 1 shows the derivation of the out-
put aaa, obtained by deleting all bs from the input
aaabb.

Deleting the least frequent symbol from a string
is non-finite-state because such a mapping re-
quires counting the number of occurrences of each
symbol. Since MAX adjudicates between the two
candidates obtained by deletion, MAX is responsi-
ble for counting in this example. While strict lo-
cality limits the power of markedness constraints,
this observation suggests that the power of faith-
fulness constraints should be limited as well. I
propose to do this using Harmonic Serialism (HS),
an alternate version of OT described in McCarthy
(2000). In HS, GEN only produces candidates that
differ from the input by one symbol. The winner
chosen by EVAL is fed back into the grammar until
a faithful mapping is obtained. To show how HS
can restrict the power of MAX, Figure 2 shows an
HS version of the tableau in Figure 1. Due to the
restricted power of GEN, only one deletion can be
performed at a time. The ab sequence in the input
aaabb cannot be destroyed by deleting only one
symbol, so MAX simply chooses the faithful can-
didate. Since a faithful mapping is obtained, this
candidate is not fed back into the grammar.

4 Formalization of Harmonic Serialism

Having motivated the use of HS and strictly local
constraints, I now present a formal model of HS.

An HS grammar, like a standard OT grammar,
computes a relation R ⊆ Σ∗ × Σ∗ via the three
components GEN, CON, and EVAL. At the be-
ginning of the computation, the grammar takes a
string x as input. GEN reads this input and returns

a set of candidates. CON assigns to each candi-
date a vector of natural numbers known as viola-
tions. Finally, EVAL, based on a linear ordering of
N × N × · · · × N, reads the set of candidates and
their violations and returns the candidate y with
the optimal violation vector. If y = x, then y is
the output of the grammar. Otherwise, a recursive
call to the grammar is made with y as the input,
and the output from this call is the output of the
grammar.

As discussed in the previous section, HS differs
from standard OT in two ways. Firstly, recursive
calls to the grammar are not featured in standard
OT; instead, EVAL chooses the output in “one fell
swoop.” Secondly, in HS, GEN is restricted so that
changes can only be made to the input “one at a
time,” so that each call to the grammar produces an
optimal candidate that is only minimally different
from the input.

These ideas are formalized in the remainder of
this section. Let us begin with the notion of a
change. A single change to a string is defined as
insertion, substitution, or deletion of a single sym-
bol in that string.
Definition 2. An operation is an ordered pair
〈x, y〉 ∈ ((Σ ∪ {λ}) × (Σ ∪ {λ}))\{〈λ, λ〉}. An
operation 〈x, y〉 is an insertion if x = λ, a deletion
if y = λ, a substitution if λ 6= x 6= y 6= λ, and an
identity if x = y.
Definition 3. A pair 〈a, b〉 ∈ Σ∗ ×Σ∗ is an appli-
cation of operation 〈x, y〉 if there exist u, v ∈ Σ∗
such that a = uxv and b = uyv. An application
of an operation 〈x, y〉 is called a change when the
operation 〈x, y〉 is not specfied.

Strictly local constraints, defined in the previ-
ous section, formalize markedness constraints. To
treat faithfulness constraints, I adopt the standard
view that faithfulness constraints militate against
certain kinds of changes to the input. I will assume
that GEN is restricted so that on input a, GEN only
produces candidates b such that 〈a, b〉 is a change.
Since only one change can be made to a, faith-
fulness constraints can be seen as binary functions
that penalize applications of banned operations.
Definition 4. A faithfulness constraint is a func-
tion f : Σ∗×Σ∗ → N such that for some setOf of
operations not including identities, f(a, b) = 1 if
〈a, b〉 is an application of some 〈x, y〉 ∈ Of , and
f(a, b) = 0 otherwise. If 〈x, y〉 ∈ Of , then we
say that f bans 〈x, y〉.

CON contains a set of constraints, which are as-

22



sumed to be ranked with respect to one another.
The ranking is represented here as a sequence of
constraints.
Definition 5. For any strictly local constraint c :
Σ∗ → N, let c be extended to a function c : Σ∗ ×
Σ∗ → N defined by c(x, y) = c(y). A constraint
ranking is a sequence of functions 〈c1, c2, . . . , cn〉
where for each i, ci : Σ∗ × Σ∗ → N is either a
strictly local constraint or a faithfulness constraint.
For any constraint ranking C, the number kC ≥ 0
is the length of the longest sequence banned by a
strictly local constraint of C.

Among the candidates produced by GEN, EVAL
chooses the one that violates the constraints
the least. Given a constraint ranking C =
〈c1, c2, . . . , cn〉 and an input x, this is determined
by considering for each candidate y the value
ci(x, y). The winner chosen by EVAL is the
one that minimizes this value for the most highly
ranked constraints possible. To compare different
candidates, I define here the notions of cost, bene-
fit, and harmonicity.
Definition 6. The cost of a change 〈x, y〉 with re-
spect to a constraint ranking C = 〈c1, c2, . . . , cn〉
is the vector

cC(x, y) = 〈c1(x, y), c2(x, y), . . . , cn(x, y)〉.

The benefit of 〈x, y〉 is

bC(x, y) = cC(x, y)− cC(x, x).

Definition 7. A vector a = 〈a1, a2, . . . , an〉 ∈
Zn is more harmonic than a vector b =
〈b1, b2, . . . , bn〉 ∈ Zn if there exists j such that
aj < bj and for all i < j, ai = bi. We denote this
by a �H b. We write a �H b if a �H b or a = b.

Putting these definitions together, an HS gram-
mar is defined as a system, parameterized by a
constraint ranking C, that takes a string as input
and applies the change that results in the greatest
benefit with respect to C. Recursion is performed
until the most beneficial change is an identity.
Definition 8. An HS grammar is an ordered triple
〈C,HC ,H ∗C 〉, where

• C is a constraint ranking;

• the relation HC ⊆ Σ∗ × Σ∗ is defined by
〈u, v〉 ∈HC if and only if

bC(u, v) = max
y

bC(u, y),

where max is taken with respect to �H over
strings y such that 〈u, y〉 is a change; and

• letting ĤC be the transitive closure of HC ,
the relation H ∗C is defined by

H ∗C = {〈x, y〉 ∈ ĤC |〈y, y〉 ∈HC}.

5 Finite-State Harmonic Serialism

The central result of this paper is that for any HS
grammar 〈C,HC ,H ∗C 〉, the relation H ∗C is ratio-
nal. In section, I derive this result in two steps.
Firstly, I construct a finite-state transducer whose
behavior is HC . This shows that a single non-
recursive call to a Harmonic Serialism grammar
can be modelled as a rational relation. Secondly,
I show that this transducer can be extended to a
transducer whose behavior is H ∗C .

5.1 HC as a Rational Relation
This subsection describes a construction for a
finite-state transducer that, for any constraint rank-
ing C, computes HC . The construction relies on
the property that the benefit of an application 〈a, b〉
of 〈x, y〉 can be computed using only information
about a context of bounded size around the posi-
tion of x in a and y in b. Since there are only
finitely many such contexts, this locality property
allows us to reduce the set of possible changes
performed by HC to a finite number of cases—
one for each possible context. For each context,
we can then construct a transducer that effects the
most beneficial change for that context while en-
suring that no context allowing for a more bene-
ficial change is available. The union of all such
transducers computes HC .

Let us now prove the locality property. To that
end, I first introduce the definition of a context-
sensitive rule, which captures the notion of an op-
eration that only applies in a certain context.
Definition 9. A rule is an ordered quadruple
〈x, y, c, d〉, where 〈x, y〉 is an operation and c, d ∈
(Σ ∪ {o,n})∗. We denote 〈x, y, c, d〉 by x →
y / c d.
Definition 10. An application of a rule x →
y / c d is a pair 〈a, b〉 such for some u, v ∈ (Σ ∪
{o,n})∗, oan = ucxdv and obn = ucydv.

The locality property then states that every ap-
plication of a rule with a sufficiently large context
has the same benefit.
Proposition 11. Let C be a constraint ranking,
and suppose 〈a1, b1〉 and 〈a2, b2〉 are applications
of a rule x → y / c d. If |c|, |d| ≥ kC − 1, then
bC(a1, b1) = bC(a2, b2).

23



Proof. Write C = 〈c1, c2, . . . , cn〉. We need to
show that for each i,

ci(a1, b1)− ci(a1, a1) = ci(a2, b2)− ci(a2, a2).

Fix any i ∈ {1, 2, . . . , n}. Note that 〈a1, b1〉 and
〈a2, b2〉 are applications of the same operation.
Therefore, if ci is a faithfulness constraint, then
ci(a1, b1) = ci(a2, b2). Since a faithfulness con-
straint cannot ban the application of an identity,
ci(a1, a1) = ci(b2, b2) = 0. From this the equa-
tion above follows.

Now suppose ci is a strictly local constraint.
The equation above can then be rewritten as fol-
lows.

ci(b1)− ci(a1) = ci(b2)− ci(a2)

Let Si be the set of sequences banned by ci. For
any string w, ci(w) is the number of occurrences
of elements of Si in w. Since b1 and a1, as well as
b2 and a2, only differ by x and y, any occurrence
of an element of Si in b1 but not a1 or in b2 but a2
must contain the x that is replaced by y. Similarly,
any occurrence of an element of Si in a1 but not b1
or a2 but not b2 must contain the y that replaces x.
Since |c|, |d| ≥ kC−1 and |s| ≤ kC for all s ∈ Si,
any occurrence of some s ∈ Si that includes either
the x or the y must be a substring of cxd or cyd.
Thus, we have

ci(b1)− ci(a1) = ci(cyd)− ci(cxd)
= ci(b2)− ci(a2),

giving us the equation above.

Definition 12. Let C be a constraint ranking. The
benefit of a rule r = x → y / c d with respect to
a constraint ranking C, denoted bC(r), is defined
by bC(r) = bC(c′xd′, c′yd′), where c′ and d′ are c
and d, respectively, with occurrences of o and n
replaced by λ.

Using Proposition 11, we can now construct a
transducer computing HC by considering all pos-
sible rules x→ y / c d, where |c| = |d| = kC−1.
For any input a, 〈a, b〉 ∈ HC if 〈a, b〉 is an appli-
cation of the most beneficial rule that could be ap-
plied to a. Thus, for each rule r, we can construct
a transducer that checks whether r is the most ben-
eficial rule that is applicable to its input, and if so,
apply r to its input. The following lemma gives
us a way to check whether r is the most beneficial
rule possible.

Lemma 13. Let C be a constraint ranking, and
suppose that 〈a, b〉 is an application of r = x →
y / c d, where |c| = |d| = kC − 1. Suppose fur-
ther that for all y′ ∈ Σ ∪ {λ},

bC(x→ y′ / c d) �H bC(r).

Then, there is a set Fr ⊆ (Σ∪{o,n})2kC−1 such
that 〈a, b〉 ∈ HC if and only if a does not contain
any element of Fr as a substring.

Proof. Since 〈a, b〉 is an application of r, the
length of amust be at least |cxd| = 2kC−1. Thus,
for any b′ ∈ Σ∗, 〈a, b′〉 ∈ HC only if 〈a, b′〉 is an
application of a rule r′ = x′ → y′ / c′ d′ with
|c′| = |d′| = kC − 1.

Such a rule r′ is applicable to a if and only if
a contains the substring c′x′d′. Thus, let us define
Fr by

Fr = {c′x′d′|bC(r′) �H bC(r),
|c′| = |d′| = kC − 1}.

By hypothesis, cxd /∈ Fr, so a rule more beneficial
than r can be applied to a if and only if a contains
a substring from Fr. But 〈a, b〉 ∈ HC if and only
if no rule more beneficial than r can be applied to
a, hence the lemma.

To use Lemma 13, we only consider rules r =
x→ y / c d such that no y′ satisfies

bC(x→ y′ / c d) �H bC(r).

To check whether a rule r is the most benefical
rule applicable to a string a, we simply construct
the set Fr and check that a does not contain any
element of Fr as a substring.

We are now ready to present the construction of
a finite-state transducer for HC .
Theorem 14. Let C = 〈c1, c2, . . . , cn〉 be a con-
straint ranking. Then, HC is a rational relation.

Proof. We need to construct a finite-state trans-
ducer T such that on input a, T outputs b if and
only if 〈a, b〉 ∈ HC . To do this, we consider
two possible cases: either |a| < 2kC − 1, or
|a| ≥ 2kC − 1. In the first case, 〈a, b〉 is gener-
ally not an application of a rule x→ y / c d with
|c|, |d| ≥ kC−1, so Proposition 11 does not apply.
Instead, we simply observe that the relation

{〈a, b〉 ∈HC ||a| < 2C − 1}

is finite, so it is automatically rational. Let T0 be a
transducer whose behavior is this relation.

24



Now, let us assume that |a| ≥ 2kC − 1. Then,
a is an application of a rule x → y / c d with
|c| = |d| = kC − 1, so we can use the technique
discussed in this subsection. To that end, let R be
the set of all rules r = x→ y / c d such that

• |c| = |d| = kC − 1;

• bC(r) �H 〈0, 0, . . . , 0〉; and

• there is no r′ = x → y′ / c d such that
bC(r

′) �H bC(r).

R is precisely the set of all rules r with |c| = |d| =
kC − 1, other than the identity, such that some ap-
plication of r is in HC . For each r ∈ R, let Fr be
defined as in Lemma 13.

For each rule r = x → y / c d ∈ R, we need
to construct a transducer Tr that applies r if it is
the most beneficial rule applicable to its input. As
discussed earlier, this amounts to checking that the
input does not contain any element of Fr as a sub-
string, and then applying the rule. Observe that the
set of strings without substrings from Fr forms a
(2kC −1)-strictly local language Sr, so to achieve
this effect, we can simply take a transducer apply-
ing the rule and restricting its domain to Sr. Let us
call this transducer Ir, whose behavior is defined
below.

[Ir] = {〈ucxdv, ucydv〉|ucxdv ∈ Sr,
y ∈ Σ ∪ {λ}}

To construct Tr, we simply add the boundary sym-
bols o and n to the input, apply Ir, and then re-
move the boundary symbols.

[Tr] = {〈osn, s〉|s ∈ Σ∗} ◦ Ir
◦ {〈s,osn〉|s ∈ Σ∗}.

Finally, to construct a transducer T computing
HC , we simply take the union of all the Trs, along
with T0 and the identity relation on any string for
which no rule in R is applicable.

[T ] =

(⋃
r∈R

[Tr]

)
∪[T0]∪{〈s, s〉|∀r ∈ R[s /∈ Sr]}

It is clear that [T ] = HC , so HC is rational.

5.2 Transducing Recursion
Having shown that HC is a rational relation for
any constraint ranking C, it remains to show that
H ∗C is rational as well. Recall that the behavior of

H ∗C is to repeatedly apply HC until a fixed point
is reached. Since rational relations are closed un-
der composition, the naı̈ve approach to transduc-
ing H ∗C is to take the transducer T constructed in
the previous subsection and compose it with itself
multiple times. This approach is not correct, how-
ever, because there is no bound on the recursion
depth of an HS grammar. A string can, in prin-
ciple, contain arbitrarily many instances of a se-
quence banned by a strictly local constraint, and
such a string could require a recursive call for each
instance of a banned sequence.

To address the problem of unbounded recursion
depth, I rely on techniques from regular model
checking, a discipline that analyzes automated sys-
tems with infinitely many state configurations and
attempts to find the set of states reachable from
the initial states. Under a paradigm introduced
by Jonsson and Nilsson (2000) and Bouajjani et
al. (2000), the set of possible states of a system
are represented as a regular language, and the
possible transitions between states are modelled
as a rational relation. Finding the set of reach-
able states amounts to finding the transitive clo-
sure of the transition relation, since the transitive
closure is exactly the relation obtained by apply-
ing the transition relation to itself arbitrarily many
times. Accordingly, much has been written in the
model checking literature about how the transitive
closure of rational relations might be computed.
Surveys of these results can be found in Nilsson
(2000), Abdulla et al. (2004), and Abdulla (2012).

Using these techniques, we can take the trans-
ducer T computing HC and compute its transitive
closure T̂ . The effect of T̂ is to apply HC to a
string arbitrarily many times, so T̂ is able to han-
dle the problem of arbitrary recursion depth.

The intuition behind the technique for comput-
ing the transitive closure is as follows. Consider
the transducer T shown at the top of Figure 3.
This transducer reads strings over Σ = {a, b} and
changes the first b to an a. This is done by having
T begin in state 0, and enter state 1 when a b is
read. Now, let us consider how a transducer com-
puting [T ] ◦ [T ], which changes the first two bs in
the input to as, might be constructed. Recall that
on an input x, the run of T on x is the sequence
q0q1 . . . qn of states that T enters into during its
computation. On input x, T produces an output
y by changing the first b of x to an a. To com-
pute [T ] ◦ [T ], we must then feed y back into T ,

25



0 1

00

10

11

a : a

b : a
a : a, b : bstart

start

a : a b : a

a : a

b : a

a : a, b : b

Figure 3: A transducer (top) and its composition
with itself (bottom)

x: a a b b . . .
Run 1: 0 0 0 1 1 . . .

y: a a a b . . .
Run 2: 0 0 0 0 1 . . .

z: a a a a . . .

Figure 4: The runs of two applications of the trans-
ducer from the top of Figure 3

producing an output z. This produces another run
p0p1 . . . pn. The two runs are visualized in Figure
4, taking x to be a sample input beginning with
aabb. A transducer T 2 computing [T ] ◦ [T ] can be
constructed by stacking the two runs on top of one
another. Each state of T 2 represents a column of
the diagram in Figure 4—an ordered pair encod-
ing the state of T during its first and its second it-
erations. Transitions can then be defined between
the columns so as to match the behavior of T dur-
ing its two passes. The resulting transducer T 2 is
shown at the bottom of Figure 3. By inspection, it
is clear that this transducer changes the first two bs
of its input to as.

Let us now make these ideas explicit by defining
the notion of a column transducer. This definition
was introduced by Abdulla et al. (2002).
Definition 15. Let T = 〈Q,Σ,Σ, {q0}, F, δ〉 be
a finite-state transducer such that 〈x, y〉 ∈ T im-
plies |x| = |y|. The column transducer for T
is the transducer T+ = 〈Q+,Σ,Σ, q+0 , F+, ρ〉,
where 〈q1q2 . . . qm, a, b, r1r2 . . . rm〉 ∈ ρ if and
only if there exist a0, a1, . . . , am such that a = a0,
b = am, and for each i, 〈q1, ai−1, ai, ri〉 ∈ δ.

Abdulla et al. (2002) show that for any trans-
ducer T computing a length-preserving relation,
[T+] is indeed the transitive closure of [T ]. How-

ever, this is not enough to show that the transi-
tive closure of [T ] is rational. In the example
of Figures 3 and 4, the transducer T 2 only com-
putes two iterations of T , so the states of T 2 are
columns of length 2. However, the column trans-
ducer T+ has states of arbitrary length, so T+ has
infinitely many states, and is therefore not a finite-
state transducer.

To remedy this, Abdulla et al. (2002), noting
that different states often exhibit the same behav-
ior, define an equivalence relation ' on Q+ in
hopes that only finitely many columns in Q+/ '
might be reachable.
Definition 16. Let T = 〈Q,Σ,Σ, {q0}, {qf}, δ〉
be a finite-state transducer. A state q ∈ Q is left-
copying if 〈q0, x, y, q〉 ∈ δ̂ implies x = y. A state
q ∈ Q is right-copying if 〈q, x, y, qf 〉 ∈ δ̂ implies
x = y. A state is non-copying if it is neither left-
copying nor right-copying.
Definition 17. Let p, q ∈ Q+. We write p ' q
if there exist m1,m2, . . . ,mk, n1, n2, . . . , nk > 0
and q1, q2, . . . , qk ∈ Q such that

• p = qm11 q
m2
2 . . . q

mk
k ,

• q = qn11 q
n2
2 . . . q

nk
k , and

• for each i, if qi is non-copying, then mi =
ni = 1.

Taking the quotient of Q+ by ' does not affect
the behavior of T+.
Theorem 18 (Abdulla et al. (2002)). Define the
quotient transducer of T by T' = 〈Q+/ '
,Σ,Σ, [q+0 ]', F

+/ ', ψ〉, where

ψ = {〈[p]', a, b, [q]'〉|〈p, a, b, q〉 ∈ ρ}.

Then, [T'] = [T+] is the transitive closure of [T ].
This result shows that the transitive closure

of [T ] is rational if only finitely many states in
Q+/ ' are reached. By inspecting Definition
17, we see that this is possible if each reachable
column contains finitely many non-copying states,
and if each column contains finitely many alter-
nations between different copying states. Abdulla
et al. (2003) introduce a technique known as bi-
determinization for ensuring that the latter condi-
tion is always met, so the former condition is suf-
ficient to ensure that the transitive closure of [T ] is
rational.

We are now ready to use Theorem 18 to show
that H ∗C is rational. To do so, we first need to
modify the construction from Theorem 14 for the

26



transducer T computing HC so that [T ] is length-
preserving. This can be done by padding strings
with symbols that are treated like λs. Insertions
are then performed by replacing these special sym-
bols with symbols from Σ, while deletions are per-
formed by replacing symbols from Σ with special
symbols. This allows insertions and deletions to
be simulated without changing the length of the
input. Once T has been made to preserve length,
we construct T', and restrict its output to strings
x such that 〈x, y〉 ∈HC only if x = y.
Theorem 19. Let C be a constraint ranking.
Then, H ∗C is rational.

Proof. Let T = 〈Q,Σ,Σ, {q0}, F, δ〉 be the finite-
state transducer such that [T ] = HC . We shall first
show that the transitive closure of T is rational,
and then use the transitive closure to construct a
finite-state transducer whose behavior is H ∗C .

Let B = {i, d} be the special symbols used
to pad strings so that [T ] can be made finite-state.
Insertions are made by changing is to other sym-
bols, and deletions are made by changing symbols
to ds. For any string x = x1x2 . . . xn, define

ι(x) = B∗x1B
∗x2 . . . xn−1B

∗xnB
∗.

In other words, ι freely inserts special symbols to a
string. Now, let us modify T by again considering
the two cases where the length of T ’s input a is at
most or greater than 2kC − 1. In the former case,
for any 〈a, b〉 ∈ [T ], write a = uxv and b = uyv.
We replace 〈a, b〉 with

• 〈ι(u)xι(v), ιudιv〉 if y = λ,

• 〈ι(u)iι(v), ιuyιv〉 if x = λ, and

• 〈ι(u)xiι(v), ιudyιv〉 if x 6= λ and y 6= λ.

In the case where |a| > 2kC − 1, let R be defined
as in the proof of Theorem 14. Each rule r = x→
y / c d in R is replaced by

• x→ d / ι(c) ι(d) if y = λ,

• i→ y / ι(c) ι(d) if x = λ, and

• xi→ dy / ι(c) ι(d) if x 6= λ and y 6= λ.

Let us call the set of these new rules R′.
In this modified version of T , the only modifi-

cations that could be made to the input are chang-
ing is to alphabet symbols and changing alpha-
bet symbols to ds. In particular, ds can never be

changed by T . Therefore, if T is applied to an
input arbitrarily many times, for any i, the ith po-
sition only changes at most twice. This means that
in the column transducer T+, the column reached
at the ith position can only contain at most two
non-copying states, so in the quotient transducer
T', only finitely many states are reachable. Re-
moving unreachable states makes T' a finite-state
transducer, so by Theorem 18, the transitive clo-
sure of [T ] is rational.

To complete the proof, let us use T' to construct
a finite-state transducer M for H ∗C . Define the
transducers E and D, which freely insert and re-
move padding symbols, respectively, as follows.

[E] = {〈x, y〉|x ∈ Σ∗, y ∈ ι(x)}
[D] = {〈x, y〉|y ∈ Σ∗, x ∈ ι(y)}

M must first insert padding symbols to its input,
then apply T', and then remove padding symbols.
Afterwards, the range of these operations must be
intersected with the set of strings such that the
most beneficial change is the identity. Letting Sr
be defined for each r as in Theorem 14, recall that
this set of strings is precisely

S =
⋃
r∈R

Sr.

Since each Sr is regular, so is S. Therefore, we
write

[M ] = {〈x, y〉 ∈ [D] ◦ [T'] ◦ [E]|y ∈ S},

completing the construction.

6 Conclusion

In this paper, I have shown that the Harmonic
Seralism version of Optimality Theory defines ra-
tional relations if markedness constraints are as-
sumed to be strictly local. This was done by con-
structing a finite-state transducer relating each in-
put with the winner chosen by EVAL after a single
iteration of the grammar. This transducer was ex-
tended to a transducer that makes recursive calls
to the grammar by relying on techniques from
regular model checking for computing the transi-
tive closure of rational relations satisfying certain
conditions. The assumption that markedness con-
straints are strictly local allowed us to show that
HC is regular by partitioning the space of pos-
sible changes effected by the grammar into a fi-
nite number of cases. The limitation of GEN to

27



“one change at a time” allowed us to construct the
transitive closure of HC in such a way that only
finitely many states in the quotient transducer are
reachable.

For computational phonology, this paper con-
tributes a new finite-state model of OT that in-
corporates ideas from recent work on the sub-
regular hierarchy and provides an example of
how the property of locality could be exploited
to restrict the power of OT to rational relations.
The model presented here is also the first to
achieve finite-stateness using restrictions on OT
originating in the phonological literature: most
markedness constraints proposed in OT analyses
are indeed strictly local, and Harmonic Serialism
was first introduced in the original manuscript of
Prince and Smolensky (1993).

This paper also has implications for theoreti-
cal phonology. While Harmonic Serialism is gen-
erally known as a way to model phonological
opacity, McCarthy (2000) mentions that in many
cases, HS analyses are not distinguishable from
standard OT analyses. On the other hand, the
ability of HS grammars to make recursive calls
is traditionally seen as a significant increase in
the complexity of OT, so a standard OT analy-
sis is usually preferable to a similar HS analysis.
The proposal of this paper, however, provides ev-
idence against that intuition: since standard OT
with strictly local constraints is more powerful
than rational relations, the finite-state model pre-
sented here shows that HS is weaker than standard
OT in language-theoretic terms. Thus, this paper
supports the viewpoint, originating from Moreton
(1999)’s proof that the recursion of EVAL always
converges to a fixed point, that HS is in fact less
complex than standard OT. While the ability to
feed the output of EVAL back into GEN seems to
increase the power of OT, this increase in power is
offset by the restriction of GEN to one operation
at a time. The rationality of HS provides an in-
teresting distinction between standard OT and HS,
and presents motivation for further work on HS
phonology.

To conclude, several issues should be addressed
in future work on this topic. Firstly, the results pre-
sented in this paper are purely theoretical. An im-
plementation of the two constructions described in
Section 5 needs to be developed if the ideas from
this paper are to be used in NLP applications. Sec-
ondly, while the class of strictly local constraints

is motived in part by empirical studies regarding
phonological patterns in natural language, many
constraints found in OT fall outside of this class.
Future work should determine the extent to which
the power of constraints can be extended while
still ensuring that HS grammars define rational re-
lations. One possibility would be to extend strictly
local constraints to a class of constraints corre-
sponding to the tier-based strictly local languages.
Finally, for the sake of formal completeness, many
commitments were made in Section 4 in the devel-
opment of the formal model of HS used in this pa-
per. In particular, I have assumed that “one change
at a time” means insertion, deletion, or substitu-
tion of a single symbol. I have also assumed that
if a single iteration of EVAL chooses multiple win-
ners, each of these winners is passed back to GEN
independently. In reality, multiple proposals ex-
ist in the HS literature regarding the implementa-
tional details of the framework. By modifying the
formalism of Section 4, further studies could in-
vestigate which of these details affect the genera-
tive power of HS, and which do not.

Acknowledgments

I would like to thank Ryan Bennett, Robert Frank,
and the reviewers for their valuable feedback and
discussion. Any remaining errors are my own.

References
Parosh Aziz Abdulla, Bengt Jonsson, Marcus Nilsson,

and Julien d’Orso. 2002. Regular model checking
made simple and effcient. In International Con-
ference on Concurrency Theory, pages 116–131.
Springer.

Parosh Aziz Abdulla, Bengt Jonsson, Marcus Nilsson,
and Julien d’Orso. 2003. Algorithmic improve-
ments in regular model checking. In International
Conference on Computer Aided Verification, pages
236–248. Springer.

Parosh Aziz Abdulla, Bengt Jonsson, Marcus Nilsson,
and Mayank Saksena. 2004. A survey of regu-
lar model checking. In International Conference on
Concurrency Theory, pages 35–48. Springer.

Parosh Aziz Abdulla. 2012. Regular model checking.
International Journal on Software Tools for Technol-
ogy Transfer (STTT), 14(2):109–118.

Ahmed Bouajjani, Bengt Jonsson, Marcus Nilsson, and
Tayssir Touili. 2000. Regular model checking. In
CAV, volume 1855, pages 403–418. Springer.

Jane Chandlee. 2014. Strictly local phonological pro-
cesses. Ph.D. thesis, University of Delaware.

28



Jason Eisner. 2000. Directional constraint evaluation
in optimality theory. Proceedings of COLING.

Jason Eisner. 2002. Comprehension and compilation
in optimality theory. In Proceedings of the 40th
Annual Meeting on Association for Computational
Linguistics, pages 56–63. Association for Computa-
tional Linguistics.

T Mark Ellison. 1994. Phonological derivation in op-
timality theory. In Proceedings of the 15th confer-
ence on Computational linguistics-Volume 2, pages
1007–1013. Association for Computational Linguis-
tics.

Robert Frank and Giorgio Satta. 1998. Optimality the-
ory and the generative complexity of constraint vio-
lability. Computational Linguistics, 24(2):307–315.

Dale Gerdemann and Mans Hulden. 2012. Practical fi-
nite state optimality theory. In FSMNLP, pages 10–
19.

Dale Gerdemann and Gertjan Van Noord. 2000. Ap-
proximation and exactness in finite state optimality
theory. arXiv preprint cs/0006038.

Jeffrey Heinz, Chetan Rawal, and Herbert G Tan-
ner. 2011. Tier-based strictly local constraints for
phonology. In Proceedings of the 49th Annual Meet-
ing of the Association for Computational Linguis-
tics: Human Language Technologies: short papers-
Volume 2, pages 58–64. Association for Computa-
tional Linguistics.

Bengt Jonsson and Marcus Nilsson. 2000. Transitive
closures of regular relations for verifying infinite-
state systems. In TACAS, volume 1785, pages 220–
234. Springer.

Lauri Karttunen. 1998. The proper treatment of op-
timality in computational phonology: plenary talk.
In Proceedings of the International Workshop on Fi-
nite State Methods in Natural Language Processing,
pages 1–12. Association for Computational Linguis-
tics.

John J McCarthy. 2000. Harmonic serialism and par-
allelism.

Robert McNaughton and Seymour A Papert. 1971.
Counter-Free Automata (MIT research monograph
no. 65). The MIT Press.

Elliott Moreton. 1999. Non-computable functions in
optimality theory.

Marcus Nilsson. 2000. Regular model checking. Ph.D.
thesis, Uppsala universitet.

Alan Prince and Paul Smolensky. 1993. Optimality
theory: Constraint interaction in generative gram-
mar. ms.

Jason Alan Riggle. 2004. Generation, recognition,
and learning in finite state Optimality Theory. Ph.D.
thesis, Citeseer.

29


	Introduction
	Formal Preliminaries
	Failure transducers
	From rewrite dictionaries to f-transducers
	Implementation and complexity analysis
	Application for Online Hyperlinking Using Link Databases
	Conclusion

