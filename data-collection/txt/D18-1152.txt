











































Rational Recurrences


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 1203–1214
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

1203

Rational Recurrences

Hao Peng Roy Schwartz} Sam Thomson| Noah A. Smith}
Paul G. Allen School of Computer Science & Engineering, University of Washington

|School of Computer Science, Carnegie Mellon University
}Allen Institute for Artificial Intelligence

{hapeng,roysch,nasmith}@cs.washington.edu, sthomson@cs.cmu.edu

Abstract

Despite the tremendous empirical success of
neural models in natural language process-
ing, many of them lack the strong intuitions
that accompany classical machine learning ap-
proaches. Recently, connections have been
shown between convolutional neural networks
(CNNs) and weighted finite state automata
(WFSAs), leading to new interpretations and
insights. In this work, we show that some re-
current neural networks also share this con-
nection to WFSAs. We characterize this
connection formally, defining rational recur-
rences to be recurrent hidden state update
functions that can be written as the Forward
calculation of a finite set of WFSAs. We show
that several recent neural models use ratio-
nal recurrences. Our analysis provides a fresh
view of these models and facilitates devising
new neural architectures that draw inspiration
from WFSAs. We present one such model,
which performs better than two recent base-
lines on language modeling and text classifica-
tion. Our results demonstrate that transferring
intuitions from classical models like WFSAs
can be an effective approach to designing and
understanding neural models.

1 Introduction

Neural models, and in particular gated variants of
recurrent neural networks (RNNs, e.g., Hochre-
iter and Schmidhuber, 1997; Cho et al., 2014),
have become a core building block for state-
of-the-art approaches in NLP (Goldberg, 2016).
While these models empirically outperform clas-
sical NLP methods on many tasks (Zaremba et al.,
2014; Bahdanau et al., 2015; Dyer et al., 2016;
Peng et al., 2017, inter alia), they typically lack
the intuition offered by classical models, making it
hard to understand the roles played by each of their
components. In this work we show that many neu-
ral models are more interpretable than previously

q1/1̄q0

8↵/1̄ 8↵/�(↵)

8↵/µ(↵)

Figure 1: A two-state WFSA B described in §2. It
is closely related to several models studied in this
paper (§4.1). Bold circles indicate initial states,
and double circles final states, which are associ-
ated with final weights. Arrows represent transi-
tions, labeled by the symbols ↵ they consume, and
the weights as a function of ↵. Arcs not drawn
are assumed to have weight 0̄. For brevity, 8↵
means 8↵ 2 ⌃, with ⌃ being the alphabet.

thought, by drawing connections to weighted fi-
nite state automata (WFSAs). We study several re-
cently proposed RNN architectures and show that
one can use WFSAs to characterize their recur-
rent updates. We call such models rational re-
currences (§3).1 Analyzing recurrences in terms
of WFSAs provides a new view of existing models
and facilitates the development of new ones.

In recent work, Schwartz et al. (2018) intro-
duced SoPa, an RNN constructed from WFSAs,
and thus rational by our definition. They also
showed that a single-layer max-pooled CNN (Le-
Cun, 1998) can be simulated by a set of simple
WFSAs (one per output dimension), and accord-
ingly are also rational. In this paper we broaden
such efforts, and show that rational recurrences are
in frequent use (Mikolov et al., 2014; Balduzzi and
Ghifary, 2016; Lei et al., 2016, 2017a,b; Bradbury
et al., 2017; Foerster et al., 2017). For instance,
we will show in §4 that the WFSA diagrammed

1 Where the term regular is used with unweighted FSAs
(e.g., regular languages, regular expressions), rational is the
weighted analog (e.g., rational series, Sakarovitch, 2009; ra-
tional kernels, Cortes et al., 2004).



1204

in Figure 1 has strong connections to several of
the models mentioned above.

Based on these observations, we then discuss
potential approaches to deriving novel neural ar-
chitectures from WFSAs (§5). As a case study,
we present a new model motivated by the in-
terpolation of a two-state WFSA and a three-
state one, capturing (soft) unigram and bigram
features, respectively. Our experiments show
that in two tasks—language modeling and text
classification—the proposed model outperforms
recently proposed rational models (§6). Fur-
ther extensions might lead to larger gains, and
the rational recurrence view could facilitate eas-
ier exploration of such extensions. To pro-
mote such exploration, we publicly release our
implementation at https://github.com/
Noahs-ARK/rational-recurrences.

2 Background: Weighted Finite State
Automata (WFSAs)

This section reviews weighted finite-state au-
tomata and semirings, which underly our anal-
yses in §3. WFSAs extend nondeterministic
unweighted finite-state automata by assigning
weights to transitions, start states, and final states.
Instead of simply accepting or rejecting a string, a
WFSA returns a score for the string, and this score
summarizes the weights along all paths through
the WFSA that consume the string. In order for
this summary score to be efficiently computable,
weights are taken from a semiring.
Definition 1 (Kuich and Salomaa, 1986). A
semiring is a set K along with two associative bi-
nary operations on K, � (addition) and ⌦ (multi-
plication), and two identity elements: 0̄ for addi-
tion, and 1̄ for multiplication. Semirings also re-
quire that addition is commutative, multiplication
distributes over addition, and that multiplication
by 0̄ annihilates (i.e., 0̄ ⌦ a = a ⌦ 0̄ = 0̄).

One common semiring is the real (or plus-
times) semiring: hR, +, ·, 0, 1i. The other one
used in this work is the max-plus semir-
ing hR [ {�1}, max, +, �1, 0i. We refer the
reader to Kuich and Salomaa (1986) for others.

Definition 2. A weighted finite-state automaton
(WFSA) over a semiring K is a 5-tuple, A =
h⌃, Q, ⌧, �, ⇢i,2 with:

2Some authors define ⌧ , �, and ⇢ to be partial functions—
applying only a subset of transitions, initial states, and final

• a finite input alphabet ⌃;
• a finite state set Q;
• transition weights ⌧ : Q⇥Q⇥(⌃ [ {"}) ! K;
• initial weights � : Q ! K;
• and final weights ⇢ : Q ! K.
" /2 ⌃ marks special "-transitions that may be
taken without consuming any input. A assigns a
score AJxK to a string x = x1 . . . xn 2 ⌃⇤ by
summing over the scores of all possible paths de-
riving x. The score of each individual path is the
product of the weights of the transitions it consists
of. Formally:

Definition 3 (path score). Let ⇡ = ⇡1 . . . ⇡n be a
sequence of adjacent transitions in A, with each
transition ⇡i = (qi, qi+1, zi) 2 Q⇥Q⇥(⌃ [ {"}).
The path ⇡ derives string x 2 ⌃⇤, which is
the substring of z = z1z2 . . . zn that excludes
" symbols (for example, if z = a"bc"""d, then
x = abcd). ⇡’s score in A is given by

A[⇡] = �(q1) ⌦
 

nO

i=1

⌧(⇡i)

!
⌦ ⇢(qn+1). (1)

Definition 4 (string score). Let ⇧(x) denote the
set of all paths in A that derive x. Then the score
assigned by A to x is defined to be

AJxK =
M

⇡2⇧(x)

A[⇡]. (2)

Because K is a semiring, AJxK can be com-
puted in time linear in |x| by the Forward algo-
rithm (Baum and Petrie, 1966). Here, for simplic-
ity, we describe the Forward algorithm without "-
transitions.3 Its dynamic program is given by:

⌦0(q) = �(q), (3a)

⌦i+1(q) =
M

q02Q
⌦i(q

0) ⌦ ⌧(q0, q, xi), (3b)

AJxK =
M

q2Q
⌦n(q) ⌦ ⇢(q). (3c)

⌦i(q) gives the total score of all paths that derive
x1 . . . xi and end in state q.

Example 5. Figure 1 diagrams a WFSA B, con-
sisting of two states. A path starts from the initial
state q0 (with �(q0) = 1̄); it then takes any num-

states respectively. Our definition is equivalent, giving the
weight functions value 0̄ wherever they were undefined.

3"-transitions can be handled with a slight modifica-
tion (Schwartz et al., 2018). Note though that if A contains
a cycle of "-transitions, then either K must follow the star
semiring laws (Kuich and Salomaa, 1986), or the number of
consecutive "-transitions allowed must be capped.

https://github.com/Noahs-ARK/rational-recurrences
https://github.com/Noahs-ARK/rational-recurrences


1205

ber of “self-loop” transitions, each consuming an
input without changing the path score (since it’s
weighted by 1̄); it then consumes an input sym-
bol ↵ and takes a transition weighted by µ(↵),
and reaches the final state q1 (with ⇢(q1) = 1̄);
it may further consume more input by taking self-
loops at q1, updating the path score by multiply-
ing it by �(↵) for each symbol ↵. Then from
Definition 4, we can calculate that B gives the
empty string score 0̄, and gives any nonempty
string x = x1 . . . xn 2 ⌃+ score BJxK =

n�1M

i=1

0

@µ(xi) ⌦
nO

j=i+1

�(xj)

1

A� µ(xn). (4)

B can be seen as capturing soft unigram pat-
terns (Davidov et al., 2010), in the sense that it
consumes one input symbol to reach the final state
from the initial state. It is straightforward to de-
sign WFSAs capturing longer patterns by includ-
ing more states (Schwartz et al., 2018), as we will
discuss later in §4 and §5.

3 Rational Recurrences

Before formally defining rational recurrences in
§3.2, we highlight the connection between WFSAs
and RNNs using a motivating example (§3.1).

3.1 A Motivating Example
We describe a simplified RNN which strips away
details of some recent RNNs, in order to highlight
the behaviors of the forget gate and the input.

Example 6. For an input sequence x = x1 . . . xn,
let the word embedding vector for xt be vt.
As in many gated RNN variants (Hochreiter and
Schmidhuber, 1997; Cho et al., 2014), we use a
forget gate ft, which is computed with an affine
transformation followed by an elementwise sig-
moid function �. The current input representation
ut is similarly computed, but with an optional non-
linearity (e.g., tanh) g. The hidden state ct can be
seen as a weighted sum of the previous state and
the new input, controlled by the forget gate.

ft = �
�
Wfvt + bf

�
, (5a)

ut = (1 � ft) � g
�
Wuvt + bu

�
, (5b)

ct = ft � ct�1 + ut. (5c)

The hidden state ct can then be used in down-
stream computation, e.g., to calculate output state
ht = tanh(ct), which is then fed to an MLP clas-
sifier. We focus only on the recurrent computation.

In Example 6, both ft and ut depend only on
the current input token xt (through vt), and not
the previous state. Importantly, the interaction
with the previous state ct�1 is not via affine trans-
formations followed by nonlinearities, as in, e.g.,
an Elman network (Elman, 1990), where ct =
tanh(Wcct�1 +Wvvt +bc). As we will discuss
later, this is important in relating this recurrent up-
date function to WFSAs.

Since the recurrent update in Equation 5c is el-
ementwise, for simplicity we focus on just the ith
dimension. Unrolling it in time steps, we get

[ct]i = [ft]i [ct�1]i + [ut]i

=
t�1X

j=1

0

@[uj ]i
tY

k=j+1

[fk]i

1

A+ [ut]i,
(6)

where [·]i denotes the ith dimension of a vector.
As noted by Lee et al. (2017), the hidden state at
time step t can be seen as a sum of previous in-
put representations, weighted by the forget gate;
longer histories typically get a smaller weight,
since the forget gate values are between 0 and 1
due to the sigmoid function.

Let’s recall the WFSA B (Figure 1 and Exam-
ple 5) using the real semiring hR, +, ·, 0, 1i. Equa-
tion 6 is recovered by parameterizing B’s weight
functions µ and � with

µ(xt) = [ut]i, �(xt) = [ft]i. (7)

Denote the resulting WFSA by Bi, and we have:

Proposition 7. Running a single layer RNN in Ex-
ample 6 over any nonempty input string x 2 ⌃+,
the ith dimension of its hidden state at time step t
equals the score assigned by Bi to x:t:

[ct]i = BiJx:tK. (8)

In other words, the ith dimension of the RNN
in Example 6 can be seen as a WFSA structurally
equivalent to B. Its weight functions are imple-
mented as the ith dimension of Equations 5, and
the learned parameters are the ith row of W and
b. Then it is straightforward to recover the full d-
dimensional RNN, by collecting d such WFSAs,
each of which is parametrized by a row in the Ws
and bs. Based on this observation, we are now
ready to formally define rational recurrences.

3.2 Recurrences and Rationality
For a function c: ⌃⇤ !Kd, its recurrence is said to
be the dependence of c(x:t) on c(x:t�1), for input



1206

sequence 8x 2 ⌃+. We discuss a class of recur-
rences that can be characterized by WFSAs. The
mathematical counterpart of WFSAs are rational
power series (Berstel and Reutenauer, 1988), jus-
tifying naming such recurrences rational:

Definition 8 (rational recurrence). The recurrence
of c : ⌃⇤ ! Kd is said to be rational, if there ex-
ists a set of weighted finite state automata {Ai}di=1
over alphabet ⌃ and semiring hK, �, ⌦, 0̄, 1̄i with
both � and ⌦ taking constant time and space, such
that 8x 2 ⌃⇤,

⇥
c(x)

⇤
i
= AiJxK, 8i 2 {1, 2, . . . , d}.4 (9)

It directly follows from Proposition 7 that

Corollary 9. The recurrence in Example 6 is ra-
tional.

4 Relationship to Existing Neural Models

This section studies several recently proposed neu-
ral architectures, and relates them to rational re-
currences. §4.1 begins by relating some of them
to the RNN defined in Example 6, and then to the
WFSA B (Example 5). We then describe a WFSA
similar to B, but with one additional state, and dis-
cuss how it provides a new view of RNN mod-
els motivated by n-gram features (§4.2). In §4.3
we study rational recurrences that are not elemen-
twise, using an existing model.

In the following discussion, we shall assume the
real seimiring, unless otherwise noted.

4.1 Neural Architectures Related to B

Despite its simplicity, Example 6 corresponds to
several existing neural architectures. For instance,
quasi-RNN (QRNN; Bradbury et al., 2017) and
simple recurrent unit (SRU; Lei et al., 2017b)
aim to speed up the recurrent computation. To
do so, they drop the matrix multiplication depen-
dence on the previous hidden state, resulting in
similar recurrences to that in Example 6.5 Other
works start from different motivations, but land on
similar recurrences, e.g., strongly-typed RNNs (T-
RNN; Balduzzi and Ghifary, 2016) and its gated

4We restrict that both operations take constant time and
space, to exclude the use of arbitrarily complex semir-
ings (§4.3).

5The SRU architecture discussed through this work is
based on Lei et al. (2017b). In a later updated version, Lei
et al. (2018) introduce diagonal matrix multiplication interac-
tion in the hidden state updates, inspired by (Li et al., 2018),
which yields a recurrence not obviously rational.

variants (T-LSTM and T-GRU), and structurally
constrained RNNs (SCRN; Mikolov et al., 2014).

The analysis in §3.1 directly applies to SRU,
T-RNN, and SCRN. In fact, Example 6 presents
a slightly more complicated version of them. In
these models, input representations are computed
without the bias term or any nonlinearity: ut =
Wuvt. By Proposition 7 and Corollary 9:
Corollary 10. The recurrences of single-layer
SRU, T-RNN, and SCRN architectures are ratio-
nal.

It is slightly more complicated to analyze the
recurrences of the QRNN, T-LSTM, and T-GRU.
Although their hidden states ct are updated in the
same way as Equation 5c, the input representa-
tions and gates may depend on previous inputs.
For example, in T-LSTM and T-GRU, the forget
gate is a function of two consecutive inputs:

ft = � (Vfvt�1 + Wfvt + bf ) . (10)

QRNNs are similar, but may depend on up to K
tokens, due to the K-window convolutions. Eis-
ner (2002) discuss finite state machines for sec-
ond (or higher) order probabilistic sequence mod-
els. Following the same intuition, we sketch the
construction of WFSAs corresponding to QRNNs
with 2-window convolutions in Appendix A, and
summarize the key results here:
Proposition 11. The recurrences of single-layer
T-GRU, T-LSTM, and QRNN are rational. In par-
ticular, a single-layer d-dimensional QRNN using
K-window convolutions can be recovered by a set
of d WFSAs, each with O(2 |⌃|K�1) states.

The size of WFSAs needed to recover QRNN
grows exponentially in the window size. There-
fore, at least for QRNNs, Proposition 11 has more
conceptual value than practical.

4.2 More than Two States
So far our discussion has centered on B, a two-
state WFSA capturing unigram patterns (Exam-
ple 5). In the same spirit as going from unigram to
n-gram features, one can use WFSAs with more
states to capture longer patterns (Schwartz et al.,
2018). In this section we augment B by intro-
ducing more states, and explore its relationship
to some neural architectures motivated by n-gram
features. We start with a three-state WFSA as an
example, and then discuss more general cases.

Figure 2 diagrams a WFSA C, augmenting B
with another state. To reach the final state q2, at



1207

q0

8↵/1

q1

8↵/�1(↵)

q2/1

8↵/�2(↵)

8↵/µ2(↵)8↵/µ1(↵)

Figure 2: A three-state WFSA C discussed in §4.2.

least two transitions must be taken, in contrast to
one in B. History information is decayed by the
self-loop at the final state q2, assuming �2 is be-
tween 0 and 1. C has another self-loop over q1,
weighted by �1 2 (0, 1). The motivation is to
allow (but down-weight) nonconsecutive bigrams,
as we will soon show.

The scores assigned by C can be inductively
computed by applying the Forward algorithm (§2).
Given input sequence x longer than one, let
CJx:0K = 0, then CJx:t+1K =

CJx:tK �2(xt+1) + �t µ2(xt+1), (11)

where

�t = �t�1 �1(xt) + µ1(xt), (12)

and �0 = 0. Unrolling �t in time, we get �t =

t�1X

j=1

0

@µ1(xj)
tY

k=j+1

�1(xk)

1

A+ µ1(xt). (13)

Due to the self-loop over state q1, �t can be seen
as a weighted sum of the µ1 terms up to xt (Equal-
tion 13). The second product term in Equation 11
then provides multiplicative interactions between
µ2, and the weighted sum of µ1s. In this sense, it
captures nonconsecutive bigram features.

At a first glance, Equations 11 and 12
resemble recurrent convolutional neural net-
works (RCNN; Lei et al., 2016). RCNN is in-
spired by nonconsecutive n-gram features and low
rank tensor factorization. It is later studied from a
string kernel perspective (Lei et al., 2017a). Here
we review its nonlinear bigram version:

c(1)t = c
(1)
t�1 � �t + u

(1)
t , (14a)

c(2)t = c
(2)
t�1 � �t + c

(1)
t�1 � u

(2)
t , (14b)

where the u(j)t s are computed similarly to Equa-
tion 5b, and c(2)t is used as output for onward
computation. Different strategies to computing �t
were explored (Lei et al., 2015, 2016). When �t
is a constant, or depends only on xt, e.g., �t =
�(W�vt+b�), the ith dimension of Equations 14

8↵/µ1,2(↵)

8↵/µ2,1(↵)
q1

8↵/µ1,1(↵)8↵/1

8↵/⌘1(↵)

8↵/µ2,2(↵) 8↵/1

8↵/⌘2(↵)
q2/1 q3 q4

Figure 3: WFSA D1 discussed in §4.3. Two initial
states q1 and q4 are used here.

can be recovered from Equation 11, by letting

µj(xt) = [u
(j)
t ]i, �j(xt) = [�t]i, j = 1, 2. (15)

It is straightforward to generalize the above dis-
cussion to higher order cases: n-gram RCNN cor-
responds to WFSAs with n + 1 states, constructed
similarly to how we build C from B (Appendix B).

Proposition 12. For a single-layer RCNN with �t
being a constant or depending only on xt, the re-
currence is rational.

As noted later in §4.3, its recurrence may not be
rational when �t = �(Wcct�1 + W�vt + b�).

4.3 Beyond Elementwise Operations

So far we have discussed rational recurrences for
models using elementwise recurrent updates (e.g.,
Equation 5c). This section uses an existing model
as an example, to study a rational recurrence that is
not elementwise. We focus on the input switched
affine network (ISAN; Foerster et al., 2017). Aim-
ing for efficiency and interpretability, it does not
use any explicit nonlinearity; its affine transforma-
tion parameters depend only on the input:

ct = Wxtct�1 + bxt . (16)

Due to the matrix multiplication, the recurrence of
a single-layer ISAN is not elementwise. Yet, we
argue that it is rational. We will sketch the proof
for a 2-dimensional case, and it is straightforward
to generalize to higher dimensions (Appendix C).

We define two WFSAs, each recovering one di-
mension of ISAN’s recurrent updates. Figure 3
diagrams one of them, D1. The other one, D2,
is identical (including shared weights), except us-
ing q3 instead of q2 as the final state. For any
nonempty input sequence x 2 ⌃+, the scores
assigned by D1 and D2 can be inductively com-
puted by applying the Forward algorithm. Letting
D1Jx:0K = D2Jx:0K = 0, for t � 1

D1Jx:tK
D2Jx:tK

�
= fWxt


D1Jx:t�1K
D2Jx:t�1K

�
+ ebxt , (17)



1208

where

fWxt =

µ1,1(xt) µ1,2(xt)
µ2,1(xt) µ2,2(xt)

�
,

ebxt =

⌘1(xt)
⌘2(xt)

�
.

(18)

Then Equation 16, in the case of hidden size 2, is
recovered by letting Wxt = fWxt and bxt = ebxt .
Proposition 13. The recurrence of a single-layer
ISAN is rational.

Corollary 14. For a single-layer Elman network,
in the absence of any nonlinearity, the recurrence
is rational.

Discussion. It is known that an Elman network
can approximate any recursively computable par-
tial function (Siegelmann and Sontag, 1995). On
the other hand, in their single-layer cases, WFSAs
(and thus models with rational recurrences) are re-
stricted to rational series (Schützenberger, 1961).
Therefore, we hypothesize that models like Elman
networks, LSTMs, and GRUs, where the recur-
rences depend on previous states through affine
transformations followed by nonlinearities, are not
rational.

This work does not intend to propose rational
recurrences as a concept general enough to include
most existing RNNs. Rather, we wish to study a
more constrained class of methods to better under-
stand the connections between WFSAs and RNNs.
Therefore in Definition 8, we restrict the semir-
ings to be “simple,” in the sense that both opera-
tions take constant time and space. Such a restric-
tion aims to exclude the possibility of hiding arbi-
trarily complex computations inside the semiring,
which might allow RNNs to satisfy the definition
in a trivial and unilluminating way.

Such theoretical limitations might be less se-
vere than they appear, since it is not yet entirely
clear what they correspond to in practice, espe-
cially when multiple vertical layers of these mod-
els are used (Leshno and Schocken, 1993). We
defer to future work the further study of the con-
nections between WFSAs and Elman-style RNNs.

Closing this section, Table 1 summarizes the
discussed recurrent neural architectures and their
corresponding WFSAs.

5 Deriving Neural Models from WFSAs

Rational recurrences provide a new view of several
recently proposed neural models. Based on such

Models Recurrence Function WFSA

§4.1 SRU, SCRN ct = ft � ct�1 + ut BT-RNN, QRNN

§4.2 RCNN
c(1)t = c

(1)
t�1 � �t + u

(1)
t

c(2)t = c
(2)
t�1 � �t + c

(1)
t�1 � u

(2)
t

C

§4.3 ISAN ct = Wxtct�1 + bxt D1,D2

Table 1: Recurrent neural network architectures
discussed in §4 and their corresponding WFSAs.
§4.1: SRU (Lei et al., 2017b), SCRN (Mikolov
et al., 2014), T-RNN and its gated variants (Bal-
duzzi and Ghifary, 2016), and QRNN (Bradbury
et al., 2017); §4.2: RCNN (Lei et al., 2016); §4.3:
ISAN (Foerster et al., 2017).

observations, this section aims to explore potential
approaches to designing neural architectures in a
more interpretable and intuitive way: by deriving
them from WFSAs. §5.1 studies an interpolation
of unigram and bigram features by combining 2-
state and 3-state WFSAs (Figures 1 and 2). We
then explore alternative semirings (§5.2), an ap-
proach orthogonal to what we’ve discussed so far.

We note that our goal is not to devise new state-
of-the-art architectures. Rather, we illustrate a
new design process for neural architectures that
draws inspiration from WFSAs. That said, in our
experiments (§6), one of our new architectures
performs as well as or better than strong baselines.

5.1 Aggregating Different Length Patterns
We start by presenting a straightforward extension
to 2-state and 3-state rational models: one com-
bining both. It is inspired by many classical NLP
models, where unigram features and higher-order
ones are interpolated.

Figure 4 diagrams a 4-state WFSA F. Com-
pared to C (Figure 2), F uses q1 as a second fi-
nal state, aiming to capture both unigram and bi-
gram patterns, since a path is allowed to stop at
q1 after consuming one input. The final states are
weighted by ⇢1 and ⇢2 respectively. Another no-
table modification is the additional state q3, which
is used to create a “shortcut” to reach q2, together
with an "-transition. Specifically, starting from q0,
a path can now take the "-transition and reach q3,
and then take a transition with weight µ2 to reach
q2. Recall from §2, that "-transitions do not con-
sume any input, yet they can still be weighted by a
(parameterized) function � not depending on the
inputs. The "-transition allows for skipping the



1209

q0

8↵/1 8↵/�1(↵) 8↵/�2(↵)

8↵/µ2(↵)8↵/µ1(↵)

q3

"/� 8↵/µ2(↵)

q1/⇢1 q2/⇢2

Figure 4: A WFSA F that combines both unigram
and bigram features (§5.1). Two final states q1 and
q2 are used, with weights ⇢1 and ⇢2, respectively.

first word in a bigram. It can be discouraged by
using � 2 (0, 1), just as we do in our experiments.

Deriving the neural architecture. As in §3, we
relate hidden states of an RNN to the scores as-
signed by WFSAs to input strings. We then derive
the neural architecture with a dynamic program.
Here we keep the discussion self-contained by ex-
plicitly overviewing the procedure. It is a direct
application of the Forward algorithm (§2), though
now in a form that deals with the "-transition.
Such an approach applies, of course, to more gen-
eral cases, as noted by Schwartz et al. (2018).

Given an input string x 2 ⌃+, let z(j)t denote
the total score of all paths landing in state qj just
after consuming xt. Let z

(j)
0 = 0, then for t � 1,

z
(0)
t = 1

z
(1)
t = z

(1)
t�1 �1(xt) + z

(0)
t�1 µ1(xt)

z
(3)
t = z

(0)
t �

z
(2)
t = z

(2)
t�1 �2(xt) + (z

(1)
t�1 + z

(3)
t�1) µ2(xt)

FJx:tK = ⇢1 z(1)t + ⇢2 z
(2)
t .

We now collect d of these WFSAs to construct an
RNN, and we parameterize their weight functions
with the technique we’ve been using:

c(1)t = c
(1)
t�1 � f

(1)
t + u

(1)
t , (19a)

c(2)t = c
(2)
t�1 � f

(2)
t + (c

(1)
t�1 + r) � u

(2)
t , (19b)

ct = p
(1) � c(1)t + p(2) � c

(2)
t , (19c)

where

f (j)t = �
�
W(j)f vt + b

(j)
f

�
, (20a)

u(j)t = (1 � f
(j)
t ) � g

�
W(j)u vt + b

(j)
u

�
, (20b)

p(j) = �(b(j)p ), r = �(br). (20c)

The p vectors correspond to the final state weights
⇢1 and ⇢2. Despite the similarities, p are different
from output gates (Bradbury et al., 2017), since the
former do not depend on the input, and are param-

Model Unigram Bigram Semiring

RRNN(B) X real
RRNN(B)m+ X max-plus
RRNN(C) X real
RRNN(F) X X real

Table 2: Rational recurrent neural architectures
compared in the experiments (§6.1).

eterized (through a sigmoid) by two leanred vec-
tors b(j)p . The same applies to r and br, which
correspond to the weights for "-transitions �.

5.2 Alternative Semirings
Our new understanding of rational recurrences al-
lows us to consider a different kind of extension:
replacing the semiring. We introduce an example,
which modifies Example 6 by replacing its real
(plus-times) semiring with the max-plus semir-
ing hR [ {�1}, max, +, �1, 0i:
Example 15.

ft = log�
�
Wfvt + bf

�
, (21a)

ut = g
�
Wuvt + bu

�
, (21b)

ct = max{ft + ct�1,ut}. (21c)

Example 15 does not use the forget gate when
computing ut (Equation 21b), which is differ-
ent from its plus-times counterpart, where ut =
(1� ft)� g

�
Wuvt +bu

�
. The reason is that, un-

like the real semiring, the max-plus semiring lacks
a well-defined negation. Possible alternatives in-
clude taking the log of a separate input gate, or
using log(1� ft), which we leave for future work.

Example 15 can be seen as replacing sum-
pooling with max-pooling. Both max and sum-
pooling have been used successfully in vision and
NLP models. Intuitively, max-pooling “detects”
the occurrence of a pattern while sum-pooling
“counts” the occurrence of a pattern. One advan-
tage of max operator is that the model’s decisions
can be back-traced and interpreted, as argued by
Schwartz et al. (2018). Such a technique is appli-
cable to all the models with rational recurrences.

6 Experiments

This section evaluates four rational RNNs on
language modeling (§6.2) and text categoriza-
tion (§6.3). Our goal is to compare the behaviors
of models derived from different WFSAs, show-
ing that our understanding of WFSAs allows us to



1210

improve existing rational models.

6.1 Compared Models
Our comparisons focus on the recurrences of the
models, i.e., how the hidden states ct are com-
puted (e.g., Equations 5c and 19c). Therefore we
follow Lei et al. (2017b) and use u(j)t = W

(j)
u v

(j)
t

across all compared models, listed below and as
well as in Table 2:
• RRNN(B), with real semiring (§4.1);
• RRNN(B)m+, with max-plus semiring (§5.2);
• RRNN(C), with real semiring (§4.2);
• RRNN(F), with real semiring (§5.1).

We also compare to an LSTM baseline. Aiming
to control for comfounding factors, we do not use
highway connections in any of the models.6 In the
interest of space, the full architectures and hyper-
parameters are detailed in Appendices D and E.

6.2 Language Modeling
Dataset and implementation. We experiment
with the Penn Treebank corpus (PTB; Marcus
et al., 1993). We use the preprocessing and splits
from Mikolov et al. (2010), resulting in a vocabu-
lary size of 10K and 1M tokens.

Following standard practice, we treat the train-
ing data as one long sequence, split into mini
batches, and train using BPTT truncated to 35
time steps (Williams and Peng, 1990). The in-
put embeddings and output softmax weights are
tied (Press and Wolf, 2017).

Results. Following Collins et al. (2017) and
Melis et al. (2018), we compare models con-
trolling for parameter budget. Table 3 sum-
marizes language modeling perplexities on PTB
test set. The middle block compares all mod-
els with two layers and 10M trainable parameters.
RRNN(B) and RRNN(C) achieve roughly the same
performance; interpolating both unigram and bi-
gram features, RRNN(F) outperforms others by
more than 2.9 test perplexity. For the three-layer
and 24M setting (the bottom block), we observe
similar trends, except that RRNN(C) slightly under-
performs RRNN(B). Here RRNN(F) outperforms
others by more than 2.1 perplexity.

Using a max-plus semiring, RRNN(B)m+ un-
derperforms RRNN(B) under both settings. Possi-
ble reasons could be the suboptimal design choice

6Thus RRNN(B) is essentially an SRU without highway
connections. We denote it differently, to note its differences
from the original implementation (Lei et al., 2017b). Simi-
larly, we do not denote RRNN(C) as RCNN (Lei et al., 2016).

Model ` # Params. Dev. Test

LSTM 2 24M 73.3 71.4
LSTM 3 24M 78.8 76.2

RRNN(B) 2 10M 73.1 69.2
RRNN(B)m+ 2 10M 75.1 71.7
RRNN(C) 2 10M 72.5 69.5
RRNN(F) 2 10M 69.5 66.3

RRNN(B) 3 24M 68.7 65.2
RRNN(B)m+ 3 24M 70.8 66.9
RRNN(C) 3 24M 70.0 67.0
RRNN(F) 3 24M 66.0 63.1

Table 3: Language modeling perplexity on PTB
test set (lower is better). LSTM numbers are taken
from Lei et al. (2017b). ` denotes the number of
layers. Bold font indicates best performance.

Split Amazon SST subj CR

Train 20K 6.9K 8K 3.0K
Dev. 05K 0.9K 1K 0.4K
Test 25K 1.8K 1K 0.4K

Table 4: Number of instances in the text classifica-
tion datasets (§6.3).

for computing input representations in the for-
mer (§5.2). Finally, most compared models out-
perform the LSTM baselines, whose numbers are
taken from Lei et al. (2017b).7

6.3 Text Classification
Implementation. We use unidirectional 2-layer
architectures for all compared models. To build
the classifiers, we feed the final RNN hidden states
into a 2-layer tanh-MLP. Further implementation
details are described in Appendix E.

Datasets. We experiment with four binary text
classification datasets, described below.
• Amazon (electronic product review corpus;

McAuley and Leskovec, 2013).8 We focus on
the positive and negative reviews.

• SST (Stanford sentiment treebank; Socher et al.,
2013).9 We focus on the binary classification
task. SST provides labels for syntactic phrases;
we experiment with a more realistic setup, and
7Melis et al. (2018) point out that carefully tuning LSTMs

can achieve much stronger performance, at the cost of excep-
tionally large amounts of computational resources for tuning.

8
http://riejohnson.com/cnn_data.html

9
nlp.stanford.edu/sentiment/index.html

http://riejohnson.com/cnn_data.html
nlp.stanford.edu/sentiment/index.html


1211

Model Amazon SST subj CR

LSTM 91.2±0.3 85.1±0.6 93.3±0.6 82.4±1.5
RRNN(B) 92.4±0.1 85.8±0.3 93.9±0.4 84.1±1.0
RRNN(C) 92.8±0.2 84.8±0.4 93.8±0.6 84.5±0.9
RRNN(B)m+ 89.2±3.1 84.9±0.4 92.6±0.5 84.3±0.5
RRNN(F) 92.7±0.2 86.5±0.6 94.8±0.5 85.1±0.5

Table 5: Text classification test accuracy averaged
over 5 runs. ± denotes standard deviation, and
bold font indicates best averaged performance.

consider only complete sentences at either train-
ing or evaluating time.

• subj (Subjectivity dataset; Pang and Lee, 2004).
As subj doesn’t come with official splits, we
randomly split it to train (80%), development
(10%), and test (10%) sets.

• CR (customer reviews dataset; Hu and Liu,
2004).10 As with subj, we randomly split this
dataset using the same ratio.

Table 4 summarizes the sizes of the datasets.

Results. Table 5 summarizes text classification
test accuracy. We report the average perfor-
mance of 5 trials different only in random seeds.
RRNN(F) outperforms all other models on 3 out
of the 4 datasets. For Amazon, the largest one,
we do not observe significant differences between
RRNN(F) and RRNN(C), while both outperform
others. This may suggest that the interpolation
of unigram and bigram features by RRNN(F) is
especially useful in small data setups. As in the
language modeling experiments, RRNN(B)m+ un-
derperforms all other models in most cases, and
in particular RRNN(B). These results provide ev-
idence that replacing the real semiring in rational
models might be challenging. We leave further ex-
ploration to future work.

7 Related Work

Weighted finite state automata. WFSAs were
once popular among many sequential tasks (Mohri
et al., 2002; Kumar and Byrne, 2003; Cortes et al.,
2004; Pardo and Birmingham, 2005; Moore et al.,
2006, inter alia), and are still successful in mor-
phology (Dreyer, 2011; Cotterell et al., 2015; Ras-
togi et al., 2016, inter alia). Compared to neural
networks, WFSAs are better understood theoreti-

10
http://www.cs.uic.edu/?liub/FBS/

sentiment-analysis.html

cally and arguably more interpretable. They were
recently revisited in combination with the for-
mer in, e.g., text generation (Ghazvininejad et al.,
2016, 2017; Lin et al., 2017) and automatic music
accompaniment (Forsyth, 2016).

Recurrent neural networks. RNNs (Elman,
1990; Jordan, 1989) prove to be strong mod-
els for sequential data (Siegelmann and Sontag,
1995). Besides the perhaps most notable gated
variants (Hochreiter and Schmidhuber, 1997; Cho
et al., 2014), extensive efforts have been devoted
to developing alternatives (Balduzzi and Ghifary,
2016; Miao et al., 2016; Zoph and Le, 2017; Lee
et al., 2017; Lei et al., 2017a; Vaswani et al., 2017;
Gehring et al., 2017, inter alia). Departing from
the above approaches, this work derives RNN ar-
chitectures drawing inspiration from WFSAs.

Another line of work studied the connections
between WFSAs and RNNs in terms of model-
ing capacity, both empirically (Kolen, 1993; Giles
et al., 1992; Weiss et al., 2018, inter alia) and the-
oretically (Cleeremans et al., 1989; Visser et al.,
2001; Chen et al., 2018, inter alia).

8 Conclusion
We presented rational recurrences, a new con-
struction to study the recurrent updates in RNNs,
drawing inspiration from WFSAs. We showed
that rational recurrences are in frequent use by
several recently proposed recurrent neural archi-
tectures, providing new understanding of them.
Based on such connections, we discussed ap-
proaches to deriving novel neural architectures
from WFSAs. Our empirical results demonstrate
the potential of doing so. We publicly release our
implementation at https://github.com/
Noahs-ARK/rational-recurrences.

Acknowledgments
We thank Jason Eisner, Luheng He, Tao Lei, Omer
Levy, members of the ARK lab at the University
of Washington, and researchers at the Allen In-
stitute for Artificial Intelligence for their helpful
comments on an early version of this work, and the
anonymous reviewers for their valuable feedback.
We also thank members of the Aristo team at the
Allen Institute for Artificial Intelligence for their
support with the Beaker experimentation system.
This work was supported in part by NSF grant IIS-
1562364 and by the NVIDIA Corporation through
the donation of a Tesla GPU.

http://www.cs.uic.edu/?liub/FBS/sentiment-analysis.html
http://www.cs.uic.edu/?liub/FBS/sentiment-analysis.html
https://github.com/Noahs-ARK/rational-recurrences
https://github.com/Noahs-ARK/rational-recurrences


1212

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-

gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proc. of ICLR.

David Balduzzi and Muhammad Ghifary. 2016.
Strongly-typed recurrent neural networks. In Proc.
of ICML.

Leonard E. Baum and Ted Petrie. 1966. Statistical
inference for probabilistic functions of finite state
Markov chains. The Annals of Mathematical Statis-
tics, 37(6):1554–1563.

Jean Berstel, Jr. and Christophe Reutenauer. 1988. Ra-
tional Series and Their Languages. Springer-Verlag,
Berlin, Heidelberg.

James Bradbury, Stephen Merity, Caiming Xiong, and
Richard Socher. 2017. Quasi-recurrent neural net-
work. In Proc. of ICLR.

Yining Chen, Sorcha Gilroy, Kevin Knight, and
Jonathan May. 2018. Recurrent neural networks as
weighted language recognizers. In Proc. of NAACL.

Kyunghyun Cho, Bart Van Merriënboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using RNN encoder-decoder
for statistical machine translation. In Proc. of
EMNLP.

Axel Cleeremans, David Servan-Schreiber, and
James L. McClelland. 1989. Finite state automata
and simple recurrent networks. Neural computation,
1(3):372–381.

Jasmine Collins, Jascha Sohl-Dickstein, and David
Sussillo. 2017. Capacity and trainability in recur-
rent neural networks. In Proc. of ICLR.

Corinna Cortes, Patrick Haffner, and Mehryar Mohri.
2004. Rational kernels: Theory and algorithms.
Journal of Machine Learning Research, 5:1035–
1062.

Ryan Cotterell, Nanyun Peng, and Jason Eisner.
2015. Modeling word forms using latent underly-
ing morphs and phonology. TACL, 3:433–447.

Dmitry Davidov, Oren Tsur, and Ari Rappoport. 2010.
Enhanced sentiment learning using twitter hashtags
and smileys. In Proc. of COLING.

Markus Dreyer. 2011. A Non-parametric Model for the
Discovery of Inflectional Paradigms from Plain Text
Using Graphical Models over Strings. Ph.D. thesis,
Johns Hopkins University.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In Proc. of NAACL.

Jason Eisner. 2002. Parameter estimation for proba-
bilistic finite-state transducers. In Proc. of ACL.

Jeffrey L. Elman. 1990. Finding structure in time.
Cognitive science, 14(2):179–211.

Jakob N. Foerster, Justin Gilmer, Jan Chorowski,
Jascha Sohl-Dickstein, and David Sussillo. 2017.
Intelligible language modeling with input switched
affine networks. In Proc. of ICML.

Jonathan P. Forsyth. 2016. Automatic musical accom-
paniment using finite state machines. Ph.D. thesis,
New York University.

Jonas Gehring, Michael Auli, David Grangier, Denis
Yarats, and Yann Dauphin. 2017. Convolutional se-
quence to sequence learning. In Proc. of ICML.

Marjan Ghazvininejad, Xing Shi, Yejin Choi, and
Kevin Knight. 2016. Generating topical poetry. In
Proc. of EMNLP.

Marjan Ghazvininejad, Xing Shi, Jay Priyadarshi, and
Kevin Knight. 2017. Hafez: an interactive poetry
generation system. In Proc. of ACL, System Demon-
strations.

C. Lee Giles, Clifford B Miller, Dong Chen, Hsing-
Hen Chen, Guo-Zheng Sun, and Yee-Chun Lee.
1992. Learning and extracting finite state automata
with second-order recurrent neural networks. Neu-
ral Computation, 4(3):393–405.

Yoav Goldberg. 2016. A primer on neural network
models for natural language processing. JAIR,
57:345–420.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Minqing Hu and Bing Liu. 2004. Mining and summa-
rizing customer reviews. In Proc. of KDD.

Michael I. Jordan. 1989. Serial order: A parallel, dis-
tributed processing approach. In Advances in Con-
nectionist Theory: Speech. Erlbaum.

Diederik Kingma and Jimmy Ba. 2015. Adam: A
method for stochastic optimization. In Proc. of
ICLR.

John F. Kolen. 1993. Fool’s gold: Extracting finite
state machines from recurrent network dynamics. In
Proc. of NIPS.

Werner Kuich and Arto Salomaa, editors. 1986. Semir-
ings, Automata, Languages. Springer-Verlag.

Shankar Kumar and William Byrne. 2003. A weighted
finite state transducer implementation of the align-
ment template model for statistical machine transla-
tion. In Proc. of NAACL.

Yann LeCun. 1998. Gradient-based Learning Applied
to Document Recognition. In Proc. of the IEEE.

Kenton Lee, Omer Levy, and Luke Zettlemoyer. 2017.
Recurrent additive networks. arXiv:1705.07393.



1213

Tao Lei, Regina Barzilay, and Tommi Jaakkola. 2015.
Molding CNNs for text: non-linear, non-consecutive
convolutions. In Proc. of EMNLP.

Tao Lei, Wengong Jin, Regina Barzilay, and Tommi
Jaakkola. 2017a. Deriving neural architectures from
sequence and graph kernels. In Proc. of ICML.

Tao Lei, Hrishikesh Joshi, Regina Barzilay, Tommi
Jaakkola, Kateryna Tymoshenko, Alessandro Mos-
chitti, and Lluı́s Màrquez. 2016. Semi-supervised
question retrieval with gated convolutions. In Proc.
of NAACL.

Tao Lei, Yu Zhang, and Yoav Artzi. 2017b. Training
RNNs as fast as CNNs. arXiv:1709.02755.

Tao Lei, Yu Zhang, Sida I. Wang, Hui Dai, and Yoav
Artzi. 2018. Simple recurrent units for highly paral-
lelizable recurrence. In Proc. of EMNLP.

Moshe Leshno and Shimon Schocken. 1993. Multi-
layer feedforward networks with a nonpolynomial
activation function can approximate any function.
Neural Networks, 6:861–867.

Shuai Li, Wanqing Li, Chris Cook, Ce Zhu, and Yanbo
Gao. 2018. Independently recurrent neural network
(IndRNN): Building A longer and deeper RNN. In
Proc. of CVPR.

Kevin Lin, Dianqi Li, Xiaodong He, Zhengyou Zhang,
and Ming-Ting Sun. 2017. Adversarial ranking for
language generation. In Proc. of NIPS.

Mitchell P. Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1993. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional Linguistics, 19(2):313–330.

Julian McAuley and Jure Leskovec. 2013. Hidden fac-
tors and hidden topics: understanding rating dimen-
sions with review text. In Proc. of RecSys.

Gábor Melis, Chris Dyer, and Phil Blunsom. 2018. On
the state of the art of evaluation in neural language
models. In Proc. of ICLR.

Yajie Miao, Jinyu Li, Yongqiang Wang, Shi-Xiong
Zhang, and Yifan Gong. 2016. Simplifying long
short-term memory acoustic models for fast training
and decoding. In Proc. of ICASSP.

Tomas Mikolov, Armand Joulin, Sumit Chopra,
Michaël Mathieu, and Marc’Aurelio Ranzato. 2014.
Learning longer memory in recurrent neural net-
works. arXiv:1412.7753.

Tomas Mikolov, Martin Karafit, Luks Burget, Jan Cer-
nock, and Sanjeev Khudanpur. 2010. Recurrent neu-
ral network based language model. In Proc. of IN-
TERSPEECH.

Mehryar Mohri, Fernando Pereira, and Michael Ri-
ley. 2002. Weighted finite-state transducers in
speech recognition. Computer Speech & Language,
16(1):69–88.

Darren Moore, John Dines, Mathew Magimai-Doss,
Jithendra Vepa, Octavian Cheng, and Thomas Hain.
2006. Juicer: A weighted finite-state transducer
speech decoder. In Proc. of MLMI.

Bo Pang and Lillian Lee. 2004. A sentimental educa-
tion: Sentiment analysis using subjectivity summa-
rization based on minimum cuts. In Proc. of ACL.

Bryan Pardo and William Birmingham. 2005. Mod-
eling form for on-line following of musical perfor-
mances. In Proc. of AAAI.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, and Noah A. Smith. 2018.
Backpropagating through structured argmax using a
spigot. In Proc. of ACL.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. GloVe: Global vectors for word
representation. In Proc. of EMNLP.

Ofir Press and Lior Wolf. 2017. Using the output em-
bedding to improve language models. In Proc. of
EACL.

Pushpendre Rastogi, Ryan Cotterell, and Jason Eisner.
2016. Weighting finite-state transductions with neu-
ral context. In Proc. of NAACL.

Jacques Sakarovitch. 2009. Rational and recognisable
power series. In Manfred Droste, Werner Kuich, and
Heiko Vogler, editors, Handbook of Weighted Au-
tomata, pages 105–174. Springer Berlin Heidelberg,
Berlin, Heidelberg.

Marcel Paul Schützenberger. 1961. On the definition
of a family of automata. Information and Control,
4(2-3):245–270.

Roy Schwartz, Sam Thomson, and Noah A. Smith.
2018. SoPa: Bridging CNNs, RNNs, and weighted
finite-state machines. In Proc. of ACL.

Hava T. Siegelmann and Eduardo D. Sontag. 1995. On
the computational power of neural nets. Journal of
Computer and System Sciences, 50(1):132–150.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Ng, and
Christopher Potts. 2013. Recursive deep models
for semantic compositionality over a sentiment tree-
bank. In Proc. of EMNLP.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Ł ukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In Proc. of NIPS.

Ingmar Visser, Maartje EJ Raijmakers, and Peter CM
Molenaar. 2001. Hidden markov model interpreta-
tions of neural networks. In Connectionist Models of
Learning, Development and Evolution, pages 197–
206. Springer.



1214

Gail Weiss, Yoav Goldberg, and Eran Yahav. 2018. On
the practical computational power of finite precision
RNNs for language recognition. In Proc. of ACL.

Ronald J. Williams and Jing Peng. 1990. An efficient
gradient-based algorithm for online training of re-
current network trajectories. Neural computation,
2(4):490–501.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
2014. Recurrent neural network regularization.
arXiv:1409.2329.

Barret Zoph and Quoc V. Le. 2017. Neural architec-
ture search with reinforcement learning. In Proc. of
ICLR.


