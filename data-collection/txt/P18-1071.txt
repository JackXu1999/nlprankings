



















































Sequence-to-Action: End-to-End Semantic Graph Generation for Semantic Parsing


Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 766–777
Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics

766

Sequence-to-Action: End-to-End Semantic Graph Generation for
Semantic Parsing

Bo Chen†‡, Le Sun†, Xianpei Han†
†State Key Laboratory of Computer Science

Institute of Software, Chinese Academy of Sciences, Beijing, China
‡University of Chinese Academy of Sciences, Beijing, China

{chenbo,sunle,xianpei}@iscas.ac.cn

Abstract

This paper proposes a neural semantic
parsing approach – Sequence-to-Action,
which models semantic parsing as an end-
to-end semantic graph generation process.
Our method simultaneously leverages the
advantages from two recent promising di-
rections of semantic parsing. Firstly, our
model uses a semantic graph to represent
the meaning of a sentence, which has a
tight-coupling with knowledge bases. Sec-
ondly, by leveraging the powerful repre-
sentation learning and prediction ability
of neural network models, we propose a
RNN model which can effectively map
sentences to action sequences for seman-
tic graph generation. Experiments show
that our method achieves state-of-the-art
performance on OVERNIGHT dataset and
gets competitive performance on GEO and
ATIS datasets.

1 Introduction

Semantic parsing aims to map natural lan-
guage sentences to logical forms (Zelle and
Mooney, 1996; Zettlemoyer and Collins, 2005;
Wong and Mooney, 2007; Lu et al., 2008;
Kwiatkowski et al., 2013). For example, the
sentence “Which states border Texas?” will
be mapped to answer (A, (state (A),
next to (A, stateid ( texas )))).

A semantic parser needs two functions, one
for structure prediction and the other for seman-
tic grounding. Traditional semantic parsers are
usually based on compositional grammar, such as
CCG (Zettlemoyer and Collins, 2005, 2007), DCS
(Liang et al., 2011), etc. These parsers compose
structure using manually designed grammars, use
lexicons for semantic grounding, and exploit fea-

Sequence-to-Action 

RNN Model

Sentence

Action 

Sequence

Semantic 

Graph

Generate

Construct

Constraints

KB

 Which states border Texas?

add_variable:     A

add_type:           state

arg_node:           A

add_entity:        texas:st

add_edge:          next_to

arg_node:           A

arg_node:           texas:st

return:                 A

A
next_to

type
statereturn

texas:st

Figure 1: Overview of our method, with a demon-
stration example.

tures for candidate logical forms ranking. Un-
fortunately, it is challenging to design grammars
and learn accurate lexicons, especially in wide-
open domains. Moreover, it is often hard to design
effective features, and its learning process is not
end-to-end. To resolve the above problems, two
promising lines of work have been proposed: Se-
mantic graph-based methods and Seq2Seq meth-
ods.

Semantic graph-based methods (Reddy et al.,
2014, 2016; Bast and Haussmann, 2015; Yih et al.,
2015) represent the meaning of a sentence as a
semantic graph (i.e., a sub-graph of a knowledge
base, see example in Figure 1) and treat semantic
parsing as a semantic graph matching/generation
process. Compared with logical forms, seman-
tic graphs have a tight-coupling with knowledge
bases (Yih et al., 2015), and share many com-
monalities with syntactic structures (Reddy et al.,
2014). Therefore both the structure and seman-
tic constraints from knowledge bases can be eas-
ily exploited during parsing (Yih et al., 2015).
The main challenge of semantic graph-based pars-
ing is how to effectively construct the semantic
graph of a sentence. Currently, semantic graphs



767

are either constructed by matching with patterns
(Bast and Haussmann, 2015), transforming from
dependency tree (Reddy et al., 2014, 2016), or
via a staged heuristic search algorithm (Yih et al.,
2015). These methods are all based on manually-
designed, heuristic construction processes, mak-
ing them hard to handle open/complex situations.

In recent years, RNN models have achieved
success in sequence-to-sequence problems due to
its strong ability on both representation learning
and prediction, e.g., in machine translation (Cho
et al., 2014). A lot of Seq2Seq models have
also been employed for semantic parsing (Xiao
et al., 2016; Dong and Lapata, 2016; Jia and
Liang, 2016), where a sentence is parsed by trans-
lating it to linearized logical form using RNN
models. There is no need for high-quality lexi-
cons, manually-built grammars, and hand-crafted
features. These models are trained end-to-end,
and can leverage attention mechanism (Bahdanau
et al., 2014; Luong et al., 2015) to learn soft align-
ments between sentences and logical forms.

In this paper, we propose a new neural semantic
parsing framework – Sequence-to-Action, which
can simultaneously leverage the advantages of se-
mantic graph representation and the strong predic-
tion ability of Seq2Seq models. Specifically, we
model semantic parsing as an end-to-end semantic
graph generation process. For example in Figure
1, our model will parse the sentence “Which states
border Texas” by generating a sequence of ac-
tions [add variable:A, add type:state,
...]. To achieve the above goal, we first design an
action set which can encode the generation process
of semantic graph (including node actions such
as add variable, add entity, add type,
edge actions such as add edge, and operation ac-
tions such as argmin, argmax, count, sum,
etc.). And then we design a RNN model which
can generate the action sequence for constructing
the semantic graph of a sentence. Finally we fur-
ther enhance parsing by incorporating both struc-
ture and semantic constraints during decoding.

Compared with the manually-designed, heuris-
tic generation algorithms used in traditional se-
mantic graph-based methods, our sequence-to-
action method generates semantic graphs using a
RNN model, which is learned end-to-end from
training data. Such a learnable, end-to-end gener-
ation makes our approach more effective and can
fit to different situations.

Compared with the previous Seq2Seq seman-
tic parsing methods, our sequence-to-action model
predicts a sequence of semantic graph generation
actions, rather than linearized logical forms. We
find that the action sequence encoding can better
capture structure and semantic information, and
is more compact. And the parsing can be en-
hanced by exploiting structure and semantic con-
straints. For example, in GEO dataset, the action
add edge:next to must subject to the seman-
tic constraint that its arguments must be of type
state and state, and the structure constraint
that the edge next to must connect two nodes to
form a valid graph.

We evaluate our approach on three standard
datasets: GEO (Zelle and Mooney, 1996), ATIS
(He and Young, 2005) and OVERNIGHT (Wang
et al., 2015b). The results show that our
method achieves state-of-the-art performance on
OVERNIGHT dataset and gets competitive perfor-
mance on GEO and ATIS datasets.

The main contributions of this paper are sum-
marized as follows:

• We propose a new semantic parsing frame-
work – Sequence-to-Action, which models
semantic parsing as an end-to-end semantic
graph generation process. This new frame-
work can synthesize the advantages of se-
mantic graph representation and the predic-
tion ability of Seq2Seq models.

• We design a sequence-to-action model, in-
cluding an action set encoding for semantic
graph generation and a Seq2Seq RNN model
for action sequence prediction. We further
enhance the parsing by exploiting structure
and semantic constraints during decoding.
Experiments validate the effectiveness of our
method.

2 Sequence-to-Action Model for
End-to-End Semantic Graph
Generation

Given a sentence X = x1, ..., x|X|, our sequence-
to-action model generates a sequence of actions
Y = y1, ..., y|Y | for constructing the correct
semantic graph. Figure 2 shows an example.
The conditional probability P (Y |X) used in our



768

Sentence: Which river runs through the most states?

Semantic Graph:

Action Sequence:

      

most

arg_for_1 arg_for_2

A B

state

traverse 

typetype

river

return

Structure Semantic Arg 

add_operation most  

add_variable A  

add_type river A 

add_variable B  

add_type state B 

add_edge traverse A, B 

end_operation most A, B 

return A  

 

Figure 2: An example of a sentence paired with its
semantic graph, together with the action sequence
for semantic graph generation.

model is decomposed as follows:

P (Y |X) =
|Y |∏
t=1

P (yt|y<t, X) (1)

where y<t = y1, ..., yt−1.
To achieve the above goal, we need: 1) an ac-

tion set which can encode semantic graph genera-
tion process; 2) an encoder which encodes natural
language input X into a vector representation, and
a decoder which generates y1, ..., y|Y | conditioned
on the encoding vector. In following we describe
them in detail.

2.1 Actions for Semantic Graph Generation

Generally, a semantic graph consists of nodes
(including variables, entities, types) and edges
(semantic relations), with some universal opera-
tions (e.g., argmax, argmin, count, sum, and
not). To generate a semantic graph, we define six
types of actions as follows:

Add Variable Node: This kind of actions de-
notes adding a variable node to semantic graph. In
most cases a variable node is a return node (e.g.,
which, what), but can also be an intermediate vari-
able node. We represent this kind of action as
add variable:A, where A is the identifier of
the variable node.

Add Entity Node: This kind of actions denotes
adding an entity node (e.g., Texas, New York) and
is represented as add entity node:texas.
An entity node corresponds to an entity in knowl-
edge bases.

Add Type Node: This kind of actions denotes
adding a type node (e.g., state, city). We represent
them as add type node:state.

Add Edge: This kind of actions denotes adding
an edge between two nodes. An edge is a binary
relation in knowledge bases. This kind of actions
is represented as add edge:next to.

Operation Action: This kind of actions de-
notes adding an operation. An operation can be
argmax, argmin, count, sum, not, et al. Be-
cause each operation has a scope, we define two
actions for an operation, one is operation start ac-
tion, represented as start operation:most,
and the other is operation end action, repre-
sented as end operation:most. The sub-
graph within the start and end operation actions
is its scope.

Argument Action: Some above actions need
argument information. For example, which nodes
the add edge:next to action should connect
to. In this paper, we design argument actions
for add type, add edge and operation ac-
tions, and the argument actions should be put di-
rectly after its main action.

For add type actions, we put an argument ac-
tion to indicate which node this type node should
constrain. The argument can be a variable node
or an entity node. An argument action for a type
node is represented as arg:A.

For add edge action, we use two argu-
ment actions: arg1 node and arg2 node,
and they are represented as arg1 node:A and
arg2 node:B.

We design argument actions for different op-
erations. For operation:sum, there are
three arguments: arg-for, arg-in and
arg-return. For operation:count, they
are arg-for and arg-return. There are two
arg-for arguments for operation:most.

We can see that each action encodes both struc-
ture and semantic information, which makes it
easy to capture more information for parsing and
can be tightly coupled with knowledge base. Fur-
thermore, we find that action sequence encoding
is more compact than linearized logical form (See
Section 4.4 for more details).



769

b1 b2 bm

x1 x2 xm

attention

s1 s2 sn

y1 yn-1

softmax controller

y1 y2 yn

...

...

...

Figure 3: Our attention-based Sequence-to-Action
RNN model, with a controller for incorporating
constraints.

2.2 Neural Sequence-to-Action Model
Based on the above action encoding mechanism,
this section describes our encoder-decoder model
for mapping sentence to action sequence. Specif-
ically, similar to the RNN model in Jia and
Liang (2016), this paper employs the attention-
based sequence-to-sequence RNN model. Figure
3 presents the overall structure.
Encoder: The encoder converts the input se-
quence x1, ..., xm to a sequence of context-
sensitive vectors b1, ..., bm using a bidirectional
RNN (Bahdanau et al., 2014). Firstly each word xi
is mapped to its embedding vector, then these vec-
tors are fed into a forward RNN and a backward
RNN. The sequence of hidden states h1, ..., hm are
generated by recurrently applying the recurrence:

hi = LSTM(φ
(x)(xi), hi−1). (2)

The recurrence takes the form of LSTM (Hochre-
iter and Schmidhuber, 1997). Finally, for each in-
put position i, we define its context-sensitive em-
bedding as bi = [hFi , h

B
i ].

Decoder: This paper uses the classical attention-
based decoder (Bahdanau et al., 2014), which gen-
erates action sequence y1, ..., yn, one action at a
time. At each time step j, it writes yj based on
the current hidden state sj , then updates the hid-
den state to sj+1 based on sj and yj . The decoder
is formally defined by the following equations:

s1 = tanh(W
(s)[hFm, h

B
1 ]) (3)

eji = s
T
j W

(a)bi (4)

aji =
exp(eji)∑m

i′=1 exp(eji′ )
(5)

cj =

m∑
i=1

ajibi (6)

P (yj = w|x, y1:j−1) ∝ exp(Uw[sj , cj ]) (7)
sj+1 = LSTM([φ

(y)(yj), cj ], sj) (8)

where the normalized attention scores aji defines
the probability distribution over input words, in-
dicating the attention probability on input word i
at time j; eji is un-normalized attention score. To
incorporate constraints during decoding, an extra
controller component is added and its details will
be described in Section 3.3.
Action Embedding. The above decoder needs
the embedding of each action. As described
above, each action has two parts, one for struc-
ture (e.g., add edge), and the other for se-
mantic (e.g., next to). As a result, ac-
tions may share the same structure or se-
mantic part, e.g., add edge:next to and
add edge:loc have the same structure part,
and add node:A and arg node:A have the
same semantic part. To make parameters more
compact, we first embed the structure part and
the semantic part independently, then concate-
nate them to get the final embedding. For in-
stance, φ(y)(add edge:next to ) = [ φ(y)strut(
add edge ), φ

(y)
sem( next to )]. The action em-

beddings φ(y) are learned during training.

3 Constrained Semantic Parsing using
Sequence-to-Action Model

In this section, we describe how to build a neural
semantic parser using sequence-to-action model.
We first describe the training and the inference of
our model, and then introduce how to incorporate
structure and semantic constraints during decod-
ing.

3.1 Training

Parameter Estimation. The parameters of our
model include RNN parameters W (s), W (a), Uw,
word embeddings φ(x), and action embeddings
φ(y). We estimate these parameters from training
data. Given a training example with a sentence X
and its action sequence Y , we maximize the like-
lihood of the generated sequence of actions given
X . The objective function is:

n∑
i=1

logP (Yi|Xi) (9)

Standard stochastic gradient descent algorithm is
employed to update parameters.
Logical Form to Action Sequence. Currently,
most datasets of semantic parsing are labeled with
logical forms. In order to train our model, we



770

compiler generator

compilergenerator

 Action 

Sequence

Semantic 

Graph

Logical 

Form

Figure 4: The procedure of converting between
logical form and action sequence.

convert logical forms to action sequences using
semantic graph as an intermediate representation
(See Figure 4 for an overview). Concretely, we
transform logical forms into semantic graphs us-
ing a depth-first-search algorithm from root, and
then generate the action sequence using the same
order. Specifically, entities, variables and types
are nodes; relations are edges. Conversely we can
convert action sequence to logical form similarly.
Based on the above algorithm, action sequences
can be transformed into logical forms in a deter-
ministic way, and the same for logical forms to
action sequences.
Mechanisms for Handling Entities. Entities play
an important role in semantic parsing (Yih et al.,
2015). In Dong and Lapata (2016), entities are
replaced with their types and unique IDs. In
Jia and Liang (2016), entities are generated via
attention-based copying mechanism helped with a
lexicon. This paper implements both mechanisms
and compares them in experiments.

3.2 Inference

Given a new sentence X , we predict action se-
quence by:

Y ∗ = argmax
Y

P (Y |X) (10)

where Y represents action sequence, and P (Y |X)
is computed using Formula (1). Beam search is
used for best action sequence decoding. Semantic
graph and logical form can be derived from Y ∗ as
described in above.

3.3 Incorporating Constraints in Decoding

For decoding, we generate action sequentially. It
is obviously that the next action has a strong cor-
relation with the partial semantic graph generated
to current, and illegal actions can be filtered us-
ing structure and semantic constraints. Specifi-
cally, we incorporate constraints in decoding using
a controller. This procedure has two steps: 1) the
controller constructs partial semantic graph using
the actions generated to current; 2) the controller
checks whether a new generated action can meet

Sentence: Which states border Texas?

Partial Semantic Graph:

 

A

next_to

type
state

texas:st

 Structure Semantic Arg Validity 

Generated 

Actions 

add_variable A   

add_type state A  

add_entity texas:st   

Candidate 

Next 

Action 

add_type city texas:st O 

add_edge loc A, texas:st O 

add_edge next_to A, A O 

add_edge next_to A, texas:st P 

…
 

…
 

…
 

…
 

Figure 5: A demonstration of illegal action filter-
ing using constraints. The graph in color is the
constructed semantic graph to current.

all structure/semantic constraints using the partial
semantic graph.

Structure Constraints. The structure constraints
ensure action sequence will form a connected
acyclic graph. For example, there must be two ar-
gument nodes for an edge, and the two argument
nodes should be different (The third candidate next
action in Figure 5 violates this constraint). This
kind of constraints are domain-independent. The
controller encodes structure constraints as a set of
rules.

Semantic Constraints. The semantic constraints
ensure the constructed graph must follow the
schema of knowledge bases. Specifically, we
model two types of semantic constraints. One is
selectional preference constraints where the argu-
ment types of a relation should follow knowledge
base schemas. For example, in GEO dataset, rela-
tion next to’s arg1 and arg2 should both be
a state. The second is type conflict constraints,
i.e., an entity/variable node’s type must be consis-
tent, i.e., a node cannot be both of type city and
state. Semantic constraints are domain-specific
and are automatically extracted from knowledge
base schemas. The controller encodes semantic
constraints as a set of rules.

4 Experiments

In this section, we assess the performance of our
method and compare it with previous methods.



771

4.1 Datasets

We conduct experiments on three standard
datasets: GEO, ATIS and OVERNIGHT.
GEO contains natural language questions about
US geography paired with corresponding Pro-
log database queries. Following Zettlemoyer and
Collins (2005), we use the standard 600/280 in-
stance splits for training/test.
ATIS contains natural language questions of a
flight database, with each question is annotated
with a lambda calculus query. Following Zettle-
moyer and Collins (2007), we use the standard
4473/448 instance splits for training/test.
OVERNIGHT contains natural language para-
phrases paired with logical forms across eight do-
mains. We evaluate on the standard train/test splits
as Wang et al. (2015b).

4.2 Experimental Settings

Following the experimental setup of Jia and Liang
(2016): we use 200 hidden units and 100-
dimensional word vectors for sentence encoding.
The dimensions of action embedding are tuned on
validation datasets for each corpus. We initialize
all parameters by uniformly sampling within the
interval [-0.1, 0.1]. We train our model for a to-
tal of 30 epochs with an initial learning rate of
0.1, and halve the learning rate every 5 epochs af-
ter epoch 15. We replace word vectors for words
occurring only once with an universal word vec-
tor. The beam size is set as 5. Our model is
implemented in Theano (Bergstra et al., 2010),
and the codes and settings are released on Github:
https://github.com/dongpobeyond/Seq2Act.

We evaluate different systems using the stan-
dard accuracy metric, and the accuracies on differ-
ent datasets are obtained as same as Jia and Liang
(2016).

4.3 Overall Results

We compare our method with state-of-the-art sys-
tems on all three datasets. Because all systems us-
ing the same training/test splits, we directly use
the reported best performances from their original
papers for fair comparison.

For our method, we train our model with three
settings: the first one is the basic sequence-to-
action model without constraints – Seq2Act; the
second one adds structure constraints in decod-
ing – Seq2Act (+C1); the third one is the full
model which adds both structure and semantic

GEO ATIS
Previous Work
Zettlemoyer and Collins (2005) 79.3 –
Zettlemoyer and Collins (2007) 86.1 84.6
Kwiatkowksi et al. (2010) 88.9 –
Kwiatkowski et al. (2011) 88.6 82.8
Liang et al. (2011)* (+lexicon) 91.1 –
Poon (2013) – 83.5
Zhao et al. (2015) 88.9 84.2
Rabinovich et al. (2017) 87.1 85.9
Seq2Seq Models
Jia and Liang (2016) 85.0 76.3
Jia and Liang (2016)* (+data) 89.3 83.3
Dong and Lapata (2016): 2Seq 84.6 84.2
Dong and Lapata (2016): 2Tree 87.1 84.6
Our Models
Seq2Act 87.5 84.6
Seq2Act (+C1) 88.2 85.0
Seq2Act (+C1+C2) 88.9 85.5

Table 1: Test accuracies on GEO and ATIS
datasets, where * indicates systems with extra-
resources are used.

constraints – Seq2Act (+C1+C2). Semantic con-
straints (C2) are stricter than structure constraints
(C1). Therefore we set that C1 should be first met
for C2 to be met. So in our experiments we add
constraints incrementally. The overall results are
shown in Table 1-2. From the overall results, we
can see that:

1) By synthetizing the advantages of seman-
tic graph representation and the prediction abil-
ity of Seq2Seq model, our method achieves state-
of-the-art performance on OVERNIGHT dataset,
and gets competitive performance on GEO and
ATIS dataset. In fact, on GEO our full model
(Seq2Act+C1+C2) also gets the best test accuracy
of 88.9 if under the same settings, which only falls
behind Liang et al. (2011)* which uses extra hand-
crafted lexicons and Jia and Liang (2016)* which
uses extra augmented training data. On ATIS our
full model gets the second best test accuracy of
85.5, which only falls behind Rabinovich et al.
(2017) which uses a supervised attention strategy.
On OVERNIGHT, our full model gets state-of-the-
art accuracy of 79.0, which even outperforms Jia
and Liang (2016)* with extra augmented training
data.

2) Compared with the linearized logical form
representation used in previous Seq2Seq base-
lines, our action sequence encoding is more effec-
tive for semantic parsing. On all three datasets,



772

Soc. Blo. Bas. Res. Cal. Hou. Pub. Rec. Avg.
Previous Work
Wang et al. (2015b) 48.2 41.9 46.3 75.9 74.4 54.0 59.0 70.8 58.8
Seq2Seq Models
Xiao et al. (2016) 80.0 55.6 80.5 80.1 75.0 61.9 75.8 – 72.7
Jia and Liang (2016) 81.4 58.1 85.2 76.2 78.0 71.4 76.4 79.6 75.8
Jia and Liang (2016)* (+data) 79.6 60.2 87.5 79.5 81.0 72.5 78.3 81.0 77.5
Our Models
Seq2Act 81.4 60.4 87.5 79.8 81.0 73.0 79.5 81.5 78.0
Seq2Act (+C1) 81.8 60.9 88.0 80.1 81.0 73.5 80.1 82.0 78.4
Seq2Act (+C1+C2) 82.1 61.4 88.2 80.7 81.5 74.1 80.7 82.9 79.0

Table 2: Test accuracies on OVERNIGHT dataset, which includes eight domains: Social, Blocks, Bas-
ketball, Restaurants, Calendar, Housing, Publications, and Recipes.

our basic Seq2Act model gets better results than
all Seq2Seq baselines. On GEO, the Seq2Act
model achieve test accuracy of 87.5, better than
the best accuracy 87.1 of Seq2Seq baseline. On
ATIS, the Seq2Act model obtains a test accuracy
of 84.6, the same as the best Seq2Seq baseline. On
OVERNGIHT, the Seq2Act model gets a test accu-
racy of 78.0, better than the best Seq2Seq baseline
gets 77.5. We argue that this is because our ac-
tion sequence encoding is more compact and can
capture more information.

3) Structure constraints can enhance semantic
parsing by ensuring the validity of graph using the
generated action sequence. In all three datasets,
Seq2Act (+C1) outperforms the basic Seq2Act
model. This is because a part of illegal actions
will be filtered during decoding.

4) By leveraging knowledge base schemas dur-
ing decoding, semantic constraints are effective
for semantic parsing. Compared to Seq2Act and
Seq2Act (+C1), the Seq2Act (+C1+C2) gets the
best performance on all three datasets. This is
because semantic constraints can further filter se-
mantic illegal actions using selectional preference
and consistency between types.

4.4 Detailed Analysis

Effect of Entity Handling Mechanisms. This pa-
per implements two entity handling mechanisms –
Replacing (Dong and Lapata, 2016) which identi-
fies entities and then replaces them with their types
and IDs, and attention-based Copying (Jia and
Liang, 2016). To compare the above two mech-
anisms, we train and test with our full model and
the results are shown in Table 3. We can see that,
Replacing mechanism outperforms Copying in all
three datasets. This is because Replacing is done

Replacing Copying
GEO 88.9 88.2
ATIS 85.5 84.0

OVERNIGHT 79.0 77.9

Table 3: Test accuracies of Seq2Act (+C1+C2) on
GEO, ATIS, and OVERNIGHT of two entity han-
dling mechanisms.

Logical Form Action Sequence
GEO 28.2 18.2
ATIS 28.4 25.8

OVERNIGHT 46.6 33.3

Table 4: Average length of logical forms and ac-
tion sequences on three datasets. On OVERNIGHT,
we average across all eight domains.

in preprocessing, while attention-based Copying
is done during parsing and needs additional copy
mechanism.
Linearized Logical Form vs. Action Sequence.
Table 4 shows the average length of linearized log-
ical forms used in previous Seq2Seq models and
the action sequences of our model on all three
datasets. As we can see, action sequence en-
coding is more compact than linearized logical
form encoding: action sequence is shorter on all
three datasets, 35.5%, 9.2% and 28.5% reduction
in length respectively. The main advantage of a
shorter/compact encoding is that it will reduce the
influence of long distance dependency problem.

4.5 Error Analysis

We perform error analysis on results and find there
are mainly two types of errors.
Unseen/Informal Sentence Structure. Some test
sentences have unseen syntactic structures. For
example, the first case in Table 5 has an unseen



773

Error Types Examples

Un-covered
Sentence
Structure

Sentence: Iowa borders how many states? (Formal Form: How many states does Iowa border?)
Gold Parse: answer(A, count(B, (const (C, stateid(iowa)), next to(C, B),
state (B)), A))
Predicted Parse: answer (A, count(B, state(B), A))

Under-
Mapping

Sentence: Please show me first class flights from indianapolis to memphis one way leaving before 10am
Gold Parse: (lambda x (and (flight x) (oneway x) (class type x first:cl)
(< (departure time x) 1000:ti) (from x indianapolis:ci) (to x
memphis:ci)))
Predicted Parse: (lambda x (and (flight x) (oneway x) (< (departure time x)
1000:ti) (from x indianapolis:ci) (to x memphis:ci)))

Table 5: Some examples for error analysis. Each example includes the sentence for parsing, with gold
parse and predicted parse from our model.

and informal structure, where entity word “Iowa”
and relation word “borders” appear ahead of the
question words “how many”. For this problem,
we can employ sentence rewriting or paraphrasing
techniques (Chen et al., 2016; Dong et al., 2017) to
transform unseen sentence structures into normal
ones.
Under-Mapping. As Dong and Lapata (2016)
discussed, the attention model does not take the
alignment history into consideration, makes some
words are ignored during parsing. For example in
the second case in Table 5, “first class” is ignored
during the decoding process. This problem can be
further solved using explicit word coverage mod-
els used in neural machine translation (Tu et al.,
2016; Cohn et al., 2016)

5 Related Work

Semantic parsing has received significant attention
for a long time (Kate and Mooney, 2006; Clarke
et al., 2010; Krishnamurthy and Mitchell, 2012;
Artzi and Zettlemoyer, 2013; Berant and Liang,
2014; Quirk et al., 2015; Artzi et al., 2015; Reddy
et al., 2017). Traditional methods are mostly
based on the principle of compositional seman-
tics, which first trigger predicates using lexicons
and then compose them using grammars. The
prominent grammars include SCFG (Wong and
Mooney, 2007; Li et al., 2015), CCG (Zettlemoyer
and Collins, 2005; Kwiatkowski et al., 2011; Cai
and Yates, 2013), DCS (Liang et al., 2011; Be-
rant et al., 2013), etc. As discussed above, the
main drawback of grammar-based methods is that
they rely on high-quality lexicons, manually-built
grammars, and hand-crafted features.

In recent years, one promising direction of se-
mantic parsing is to use semantic graph as rep-
resentation. Thus semantic parsing is modeled
as a semantic graph generation process. Ge and
Mooney (2009) build semantic graph by trans-

forming syntactic tree. Bast and Haussmann
(2015) identify the structure of a semantic query
using three pre-defined patterns. Reddy et al.
(2014, 2016) use Freebase-based semantic graph
representation, and convert sentences to semantic
graphs using CCG or dependency tree. Yih et al.
(2015) generate semantic graphs using a staged
heuristic search algorithm. These methods are all
based on manually-designed, heuristic generation
process, which may suffer from syntactic parse er-
rors (Ge and Mooney, 2009; Reddy et al., 2014,
2016), structure mismatch (Chen et al., 2016), and
are hard to deal with complex sentences (Yih et al.,
2015).

One other direction is to employ neural
Seq2Seq models, which models semantic parsing
as an end-to-end, sentence to logical form machine
translation problem. Dong and Lapata (2016), Jia
and Liang (2016) and Xiao et al. (2016) transform
word sequence to linearized logical forms. One
main drawback of these methods is that it is hard
to capture and exploit structure and semantic con-
straints using linearized logical forms. Dong and
Lapata (2016) propose a Seq2Tree model to cap-
ture the hierarchical structure of logical forms.

It has been shown that structure and seman-
tic constraints are effective for enhancing seman-
tic parsing. Krishnamurthy et al. (2017) use type
constraints to filter illegal tokens. Liang et al.
(2017) adopt a Lisp interpreter with pre-defined
functions to produce valid tokens. Iyyer et al.
(2017) adopt type constraints to generate valid ac-
tions. Inspired by these approaches, we also in-
corporate both structure and semantic constraints
in our neural sequence-to-action model.

Transition-based approaches are important in
both dependency parsing (Nivre, 2008; Hender-
son et al., 2013) and AMR parsing (Wang et al.,
2015a). In semantic parsing, our method has a
tight-coupling with knowledge bases, and con-



774

straints can be exploited for more accurate decod-
ing. We believe this can also be used to enhance
previous transition based methods and may also be
used in other parsing tasks, e.g., AMR parsing.

6 Conclusions

This paper proposes Sequence-to-Action, a
method which models semantic parsing as an
end-to-end semantic graph generation process.
By leveraging the advantages of semantic graph
representation and exploiting the representation
learning and prediction ability of Seq2Seq models,
our method achieved significant performance im-
provements on three datasets. Furthermore, struc-
ture and semantic constraints can be easily incor-
porated in decoding to enhance semantic parsing.

For future work, to solve the problem of the lack
of training data, we want to design weakly super-
vised learning algorithm using denotations (QA
pairs) as supervision. Furthermore, we want to
collect labeled data by designing an interactive UI
for annotation assist like (Yih et al., 2016), which
uses semantic graphs to annotate the meaning of
sentences, since semantic graph is more natural
and can be easily annotated without the need of
expert knowledge.

Acknowledgments

This research work is supported by the National
Key Research and Development Program of China
under Grant No.2017YFB1002104; and the Na-
tional Natural Science Foundation of China under
Grants no. 61572477 and 61772505. Moreover,
we sincerely thank the reviewers for their valuable
comments.

References
Yoav Artzi, Kenton Lee, and Luke Zettlemoyer.

2015. Broad-coverage ccg semantic parsing
with amr. In Proceedings of the 2015 Con-
ference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Lisbon, Portugal, pages 1699–1710.
http://aclweb.org/anthology/D15-1198.

Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-
pervised learning of semantic parsers for mapping
instructions to actions. Transactions of the Associa-
tion for Computational Linguistics 1(1):49–62.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua
Bengio. 2014. Neural machine translation by
jointly learning to align and translate. CoRR
abs/1409.0473. http://arxiv.org/abs/1409.0473.

Hannah Bast and Elmar Haussmann. 2015. More
accurate question answering on freebase. In
Proceedings of the 24th ACM International on
Conference on Information and Knowledge Man-
agement, CIKM 2015, Melbourne, VIC, Aus-
tralia, October 19 - 23, 2015. pages 1431–1440.
https://doi.org/10.1145/2806416.2806472.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on Freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Seattle, Washington, USA, pages 1533–
1544. http://www.aclweb.org/anthology/D13-1160.

Jonathan Berant and Percy Liang. 2014. Se-
mantic parsing via paraphrasing. In Proceed-
ings of the 52nd Annual Meeting of the Asso-
ciation for Computational Linguistics (Volume 1:
Long Papers). Association for Computational Lin-
guistics, Baltimore, Maryland, pages 1415–1425.
http://www.aclweb.org/anthology/P14-1133.

James Bergstra, Olivier Breuleux, Frédéric Bastien,
Pascal Lamblin, Razvan Pascanu, Guillaume Des-
jardins, Joseph Turian, David Warde-Farley, and
Yoshua Bengio. 2010. Theano: A cpu and gpu math
compiler in python. In Proc. 9th Python in Science
Conf . pages 1–7.

Qingqing Cai and Alexander Yates. 2013. Large-scale
semantic parsing via schema matching and lexicon
extension. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers). Association for Computa-
tional Linguistics, Sofia, Bulgaria, pages 423–433.
http://www.aclweb.org/anthology/P13-1042.

Bo Chen, Le Sun, Xianpei Han, and Bo An. 2016.
Sentence rewriting for semantic parsing. In
Proceedings of the 54th Annual Meeting of the
Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 766–777.
http://www.aclweb.org/anthology/P16-1073.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using rnn encoder–decoder
for statistical machine translation. In Proceedings of
the 2014 Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP). Association
for Computational Linguistics, Doha, Qatar, pages
1724–1734. http://www.aclweb.org/anthology/D14-
1179.

James Clarke, Dan Goldwasser, Ming-Wei Chang,
and Dan Roth. 2010. Driving semantic parsing
from the world’s response. In Proceedings of
the Fourteenth Conference on Computational Nat-
ural Language Learning. Association for Computa-
tional Linguistics, Uppsala, Sweden, pages 18–27.
http://www.aclweb.org/anthology/W10-2903.

http://aclweb.org/anthology/D15-1198
http://aclweb.org/anthology/D15-1198
http://aclweb.org/anthology/D15-1198
http://arxiv.org/abs/1409.0473
http://arxiv.org/abs/1409.0473
http://arxiv.org/abs/1409.0473
https://doi.org/10.1145/2806416.2806472
https://doi.org/10.1145/2806416.2806472
https://doi.org/10.1145/2806416.2806472
http://www.aclweb.org/anthology/D13-1160
http://www.aclweb.org/anthology/D13-1160
http://www.aclweb.org/anthology/D13-1160
http://www.aclweb.org/anthology/P14-1133
http://www.aclweb.org/anthology/P14-1133
http://www.aclweb.org/anthology/P14-1133
http://www.aclweb.org/anthology/P13-1042
http://www.aclweb.org/anthology/P13-1042
http://www.aclweb.org/anthology/P13-1042
http://www.aclweb.org/anthology/P13-1042
http://www.aclweb.org/anthology/P16-1073
http://www.aclweb.org/anthology/P16-1073
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/D14-1179
http://www.aclweb.org/anthology/W10-2903
http://www.aclweb.org/anthology/W10-2903
http://www.aclweb.org/anthology/W10-2903


775

Trevor Cohn, Cong Duy Vu Hoang, Ekaterina Vy-
molova, Kaisheng Yao, Chris Dyer, and Gholam-
reza Haffari. 2016. Incorporating structural align-
ment biases into an attentional neural translation
model. In Proceedings of the 2016 Conference
of the North American Chapter of the Associa-
tion for Computational Linguistics: Human Lan-
guage Technologies. Association for Computational
Linguistics, San Diego, California, pages 876–885.
http://www.aclweb.org/anthology/N16-1102.

Li Dong and Mirella Lapata. 2016. Language
to logical form with neural attention. In Pro-
ceedings of the 54th Annual Meeting of the
Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 33–43.
http://www.aclweb.org/anthology/P16-1004.

Li Dong, Jonathan Mallinson, Siva Reddy, and Mirella
Lapata. 2017. Learning to paraphrase for ques-
tion answering. In Proceedings of the 2017 Con-
ference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Copenhagen, Denmark, pages 875–886.
https://www.aclweb.org/anthology/D17-1091.

Ruifang Ge and Raymond Mooney. 2009. Learn-
ing a compositional semantic parser using an
existing syntactic parser. In Proceedings of
the Joint Conference of the 47th Annual Meet-
ing of the ACL and the 4th International Joint
Conference on Natural Language Processing
of the AFNLP. Association for Computational
Linguistics, Suntec, Singapore, pages 611–619.
http://www.aclweb.org/anthology/P/P09/P09-1069.

Yulan He and Steve Young. 2005. Semantic pro-
cessing using the hidden vector state model.
Computer Speech Language 19(1):85 – 106.
https://doi.org/https://doi.org/10.1016/j.csl.2004.03.001.

James Henderson, Paola Merlo, Ivan Titov, and
Gabriele Musillo. 2013. Multilingual joint parsing
of syntactic and semantic dependencies with a latent
variable model. Comput. Linguist. 39(4):949–998.
http://dx.doi.org/10.1162/COLIa00158.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Comput. 9(8):1735–
1780. https://doi.org/10.1162/neco.1997.9.8.1735.

Mohit Iyyer, Wen-tau Yih, and Ming-Wei Chang.
2017. Search-based neural structured learning
for sequential question answering. In Proceed-
ings of the 55th Annual Meeting of the Asso-
ciation for Computational Linguistics (Volume 1:
Long Papers). Association for Computational Lin-
guistics, Vancouver, Canada, pages 1821–1831.
http://aclweb.org/anthology/P17-1167.

Robin Jia and Percy Liang. 2016. Data recom-
bination for neural semantic parsing. In Pro-
ceedings of the 54th Annual Meeting of the

Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 12–22.
http://www.aclweb.org/anthology/P16-1002.

Rohit J. Kate and Raymond J. Mooney. 2006. Us-
ing string-kernels for learning semantic parsers.
In Proceedings of the 21st International Confer-
ence on Computational Linguistics and 44th An-
nual Meeting of the Association for Computa-
tional Linguistics. Association for Computational
Linguistics, Sydney, Australia, pages 913–920.
https://doi.org/10.3115/1220175.1220290.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt
Gardner. 2017. Neural semantic parsing with
type constraints for semi-structured tables. In
Proceedings of the 2017 Conference on Em-
pirical Methods in Natural Language Process-
ing. Association for Computational Linguis-
tics, Copenhagen, Denmark, pages 1516–1526.
https://www.aclweb.org/anthology/D17-1160.

Jayant Krishnamurthy and Tom Mitchell. 2012.
Weakly supervised training of semantic parsers.
In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Pro-
cessing and Computational Natural Language
Learning. Association for Computational Lin-
guistics, Jeju Island, Korea, pages 754–765.
http://www.aclweb.org/anthology/D12-1069.

Tom Kwiatkowksi, Luke Zettlemoyer, Sharon Gold-
water, and Mark Steedman. 2010. Inducing prob-
abilistic CCG grammars from logical form with
higher-order unification. In Proceedings of the
2010 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Compu-
tational Linguistics, Cambridge, MA, pages 1223–
1233. http://www.aclweb.org/anthology/D10-1119.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and Luke
Zettlemoyer. 2013. Scaling semantic parsers with
on-the-fly ontology matching. In Proceedings of
the 2013 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Computa-
tional Linguistics, Seattle, Washington, USA, pages
1545–1556. http://www.aclweb.org/anthology/D13-
1161.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Gold-
water, and Mark Steedman. 2011. Lexical gen-
eralization in ccg grammar induction for seman-
tic parsing. In Proceedings of the 2011 Confer-
ence on Empirical Methods in Natural Language
Processing. Association for Computational Linguis-
tics, Edinburgh, Scotland, UK., pages 1512–1523.
http://www.aclweb.org/anthology/D11-1140.

Junhui Li, Muhua Zhu, Wei Lu, and Guodong Zhou.
2015. Improving semantic parsing with enriched
synchronous context-free grammar. In Proceed-
ings of the 2015 Conference on Empirical Methods
in Natural Language Processing. Association for
Computational Linguistics, Lisbon, Portugal, pages
1455–1465. http://aclweb.org/anthology/D15-1170.

http://www.aclweb.org/anthology/N16-1102
http://www.aclweb.org/anthology/N16-1102
http://www.aclweb.org/anthology/N16-1102
http://www.aclweb.org/anthology/N16-1102
http://www.aclweb.org/anthology/P16-1004
http://www.aclweb.org/anthology/P16-1004
http://www.aclweb.org/anthology/P16-1004
https://www.aclweb.org/anthology/D17-1091
https://www.aclweb.org/anthology/D17-1091
https://www.aclweb.org/anthology/D17-1091
http://www.aclweb.org/anthology/P/P09/P09-1069
http://www.aclweb.org/anthology/P/P09/P09-1069
http://www.aclweb.org/anthology/P/P09/P09-1069
http://www.aclweb.org/anthology/P/P09/P09-1069
https://doi.org/https://doi.org/10.1016/j.csl.2004.03.001
https://doi.org/https://doi.org/10.1016/j.csl.2004.03.001
https://doi.org/https://doi.org/10.1016/j.csl.2004.03.001
http://dx.doi.org/10.1162/COLI_a_00158
http://dx.doi.org/10.1162/COLI_a_00158
http://dx.doi.org/10.1162/COLI_a_00158
http://dx.doi.org/10.1162/COLI_a_00158
https://doi.org/10.1162/neco.1997.9.8.1735
https://doi.org/10.1162/neco.1997.9.8.1735
https://doi.org/10.1162/neco.1997.9.8.1735
http://aclweb.org/anthology/P17-1167
http://aclweb.org/anthology/P17-1167
http://aclweb.org/anthology/P17-1167
http://www.aclweb.org/anthology/P16-1002
http://www.aclweb.org/anthology/P16-1002
http://www.aclweb.org/anthology/P16-1002
https://doi.org/10.3115/1220175.1220290
https://doi.org/10.3115/1220175.1220290
https://doi.org/10.3115/1220175.1220290
https://www.aclweb.org/anthology/D17-1160
https://www.aclweb.org/anthology/D17-1160
https://www.aclweb.org/anthology/D17-1160
http://www.aclweb.org/anthology/D12-1069
http://www.aclweb.org/anthology/D12-1069
http://www.aclweb.org/anthology/D10-1119
http://www.aclweb.org/anthology/D10-1119
http://www.aclweb.org/anthology/D10-1119
http://www.aclweb.org/anthology/D10-1119
http://www.aclweb.org/anthology/D13-1161
http://www.aclweb.org/anthology/D13-1161
http://www.aclweb.org/anthology/D13-1161
http://www.aclweb.org/anthology/D13-1161
http://www.aclweb.org/anthology/D11-1140
http://www.aclweb.org/anthology/D11-1140
http://www.aclweb.org/anthology/D11-1140
http://www.aclweb.org/anthology/D11-1140
http://aclweb.org/anthology/D15-1170
http://aclweb.org/anthology/D15-1170
http://aclweb.org/anthology/D15-1170


776

Chen Liang, Jonathan Berant, Quoc Le, Kenneth D.
Forbus, and Ni Lao. 2017. Neural symbolic ma-
chines: Learning semantic parsers on freebase with
weak supervision. In Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers). Association
for Computational Linguistics, Vancouver, Canada,
pages 23–33. http://aclweb.org/anthology/P17-
1003.

Percy Liang, Michael Jordan, and Dan Klein.
2011. Learning dependency-based composi-
tional semantics. In Proceedings of the 49th
Annual Meeting of the Association for Com-
putational Linguistics: Human Language Tech-
nologies. Association for Computational Linguis-
tics, Portland, Oregon, USA, pages 590–599.
http://www.aclweb.org/anthology/P11-1060.

Wei Lu, Hwee Tou Ng, Wee Sun Lee, and
Luke S. Zettlemoyer. 2008. A generative model
for parsing natural language to meaning repre-
sentations. In Proceedings of the 2008 Con-
ference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Honolulu, Hawaii, pages 783–792.
http://www.aclweb.org/anthology/D08-1082.

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-based
neural machine translation. In Proceedings of the
2015 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Compu-
tational Linguistics, Lisbon, Portugal, pages 1412–
1421. http://aclweb.org/anthology/D15-1166.

Joakim Nivre. 2008. Algorithms for deterministic in-
cremental dependency parsing. Comput. Linguist.
34(4):513–553. http://dx.doi.org/10.1162/coli.07-
056-R1-07-027.

Hoifung Poon. 2013. Grounded unsupervised seman-
tic parsing. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers). Association for Computa-
tional Linguistics, Sofia, Bulgaria, pages 933–943.
http://www.aclweb.org/anthology/P13-1092.

Chris Quirk, Raymond Mooney, and Michel Galley.
2015. Language to code: Learning semantic parsers
for if-this-then-that recipes. In Proceedings of the
53rd Annual Meeting of the Association for Compu-
tational Linguistics and the 7th International Joint
Conference on Natural Language Processing (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Beijing, China, pages 878–888.
http://www.aclweb.org/anthology/P15-1085.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code gen-
eration and semantic parsing. In Proceed-
ings of the 55th Annual Meeting of the Asso-
ciation for Computational Linguistics (Volume 1:
Long Papers). Association for Computational Lin-
guistics, Vancouver, Canada, pages 1139–1149.
http://aclweb.org/anthology/P17-1105.

Siva Reddy, Mirella Lapata, and Mark Steedman.
2014. Large-scale semantic parsing without
question-answer pairs. Transactions of the Asso-
ciation for Computational Linguistics 2:377–392.
http://aclweb.org/anthology/Q14-1030.

Siva Reddy, Oscar Täckström, Michael Collins,
Tom Kwiatkowski, Dipanjan Das, Mark Steed-
man, and Mirella Lapata. 2016. Transforming
Dependency Structures to Logical Forms for
Semantic Parsing. Transactions of the Associ-
ation for Computational Linguistics 4:127–140.
http://sivareddy.in/papers/reddy2016transforming.pdf.

Siva Reddy, Oscar Täckström, Slav Petrov, Mark
Steedman, and Mirella Lapata. 2017. Universal
semantic parsing. In Proceedings of the 2017
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Copenhagen, Denmark, pages 89–101.
https://www.aclweb.org/anthology/D17-1009.

Zhaopeng Tu, Zhengdong Lu, Yang Liu, Xiao-
hua Liu, and Hang Li. 2016. Modeling cov-
erage for neural machine translation. In Pro-
ceedings of the 54th Annual Meeting of the
Association for Computational Linguistics (Vol-
ume 1: Long Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 76–85.
http://www.aclweb.org/anthology/P16-1008.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015a. A transition-based algorithm for amr
parsing. In Proceedings of the 2015 Confer-
ence of the North American Chapter of the As-
sociation for Computational Linguistics: Human
Language Technologies. Association for Computa-
tional Linguistics, Denver, Colorado, pages 366–
375. http://www.aclweb.org/anthology/N15-1040.

Yushi Wang, Jonathan Berant, and Percy Liang. 2015b.
Building a semantic parser overnight. In Proceed-
ings of the 53rd Annual Meeting of the Association
for Computational Linguistics and the 7th Interna-
tional Joint Conference on Natural Language Pro-
cessing (Volume 1: Long Papers). Association for
Computational Linguistics, Beijing, China, pages
1332–1342. http://www.aclweb.org/anthology/P15-
1129.

Yuk Wah Wong and Raymond Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Proceedings of the 45th
Annual Meeting of the Association of Computa-
tional Linguistics. Association for Computational
Linguistics, Prague, Czech Republic, pages 960–
967. http://www.aclweb.org/anthology/P07-1121.

Chunyang Xiao, Marc Dymetman, and Claire Gardent.
2016. Sequence-based structured prediction for se-
mantic parsing. In Proceedings of the 54th Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers). Association for
Computational Linguistics, Berlin, Germany, pages
1341–1350. http://www.aclweb.org/anthology/P16-
1127.

http://aclweb.org/anthology/P17-1003
http://aclweb.org/anthology/P17-1003
http://aclweb.org/anthology/P17-1003
http://aclweb.org/anthology/P17-1003
http://aclweb.org/anthology/P17-1003
http://www.aclweb.org/anthology/P11-1060
http://www.aclweb.org/anthology/P11-1060
http://www.aclweb.org/anthology/P11-1060
http://www.aclweb.org/anthology/D08-1082
http://www.aclweb.org/anthology/D08-1082
http://www.aclweb.org/anthology/D08-1082
http://www.aclweb.org/anthology/D08-1082
http://aclweb.org/anthology/D15-1166
http://aclweb.org/anthology/D15-1166
http://aclweb.org/anthology/D15-1166
http://dx.doi.org/10.1162/coli.07-056-R1-07-027
http://dx.doi.org/10.1162/coli.07-056-R1-07-027
http://dx.doi.org/10.1162/coli.07-056-R1-07-027
http://dx.doi.org/10.1162/coli.07-056-R1-07-027
http://www.aclweb.org/anthology/P13-1092
http://www.aclweb.org/anthology/P13-1092
http://www.aclweb.org/anthology/P13-1092
http://www.aclweb.org/anthology/P15-1085
http://www.aclweb.org/anthology/P15-1085
http://www.aclweb.org/anthology/P15-1085
http://aclweb.org/anthology/P17-1105
http://aclweb.org/anthology/P17-1105
http://aclweb.org/anthology/P17-1105
http://aclweb.org/anthology/Q14-1030
http://aclweb.org/anthology/Q14-1030
http://aclweb.org/anthology/Q14-1030
http://sivareddy.in/papers/reddy2016transforming.pdf
http://sivareddy.in/papers/reddy2016transforming.pdf
http://sivareddy.in/papers/reddy2016transforming.pdf
http://sivareddy.in/papers/reddy2016transforming.pdf
https://www.aclweb.org/anthology/D17-1009
https://www.aclweb.org/anthology/D17-1009
https://www.aclweb.org/anthology/D17-1009
http://www.aclweb.org/anthology/P16-1008
http://www.aclweb.org/anthology/P16-1008
http://www.aclweb.org/anthology/P16-1008
http://www.aclweb.org/anthology/N15-1040
http://www.aclweb.org/anthology/N15-1040
http://www.aclweb.org/anthology/N15-1040
http://www.aclweb.org/anthology/P15-1129
http://www.aclweb.org/anthology/P15-1129
http://www.aclweb.org/anthology/P15-1129
http://www.aclweb.org/anthology/P07-1121
http://www.aclweb.org/anthology/P07-1121
http://www.aclweb.org/anthology/P07-1121
http://www.aclweb.org/anthology/P07-1121
http://www.aclweb.org/anthology/P16-1127
http://www.aclweb.org/anthology/P16-1127
http://www.aclweb.org/anthology/P16-1127
http://www.aclweb.org/anthology/P16-1127


777

Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and
Jianfeng Gao. 2015. Semantic parsing via staged
query graph generation: Question answering with
knowledge base. In Proceedings of the 53rd
Annual Meeting of the Association for Computa-
tional Linguistics and the 7th International Joint
Conference on Natural Language Processing (Vol-
ume 1: Long Papers). Association for Compu-
tational Linguistics, Beijing, China, pages 1321–
1331. http://www.aclweb.org/anthology/P15-1128.

Wen-tau Yih, Matthew Richardson, Chris Meek, Ming-
Wei Chang, and Jina Suh. 2016. The value of se-
mantic parse labeling for knowledge base question
answering. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers). Association for Computa-
tional Linguistics, Berlin, Germany, pages 201–206.
http://anthology.aclweb.org/P16-2033.

John M. Zelle and Raymond J. Mooney. 1996.
Learning to parse database queries using induc-
tive logic programming. In AAAI/IAAI. AAAI
Press/MIT Press, Portland, OR, pages 1050–1055.
http://www.cs.utexas.edu/users/ai-lab/?zelle:aaai96.

Luke Zettlemoyer and Michael Collins. 2007. On-
line learning of relaxed CCG grammars for
parsing to logical form. In Proceedings of the
2007 Joint Conference on Empirical Methods
in Natural Language Processing and Compu-
tational Natural Language Learning (EMNLP-
CoNLL). Association for Computational Linguis-
tics, Prague, Czech Republic, pages 678–687.
http://www.aclweb.org/anthology/D/D07/D07-
1071.

Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In UAI ’05, Proceedings of the 21st Con-
ference in Uncertainty in Artificial Intelligence, Ed-
inburgh, Scotland, July 26-29, 2005. pages 658–666.

Kai Zhao, Hany Hassan, and Michael Auli. 2015.
Learning translation models from monolingual con-
tinuous representations. In Proceedings of the 2015
Conference of the North American Chapter of the
Association for Computational Linguistics: Human
Language Technologies. Association for Computa-
tional Linguistics, Denver, Colorado, pages 1527–
1536. http://www.aclweb.org/anthology/N15-1176.

http://www.aclweb.org/anthology/P15-1128
http://www.aclweb.org/anthology/P15-1128
http://www.aclweb.org/anthology/P15-1128
http://www.aclweb.org/anthology/P15-1128
http://anthology.aclweb.org/P16-2033
http://anthology.aclweb.org/P16-2033
http://anthology.aclweb.org/P16-2033
http://anthology.aclweb.org/P16-2033
http://www.cs.utexas.edu/users/ai-lab/?zelle:aaai96
http://www.cs.utexas.edu/users/ai-lab/?zelle:aaai96
http://www.cs.utexas.edu/users/ai-lab/?zelle:aaai96
http://www.aclweb.org/anthology/D/D07/D07-1071
http://www.aclweb.org/anthology/D/D07/D07-1071
http://www.aclweb.org/anthology/D/D07/D07-1071
http://www.aclweb.org/anthology/D/D07/D07-1071
http://www.aclweb.org/anthology/D/D07/D07-1071
http://www.aclweb.org/anthology/N15-1176
http://www.aclweb.org/anthology/N15-1176
http://www.aclweb.org/anthology/N15-1176

