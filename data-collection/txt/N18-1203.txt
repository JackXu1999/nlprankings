



















































Learning to Map Context-Dependent Sentences to Executable Formal Queries


Proceedings of NAACL-HLT 2018, pages 2238–2249
New Orleans, Louisiana, June 1 - 6, 2018. c©2018 Association for Computational Linguistics

Learning to Map Context-Dependent Sentences
to Executable Formal Queries

Alane Suhr†, Srinivasan Iyer‡, and Yoav Artzi†

† Dept. of Computer Science and Cornell Tech, Cornell University, New York, NY
{suhr, yoav}@cs.cornell.edu

‡ Paul G. Allen School of Computer Science & Engineering, Univ. of Washington, Seattle, WA
sviyer@cs.washington.edu

Abstract

We propose a context-dependent model to map
utterances within an interaction to executable
formal queries. To incorporate interaction his-
tory, the model maintains an interaction-level
encoder that updates after each turn, and can
copy sub-sequences of previously predicted
queries during generation. Our approach com-
bines implicit and explicit modeling of refer-
ences between utterances. We evaluate our
model on the ATIS flight planning interac-
tions, and demonstrate the benefits of model-
ing context and explicit references.

1 Introduction

The meaning of conversational utterances depends
strongly on the history of the interaction. Con-
sider a user querying a flight database using nat-
ural language (Figure 1). Given a user utterance,
the system must generate a query, execute it, and
display results to the user, who then provides the
next request. Key to correctly mapping utterances
to executable queries is resolving references. For
example, the second utterance implicitly depends
on the first, and the reference ones in the third
utterance explicitly refers to the response to the
second utterance. Within an interactive system,
this information needs to be composed with men-
tions of database entries (e.g., Seattle, next Mon-
day) to generate a formal executable representa-
tion. In this paper, we propose encoder-decoder
models that directly map user utterances to exe-
cutable queries, while considering the history of
the interaction, including both previous utterances
and their generated queries.

Reasoning about how the meaning of an utter-
ance depends on the history of the interaction is
critical to correctly respond to user requests. As
interactions progress, users may omit previously-
mentioned constraints and entities, and an increas-

show me flights from seattle to boston next monday
[Table with 31 flights]
on american airlines
[Table with 5 flights]
which ones arrive at 7pm
[No flights returned]
show me delta flights
[Table with 5 flights]
. . .

Figure 1: An excerpt of an interaction from the ATIS
flight planning system (Hemphill et al., 1990; Dahl
et al., 1994). Each request is followed by a description
of the system response.
ing portion of the utterance meaning must be de-
rived from the interaction history. Figure 2 shows
SQL queries for the utterances in Figure 1. As the
interaction progresses, the majority of the gener-
ated query is derived from the interaction history
(underlined), rather than from the current utter-
ance. A key challenge is resolving what past infor-
mation is incorporated and how. For example, in
the figure, the second utterance depends on the set
of flights defined by the first, while adding a new
constraint. The third utterance further refines this
set by adding a constraint to the constraints from
both previous utterances. In contrast, the fourth
utterance refers only to the first one, and skips the
two utterances in between.1 Correctly generating
the fourth query requires understanding that the
time constraint (at 7pm) can be ignored as it fol-
lows an airline constraint that has been replaced.

We study complementary methods to enable
this type of reasoning. The first set of methods im-
plicitly reason about references by modifying the
encoder-decoder architecture to encode informa-
tion from previous utterances for generation de-
cisions. We experiment with attending over pre-
vious utterances and using an interaction-level re-
current encoder. We also study explicitly main-
taining a set of referents using segments from pre-

1An alternative explanation is that utterance four refers to
utterance three, and deletes the time and airline constraints.

2238



x̄1: show me flights from seattle to boston next monday
ȳ1: (SELECT DISTINCT flight.flight id FROM flight WHERE (flight.from airport IN (SELECT

airport service.airport code FROM airport service WHERE airport service.city code IN (SELECT
city.city code FROM city WHERE city.city name = ’SEATTLE’))) AND (flight.to airport IN (SELECT
airport service.airport code FROM airport service WHERE airport service.city code IN (SELECT
city.city code FROM city WHERE city.city name = ’BOSTON’))) AND (flight.flight days IN (SELECT
days.days code FROM days WHERE days.day name IN (SELECT date day.day name FROM date day WHERE
date day.year = 1993 AND date day.month number = 2 AND date day.day number = 8))));

x̄2: on american airlines
ȳ2: (SELECT DISTINCT flight.flight id FROM flight WHERE (flight.airline code = ’AA’) AND (flight.from airport

IN (SELECT airport service.airport code FROM airport service WHERE airport service.city code IN (SELECT
city.city code FROM city WHERE city.city name = ’SEATTLE’))) AND (flight.to airport IN (SELECT air
port service.airport code FROM airport service WHERE airport service.city code IN (SELECT city.city code
FROM city WHERE city.city name = ’BOSTON’))) AND (flight.flight days IN (SELECT days.days code FROM
days WHERE days.day name IN (SELECT date day.day name FROM date day WHERE date day.year = 1993 AND
date day.month number = 2 AND date day.day number = 8))));

x̄3: which ones arrive at 7pm
ȳ3: (SELECT DISTINCT flight.flight id FROM flight WHERE (flight.airline code = ’AA’) AND (flight.from airport

IN (SELECT airport service.airport code FROM airport service WHERE airport service.city code IN (SELECT
city.city code FROM city WHERE city.city name = ’SEATTLE’))) AND (flight.to airport IN (SELECT air
port service.airport code FROM airport service WHERE airport service.city code IN (SELECT city.city code
FROM city WHERE city.city name = ’BOSTON’))) AND (flight.flight days IN (SELECT days.days code FROM
days WHERE days.day name IN (SELECT date day.day name FROM date day WHERE date day.year = 1993 AND
date day.month number = 2 AND date day.day number = 8))) AND (flight.arrival time = 1900));

x̄4: show me delta flights
ȳ4: (SELECT DISTINCT flight.flight id FROM flight WHERE (flight.airline code = ’DL’) AND (flight.from airport

IN (SELECT airport service.airport code FROM airport service WHERE airport service.city code IN (SELECT
city.city code FROM city WHERE city.city name = ’SEATTLE’))) AND (flight.to airport IN (SELECT air
port service.airport code FROM airport service WHERE airport service.city code IN (SELECT city.city code
FROM city WHERE city.city name = ’BOSTON’))) AND (flight.flight days IN (SELECT days.days code FROM
days WHERE days.day name IN (SELECT date day.day name FROM date day WHERE date day.year = 1993 AND
date day.month number = 2 AND date day.day number = 8))));

Figure 2: Annotated SQL queries (ȳ1,. . . ,ȳ4) in the ATIS (Hemphill et al., 1990) domain for utterances (x̄1,. . . ,x̄4)
from Figure 1. Underlining (not part of the annotation) indicates segments originating from the interaction context.

vious queries. At each step, the decoder chooses
whether to output a token or select a segment from
the set, which is appended to the output in a sin-
gle decoding step. In addition to enabling refer-
ences to previously mentioned entities, sets, and
constraints, this method also reduces the number
of generation steps required, illustrated by the un-
derlined segments in Figure 2. For example, the
query ȳ2 will require 17 steps instead of 94.

We evaluate our approach using the
ATIS (Hemphill et al., 1990; Dahl et al., 1994)
task, where a user interacts with a SQL flight
database using natural language requests, and
almost all queries require joins across multiple
tables. In addition to reasoning about contextual
phenomena, we design our system to effectively
resolve database values, including resolution of
time expressions (e.g., next monday in Figure 1)
using an existing semantic parser. Our evaluation
shows that reasoning about the history of the
interaction is necessary, relatively increasing
performance by 28.6% over a baseline with no
access to this information, and that combining
the implicit and explicit methods provides the
best performance. Furthermore, our analysis
shows that our full approach maintains its per-
formance as interaction length increases, while
the performance of systems without explicit
modeling deteriorates. Our code is available at
https://github.com/clic-lab/atis.

2 Technical Overview

Our goal is to map utterances in interactions to for-
mal executable queries. We evaluate our approach
with the ATIS corpus (Hemphill et al., 1990; Dahl
et al., 1994), where users query a realistic flight
planning system using natural language. The sys-
tem responds by displaying tables and database
entries. User utterances are mapped to SQL to
query a complex database with 27 tables and 162K
entries. 96.6% of the queries require joins of dif-
ferent tables. Section 7 describes ATIS.

Task Notation Let I be the set of all interac-
tions, X the set of all utterances, and Y the set
of all formal queries. A user utterance x̄ ∈ X of
length |x̄| is a sequence 〈x1, . . . , x|x̄|〉, where each
xi is a natural language token. A formal query
ȳ ∈ Y of length |ȳ| is a sequence 〈y1, . . . , y|ȳ|〉,
where each yi is a formal query token. An inter-
action Ī ∈ I is a sequence of n utterance-query
pairs 〈(x̄1, ȳ1), . . . , (x̄n, ȳn)〉 representing an in-
teraction with n turns. To refer to indexed inter-
actions and their content, we mark Ī(l) as an in-
teraction with index l, the i-th utterance and query
in Ī(l) as x̄(l)i and ȳ

(l)
i , and the j-th tokens in x̄

(l)
i

and ȳ(l)i as x
(l)
i,j and y

(l)
i,j . At turn i, we denote the

interaction history of length i − 1 as Ī[: i − 1] =
〈(x̄1, ȳ1), . . . , (x̄i−1, ȳi−1)〉. Given Ī[: i− 1] and
utterance x̄i our goal is to generate ȳi, while con-
sidering both x̄i and Ī[: i − 1]. Following the ex-

2239



ecution of ȳi, the interaction history at turn i + 1
becomes Ī[: i] = 〈(x̄1, ȳ1), . . . , (x̄i, ȳi)〉.
Model Our model is based on the recurrent
neural network (RNN; Elman, 1990) encoder-
decoder framework with attention (Cho et al.,
2014; Sutskever et al., 2014; Bahdanau et al.,
2015; Luong et al., 2015). We modify the model
in three ways to reason about context from the in-
teraction history by attending over previous utter-
ances (Section 4.2), adding a turn-level recurrent
encoder that updates after each turn (Section 4.3),
and adding a mechanism to copy segments of
queries from previous utterances (Section 4.4).
We also design a scoring function to score values
that are abstracted during pre-processing, includ-
ing entities and times (Section 6). The full model
selects between generating query tokens and copy-
ing complete segments from previous queries.
Learning We assume access to a training set
that contains N interactions {Ī(l)}Nl=1. We train
using a token-level cross-entropy objective (Sec-
tion 5). For models that use the turn-level en-
coder, we construct computational graphs for the
entire interaction and back-propagate the loss for
all queries together. Without the turn-level en-
coder, each utterance is processed separately.
Evaluation We evaluate using a test set
{Ī(l)}Ml=1 of M interactions. We measure the
accuracy of each utterance for each test interac-
tion against the annotated query and its execution
result. For models that copy segments from
previous queries, we evaluate using both predicted
and gold previous queries.

3 Related Work

Mapping sentences to formal representations,
commonly known as semantic parsing, has been
studied extensively with linguistically-motivated
compositional representations, including variable-
free logic (e.g., Zelle and Mooney, 1996; Clarke
et al., 2010), lambda calculus (e.g., Zettlemoyer
and Collins, 2005; Artzi and Zettlemoyer, 2011;
Kushman and Barzilay, 2013), and dependency-
based compositional semantics (e.g., Liang et al.,
2011; Berant et al., 2013). Recovering lambda-
calculus representations was also studied with
ATIS with focus on context-independent meaning
using grammar-based approaches (Zettlemoyer
and Collins, 2007; Kwiatkowski et al., 2011;
Wang et al., 2014) and neural networks (Dong and
Lapata, 2016; Jia and Liang, 2016).

Recovering context-independent executable
representations has been receiving increasing
attention. Mapping sentence in isolation to
SQL queries has been studied with ATIS using
statistical parsing (Popescu et al., 2004; Poon,
2013) and sequence-to-sequence models (Iyer
et al., 2017). Generating executable programs
was studied with other domains and formal
languages (Giordani and Moschitti, 2012; Ling
et al., 2016; Zhong et al., 2017; Xu et al., 2017).
Recently, various approaches were proposed to
use the formal language syntax to constrain the
search space (Yin and Neubig, 2017; Rabinovich
et al., 2017; Krishnamurthy et al., 2017; Cheng
et al., 2017) making all outputs valid programs.
These contributions are orthogonal to ours, and
can be directly integrated into our decoder.

Generating context-dependent formal represen-
tations has received less attention. Miller et al.
(1996) used ATIS and mapped utterances to se-
mantic frames, which were then mapped to SQL
queries. For learning, they required full super-
vision, including annotated parse trees and con-
textual dependencies.2 Zettlemoyer and Collins
(2009) addressed the problem with lambda calcu-
lus, using a semantic parser trained separately with
context-independent data. In contrast, we generate
executable formal queries and require only inter-
action query annotations for training.

Recovering context-dependent meaning was
also studied with the SCONE (Long et al., 2016)
and SequentialQA (Iyyer et al., 2017) corpora. We
compare ATIS to these corpora in Section 7. Re-
solving explicit references, a part of our problem,
has been studied as co-reference resolution (Ng,
2010). Context-dependent language understand-
ing was also studied for dialogue systems, in-
cluding with ATIS, as surveyed by Tür et al.
(2010). More recently, encoder-decoder meth-
ods were applied to dialogue systems (Peng et al.,
2017; Li et al., 2017), including using hierarchi-
cal RNNs (Serban et al., 2016, 2017), an architec-
ture related to our turn-level encoder. These ap-
proaches use slot-filling frames with limited ex-
pressivity, while we focus on the original repre-
sentation of unconstrained SQL queries.

2Miller et al. (1996) provide limited details about their
evaluation. Later work notes that they evaluate SQL query
correctness (Zettlemoyer and Collins, 2009) with an accuracy
of 78.4%, higher than our results. However, the lack of de-
tails (e.g., if the metric is strict or relaxed) makes comparison
difficult. In addition, we use significantly less supervision,
and re-split the data to avoid scenario bias (Section 7).

2240



4 Context-dependent Model

We base our model on an encoder-decoder archi-
tecture with attention (Cho et al., 2014; Sutskever
et al., 2014; Bahdanau et al., 2015; Luong et al.,
2015). At each interaction turn i, given the current
utterance x̄i and the interaction history Ī[: i − 1],
the model generates the formal query ȳi. Figure 3
illustrates our architecture. We describe the base
architecture, and gradually add components.

4.1 Base Encoder-Decoder Architecture

Our base architecture uses an encoder to process
the user utterance x̄i = 〈xi,1, . . . , xi,|x̄i|〉 and a
decoder to generate the output query ȳi token-by-
token. This architecture does not observe the in-
teraction history Ī[: i− 1].

The encoder computes a hidden state hEj =

[h
−→
E
j ;h

←−
E
j ] for each token xi,j using a bi-directional

RNN. The forward RNN is defined by: 3

h
−→
E
j = LSTM

−→
E
(
φx(xi,j);h

−→
E
j−1
)

, (1)

where LSTM
−→
E is a long short-term memory re-

currence (LSTM; Hochreiter and Schmidhuber,
1997) and φx is a learned embedding function for
input tokens. The backward RNN recurs in the op-
posite direction with separate parameters.

We generate the query with an RNN decoder.
The decoder state at step k is:

hDk = LSTM
D
(

[φy(yi,k−1); ck−1] ;h
D
k−1
)

,

where LSTMD is a two-layer LSTM recurrence,
φy is a learned embedding function for query to-
kens, and ck is an attention vector computed from
the encoder states. yi,0 is a special start token, and
c0 is a zero-vector. The initial hidden state and
cell memory of each layer are initialized as hE|x̄i|
and cE|x̄i|. The attention vector ck is a weighted
sum of the encoder hidden states:

sk(j) = h
E
j W

AhDk (2)
αk = softmax(sk) (3)

ck =

|x̄i|∑

j=1

hEj αk(j) , (4)

where WA is a learned matrix. The probabilities
of output query tokens are computed as:

mk = tanh
(

[hDk ; ck]W
m
)

(5)

P (yi,k = w | x̄i, ȳi,1:k−1) ∝ exp(mkWow + bow) (6)

where Wm, Wo, and bo are learned.

3We omit the memory cell (often denoted as cj) from all
LSTM descriptions. We use only the LSTM hidden state hj
in other parts of the architecture unless explicitly noted.

4.2 Incorporating Recent History

We provide the model with the most recent in-
teraction history by concatenating the previous h
utterances 〈x̄i−h, ..., x̄i−1〉 with the current utter-
ance in order, adding a special delimiter token be-
tween each utterance. The concatenated input pro-
vides the model access to previous utterances, but
not to previously generated queries, or utterances
that are more than h turns in the past. The archi-
tecture remains the same, except that the encoder
and attention are computed over the concatenated
sequence of tokens. The probability of an output
query token is computed the same, but is now con-
ditioned on the interaction history:

P (yi,k = w | x̄i, ȳi,1:k−1, Ī[: i− 1]) ∝ (7)
exp(mkW

o
w + b

o
w) .

4.3 Turn-level Encoder

Concatenating recent utterances to provide access
to recent history has computational drawbacks.
The encoding of the utterance depends on its loca-
tion in the concatenated string. This requires en-
coding all recent history for each new utterance,
and does not allow re-use of computation between
utterances during encoding. It also introduces a
tradeoff between computation cost and expressiv-
ity: attending over the h previous utterances al-
lows the decoder access to the information in these
utterances when generating a query, but is compu-
tationally more expensive as h increases. We ad-
dress this by encoding each utterance once. To ac-
count for the influence of the interaction history
on utterance encoding, we maintain a discourse
state encoding hIi computed with a turn-level re-
currence, and use it during utterance encoding.
The state is maintained and updated over the entire
interaction. At turn i, this model has access to the
complete prefix of the interaction Ī[: i−1] and the
current request x̄i. In contrast, the concatenation-
based encoder (Section 4.2) has access only to in-
formation from the previous h utterances. We also
use positional encoding in the attention computa-
tion to account for the position of each utterance
relative to the current utterance.

Formally, we modify Equation 1 to encode x̄i:
h
−→
E
i,j = LSTM

−→
E
([
φx(xi,j);h

I
i−1
]

;h
−→
E
i,j−1

)
,

where hIi−1 is the discourse state following utter-

ance x̄i−1. LSTM
←−
E is modified analogously. In

contrast to the concatenation-based model, the re-
currence processes a single utterance. The dis-

2241



show me flights from seattle to boston

which ones arrive at 7pm

(SELECT DISTINCT flight.flight_id ... );

SELECT(

DISTINCT flight.flight_id FROM flight

flight.airline_code = 'AA'

flight.from_airport IN (SELECT 
airport_service.airport_code ... city.city_code 
FROM city WHERE city.city_name = 'SEATTLE'))

x̄1 :

x̄2 :

ȳ1 :

Discourse 
State 

on american airlines
(SELECT DISTINCT flight.flight_id ... );y2 :

x3 :

Word  
Embeddings

Turn-Level 
Encoder

Encoder State

Segments from Previous Queries

Segment  
Encoder

SegmentsSQL Tokens
Attention 
Scores 

Attention  
State

Output  
Distribution

}

(SELECT DISTINCT flight.flight_id FROM flight ...
SoftMax + 

Weighted Sum

I

I

I

Q

Q

Q

D D D

s̄1 :

s3

hE3

s̄2 :

s̄3 :�
x(x3,j)

hD3

E E E E E

c3

hI2

...

Figure 3: Illustration of the model architecture during the third decoding step while processing the instruction
which ones arrive at 7pm from the interaction in Figure 2. The current discourse state hI2 is used to encode the
current utterance x̄3 (Section 4.3). Query segments from previous queries are encoded into vector representa-
tions (Section 4.4). In each generation step, the decoder attends over the previous and current utterances, and a
probability distribution is computed over SQL tokens and query segments. Here, segment s̄1 is selected.

course state hIi is computed as
hIi = LSTM

I
(
hEi,|x̄i|;h

I
i−1
)

.

Similar to the concatenation-based model, we at-
tend over the current utterance and the h previ-
ous utterances. We add relative position embed-
dings φI to each hidden state. These embeddings
are learned for each possible distance 0, . . . , h− 1
from the current utterance. We modify Equation 2
to index over both utterances and tokens:

sk(t, j) =
[
hEt,j ;φ

I(i− t)
]
WAhDk . (8)

In contrast to the concatenation model, without
position embeddings, the attention computation
has no indication of the utterance position, as our
ablation shows in Section 8. The attention distri-
bution is computed as in Equation 3, and normal-
ized across all utterances. The position embedding
is also used to compute the context vector ck:

ck =

i∑

t=i−h

|x̄t|∑

j=1

[
hEt,j ;φ

I(i− t)
]
αk(t, j) .

4.4 Copying Query Segments

The discourse state and attention over previous ut-
terances allow the model to consider the interac-
tion history when generating queries. However,
we observe that context-dependent reasoning of-
ten requires generating sequences that were gen-
erated in previous turns. Figure 2 shows how seg-
ments (underlined) extracted from previous utter-
ances are predominant in later queries. To take
advantage of what was previously generated, we
add copying of complete segments from previous
queries by expanding the set of outputs at each
generation step. This mechanism explicitly mod-
els references, reduces the number of steps re-

quired to generate queries, and provides an inter-
pretable view of what parts of a query originate in
context. Figure 3 illustrates this architecture.
Extracting Segments Given the interaction his-
tory Ī[: i − 1], we construct the set of seg-
ments Si−1 by deterministically extracting sub-
trees from previously generated queries.4 In our
data, we extract 13 ± 5.9 (µ ± σ) segments for
each annotated query. Each segment s̄ ∈ Si−1 is
a tuple 〈a, b, l, r〉, where a and b are the indices of
the first and most recent queries, ȳa and ȳb, in the
interaction that contain the segment. l and r are
the start and end indices of the segment in ȳb.
Encoding Segments We represent a segment
s̄ = 〈a, b, l, r〉 using the hidden states of an
RNN encoding of the query ȳb. The hidden
states 〈hQ1, ...,hQ|ȳb|〉 are computed using a
bi-directional LSTM RNN similar to the utter-
ance encoder (Equation 1), except using separate
LSTM parameters and φy to embed the query to-
kens. The embedded representation of a segment
is a concatenation of the hidden states at the seg-
ment endpoints and an embedding of the relative
position of the utterance where it appears first:

hS =
[
hQl ;h

Q
r ;φ

g(min(g, i− a))
]
,

where φg is a learned embedding function of the
position of the initial query ȳa relative to the cur-
rent turn index i. We learn an embedding for each
relative position that is smaller than g, and use the
same embedding for all other positions.
Generation with Segments At each generation
step, the decoder selects between a single query
token or a segment. When a segment is selected, it

4The process of extracting sub-trees is described in the
supplementary material.

2242



is appended to the generated query, an embedded
segment representation for the next step is com-
puted, and generation continues. The probability
of a segment s̄ = 〈a, b, l, r〉 at decoding step k is:

P (yi,k = s̄ | x̄i, ȳi,1:k−1, Ī[: i− 1]) ∝ (9)
exp

(
mkW

S

hS
)

,

where mk is computed in Equation 5 and W
S

is a
learned matrix. To simplify the notation, we as-
sign the segment to a single output token. The
output probabilities (Equations 7 and 9) are nor-
malized together to a single probability distribu-
tion. When a segment is selected, the embedding
used as input for the next generation step is a bag-
of-words encoding of the segment. We extend the
output token function φy to take segments:

φy(s̄ = 〈a, b, l, r〉) = 1
r − l

r∑

k=l

φy (yb,k) .

The recursion in φy is limited to depth one because
segments do not contain other segments.

4.5 Inference with Full Model
Given an utterance x̄i and the history of interaction
Ī[: i − 1], we generate the query ȳi. An interac-
tion starts with the user providing the first utter-
ance x̄1. The utterance is encoded using the initial
discourse state hI0, the discourse state h

I
1 is com-

puted, the query ȳ1 is generated, and the set of seg-
ments S1 is created. The initial discourse state hI0
is learned, and the set of segments S0 used when
generating ȳ1 is the empty set. The attention is
computed only over the first utterance because no
previous utterances exist. The user then provides
the next utterance or concludes the interaction. At
turn i, the utterance x̄i is encoded using the dis-
course state hIi−1, the discourse state h

I
i is com-

puted, and the query ȳi is generated using the set
of segments Si−1. The model has no access to fu-
ture utterances. We use greedy inference for gen-
eration. Figure 3 illustrates a single decoding step.

5 Learning

We assume access to a training set of N interac-
tions {Ī(l)}Nl=1. Given an interaction Ī(l), each ut-
terance x̄(l)i where 1 ≤ i ≤ |Ī(l)|, is paired with
an annotated query ȳ(l)i . The set of segments from
previous utterances is deterministically extracted
from the annotated queries during learning. How-
ever, the data does not indicate what parts of each
query originate in segments copied from previ-
ous utterances. We adopt a simple approach and
heuristically identify context-dependent segments

based on entities that appear in the utterance and
the query.5 Once we identify a segment in the an-
notated query, we replace it with a unique place-
holder token, and it appears to the learning algo-
rithm as a single generation decision. Treating this
decision as latent is an important direction for fu-
ture work. Given the segment copy decisions, we
minimize the token cross-entropy loss:
L(y(l)i,k) = − logP

(
y

(l)
i,k | x̄

(l)
i , ȳ

(l)
i,1:k−1, Ī

(l)[: i− 1]
)

,

where k is the index of the output token. The base
and recent-history encoders (Sections 4.1 and 4.2)
can be trained by processing each utterance sep-
arately. For these models, given a mini-batch B
of utterances, each identified by an interaction-
utterance index pair, the loss is the mean token loss

L = 1∑
(i,j)∈B |ȳ

(j)
i |

∑

(i,j)∈B

|ȳ(j)i |∑

k=1

L(y(j)i,k ) .

The turn-level encoder (Section 4.3) requires
building a computation graph for the entire inter-
action. We update the model parameters for each
interaction. The interaction loss is

L = n
B

1
∑n

i=1 |ȳ
(j)
i |

n∑

i=1

|ȳ(j)i |∑

k=1

L(y(j)i,k ) ,

whereB is the batch size, and nB re-normalizes the
loss so the gradient magnitude is not dependent on
the number of utterances in the interaction. Our
ablations (−batch re-weight in Table 2) shows the
importance of this term. For both cases, we use
teacher forcing (Williams and Zipser, 1989).

6 Reasoning with Anonymized Tokens

An important practical consideration for genera-
tion in ATIS and other database domains is reason-
ing about database values, such as entities, times,
and dates. For example, the first utterance in Fig-
ure 2 includes two entities and a date reference.
With limited data, learning to both reason about a
large number of entities and to resolve dates are
challenging for neural network models. Follow-
ing previous work (Dong and Lapata, 2016; Iyer
et al., 2017), we address this with anonymization,
where the data is pre- and post-processed to ab-
stract over tokens that can be heuristically resolved
to tokens in the query language. In contrast to pre-
vious work, we design a special scoring function
to anonymized tokens to reflect how they are used
in the input utterances. Figure 4 illustrates pre-
processing in ATIS. For example, we use a tem-
poral semantic parser to resolve dates (e.g., next

5The alignment is detailed in the supplementary material.

2243



Original utterance and query:
x̄1: show me flights from seattle to boston next monday
ȳ1: ( SELECT DISTINCT flight.flight id ...

city.city name = ’SEATTLE’ ... city.city name
= ’BOSTON’ ... date day.year = 1993 AND
date day.month number = 2 AND date day.day number
= 8 ...

Anonymized utterance and query:
x̄′1: show me flights from CITY#1 to CITY#2 DAY#1 MONTH#1 YEAR#1
ȳ′1: ( SELECT DISTINCT flight.flight id ...

city.city name = CITY#1 ... city.city name
= CITY#2 ... date day.year = YEAR#1
AND date day.month number = MONTH#1 AND
date day.day number = DAY#1 ...

Anonymization mapping:
CITY#1 ’SEATTLE’ MONTH#1 2
CITY#2 ’BOSTON’ YEAR#1 1993
DAY#1 8

Figure 4: An example of date and entity anonymization
pre-processing for x̄1 and ȳ1 in Figure 2.

Monday) and replace them with day, month, and
year placeholders. To anonymize database entries,
we use a dictionary compiled from the database
(e.g., to map Seattle to SEATTLE). The full de-
tails of the anonymization procedure are provided
in the supplementary material. Following pre-
processing, the model reasons about encoding and
generation of anonymized tokens (e.g., CITY#1)
in addition to regular output tokens and query seg-
ments from the interaction history. Anonymized
tokens are typed (e.g., CITY), map to a token in
the query language (e.g., ’BOSTON’), and appear
both in input utterances and generated queries.

We modify our encoder and decoder embedding
functions (φx and φy) to map anonymized tokens
to the embeddings of their types (e.g., CITY). The
type embeddings in φx and φy are separate. Using
the types only, while ignoring the indices, avoids
learning biases that arise from the arbitrary order-
ing of the tokens in the training data. However,
it does not allow distinguishing between entries
with the same type for generation decisions; for
example, the common case where multiple cities
are mentioned in an interaction. We address this
by scoring anonymized token based on the mag-
nitude of attention assigned to them at generation
step k. The attention magnitude is computed from
the encoder hidden states. This computation con-
siders both the decoder state and the location of
the anonymized tokens in the input utterances to
account for how they are used in the interaction.
The probability of an anonymized token w at gen-
eration step k is
P (yi,k = w | x̄i, ȳi,1:k−1, Ī[: i− 1]) ∝

i∑

t=i−h

|x̄t|∑

j=1

(exp (sk (t, j)))

where sk (t, j) is the attention score computed in
Equation 8. This probability is normalized to-

Mean/max utterances per interaction 7.0 / 64
Mean/max tokens per utterance 10.2 / 47
Mean/max token per SQL query 102.9 / 1286
Input vocabulary size 1582
Output vocabulary size 982

Table 1: ATIS data statistics.

gether with the probabilities in Equations 7 and 9
to form the complete output probability.

7 Experimental Setup

Hyperparameters, architecture details, and other
experimental choices are detailed in the supple-
mentary material.

Data We use ATIS (Hemphill et al., 1990; Dahl
et al., 1994) to evaluate our approach. The data
was originally collected using wizard-of-oz exper-
iments, and annotated with SQL queries. Each in-
teraction was based on a scenario given to a user.
We observed that the original data split shares sce-
narios between the train, development, and test
splits. This introduces biases, where travel pat-
terns that appeared during training repeat in test-
ing. For example, a model trained on the orig-
inal data split often correctly resolves the exact
referenced by on Saturday with no pre-processing
or access to the document date. We evaluate this
overfitting empirically in the supplementary mate-
rial. We re-split the data to avoid this bias. We
evenly distribute scenarios across splits so that
each split contains both scenarios with many and
few representative interactions. The new split fol-
lows the original split sizes with 1148/380/130
train/dev/test interactions. Table 1 shows data
statistics. The system uses a SQL database of 27
tables and 162K entries. 96.6% of the queries re-
quire at least one join, and 93% at least two joins.
The most related work on ATIS to ours is Miller
et al. (1996), which we discuss in Section 3.

The most related corpora to ATIS are
SCONE (Long et al., 2016) and Sequen-
tialQA (Iyyer et al., 2017). SCONE (Long
et al., 2016) contains micro-domains consist-
ing of stack- or list-like elements. The formal
representation is linguistically-motivated and
the majority of queries include a single binary
predicate. All interactions include five turns.
SequentialQA (Iyyer et al., 2017) contains se-
quences of questions on a single Wikipedia table.
Interactions are on average 2.9 turns long, and
were created by re-phrasing a question from a
context-independent corpus (Pasupat and Liang,
2015). In contrast, ATIS uses a significantly larger

2244



database, requires generating complex queries
with multiple joins, includes longer interactions,
and was collected through interaction with users.
The supplementary material contains analysis of
the contextual phenomena observed in ATIS.
Pre-processing We pre-process the data to iden-
tify and anonymize entities (e.g., cities), numbers,
times, and dates. We use string matching heuris-
tics to identify entities and numbers, and identify
and resolve times and dates using UWTime (Lee
et al., 2014). When resolving dates we use the
original interaction date as the document time.
The supplementary material details this process.
Metrics We evaluate using query accuracy, strict
denotation accuracy, and relaxed denotation accu-
racy. Query accuracy is the percentage of pre-
dicted queries that match the reference query.
Strict denotation accuracy is the percentage of pre-
dicted queries that execute to exactly the same ta-
ble as the reference query. In contrast to strict,
relaxed gives credit to a prediction query that fails
to execute if the reference table is empty. In cases
when the utterance is ambiguous and there are
multiple gold queries, we consider the query or ta-
ble correct if they match any of the gold labels.
Systems We evaluate four systems: (a)
SEQ2SEQ-0: the baseline encoder-decoder
model (Section 4.1); (b) SEQ2SEQ-H: encoder-
decoder with attention on current and previous
utterances (Section 4.2); (c) S2S+ANON: encoder-
decoder with attention on previous utterances
and anonymization scoring (Section 6); and (d)
FULL: the complete approach including segment
copying (Section 4.4). For FULL, we evaluate
with predicted and gold (FULL-GOLD) previous
queries, and without attention on previous utter-
ances (FULL-0). All models except SEQ2SEQ-0
and FULL-0 use h = 3 previous utterances. We
limit segment copying to segments that appear in
the most recent query only.6 Unless specifically
ablated, all experiments use pre-processing.

8 Results

Table 2 shows development and test results. We
run each experiment five times and report mean
and standard deviation. The main metric we fo-
cus on is strict denotation accuracy. The rel-
atively low performance of SEQ2SEQ-0 demon-

6While we only use segments from the most recent query,
they often appear for the first time much earlier in the inter-
action, which influences their absolute position value a.

Model Query DenotationRelaxed Strict
Development Results
SEQ2SEQ-0 28.7±1.7 48.8±1.4 43.2±1.8
SEQ2SEQ-H 35.1±2.2 59.4±2.4 56.7±3.2
S2S+ANON 37.6±0.7 61.6±0.7 60.6±0.7
FULL-0 36.3±0.5 61.5±0.8 61.0±0.9
FULL 37.5±0.9 63.0±0.7 62.5±0.9
– turn-level enc. 37.4±1.5 62.1±2.5 61.4±2.7
– batch re-weight 36.4±0.6 61.8±0.3 61.5±0.4
– input pos. embs. 33.3±0.2 57.9±0.8 57.4±0.8
– query segments 36.0±0.9 59.5±1.3 58.3±1.4
– anon. scoring 35.7±0.5 60.8±1.1 60.0±1.0
– pre-processing 26.4±6.1 53.3±8.6 53.0±8.5
FULL-GOLD 42.1±0.8 66.6±0.7 66.1±0.7
Test Results
SEQ2SEQ-0 35.7±1.5 56.4±1.1 53.8±1.0
SEQ2SEQ-H 42.2±2.0 66.6±3.2 65.8±3.4
S2S+ANON 44.0±1.2 69.3±1.0 68.6±1.1
FULL-0 43.1±1.3 67.8±1.6 67.2±1.6
FULL 43.6±1.0 69.3±0.8 69.2±0.8
FULL-GOLD 47.4±1.3 72.3±0.5 72.0±0.5

Table 2: Mean and standard deviation development and
test results, including ablations on the FULL model.

strates the need for context in this task. Attend-
ing on recent history significantly increases perfor-
mance. Both SEQ2SEQ models score anonymized
tokens as regular vocabulary tokens. Adding
anonymized token scoring further increases per-
formance (S2S+ANON). FULL-0 and FULL add
segment copying and the turn-level encoder. The
relatively high performance of FULL-0 shows that
substituting segment copying with attention main-
tains and even improves the system effectiveness.
However, the best performance is provided with
FULL, which combines both. This shows the ben-
efit of redundancy in accessing contextual infor-
mation. Unlike the other systems, both FULL and
FULL-0 suffer from cascading errors due to select-
ing query segments from previously incorrect pre-
dictions. The higher FULL-GOLD performance il-
lustrates the influence of error propagation. While
part of this error can be mitigated by having both
attention and segment copying, this behavior is
unlikely to be learned from supervised learning,
where errors are never observed.

Ablations show that all components contribute
to the system performance. Performance drops
when using a concatenation-based encoder in-
stead of the turn-level encoder (−turn-level enc.;
Section 4.3). Using batch-reweighting (−batch-
reweight; Section 5) and input position embed-
dings (−input pos. embs.; Section 4.3) are
critical to the performance of the turn-level en-
coder. Removing copying of query segments

2245



0 5 10 15 20
30

45

60

75

(a) Interaction turns

St
ri

ct
D

en
ot

at
io

n
SEQ2SEQ-0 FULL SEQ2SEQ-H
FULL-GOLD S2S+ANON

0 1 2 3

(b) History length h
Figure 5: Mean development strict denotation accuracy
as function of turns and h.

Model Query DenotationRelaxed Strict
Development Results
S2S+ANON 44.4±1.2 69.9±0.3 68.9±0.3
FULL 42.8±0.2 68.8±0.2 68.4±0.2
FULL-GOLD 47.5±0.2 71.5±0.4 70.7±0.6
Test Results
S2S+ANON 43.9±0.3 67.4±1.0 67.2±1.0
FULL 44.3±0.2 66.3±0.3 66.3±0.4
FULL-GOLD 47.2±0.3 68.2±0.5 67.9±0.4

Table 3: Results on the original split of the data.

from the interaction history lowers performance
(−query segments; Section 4.4). Treating indexed
anonymized tokens as regular tokens, rather than
using attention-based scoring and type embed-
dings, lowers performance (−anon. scoring; Sec-
tion 6). Finally, pre-processing, which includes
anonymization, is critical (−pre-processing).

Figure 5(a) shows the performance as interac-
tions progress. All systems show a drop in per-
formance after the first utterance, which is always
context-independent. As expected, SEQ2SEQ-0
shows the biggest drop. The FULL approach is the
most stable as the interaction progresses.

Figure 5(b) shows the performance as we de-
crease the number of previous utterances used for
attention h. Without the turn-level encoder and
segment copying (SEQ2SEQ-H and S2S+ANON),
performance decreases significantly as h de-
creases. In contrast, the FULL model shows a
smaller decrease (1.5%). The supplementary ma-
terial includes attention analysis demonstrating the
importance of previous-utterance attention. How-
ever, attending on fewer utterances improves in-
ference speed: FULL-0 is 30% faster than FULL.

Finally, while we re-split the data due to sce-
nario sharing between train and test early in devel-
opment and used this split only for development,
we also evaluate on the original split (Table 3).
We report mean and standard deviation over three
trials. The high performance of S2S+ANON po-
tentially indicates it benefits more from the differ-
ences between the splitting procedures.

9 Analysis

We analyze errors made by the full model on thirty
development interactions. When analyzing the
output of FULL, we focus on error propagation
and analyze predictions that resulted in an incor-
rect table when using FULL, but a correct table
when using FULL-GOLD. 56.7% are due to selec-
tion of a segment that contained an incorrect con-
straint. 43.4% of the errors are caused by a neces-
sary segment missing during generation. 93.0%
of all predictions are valid SQL and follow the
database schema. We also analyze the errors of
FULL-GOLD. We observe that 30.0% of errors are
due to generating constraints that were not men-
tioned by the user. Other common errors include
generating relevant constraints with incorrect val-
ues (23.3%) and missing constraints (23.3%).

We also evaluate our model’s ability to re-
cover long-distance references while constraints
are added, changed, or removed, and when target
attributes change. The supplementary material in-
cludes the analysis details. In general, the model
resolves references well. However, it fails to re-
cover constraints mentioned in the past following a
user focus state change (Grosz and Sidner, 1986).

10 Discussion

We study models that recover context-dependent
executable representations from user utterances by
reasoning about interaction history. We observe
that our segment-copying models suffer from er-
ror propagation when extracting segments from
previously-generated queries. This could be mit-
igated by training a model to ignore erroneous
segments, and recover by relying on attention for
generation. However, because supervised learning
does not expose the model to erroneous states, a
different learning approach is required. Our analy-
sis demonstrates that our model is relatively insen-
sitive to interaction length, and is able to recover
both explicit and implicit references to previously-
mentioned entities and constraints. Further study
of user focus change is required, an important phe-
nomenon that is relatively rare in ATIS.

Acknowledgements

This research was supported by the NSF (CRII-
1656998), Schmidt Sciences, a gift from Google,
and cloud computing credits from Amazon. We
thank Valts Blukis, Luke Zettlemoyer, and the
anonymous reviewers for their helpful comments.

2246



References
Yoav Artzi and Luke Zettlemoyer. 2011. Bootstrap-

ping semantic parsers from conversations. In Pro-
ceedings of the Conference on Empirical Methods
in Natural Language Processing. http://www.
aclweb.org/anthology/D11-1039.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proceedings of
the International Conference on Learning Represen-
tations.

Jonathan Berant, Andrew Chou, Roy Frostig, and
Percy Liang. 2013. Semantic parsing on Free-
base from question-answer pairs. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing. http://www.aclweb.
org/anthology/D13-1160.

Jianpeng Cheng, Siva Reddy, Vijay Saraswat, and
Mirella Lapata. 2017. Learning structured natu-
ral language representations for semantic parsing.
In Proceedings Association for Computational Lin-
guistics. https://doi.org/10.18653/v1/
P17-1005.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using RNN encoder–decoder
for statistical machine translation. In Proceedings
of the 2014 Conference on Empirical Methods in
Natural Language Processing (EMNLP). https:
//doi.org/10.3115/v1/D14-1179.

James Clarke, Dan Goldwasser, Ming-Wei Chang,
and Dan Roth. 2010. Driving semantic pars-
ing from the world’s response. In Proceedings
of the Conference on Computational Natural Lan-
guage Learning. http://www.aclweb.org/
anthology/W10-2903.

Deborah A. Dahl, Madeleine Bates, Michael Brown,
William Fisher, Kate Hunicke-Smith, David Pal-
lett, Christine Pao, Alexander Rudnicky, and Eliz-
abeth Shriberg. 1994. Expanding the scope
of the ATIS task: The ATIS-3 corpus. In
Proceedings of the Workshop on Human Lan-
guage Technology. http://www.aclweb.
org/anthology/H94-1010.

Li Dong and Mirella Lapata. 2016. Language to logical
form with neural attention. In Proceedings of the As-
sociation for Computational Linguistics. https:
//doi.org/10.18653/v1/P16-1004.

Jeffrey L. Elman. 1990. Finding structure in time.
Cognitive Science 14:179–211.

Alessandra Giordani and Alessandro Moschitti. 2012.
Translating questions to SQL queries with gener-
ative parsers discriminatively reranked. In Con-

ference on Computational Linguistics. http://
www.aclweb.org/anthology/C12-2040.

Barbara J. Grosz and Candace L. Sidner. 1986. At-
tention, intentions, and the structure of discourse.
Computational Linguistics 12(3). http://www.
aclweb.org/anthology/J86-3001.

Charles T. Hemphill, John J. Godfrey, and George R.
Doddington. 1990. The ATIS spoken language
systems pilot corpus. In Proceedings of the
DARPA Speech and Natural Language Workshop.
http://www.aclweb.org/anthology/
H90-1021.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Computation 9.

Srinivasan Iyer, Ioannis Konstas, Alvin Cheung,
Jayant Krishnamurthy, and Luke Zettlemoyer. 2017.
Learning a neural semantic parser from user feed-
back. In Proceedings of the the Association for
Computational Linguistics. https://doi.org/
10.18653/v1/P17-1089.

Mohit Iyyer, Wen-tau Yih, and Ming-Wei Chang. 2017.
Search-based neural structured learning for sequen-
tial question answering. In Proceedings of the As-
sociation for Computational Linguistics. https:
//doi.org/10.18653/v1/P17-1167.

Robin Jia and Percy Liang. 2016. Data recombi-
nation for neural semantic parsing. In Proceed-
ings of the Association for Computational Lin-
guistics. https://doi.org/10.18653/v1/
P16-1002.

Diederik Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. In Proceedings
of the International Conference on Learning Repre-
sentations.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gard-
ner. 2017. Neural semantic parsing with type con-
straints for semi-structured tables. In Proceedings
of theConference on Empirical Methods in Natural
Language Processing. https://www.aclweb.
org/anthology/D17-1160.

Nate Kushman and Regina Barzilay. 2013. Us-
ing semantic unification to generate regular ex-
pressions from natural language. In Proceedings
of the North American Chapter of the Associa-
tion for Computational Linguistics: Human Lan-
guage Technologies. http://www.aclweb.
org/anthology/N13-1103.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Gold-
water, and Mark Steedman. 2011. Lexical gen-
eralization in CCG grammar induction for se-
mantic parsing. In Proceedings of Confer-
ence on Empirical Methods in Natural Lan-
guage Processing. http://www.aclweb.
org/anthology/D11-1140.

2247



Kenton Lee, Yoav Artzi, Jesse Dodge, and Luke Zettle-
moyer. 2014. Context-dependent semantic parsing
for time expressions. In Proceedings of the As-
sociation for Computational Linguistics. https:
//doi.org/10.3115/v1/P14-1135.

Xiujun Li, Yun-Nung Chen, Lihong Li, and Jianfeng
Gao. 2017. End-to-end task-completion neural dia-
logue systems. CoRR abs/1703.01008.

Percy Liang, Michael Jordan, and Dan Klein.
2011. Learning dependency-based compositional
semantics. In Proceedings of the Associa-
tion for Computational Linguistics: Human Lan-
guage Technologies. http://www.aclweb.
org/anthology/P11-1060.

Wang Ling, Phil Blunsom, Edward Grefenstette,
Karl Moritz Hermann, Tomás Kociský, Fumin
Wang, and Andrew Senior. 2016. Latent pre-
dictor networks for code generation. CoRR
abs/1603.06744.

Reginald Long, Panupong Pasupat, and Percy Liang.
2016. Simpler context-dependent logical forms via
model projections. In Proceedings of the Associ-
ation for Computational Linguistics. https://
doi.org/10.18653/v1/P16-1138.

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-
based neural machine translation. In Proceedings
of the Conference on Empirical Methods in Natural
Language Processing. https://doi.org/10.
18653/v1/D15-1166.

Scott Miller, David Stallard, Robert Bobrow, and
Richard Schwartz. 1996. A fully statistical
approach to natural language interfaces. In
Proceedings of the Association for Computa-
tional Linguistics. http://www.aclweb.org/
anthology/P96-1008.

Vincent Ng. 2010. Supervised noun phrase coref-
erence research: The first fifteen years. In
Proceedings of the Association for Computa-
tional Linguistics. http://www.aclweb.org/
anthology/P10-1142.

Panupong Pasupat and Percy Liang. 2015. Com-
positional semantic parsing on semi-structured ta-
bles. In Proceedings of the Association for Com-
putational Linguistics. https://doi.org/10.
3115/v1/P15-1142.

Baolin Peng, Xiujun Li, Lihong Li, Jianfeng Gao,
Asli Celikyilmaz, Sungjin Lee, and Kam-Fai Wong.
2017. Composite task-completion dialogue pol-
icy learning via hierarchical deep reinforcement
learning. In Proceedings of the Conference on
Empirical Methods in Natural Language Process-
ing. https://aclanthology.info/pdf/
D/D17/D17-1236.pdf.

Hoifung Poon. 2013. Grounded unsupervised semantic
parsing. In Proceedings of the Association for Com-
putational Linguistics. http://www.aclweb.
org/anthology/P13-1092.

Ana-Maria Popescu, Alex Armanasu, Oren Etzioni,
David Ko, and Alexander Yates. 2004. Mod-
ern natural language interfaces to databases: Com-
posing statistical parsing with semantic tractabil-
ity. In International Conference on Computa-
tional Linguistics. http://www.aclweb.org/
anthology/C04-1021.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code genera-
tion and semantic parsing. In Proceedings of the As-
sociation for Computational Linguistics. https:
//doi.org/10.18653/v1/P17-1105.

Iulian Serban, Alessandro Sordoni, Yoshua Bengio,
Aaron C. Courville, and Joelle Pineau. 2016. Build-
ing end-to-end dialogue systems using generative hi-
erarchical neural network models. In Association
for the Advancement of Artificial Intelligence.

Iulian Serban, Alessandro Sordoni, Ryan Lowe, Lau-
rent Charlin, Joelle Pineau, Aaron C. Courville, and
Yoshua Bengio. 2017. A hierarchical latent variable
encoder-decoder model for generating dialogues. In
Association for the Advancement of Artificial Intel-
ligence.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. In Neural Information Processing Systems.

Gökhan Tür, Dilek Z. Hakkani-Tür, and Larry P. Heck.
2010. What is left to be understood in ATIS? In Pro-
ceedings of the Spoken Language Technology Work-
shop.

Adrienne Wang, Tom Kwiatkowski, and Luke Zettle-
moyer. 2014. Morpho-syntactic lexical generaliza-
tion for CCG semantic parsing. In Proceedings of
the Conference on Empirical Methods in Natural
Language Processing. https://doi.org/10.
3115/v1/D14-1135.

Ronald J. Williams and David Zipser. 1989. A learn-
ing algorithm for continually running fully recurrent
neural networks. Neural Computation 1:270–280.

Xiaojun Xu, Chang Liu, and Dawn Xiaodong Song.
2017. SQLNet: Generating structured queries from
natural language without reinforcement learning.
CoRR abs/1711.04436.

Pengcheng Yin and Graham Neubig. 2017. A syntac-
tic neural model for general-purpose code genera-
tion. In Proceedings of the Association for Com-
putational Linguistics. https://doi.org/10.
18653/v1/P17-1041.

John M. Zelle and Raymond J. Mooney. 1996. Com-
parative results on using inductive logic program-
ming for corpus-based parser construction. In Con-
nectionist, Statistical and Symbolic Approaches to
Learning for Natural Language Processing.

2248



Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In Proceedings of the Conference on Un-
certainty in Artificial Intelligence.

Luke S. Zettlemoyer and Michael Collins. 2007. On-
line learning of relaxed CCG grammars for pars-
ing to logical form. In Proceedings of the Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning. http://www.aclweb.org/
anthology/D07-1071.

Luke S. Zettlemoyer and Michael Collins. 2009.
Learning context-dependent mappings from sen-
tences to logical form. In Proceedings of the
Joint Conference of the Association for Compu-
tational Linguistics and the International Joint
Conference on Natural Language Processing of
the AFNLP. http://www.aclweb.org/
anthology/P09-1110.

Victor Zhong, Caiming Xiong, and Richard Socher.
2017. Seq2SQL: Generating structured queries
from natural language using reinforcement learning.
CoRR abs/1709.00103.

2249


