



















































AMR dependency parsing with a typed semantic algebra


Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 1831–1841
Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics

1831

AMR Dependency Parsing with a Typed Semantic Algebra

Jonas Groschwitz∗† Matthias Lindemann∗ Meaghan Fowlie∗

Mark Johnson† Alexander Koller∗
∗ Saarland University, Saarbrücken, Germany † Macquarie University, Sydney, Australia

{jonasg|mlinde|mfowlie|koller}@coli.uni-saarland.de
mark.johnson@mq.edu.au

Abstract

We present a semantic parser for Abstract
Meaning Representations which learns to
parse strings into tree representations of the
compositional structure of an AMR graph.
This allows us to use standard neural tech-
niques for supertagging and dependency
tree parsing, constrained by a linguistically
principled type system. We present two
approximative decoding algorithms, which
achieve state-of-the-art accuracy and out-
perform strong baselines.

1 Introduction

Over the past few years, Abstract Meaning Repre-
sentations (AMRs, Banarescu et al. (2013)) have
become a popular target representation for seman-
tic parsing. AMRs are graphs which describe the
predicate-argument structure of a sentence. Be-
cause they are graphs and not trees, they can cap-
ture reentrant semantic relations, such as those in-
duced by control verbs and coordination. How-
ever, it is technically much more challenging to
parse a string into a graph than into a tree. For
instance, grammar-based approaches (Peng et al.,
2015; Artzi et al., 2015) require the induction
of a grammar from the training corpus, which
is hard because graphs can be decomposed into
smaller pieces in far more ways than trees. Neural
sequence-to-sequence models, which do very well
on string-to-tree parsing (Vinyals et al., 2014), can
be applied to AMRs but face the challenge that
graphs cannot easily be represented as sequences
(van Noord and Bos, 2017a,b).

In this paper, we tackle this challenge by making
the compositional structure of the AMR explicit.
As in our previous work, Groschwitz et al. (2017),
we view an AMR as consisting of atomic graphs
representing the meanings of the individual words,

which were combined compositionally using lin-
guistically motivated operations for combining a
head with its arguments and modifiers. We repre-
sent this structure as terms over the AM algebra as
defined in Groschwitz et al. (2017). This previous
work had no parser; here we show that the terms
of the AM algebra can be viewed as dependency
trees over the string, and we train a dependency
parser to map strings into such trees, which we
then evaluate into AMRs in a postprocessing step.
The dependency parser relies on type information,
which encodes the semantic valencies of the atomic
graphs, to guide its decisions.

More specifically, we combine a neural supertag-
ger for identifying the elementary graphs for the
individual words with a neural dependency model
along the lines of Kiperwasser and Goldberg (2016)
for identifying the operations of the algebra. One
key challenge is that the resulting term of the AM
algebra must be semantically well-typed. This
makes the decoding problem NP-complete. We
present two approximation algorithms: one which
takes the unlabeled dependency tree as given, and
one which assumes that all dependencies are pro-
jective. We evaluate on two data sets, achieving
state-of-the-art results on one and near state-of-the-
art results on the other (Smatch f-scores of 71.0
and 70.2 respectively). Our approach clearly out-
performs strong but non-compositional baselines.

Plan of the paper. After reviewing related work
in Section 2, we explain the AM algebra in Sec-
tion 3 and extend it to a dependency view in Sec-
tion 4. We explain model training in Section 5
and decoding in Section 6. Section 7 evaluates a
number of variants of our system.

2 Related Work

Recently, AMR parsing has generated considerable
research activity, due to the availability of large-

{jonasg|mlinde|mfowlie|koller}@coli.uni-saarland.de
mark.johnson@mq.edu.au


1832

scale annotated data (Banarescu et al., 2013) and
two successful SemEval Challenges (May, 2016;
May and Priyadarshi, 2017).

Methods from dependency parsing have been
shown to be very successful for AMR parsing.
For instance, the JAMR parser (Flanigan et al.,
2014, 2016) distinguishes concept identification
(assigning graph fragments to words) from rela-
tion identification (adding graph edges which con-
nect these fragments), and solves the former with
a supertagging-style method and the latter with a
graph-based dependency parser. Foland and Mar-
tin (2017) use a variant of this method based on an
intricate neural model, yielding state-of-the-art re-
sults. We go beyond these approaches by explicitly
modeling the compositional structure of the AMR,
which allows the dependency parser to combine
AMRs for the words using a small set of universal
operations, guided by the types of these AMRs.

Other recent methods directly implement a de-
pendency parser for AMRs, e.g. the transition-
based model of Damonte et al. (2017), or postpro-
cess the output of a dependency parser by adding
missing edges (Du et al., 2014; Wang et al., 2015).
In contrast to these, our model makes no strong
assumptions on the dependency parsing algorithm
that is used; here we choose that of Kiperwasser
and Goldberg (2016).

The commitment of our parser to derive AMRs
compositionally mirrors that of grammar-based
AMR parsers (Artzi et al., 2015; Peng et al., 2015).
In particular, there are parallels between the types
we use in the AM algebra and CCG categories
(see Section 3 for details). As a neural system,
our parser struggles less with coverage issues than
these, and avoids the complex grammar induction
process these models require.

More generally, our use of semantic types to re-
strict our parser is reminiscent of Kwiatkowski et al.
(2010), Krishnamurthy et al. (2017) and Zhang et al.
(2017), and the idea of deriving semantic represen-
tations from dependency trees is also present in
Reddy et al. (2017).

3 The AM algebra

A core idea of this paper is to parse a string into a
graph by instead parsing a string into a dependency-
style tree representation of the graph’s composi-
tional structure, represented as terms of the Apply-
Modify (AM) algebra (Groschwitz et al., 2017).

The values of the AM algebra are annotated s-

want

s o[s]

AR
G0

ARG1

write

person

AR
G
0

sleep

s

AR
G
0

m

sound

m
an
ne
r

Figure 1: Elementary as-graphs Gwant, Gwriter,
Gsleep, and Gsound for the words “want”, “writer”,
“sleep”, and “soundly” respectively.

graphs, or as-graphs: directed graphs with node
and edge labels in which certain nodes have been
designated as sources (Courcelle and Engelfriet,
2012) and annotated with type information. Some
examples of as-graphs are shown in Fig. 1. Each
as-graph has exactly one root, indicated by the bold
outline. The sources are indicated by red labels; for
instance, Gwant has an S-source and an O-source.
The annotations, written in square brackets behind
the red source names, will be explained below. We
use these sources to mark open argument slots; for
example, Gsleep in Fig. 1 represents an intransitive
verb, missing its subject, which will be added at
the S-source.

The AM algebra can combine as-graphs with
each other using two linguistically motivated op-
erations: apply and modify. Apply (APP) adds an
argument to a predicate. For example, we can add
a subject – the graph Gwriter in Fig. 1 – to the graph
GVP in Fig. 2d using APPS, yielding the complete
AMR in Fig. 2b. Linguistically, this is like filling
the subject (S) slot of the predicate wants to sleep
soundly with the argument the writer. In general,
for a source a, APPa(GP , GA), combines the as-
graph GP representing a predicate, or head, with
the as-graph GA, which represents an argument.
It does this by plugging the root node of GA into
the a-source u of GP – that is, the node u of GP
marked with source a. The root of the resulting
as-graph G is the root of GP , and we remove the a
marking on u, since that slot is now filled.

The modify operation (MOD) adds a modifier
to a graph. For example, we can combine two ele-
mentary graphs from Fig. 1 with MODm (Gsleep,
Gsound), yielding the graph in Fig. 2c. The M-
source of the modifier Gsoundly attaches to the root
of Gsleep. The root of the result is the same as the
root of Gsleep in the same sense that a verb phrase
with an adverb modifier is still a verb phrase. In
general, MODa(GH , GM ), combines a head GH
with a modifier GM . It plugs the root of GH into
the a-source u of GM . Although this may add in-
coming edges to the root of GH , that node is still



1833

the root of the resulting graph G. We remove the a
marking from GM .

In both APP and MOD, if there is any other
source b which is present in both graphs, the nodes
marked with b are unified with each other. For ex-
ample, when Gwant is O-applied to t1 in Fig. 2d,
the S-sources of the graphs for “want” and “sleep
soundly” are unified into a single node, creating
a reentrancy. This falls out of the definition of
merge for s-graphs which formally underlies both
operations (see (Courcelle and Engelfriet, 2012)).

Finally, the AM algebra uses types to restrict its
operations. Here we define the type of an as-graph
as the set of its sources with their annotations1; thus
for example, in Fig. 1, the graph for “writer” has
the empty type [ ],Gsleep has type [S], andGwant has
type [S, O[S]]. Each source in an as-graph specifies
with its annotation the type of the as-graph which
is plugged into it via APP. In other words, for a
source a, we may only a-apply GP with GA if
the annotation of the a-source in GP matches the
type of GA. For example, the O-source of Gwants
(Fig. 1) requires that we plug in an as-graph of type
[S]; observe that this means that the reentrancy in
Fig. 2b is lexically specified by the control verb
“want”. All other source nodes in Fig. 1 have no
annotation, indicating a type requirement of [ ].

Linguistically, modification is optional; we there-
fore want the modified graph to be derivationally
just like the unmodified graph, in that exactly the
same operations can apply to it. In a typed algebra,
this means MOD should not change the type of the
head. MODa therefore requires that the modifier
GM have no sources not already present in the head
GH , except a, which will be deleted anyway.

As in any algebra, we can build terms from con-
stants (denoting elementary as-graphs) by recur-
sively combining them with the operations of the
AM algebra. By evaluating the operations bottom-
up, we obtain an as-graph as the value of such
a term; see Fig. 2 for an example. However, as
discussed above, an operation in the term may be
undefined due to a type mismatch. We call an AM-
term well-typed if all its operations are defined. Ev-
ery well-typed AM-term evaluates to an as-graph.
Since the applicability of an AM operation depends
only on the types, we also write τ = f(τ1, τ2) if
as-graphs of type τ1 and τ2 can be combined with
the operation f and the result has type τ .

1See (Groschwitz et al., 2017) for a more formally com-
plete definition.

Relationship to CCG. There is close relation-
ship between the types of the AM algebra and the
categories of CCG. A type [S, O] specifies that the
as-graph needs to be applied to two arguments to
be semantically complete, similar a CCG category
such as S\NP/NP, where a string needs to be ap-
plied to two NP arguments to be syntactically com-
plete. However, AM types govern the combination
of graphs, while CCG categories control the com-
bination of strings. This relieves AM types of the
need to talk about word order; there are no “for-
ward” or “backward” slashes in AM types, and a
smaller set of operations. Also, the AM algebra
spells out raising and control phenomena more ex-
plicitly in the types.

4 Indexed AM terms

In this paper, we connect AM terms to the input
string w for which we want to produce a graph.
We do this in an indexed AM term, exemplified in
Fig. 3a. We assume that every elementary as-graph
G at a leaf represents the meaning of an individual
word token wi in w, and write G[i] to annotate the
leaf G with the index i of this token. This induces
a connection between the nodes of the AMR and
the tokens of the string, in that the label of each
node was contributed by the elementary as-graph
of exactly one token.

We define the head index of a subtree t to be the
index of the token which contributed the root of
the as-graph to which t evaluates. For a leaf with
annotation i, the head index is i; for an APP or
MOD node, the head index is the head index of the
left child, i.e. of the head argument. We annotate
each APP and MOD operation with the head index
of the left and right subtree.

4.1 AM dependency trees

We can represent indexed AM terms more com-
pactly as AM dependency trees, as shown in Fig. 3b.
The nodes of such a dependency tree are the tokens
of w. We draw an edge with label f from i to k
if there is a node with label f [i, k] in the indexed
AM term. For example, the tree in 3b has an edge
labeled MODm from 5 (Gsleep) to 6 (Gsoundly) be-
cause there is a node in the term in 3a labeled
MODm[5, 6]. The same AM dependency tree may
represent multiple indexed AM terms, because the
order of apply and modify operations is not spec-
ified in the dependency tree. However, it can be
shown that all well-typed AM terms that map to



1834

APPs

Gwant

APPo
MODm

Gsleep Gsoundly

Gwriter

want

AR
G0

ARG1

person

write

ARG0

sleep
ARG0

sound

m
an
ne
r

sleep

s

AR
G0

sound

m
anner

(a) (b) (c) (d)
want

AR
G0

ARG1
sleep

ARG0

sound

m
an
ne
r

s

Figure 2: (a) An AM-term with its value (b), along with the values for its subexpressions (c) t1 =
MODm(Gsleep, Gsound) and (d) t2 = APPo(Gwant, t1).

APPs[3,2]

Gwant[3]

APPo[3,5]

MODm[5,6]

Gsleep[5] Gsoundly[6]

Gwriter[2]

(a)

2: Gwriter

6: Gsoundly

4: ⊥5: Gsleep

AP
P s

AP
P o

IGNORE

M
O

D m

(b)

1: ⊥

IGNORE

3: Gwant

Figure 3: (a) An indexed AM term and (b) an AM
dependency tree, linking the term in Fig. 2;a to the
sentence “The writer wants to sleep soundly”.

the same AM dependency tree evaluate to the same
as-graph. We define a well-typed AM dependency
tree as one that represents a well-typed AM term.

Because not all words in the sentence contribute
to the AMR, we include a mechanism for ignoring
words in the input. As a special case, we allow the
constant ⊥, which represents a dummy as-graph
(of type ⊥) which we use as the semantic value
of words without a semantic value in the AMR.
We furthermore allow the edge label IGNORE in an
AM dependency tree, where IGNORE(τ1, τ2) = τ1
if τ2 = ⊥ and is undefined otherwise; in particular,
an AM dependency tree with IGNORE edges is only
well-typed if all IGNORE edges point into ⊥ nodes.
We keep all other operations f(τ1, τ2) as is, i.e. they
are undefined if either τ1 or τ2 is⊥, and never yield
⊥ as a result. When reconstructing an AM term
from the AM dependency tree, we skip IGNORE
edges, such that the subtree below them will not
contribute to the overall AMR.

4.2 Converting AMRs to AM terms

In order to train a model that parses sentences into
AM dependency trees, we need to convert an AMR
corpus – in which sentences are annotated with
AMRs – into a treebank of AM dependency trees.
We do this in three steps: first, we break each AMR
up into elementary graphs and identify their roots;
second, we assign sources and annotations to make
elementary as-graphs out of them; and third, com-
bine them into indexed AM terms.

For the first step, an aligner uses hand-written
heuristics to identify the string token to which each

node in the AMR corresponds (see Section C in the
Supplementary Materials for details). We proceed
in a similar fashion as the JAMR aligner (Flanigan
et al., 2014), i.e. by starting from high-confidence
token-node pairs and then extending them until the
whole AMR is covered. Unlike the JAMR aligner,
our heuristics ensure that exactly one node in each
elementary graph is marked as the root, i.e. as the
node where other graphs can attach their edges
through APP and MOD. When an edge connects
nodes of two different elementary graphs, we use
the “blob decomposition” algorithm of Groschwitz
et al. (2017) to decide to which elementary graph
it belongs. For the example AMR in Fig. 2b, we
would obtain the graphs in Fig. 1 (without source
annotations). Note that ARG edges belong with
the nodes at which they start, whereas the “manner”
edge in Gsoundly goes with its target.

In the second step we assign source names and
annotations to the unlabeled nodes of each elemen-
tary graph. Note that the annotations are crucial
to our system’s ability to generate graphs with
reentrancies. We mostly follow the algorithm of
Groschwitz et al. (2017), which determines neces-
sary annotations based on the structure of the given
graph. The algorithm chooses each source name de-
pending on the incoming edge label. For instance,
the two leaves of Gwant can have the source labels
S and O because they have incoming edges labeled
ARG0 and ARG1. However, the Groschwitz algo-
rithm is not deterministic: It allows object promo-
tion (the sources for an ARG3 edge may be O3, O2,
or O), unaccusative subjects (promoting the mini-
mal object to S if the elementary graph contains an
ARGi-edge (i > 0) but no ARG0-edge (Perlmutter,
1978)), and passive alternation (swapping O and S).
To make our as-graphs more consistent, we prefer
constants that promote objects as far as possible,
use unaccusative subjects, and no passive alterna-
tion, but still allow constants that do not satisfy
these conditions if necessary. This increased our
Smatch score significantly.

Finally, we choose an arbitrary AM dependency



1835

tree that combines the chosen elementary as-graphs
into the annotated AMR; in practice, the differ-
ences between the trees seem to be negligible.2

5 Training

We can now model the AMR parsing task as the
problem of computing the best well-typed AM de-
pendency tree t for a given sentence w. Because t
is well-typed, it can be decoded into an (indexed)
AM term and thence evaluated to an as-graph.

We describe t in terms of the elementary as-
graphs G[i] it uses for each token i and of its edges
f [i, k]. We assume a node-factored, edge-factored
model for the score ω(t) of t:

ω(t) =
∑

1≤i≤n
ω(G[i]) +

∑
f [i,k]∈E

ω(f [i, k]), (1)

where the edge weight further decomposes into the
sum ω(f [i, k]) = ω(i → k) + ω(f | i → k) of a
score ω(i→ k) for the presence of an edge from i
to k and a score ω(f | i→ k) for this edge having
label f . Our aim is to compute the well-typed t
with the highest score.

We present three models for ω: one for the graph
scores and two for the edge scores. All of these are
based on a two-layer bidirectional LSTM, which
reads inputs x = (x1, . . . , xn) token by token, con-
catenating the hidden states of the forward and
the backward LSTMs in each layer. On the sec-
ond layer, we thus obtain vector representations
vi = BiLSTM(x, i) for the individual input tokens
(see Fig. 4). Our models differ in the inputs x and
the way they predict scores from the vi.

5.1 Supertagging for elementary as-graphs

We construe the prediction of the as-graphs G[i]
for each input position i as a supertagging task
(Lewis et al., 2016). The supertagger reads inputs
xi = (wi, pi, ci), where wi is the word token, pi its
POS tag, and ci is a character-based LSTM encod-
ing of wi. We use pretrained GloVe embeddings
(Pennington et al., 2014) concatenated with learned
embeddings for wi, and learned embeddings for pi.

To predict the score for each elementary as-graph
out of a set of K options, we add a K-dimensional
output layer as follows:

ω(G[i]) = log softmax(W · vi + b)
2Indeed, we conjecture that for a fixed set of constants and

a fixed AMR, there is only one dependency tree.

x1

v1

x2

v2

xn

vn
...
...

ω(G[1]) ω(G[2]) ω(G[n])

ω(2 → n) ω(f | 2 → n)
v⊥

ω(⊥ → 1)

Figure 4: Architecture of the neural taggers.

and train the neural network using a cross-entropy
loss function. This maximizes the likelihood of the
elementary as-graphs in the training data.

5.2 Kiperwasser & Goldberg edge model

Predicting the edge scores amounts to a dependency
parsing problem. We chose the dependency parser
of Kiperwasser and Goldberg (2016), henceforth
K&G, to learn them, because of its accuracy and its
fit with our overall architecture. The K&G parser
scores the potential edge from i to k and its label
from the concatenations of vi and vk:

MLPθ(v) = W2 · tanh(W1 · v + b1) + b2
ω(i→ k) = MLPE(vi ◦ vk)

ω(f | i→ k) = MLPLBL(vi ◦ vk)

We use inputs xi = (wi, pi, τi) including the type
τi of the supertag G[i] at position i, using trained
embeddings for all three. At evaluation time, we
use the best scoring supertag according to the
model of Section 5.1. At training time, we sample
from q, where q(τi) = (1− δ) + δ · p(τi|pi, pi−1),
q(τ) = δ · p(τ |pi, pi−1) for any τ 6= τi and δ is
a hyperparameter controlling the bias towards the
aligned supertag. We train the model using K&G’s
original DyNet implementation. Their algorithm
uses a hinge loss function, which maximizes the
score difference between the gold dependency tree
and the best predicted dependency tree, and there-
fore requires parsing each training instance in each
iteration. Because the AM dependency trees are
highly non-projective, we replaced the projective
parser used in the off-the-shelf implementation by
the Chu-Liu-Edmonds algorithm implemented in
the TurboParser (Martins et al., 2010), improving
the LAS on the development set by 30 points.

5.3 Local edge model

We also trained a local edge score model, which
uses a cross-entropy rather than a hinge loss and
therefore avoids the repeated parsing at training



1836

time. Instead, we follow the intuition that every
node in a dependency tree has at most one incom-
ing edge, and train the model to score the correct
incoming edge as high as possible. This model
takes inputs xi = (wi, pi).

We define the edge and edge label scores as in
Section 5.2, with tanh replaced by ReLU. We fur-
ther add a learned parameter v⊥ for the “LSTM em-
bedding” of a nonexistent node, obtaining scores
ω(⊥ → k) for k having no incoming edge.

To train ω(i → k), we collect all scores for
edges ending at the same node k into a vector
ω(• → k). We then minimize the cross-entropy
loss for the gold edge into k under softmax(ω(• →
k)), maximizing the likelihood of the gold edges.
To train the labels ω(f | i → k), we simply mini-
mize the cross-entropy loss of the actual edge labels
f of the edges which are present in the gold AM
dependency trees.

The PyTorch code for this and the supertag-
ger are available at bitbucket.org/tclup/
amr-dependency.

6 Decoding

Given learned estimates for the graph and edge
scores, we now tackle the challenge of comput-
ing the best well-typed dependency tree t for the
input string w, under the score model (equation
(1)). The requirement that t must be well-typed
is crucial to ensure that it can be evaluated to an
AMR graph, but as we show in the Supplementary
Materials (Section A), makes the decoding prob-
lem NP-complete. Thus, an exact algorithm is not
practical. In this section, we develop two differ-
ent approximation algorithms for AM dependency
parsing: one which assumes the (unlabeled) de-
pendency tree structure as known, and one which
assumes that the AM dependency tree is projective.

6.1 Projective decoder

The projective decoder assumes that the AM de-
pendency tree is projective, i.e. has no crossing
dependency edges. Because of this assumption, it
can recursively combine adjacent substrings using
dynamic programming. The algorithm is shown in
Fig. 5 as a parsing schema (Shieber et al., 1995),
which derives items of the form ([i, k], r, τ) with
scores s. An item represents a well-typed deriva-
tion of the substring from i to k with head index r,
and which evaluates to an as-graph of type τ .

The parsing schema consists of three types of

s = ω(G[i]) G 6= ⊥
([i, i+ 1], i, τ(G)) : s

Init

([i, k], r, τ) : s s′ = ω(⊥[k])
([i, k + 1], r, τ) : s+ s′

Skip-R

([i, k], r, τ) : s s′ = ω(⊥[i− 1])
([i− 1, k], r, τ) : s+ s′ Skip-L

([i, j], r1, τ1) : s1 ([j, k], r2, τ2) : s2
τ = f(τ1, τ2) defined s = ω(f [r1, r2])

Arc-R [f ]
([i, k], r1, τ) : s1 + s2 + s

([i, j], r1, τ1) : s1 ([j, k], r2, τ2) : s2
τ = f(τ2, τ1) defined s = ω(f [r2, r1])

Arc-L [f ]
([i, k], r2, τ) : s1 + s2 + s

Figure 5: Rules for the projective decoder.

rules. First, the Init rule generates an item for each
graph fragment G[i] that the supertagger predicted
for the token wi, along with the score and type
of that graph fragment. Second, given items for
adjacent substrings [i, j] and [j, k], the Arc rules
apply an operation f to combine the indexed AM
terms for the two substrings, with Arc-R making
the left-hand substring the head and the right-hand
substring the argument or modifier, and Arc-L the
other way around. We ensure that the result is
well-typed by requiring that the types can be com-
bined with f . Finally, the Skip rules allow us to
extend a substring such that it covers tokens which
do not correspond to a graph fragment (i.e., their
AM term is ⊥), introducing IGNORE edges. After
all possible items have been derived, we extract
the best well-typed tree from the item of the form
([1, n], r, τ) with the highest score, where τ = [ ].

Because we keep track of the head indices, the
projective decoder is a bilexical parsing algorithm,
and shares a parsing complexity of O(n5) with
other bilexical algorithms such as the Collins parser.
It could be improved to a complexity of O(n4)
using the algorithm of Eisner and Satta (1999).

6.2 Fixed-tree decoder

The fixed-tree decoder computes the best unlabeled
dependency tree tr for w, using the edge scores
ω(i→ k), and then computes the best AM depen-
dency tree forw whose unlabeled version is tr. The
Chu-Liu-Edmonds algorithm produces a forest of
dependency trees, which we want to combine into
tr. We choose the tree whose root r has the highest
score for being the root of the AM dependency tree
and make the roots of all others children of r.

At this point, the shape of tr is fixed. We choose

bitbucket.org/tclup/amr-dependency
bitbucket.org/tclup/amr-dependency


1837

s = ω(G[i])
(i, ∅, τ(G)) : s Init

(i, C1, τ1) : s1 (k, Ch(k), τ2) : s2
k ∈ Ch(i)\C1

τ = f(τ1, τ2) defined s = ω(f [i, k])
Edge[f ]

(i, C1 ∪ {k}, τ) : s1 + s2 + s

Figure 6: Rules for the fixed-tree decoder.

supertags for the nodes and edge labels for the
edges by traversing tr bottom-up, computing types
for the subtrees as we go along. Formally, we apply
the parsing schema in Fig. 6. It uses items of the
form (i, C, τ) : s, where 1 ≤ i ≤ n is a node of
tr, C is the set of children of i for which we have
already chosen edge labels, and τ is a type. We
write Ch(i) for the set of children of i in tr.

The Init rule generates an item for each graph
that the supertagger can assign to each token i in
w, ensuring that every token is also assigned ⊥ as
a possible supertag. The Edge rule labels an edge
from a parent node i in tr to one of its children k,
whose children already have edge labels. As above,
this rule ensures that a well-typed AM dependency
tree is generated by locally checking the types. In
particular, if all types τ2 that can be derived for k
are incompatible with τ1, we fall back to an item
for k with τ2 = ⊥ (which always exists), along
with an IGNORE edge from i to k.

The complexity of this algorithm is O(n · 2d · d),
where d is the maximal arity of the nodes in tr.

7 Evaluation

We evaluate our models on the LDC2015E86 and
LDC2017T103 datasets (henceforth “2015” and
“2017”). Technical details and hyperparameters of
our implementation can be found in Sections B to
D of the Supplementary Materials.

7.1 Training data
The original LDC datasets pair strings with AMRs.
We convert each AMR in the training and devel-
opment set into an AM dependency tree, using
the procedure of Section 4.2. About 10% of the
training instances cannot be split into elementary
as-graphs by our aligner; we removed these from
the training data. Of the remaining AM dependency
trees, 37% are non-projective.

Furthermore, the AM algebra is designed to han-
dle short-range reentrancies, modeling grammati-

3https://catalog.ldc.upenn.edu/
LDC2017T10, identical to LDC2016E25.

cal phenomena such as control and coordination,
as in the derivation in Fig. 2. It cannot easily han-
dle the long-range reentrancies in AMRs which
are caused by coreference, a non-compositional
phenomenon.4 We remove such reentrancies from
our training data (about 60% of the roughly 20,000
reentrant edges). Despite this, our model performs
well on reentrant edges (see Table 2).

7.2 Pre- and postprocessing
We use simple pre- and postprocessing steps to han-
dle rare words and some AMR-specific patterns. In
AMRs, named entities follow a pattern shown in
Fig. 7. Here the named entity is of type “person”,
has a name edge to a “name” node whose children
spell out the tokens of “Agatha Christie”, and a link
to a wiki entry. Before training, we replace each
“name” node, its children, and the corresponding
span in the sentence with a special NAME token,
and we completely remove wiki edges. In this
example, this leaves us with only a “person” and
a NAME node. Further, we replace numbers and
some date patterns with NUMBER and DATE to-
kens. On the training data this is straightforward,
since names and dates are explicitly annotated in
the AMR. At evaluation time, we detect dates and
numbers with regular expressions, and names with
Stanford CoreNLP (Manning et al., 2014). We also
use Stanford CoreNLP for our POS tags.

Each elementary as-graph generated by the pro-
cedure of Section 4.2 has a unique node whose
label corresponds most closely to the aligned word
(e.g. the “want” node in Gwant and the “write” node
in Gwriter). We replace these node labels with LEX
in preprocessing, reducing the number of different
elementary as-graphs from 28730 to 2370. We fac-
tor the supertagger model of Section 5.1 such that
the unlexicalized version of G[i] and the label for
LEX are predicted separately.

At evaluation, we re-lexicalize all LEX nodes in
the predicted AMR. For words that were frequent
in the training data (at least 10 times), we take the
supertagger’s prediction for the label. For rarer
words, we use simple heuristics, explained in the
Supplementary Materials (Section D). For names,
we just look up name nodes with their children and
wiki entries observed for the name string in the
training data, and for unseen names use the literal
tokens as the name, and no wiki entry. Similarly,

4As Damonte et al. (2017) comment: “A valid criticism
of AMR is that these two reentrancies are of a completely
different type, and should not be collapsed together.”

https://catalog.ldc.upenn.edu/LDC2017T10
https://catalog.ldc.upenn.edu/LDC2017T10


1838

we collect the type for each encountered name (e.g.
“person” for “Agatha Christie”), and correct it in
the output if the tagger made a different prediction.
We recover dates and numbers straightforwardly.

7.3 Supertagger accuracy
All of our models rely on the supertagger to predict
elementary as-graphs; they differ only in the edge
scores. We evaluated the accuracy of the supertag-
ger on the converted development set (in which
each token has a supertag) of the 2015 data set, and
achieved an accuracy of 73%. The correct supertag
is within the supertagger’s 4 best predictions for
90% of the tokens, and within the 10 best for 95%.

Interestingly, supertags that introduce grammat-
ical reentrancies are predicted quite reliably, al-
though they are relatively rare in the training data.
The elementary as-graph for subject control verbs
(see Gwant in Fig. 1) accounts for only 0.8% of
supertags in the training data, yet 58% of its oc-
currences in the development data are predicted
correctly (84% in 4-best). The supertag for VP co-
ordination (with type [OP1[S], OP2[S]]) makes up
for 0.4% of the training data, but 74% of its oc-
currences are recognized correctly (92% in 4-best).
Thus the prediction of informative types for indi-
vidual words is feasible.

7.4 Comparison to Baselines
Type-unaware fixed-tree baseline. The fixed-tree
decoder is built to ensure well-typedness of the pre-
dicted AM dependency trees. To investigate to
what extent this is required, we consider a baseline
which just adds the individually highest-scoring
supertags and edge labels to the unlabeled depen-
dency tree tu, ignoring types. This leads to AM
dependency trees which are not well-typed for 75%
of the sentences (we fall back to the largest well-
typed subtree in these cases). Thus, an off-the-
shelf dependency parser can reliably predict the
tree structure of the AM dependency tree, but cor-
rect supertag and edge label assignment requires a
decoder which takes the types into account.

JAMR-style baseline. Our elementary as-
graphs differ from the elementary graphs used in
JAMR-style algorithms in that they contain explicit
source nodes, which restrict the way in which they
can be combined with other as-graphs. We investi-
gate the impact of this choice by implementing a
strong JAMR-style baseline. We adapt the AMR-to-
dependency conversion of Section 4.2 by removing
all unlabeled nodes with source names from the

Model 2015 2017
Ours
local edge + projective decoder 70.2±0.3 71.0±0.5
local edge + fixed-tree decoder 69.4±0.6 70.2±0.5
K&G edge + projective decoder 68.6±0.7 69.4±0.4
K&G edge + fixed-tree decoder 69.6±0.4 69.9±0.2
Baselines
fixed-tree (type-unaware) 26.0±0.6 27.9±0.6
JAMR-style 66.1 66.2
Previous work
CAMR (Wang et al., 2015) 66.5 -
JAMR (Flanigan et al., 2016) 67 -
Damonte et al. (2017) 64 -
van Noord and Bos (2017b) 68.5 71.0
Foland and Martin (2017) 70.7 -
Buys and Blunsom (2017) - 61.9

Table 1: 2015 & 2017 test set Smatch scores

elementary graphs. For instance, the graph Gwant
in Fig. 1 now only consists of a single “want” node.
We then aim to directly predict AMR edges be-
tween these graphs, using a variant of the local
edge scoring model of Section 5.3 which learns
scores for each edge in isolation. (The assumption
for the original local model, that each node has
only one incoming edge, does not apply here.)

When parsing a string, we choose the highest-
scoring supertag for each word; there are only 628
different supertags in this setting, and 1-best su-
pertagging accuracy is high at 88%. We then follow
the JAMR parsing algorithm by predicting all edges
whose score is over a threshold (we found -0.02 to
be optimal) and then adding edges until the graph
is connected. Because we do not predict which
node is the root of the AMR, we evaluated this
model as if it always predicted the root correctly,
overestimating its score slightly.

7.5 Results

Table 1 shows the Smatch scores (Cai and Knight,
2013) of our models, compared to a selection of
previously published results. Our results are av-
erages over 4 runs with 95% confidence intervals
(JAMR-style baselines are single runs). On the
2015 dataset, our best models (local + projective,
K&G + fixed-tree) outperform all previous work,
with the exception of the Foland and Martin (2017)
model; on the 2017 set we match state of the art re-
sults (though note that van Noord and Bos (2017b)
use 100k additional sentences of silver data). The
fixed-tree decoder seems to work well with either
edge model, but performance of the projective de-
coder drops with the K&G edge scores. It may be
that, while the hinge loss used in the K&G edge
scoring model is useful to finding the correct un-



1839

2015 2017
Metric W’15 F’16 D’17 PD FTD vN’17 PD FTD
Smatch 67 67 64 70 70 71 71 70
Unlabeled 69 69 69 73 73 74 74 74
No WSD 64 68 65 71 70 72 72 70
Named Ent. 75 79 83 79 78 79 78 77
Wikification 0 75 64 71 72 65 71 71
Negations 18 45 48 52 52 62 57 55
Concepts 80 83 83 83 84 82 84 84
Reentrancies 41 42 41 46 44 52 49 46
SRL 60 60 56 63 61 66 64 62

Table 2: Details for the LDC2015E86 and LDC2017T10 test sets

Agatha_Christiename

person

na
me

wiki

Agatha Christie

op
1 op2

Figure 7: A named entity

labeled dependency tree in the fixed-tree decoder,
scores for bad edges – which are never used when
computing the hinge loss – are not trained accu-
rately. Thus such edges may be erroneously used
by the projective decoder.

As expected, the type-unaware baseline has low
recall, due to its inability to produce well-typed
trees. The fact that our models outperform the
JAMR-style baseline so clearly is an indication
that they indeed gain some of their accuracy from
the type information in the elementary as-graphs,
confirming our hypothesis that an explicit model of
the compositional structure of the AMR can help
the parser learn an accurate model.

Table 2 analyzes the performance of our two
best systems (PD = projective, FTD = fixed-tree)
in more detail, using the categories of Damonte
et al. (2017), and compares them to Wang’s, Flani-
gan’s, and Damonte’s AMR parsers on the 2015
set and , and van Noord and Bos (2017b) for the
2017 dataset. (Foland and Martin (2017) did not
publish such results.) The good scores we achieve
on reentrancy identification, despite removing a
large amount of reentrant edges from the training
data, indicates that our elementary as-graphs suc-
cessfully encode phenomena such as control and
coordination.

The projective decoder is given 4, and the fixed-
tree decoder 6, supertags for each token. We trained
the supertagging and edge scoring models of Sec-
tion 5 separately; joint training did not help. Not
sampling the supertag types τi during training of
the K&G model, removing them from the input,
and removing the character-based LSTM encod-
ings ci from the input of the supertagger, all re-
duced our models’ accuracy.

7.6 Differences between the parsers

Although the Smatch scores for our two best mod-
els are close, they sometimes struggle with different
sentences. The fixed-tree parser is at the mercy of

the fixed tree; the projective parser cannot produce
non-projective AM dependency trees. It is remark-
able that the projective parser does so well, given
the prevalence of non-projective trees in the train-
ing data. Looking at its analyses, we find that it
frequently manages to find a projective tree which
yields an (almost) correct AMR, by choosing su-
pertags with unusual types, and by using modify
rather than apply (or vice versa).

8 Conclusion

We presented an AMR parser which applies meth-
ods from supertagging and dependency parsing to
map a string into a well-typed AM term, which it
then evaluates into an AMR. The AM term repre-
sents the compositional semantic structure of the
AMR explicitly, allowing us to use standard tree-
based parsing techniques.

The projective parser currently computes the
complete parse chart. In future work, we will speed
it up through the use of pruning techniques. We
will also look into more principled methods for
splitting the AMRs into elementary as-graphs to
replace our hand-crafted heuristics. In particular,
advanced methods for alignments, as in Lyu and
Titov (2018), seem promising. Overcoming the
need for heuristics also seems to be a crucial in-
gredient for applying our method to other semantic
representations.

Acknowledgements We would like to thank the
anonymous reviewers for their comments. We
thank Stefan Grünewald for his contribution to our
PyTorch implementation, and want to acknowledge
the inspiration obtained from Nguyen et al. (2017).
We also extend our thanks to the organizers and
participants of the Oslo CAS Meaning Construc-
tion workshop on Universal Dependencies. This
work was supported by the DFG grant KO 2916/2-1
and a Macquarie University Research Excellence
Scholarship for Jonas Groschwitz.



1840

References
Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.

Broad-coverage CCG Semantic Parsing with AMR.
In Proceedings of the 2015 Conference on Empirical
Methods in Natural Language Processing.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract Meaning Representation
for Sembanking. In Proceedings of the 7th Linguis-
tic Annotation Workshop and Interoperability with
Discourse.

Jan Buys and Phil Blunsom. 2017. Oxford at SemEval-
2017 task 9: Neural AMR parsing with pointer-
augmented attention. In Proceedings of the 11th
International Workshop on Semantic Evaluation
(SemEval-2017). pages 914–919.

Shu Cai and Kevin Knight. 2013. Smatch: an evalua-
tion metric for semantic feature structures. In Pro-
ceedings of the 51st Annual Meeting of the Associa-
tion for Computational Linguistics.

Bruno Courcelle and Joost Engelfriet. 2012. Graph
Structure and Monadic Second-Order Logic, a Lan-
guage Theoretic Approach. Cambridge University
Press.

Marco Damonte, Shay B. Cohen, and Giorgio Satta.
2017. An incremental parser for abstract meaning
representation. In Proceedings of the 15th Confer-
ence of the European Chapter of the Association for
Computational Linguistics: Volume 1, Long Papers.
Association for Computational Linguistics.

Yantao Du, Fan Zhang, Weiwei Sun, and Xiaojun Wan.
2014. Peking: Profiling syntactic tree parsing tech-
niques for semantic graph parsing. In Proceedings
of the 8th International Workshop on Semantic Eval-
uation (SemEval 2014).

Jason Eisner and Giorgio Satta. 1999. Efficient pars-
ing for bilexical context-free grammars and head au-
tomaton grammars. In Proceedings of the 37th ACL.

Jeffrey Flanigan, Chris Dyer, Noah A Smith, and Jaime
Carbonell. 2016. CMU at SemEval-2016 task 8:
Graph-based AMR parsing with infinite ramp loss.
In Proceedings of the 10th International Workshop
on Semantic Evaluation (SemEval-2016).

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. In Proceedings of the 52nd Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers).

William Foland and James H. Martin. 2017. Abstract
Meaning Representation Parsing using LSTM Re-
current Neural Networks. In Proceedings of the
55th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers).

Jonas Groschwitz, Meaghan Fowlie, Mark Johnson,
and Alexander Koller. 2017. A constrained graph
algebra for semantic parsing with amrs. In Proceed-
ings of the 12th International Conference on Com-
putational Semantics (IWCS).

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and Accurate Dependency Parsing Using Bidi-
rectional LSTM Feature Representations. Transac-
tions of the Association for Computational Linguis-
tics 4:313–327.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gard-
ner. 2017. Neural semantic parsing with type con-
straints for semi-structured tables. In Proceedings of
the 2017 Conference on Empirical Methods in Natu-
ral Language Processing. pages 1516–1526.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing probabilis-
tic CCG grammars from logical form with higher-
order unification. In Proceedings of the 2010 confer-
ence on empirical methods in natural language pro-
cessing. Association for Computational Linguistics,
pages 1223–1233.

Mike Lewis, Kenton Lee, and Luke Zettlemoyer. 2016.
LSTM CCG Parsing. In Proceedings of the 2016
Conference of the North American Chapter of the
Association for Computational Linguistics: Human
Language Technologies.

Chunchuan Lyu and Ivan Titov. 2018. Amr parsing as
graph prediction with latent alignment. In Proceed-
ings of the 56th Annual Conference of the Associa-
tion for Computational Linguistics (ACL).

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The stanford corenlp natural language
processing toolkit. In Proceedings of 52nd Annual
Meeting of the Association for Computational Lin-
guistics: System Demonstrations.

André F. T. Martins, Noah A. Smith, Eric P. Xing,
Pedro M. Q. Aguiar, and Mário A. T. Figueiredo.
2010. Turbo parsers: Dependency parsing by ap-
proximate variational inference. In Proceedings of
the 2010 Conference on Empirical Methods in Natu-
ral Language Processing. Association for Computa-
tional Linguistics.

Jonathan May. 2016. Semeval-2016 task 8: Mean-
ing representation parsing. In Proceedings of the
10th International Workshop on Semantic Evalu-
ation (SemEval-2016). Association for Computa-
tional Linguistics.

Jonathan May and Jay Priyadarshi. 2017. Semeval-
2017 task 9: Abstract meaning representation
parsing and generation. In Proceedings of the
11th International Workshop on Semantic Evalu-
ation (SemEval-2017). Association for Computa-
tional Linguistics.



1841

Dat Quoc Nguyen, Mark Dras, and Mark Johnson.
2017. A novel neural network model for joint POS
tagging and graph-based dependency parsing. arXiv
preprint arXiv:1705.05952 .

Xiaochang Peng, Linfeng Song, and Daniel Gildea.
2015. A synchronous hyperedge replacement gram-
mar based approach for amr parsing. In Proceedings
of the 19th Conference on Computational Language
Learning.

Jeffrey Pennington, Richard Socher, and Christopher D.
Manning. 2014. Glove: Global vectors for word rep-
resentation. In Empirical Methods in Natural Lan-
guage Processing (EMNLP).

David M Perlmutter. 1978. Impersonal passives and
the unaccusative hypothesis. In annual meeting of
the Berkeley Linguistics Society. volume 4, pages
157–190.

Siva Reddy, Oscar Täckström, Slav Petrov, Mark Steed-
man, and Mirella Lapata. 2017. Universal semantic
parsing. In Proceedings of the 2017 Conference on
Empirical Methods in Natural Language Processing.
Association for Computational Linguistics, pages
89–101. http://aclweb.org/anthology/D17-1009.

Stuart Shieber, Yves Schabes, and Fernando Pereira.
1995. Principles and implementation of deductive
parsing. Journal of Logic Programming 24(1–2):3–
36.

Rik van Noord and Johan Bos. 2017a. Dealing with
co-reference in neural semantic parsing. In Proceed-
ings of the 2nd Workshop on Semantic Deep Learn-
ing (SemDeep-2).

Rik van Noord and Johan Bos. 2017b. Neural seman-
tic parsing by character-based translation: Experi-
ments with abstract meaning representations. Com-
putational Linguistics in the Netherlands Journal .

Oriol Vinyals, Lukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey E. Hinton. 2014. Gram-
mar as a foreign language. CoRR abs/1412.7449.

Chuan Wang, Nianwen Xue, and Sameer Pradhan.
2015. A Transition-based Algorithm for AMR Pars-
ing. In Proceedings of NAACL-HLT .

Yuchen Zhang, Panupong Pasupat, and Percy Liang.
2017. Macro grammars and holistic trigger-
ing for efficient semantic parsing. In Proceed-
ings of the 2017 Conference on Empirical Meth-
ods in Natural Language Processing. Association
for Computational Linguistics, pages 1214–1223.
http://aclweb.org/anthology/D17-1125.

http://aclweb.org/anthology/D17-1009
http://aclweb.org/anthology/D17-1009
http://aclweb.org/anthology/D17-1009
http://aclweb.org/anthology/D17-1125
http://aclweb.org/anthology/D17-1125
http://aclweb.org/anthology/D17-1125

