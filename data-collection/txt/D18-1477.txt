











































Simple Recurrent Units for Highly Parallelizable Recurrence


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 4470–4481
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

4470

Simple Recurrent Units for Highly Parallelizable Recurrence

Tao Lei1 Yu Zhang2 Sida I. Wang1,3 Hui Dai1 Yoav Artzi1,4
1ASAPP Inc. 2Google Brain 3Princeton University 4Cornell University

1
{tao, hd}@asapp.com

2
ngyuzh@google.com

3
sidaw@cs.princeton.edu

4
yoav@cs.cornell.edu

Abstract
Common recurrent neural architectures scale
poorly due to the intrinsic difficulty in par-
allelizing their state computations. In this
work, we propose the Simple Recurrent Unit
(SRU), a light recurrent unit that balances
model capacity and scalability. SRU is de-
signed to provide expressive recurrence, en-
able highly parallelized implementation, and
comes with careful initialization to facili-
tate training of deep models. We demon-
strate the effectiveness of SRU on multiple
NLP tasks. SRU achieves 5–9x speed-up
over cuDNN-optimized LSTM on classifica-
tion and question answering datasets, and de-
livers stronger results than LSTM and convo-
lutional models. We also obtain an average of
0.7 BLEU improvement over the Transformer
model (Vaswani et al., 2017) on translation by
incorporating SRU into the architecture.1

1 Introduction
Recurrent neural networks (RNN) are at the core
of state-of-the-art approaches for a large num-
ber of natural language tasks, including machine
translation (Cho et al., 2014; Bahdanau et al.,
2015; Jean et al., 2015; Luong et al., 2015), lan-
guage modeling (Zaremba et al., 2014; Gal and
Ghahramani, 2016; Zoph and Le, 2016), opin-
ion mining (Irsoy and Cardie, 2014), and situated
language understanding (Mei et al., 2016; Misra
et al., 2017; Suhr et al., 2018; Suhr and Artzi,
2018). Key to many of these advancements are
architectures of increased capacity and computa-
tion. For instance, the top-performing models for
semantic role labeling and translation use eight re-
current layers, requiring days to train (He et al.,
2017; Wu et al., 2016b). The scalability of these
models has become an important problem that im-
pedes NLP research.

1Our code is available at https://github.com/
taolei87/sru.

The difficulty of scaling recurrent networks
arises from the time dependence of state com-
putation. In common architectures, such as
Long Short-term Memory (LSTM; Hochreiter
and Schmidhuber, 1997) and Gated Recurrent
Units (GRU; Cho et al., 2014), the computation
of each step is suspended until the complete ex-
ecution of the previous step. This sequential de-
pendency makes recurrent networks significantly
slower than other operations, and limits their ap-
plicability. For example, recent translation mod-
els consist of non-recurrent components only, such
as attention and convolution, to scale model train-
ing (Gehring et al., 2017; Vaswani et al., 2017).

In this work, we introduce the Simple Recurrent
Unit (SRU), a unit with light recurrence that offers
both high parallelization and sequence modeling
capacity. The design of SRU is inspired by pre-
vious efforts, such as Quasi-RNN (QRNN; Brad-
bury et al., 2017) and Kernel NN (KNN; Lei et al.,
2017), but enjoys additional benefits:

• SRU exhibits the same level of parallelism as
convolution and feed-forward nets. This is
achieved by balancing sequential dependence
and independence: while the state compu-
tation of SRU is time-dependent, each state
dimension is independent. This simplifica-
tion enables CUDA-level optimizations that
parallelize the computation across hidden di-
mensions and time steps, effectively using the
full capacity of modern GPUs. Figure 1 com-
pares our architecture’s runtimes to common
architectures.

• SRU replaces the use of convolutions (i.e., n-
gram filters), as in QRNN and KNN, with
more recurrent connections. This retains
modeling capacity, while using less compu-
tation (and hyper-parameters).

https://github.com/taolei87/sru
https://github.com/taolei87/sru


4471

Figure 1: Average processing time in milliseconds of a batch of 32 samples using cuDNN LSTM, word-
level convolution conv2d (with filter width k = 2 and k = 3), and the proposed SRU. We vary the
number of tokens per sequence (l) and feature dimension (d).

• SRU improves the training of deep recur-
rent models by employing highway connec-
tions (Srivastava et al., 2015) and a parame-
ter initialization scheme tailored for gradient
propagation in deep architectures.

We evaluate SRU on a broad set of problems,
including text classification, question answering,
translation and character-level language model-
ing. Our experiments demonstrate that light re-
currence is sufficient for various natural language
tasks, offering a good trade-off between scala-
bility and representational power. On classifica-
tion and question answering datasets, SRU out-
performs common recurrent and non-recurrent ar-
chitectures, while achieving 5–9x speed-up com-
pared to cuDNN LSTM. Stacking additional lay-
ers further improves performance, while incurring
relatively small costs owing to the cheap compu-
tation of a single layer. We also obtain an average
improvement of 0.7 BLEU score on the English
to German translation task by incorporating SRU
into Transformer (Vaswani et al., 2017).

2 Related Work

Improving on common architectures for sequence
processing has recently received significant atten-
tion (Greff et al., 2017; Balduzzi and Ghifary,
2016; Miao et al., 2016; Zoph and Le, 2016; Lee
et al., 2017). One area of research involves incor-
porating word-level convolutions (i.e. n-gram fil-
ters) into recurrent computation (Lei et al., 2015;
Bradbury et al., 2017; Lei et al., 2017). For ex-
ample, Quasi-RNN (Bradbury et al., 2017) pro-
poses to alternate convolutions and a minimal-
ist recurrent pooling function and achieves sig-
nificant speed-up over LSTM. While Bradbury
et al. (2017) focus on the speed advantages of
the network, Lei et al. (2017) study the theoret-

ical characteristics of such computation and pos-
sible extensions. Their results suggest that sim-
plified recurrence retains strong modeling capac-
ity through layer stacking. This finding motivates
the design of SRU for both high parallelization
and representational power. SRU also relates to
IRNN (Le et al., 2015), which uses an identity di-
agonal matrix to initialize hidden-to-hidden con-
nections. SRU uses point-wise multiplication for
hidden connections, which is equivalent to using
a diagonal weight matrix. This can be seen as a
constrained version of diagonal initialization.

Various strategies have been proposed to scale
network training (Goyal et al., 2017) and to
speed up recurrent networks (Diamos et al., 2016;
Shazeer et al., 2017; Kuchaiev and Ginsburg,
2017). For instance, Diamos et al. (2016) utilize
hardware infrastructures by stashing RNN param-
eters on cache (or fast memory). Shazeer et al.
(2017) and Kuchaiev and Ginsburg (2017) im-
prove the computation via conditional computing
and matrix factorization respectively. Our imple-
mentation for SRU is inspired by the cuDNN-
optimized LSTM (Appleyard et al., 2016), but en-
ables more parallelism – while cuDNN LSTM re-
quires six optimization steps, SRU achieves more
significant speed-up via two optimizations.

The design of recurrent networks, such as SRU
and related architectures, raises questions about
representational power and interpretability (Chen
et al., 2018; Peng et al., 2018). Balduzzi and Ghi-
fary (2016) applies type-preserving transforma-
tions to discuss the capacity of various simplified
RNN architectures. Recent work (Anselmi et al.,
2015; Daniely et al., 2016; Zhang et al., 2016; Lei
et al., 2017) relates the capacity of neural networks
to deep kernels. We empirically demonstrate SRU
can achieve compelling results by stacking multi-
ple layers.



4472

3 Simple Recurrent Unit

We present and explain the design of Simple Re-
current Unit (SRU) in this section. A single layer
of SRU involves the following computation:

ft = � (Wfxt + vf � ct�1 + bf ) (1)
ct = ft � ct�1 + (1� ft)� (Wxt) (2)

rt = � (Wrxt + vr � ct�1 + br) (3)
ht = rt � ct + (1� rt)� xt (4)

where W, Wf and Wr are parameter matrices
and vf , vr, bf and bv are parameter vectors to
be learnt during training. The complete architec-
ture decomposes to two sub-components: a light
recurrence (Equation 1 and 2) and a highway net-
work (Equation 3 and 4).

The light recurrence component successively
reads the input vectors xt and computes the se-
quence of states ct capturing sequential informa-
tion. The computation resembles other recurrent
networks such as LSTM, GRU and RAN (Lee
et al., 2017). Specifically, a forget gate ft controls
the information flow (Equation 1) and the state
vector ct is determined by adaptively averaging
the previous state ct�1 and the current observation
Wxt according to ft (Equation 2).

One key design decision that differs from previ-
ous gated recurrent architectures is the way ct�1
is used in the sigmoid gate. Typically, ct�1 is
multiplied with a parameter matrix to compute ft,
e.g., ft = �(Wfxt + Vfct�1 + bf ). However,
the inclusion of Vfct�1 makes it difficult to par-
allelize the state computation: each dimension of
ct and ft depends on all entries of ct�1, and the
computation has to wait until ct�1 is fully com-
puted. To facilitate parallelization, our light recur-
rence component uses a point-wise multiplication
vf � ct�1 instead. With this simplification, each
dimension of the state vectors becomes indepen-
dent and hence parallelizable.

The highway network component (Srivastava
et al., 2015) facilitates gradient-based training of
deep networks. It uses the reset gate rt (Equation
3) to adaptively combine the input xt and the state
ct produced from the light recurrence (Equation
4), where (1 � rt) � xt is a skip connection that
allows the gradient to directly propagate to the pre-
vious layer. Such connections have been shown to
improve scalability (Wu et al., 2016a; Kim et al.,
2016; He et al., 2016; Zilly et al., 2017).

The combination of the two components makes
the overall architecture simple yet expressive, and
easy to scale due to enhanced parallelization and
gradient propagation.

3.1 Parallelized Implementation
Despite the parallelization friendly design of SRU,
a naive implementation which computes equations
(1)–(4) for each step t sequentially would not
achieve SRU’s full potential. We employ two op-
timizations to enhance parallelism. The optimiza-
tions are performed in the context of GPU / CUDA
programming, but the general idea can be applied
to other parallel programming models.

We re-organize the computation of equations
(1)–(4) into two major steps. First, given the input
sequence {x1 · · ·xL}, we batch the matrix multi-
plications across all time steps. This significantly
improves the computation intensity (e.g. GPU uti-
lization). The batched multiplication is:

U> =

0

@
W
Wf
Wr

1

A [x1,x2, · · · ,xL] ,

where L is the sequence length, U 2 RL⇥3d is
the computed matrix and d is the hidden state size.
When the input is a mini-batch of B sequences, U
would be a tensor of size (L,B, 3d).

The second step computes the remaining point-
wise operations. Specifically, we compile all
point-wise operations into a single fused CUDA
kernel and parallelize the computation across each
dimension of the hidden state. Algorithm 1 shows
the pseudo code of the forward function. The com-
plexity of this step is O(L ·B · d) per layer, where
L is the sequence length and B is the batch size. In
contrast, the complexity of LSTM is O(L ·B · d2)
because of the hidden-to-hidden multiplications
(e.g. Vht�1), and each dimension can not be in-
dependently parallelized. The fused kernel also
reduces overhead. Without it, operations such as
sigmoid activation would each invoke a separate
function call, adding kernel launching latency and
more data moving costs.

The implementation of a bidirectional SRU is
similar: the matrix multiplications of both direc-
tions are batched, and the fused kernel handles and
parallelizes both directions at the same time.

3.2 Initialization
Proper parameter initialization can reduce gradient
propagation difficulties and hence have a positive



4473

Algorithm 1 Mini-batch version of the forward pass defined in Equations (1)–(4).

Indices: Sequence length L, mini-batch size B, hidden state dimension d.
Input: Input sequences batch x[l, i, j]; grouped matrix multiplication U[l, i, j0];

initial state c0[i, j]; parameters vf [j], vr[j], bf [j] and br[j].
Output: Output h[·, ·, ·] and internal c[·, ·, ·] states.

Initialize h[·, ·, ·] and c[·, ·, ·] as two L⇥B ⇥ d tensors.
for i = 1, · · · , B; j = 1, · · · , d do // Parallelize each example i and dimension j

c = c0[i, j]
for l = 1, · · · , L do

f = � (U[l, i, j + d] + vf [j]⇥ c+ bf [j] )
c = f ⇥ c+ (1� f)⇥U[l, i, j]
r = � (U[l, i, j + d⇥ 2] + vr[j]⇥ c+ br[j] )
h = r ⇥ c+ (1� r)⇥ x[l, i, j]
c[l, i, j] = c
h[l, i, j] = h

return h[·, ·, ·] and c[·, ·, ·]

impact on the final performance. We now describe
an initialization strategy tailored for SRU.

We start by adopting common initializations de-
rived for feed-forward networks (Glorot and Ben-
gio, 2010; He et al., 2015). The weights of param-
eter matrices are drawn with zero mean and 1/d
variance, for instance, via the uniform distribution
[�

p
3/d,+

p
3/d]. This ensures the output vari-

ance remains approximately the same as the input
variance after the matrix multiplication.

However, the light recurrence and highway
computation would still reduce the variance of
hidden representations by a factor of 1/3 to 1/2:

1

3
 Var[ht]

Var[xt]
 1

2
,

and the factor converges to 1/2 in deeper layers
(see Appendix A). This implies the output ht and
the gradient would vanish in deep models. To off-
set the problem, we introduce a scaling correction
constant ↵ in the highway connection

ht = rt � ct + (1� rt)� xt · ↵ ,

where ↵ is set to
p
3 such that Var[ht] ⇡ Var[xt]

at initialization. When the highway network is ini-
tialized with a non-zero bias br = b, the scaling
constant ↵ can be accordingly set as:

↵ =
p

1 + exp(b)⇥ 2 .

Figure 2 compares the training progress with and
without the scaling correction. See Appendix A
for the derivation and more discussion.

0.25

0.38

0.52

0.65

5 layer

step no scaling with scaling

1 0.69587987661361
69

0.69471210241317
75

2 0.69360971450805
66

0.70679479837417
6

4 0.69167828559875
49

0.68963408470153
81

5 0.69149464368820
19

0.68712782859802
25

6 0.69109219312667
85

0.68311333656311
04

7 0.69028604030609
13

0.68658131361007
69

8 0.68636518716812
13

0.67472738027572
63

9 0.69153815507888
79

0.68284726142883
3

10 0.68511354923248
29

0.68266063928604
13

11 0.67692613601684
57

0.66606879234313
96

12 0.68502306938171
39

0.67288947105407
71

13 0.68517547845840
45

0.67398208379745
48

14 0.66570037603378
3

0.63540393114089
97

15 0.65827196836471
56

0.63521456718444
82

16 0.66550070047378
54

0.65113437175750
73

17 0.66228967905044
56

0.65273129940032
96

18 0.59680402278900
15

0.57722926139831
54

19 0.66552460193634
03

0.66869622468948
36

20 0.58357143402099
61

0.57429039478302

21 0.66341418027877
81

0.69616597890853
88

22 0.59275627136230
47

0.61363184452056
88

23 0.57578068971633
91

0.57446819543838
5

24 0.56586354970932
01

0.61302137374877
93

25 0.58144080638885
5

0.61606216430664
06

26 0.62346082925796
51

0.61466139554977
42

27 0.71355241537094
12

0.65056872367858
89

28 0.58123964071273
8

0.62549662590026
86

30 0.68998241424560
55

0.63613635301589
97

31 0.62475991249084
47

0.65779834985733
03

32 0.61295872926712
04

0.61878007650375
37

33 0.55482220649719
24

0.62934297323226
93

34 0.57439488172531
13

0.57176047563552
86

35 0.56072294712066
65

0.57941019535064
7

36 0.51351976394653
32

0.52448111772537
23

37 0.61627656221389
77

0.65032446384429
93

38 0.70487678050994
87

0.68365365266799
93

39 0.52156120538711
55

0.55995535850524
9

40 0.61801612377166
75

0.59346944093704
22

41 0.66186791658401
49

0.71131658554077
15

43 0.55648767948150
63

0.60116279125213
62

44 0.56969976425170
9

0.62786942720413
21

45 0.51646989583969
12

0.57864898443222
05

46 0.62215346097946
17

0.60114127397537
23

0.25

0.42

0.58

0.75

0 250 500 750 1000

• no scaling
• with scaling

5 layers

20 layers

�2

Figure 2: Training curves of SRU on classification.
The x-axis is the number of training steps and the
y-axis is the training loss. Scaling correction im-
proves the training progress, especially for deeper
models with many stacked layers.

4 Experiments

We evaluate SRU on several natural language pro-
cessing tasks and perform additional analyses of
the model. The set of tasks includes text classifica-
tion, question answering, machine translation, and
character-level language modeling. Training time
on these benchmarks ranges from minutes (classi-
fication) to days (translation), providing a variety
of computation challenges.

The main question we study is the performance-
speed trade-off SRU provides in comparison to



4474

Model Size CR SUBJ MR TREC MPQA SST Time

Best reported results:
Wang and Manning (2013) 82.1 93.6 79.1 - 86.3 - -
Kalchbrenner et al. (2014) - - - 93.0 - 86.8 -
Kim (2014) 85.0 93.4 81.5 93.6 89.6 88.1 -
Zhang and Wallace (2017) 84.7 93.7 81.7 91.6 89.6 85.5 -
Zhao et al. (2015) 86.3 95.5 83.1 92.4 93.3 - -

Our setup (default Adam, fixed word embeddings):
CNN 360k 83.1±1.6 92.7±0.9 78.9±1.3 93.2±0.8 89.2±0.8 85.1±0.6 417
LSTM 352k 82.7±1.9 92.6±0.8 79.8±1.3 93.4±0.9 89.4±0.7 88.1±0.8 2409
QRNN (k=1) 165k 83.5±1.9 93.4±0.6 82.0±1.0 92.5±0.5 90.2±0.7 88.2±0.4 345
QRNN (k=1) + highway 204k 84.0±1.9 93.4±0.8 82.1±1.2 93.2±0.6 89.6±1.2 88.9±0.2 371
SRU (2 layers) 204k 84.9±1.6 93.5±0.6 82.3±1.2 94.0±0.5 90.1±0.7 89.2±0.3 320
SRU (4 layers) 303k 85.9±1.5 93.8±0.6 82.9±1.0 94.8±0.5 90.1±0.6 89.6±0.5 510
SRU (8 layers) 502k 86.4±1.7 93.7±0.6 83.1±1.0 94.7±0.5 90.2±0.8 88.9±0.6 879

Table 1: Test accuracies on classification benchmarks (Section 4.1). The first block presents best reported
results of various methods. The second block compares SRU and other baselines given the same setup.
For the SST dataset, we report average results of 5 runs. For other datasets, we perform 3 independent
trials of 10-fold cross validation (3⇥10 runs). The last column compares the wall clock time (in seconds)
to finish 100 epochs on the SST dataset.

other architectures. We stack multiple layers of
SRU to directly substitute other recurrent, convo-
lutional or feed-forward modules. We minimize
hyper-parameter tuning and architecture engineer-
ing for a fair comparison. Such efforts have a non-
trivial impact on the results, which are beyond the
scope of our experiments. Unless noted otherwise,
the hyperparameters are set identical to prior work.

4.1 Text Classification
Dataset We use six sentence classification
benchmarks: movie review sentiment (MR; Pang
and Lee, 2005), sentence subjectivity (SUBJ;
Pang and Lee, 2004), customer reviews polar-
ity (CR; Hu and Liu, 2004), question type (TREC;
Li and Roth, 2002), opinion polarity (MPQA;
Wiebe et al., 2005), and the Stanford sentiment
treebank (SST; Socher et al., 2013).2

Following Kim (2014), we use word2vec em-
beddings trained on 100 billion Google News to-
kens. For simplicity, all word vectors are normal-
ized to unit vectors and are fixed during training.

Setup We stack multiple SRU layers and use
the last output state to predict the class label for
a given sentence. We train for 100 epochs and
use the validation (i.e., development) set to se-
lect the best training epoch. We perform 10-fold

2We use the binary version of SST dataset.

cross validation for datasets that do not have a
standard train-evaluation split. The result on SST
is averaged over five independent trials. We use
Adam (Kingma and Ba, 2014) with the default
learning rate 0.001, a weight decay 0 and a hid-
den dimension of 128.

We compare SRU with a wide range of meth-
ods on these datasets, including various convo-
lutional models (Kalchbrenner et al., 2014; Kim,
2014; Zhang and Wallace, 2017) and a hierarchical
sentence model (Zhao et al., 2015) reported as the
state of the art on these datasets (Conneau et al.,
2017). Their setups are not exactly the same as
ours, and may involve more tuning on word em-
beddings and other regularizations. We use the
setup of Kim (2014) but do not fine-tune word
embeddings and the learning method for simplic-
ity. In addition, we directly compare against
three baselines trained using our code base: a re-
implementation of the CNN model of Kim (2014),
a two-layer LSTM model and Quasi-RNN (Brad-
bury et al., 2017). We use the official implemen-
tation of Quasi-RNN and also implement a ver-
sion with highway connection for a fair compar-
ison. These baselines are trained using the same
hyper-parameter configuration as SRU.

Results Table 1 compares the test results on the
six benchmarks. We select the best number re-



4475

Figure 3: Mean validation accuracies (y-axis) and standard deviations of the CNN, 2-layer LSTM and
2-layer SRU models. We plot the curves of the first 100 epochs. X-axis is the training time used (in
seconds). Timings are performed on NVIDIA GeForce GTX 1070 GPU, Intel Core i7-7700K Processor
and cuDNN 7003.

ported in previous methods when multiple model
variants were explored in their experiments. De-
spite our simple setup, SRU outperforms most pre-
vious methods and achieves comparable results
compared to the state-of-the-art but more sophisti-
cated model of Zhao et al. (2015). Figure 3 shows
validation performance relative to training time for
SRU, cuDNN LSTM and the CNN model. Our
SRU implementation runs 5–9 times faster than
cuDNN LSTM, and 6–40% faster than the CNN
model of Kim (2014). On the movie review (MR)
dataset for instance, SRU completes 100 training
epochs within 40 seconds, while LSTM takes over
320 seconds.

4.2 Question Answering

Dataset We use the Stanford Question Answer-
ing Dataset (SQuAD; Rajpurkar et al., 2016).
SQuAD is a large machine comprehension dataset
that includes over 100K question-answer pairs ex-
tracted from Wikipedia articles. We use the stan-
dard train and development sets.

Setup We use the Document Reader model of
Chen et al. (2017) as our base architecture for
this task. The model is a combination of word-
level bidirectional RNNs and attentions, providing
a good testbed to compare our bidirectional SRU

implementation with other RNN components.3

We use the open source implementation of Doc-
ument Reader in our experiments.4 We train mod-
els for up to 100 epochs, with a batch size of
32 and a hidden dimension of 128. Following
the author suggestions, we use the Adamax op-
timizer (Kingma and Ba, 2014) and variational
dropout (Gal and Ghahramani, 2016) during train-
ing. We compare with two alternative recurrent
components: the bidirectional LSTM adopted in
the original implementation of Chen et al. (2017)
and Quasi-RNN with highway connections for im-
proved performance.

Results Table 2 summarizes the results on
SQuAD. SRU achieves 71.4% exact match and
80.2% F1 score, outperforming the bidirectional
LSTM model by 1.9% (EM) and 1.4% (F1) re-
spectively. SRU also exhibits over 5x speed-up
over LSTM and 53–63% reduction in total train-
ing time. In comparison with QRNN, SRU ob-
tains 0.8% improvement on exact match and 0.6%
on F1 score, and runs 60% faster. This speed im-
provement highlights the impact of the fused ker-

3The current state-of-the-art models (Seo et al., 2016;
Wang et al., 2017) make use of additional components such
as character-level embeddings, which are not directly com-
parable to the setup of Chen et al. (2017). However, these
models can potentially benefit from SRU since RNNs are in-
corporated in the model architecture.

4
https://github.com/hitvoice/DrQA

https://github.com/hitvoice/DrQA


4476

Model # layers Size Dev Dev Time per epochEM F1 RNN Total

LSTM 3 4.1m 69.5 78.8 316s 431s(Chen et al., 2017)

QRNN (k=1) + highway 4 2.4m 70.1± 0.1 79.4± 0.1 113s 214s6 3.2m 70.6± 0.1 79.6± 0.2 161s 262s

SRU 3 2.0m 70.2± 0.3 79.3± 0.1 58s 159s
SRU 4 2.4m 70.7± 0.1 79.7± 0.1 72s 173s
SRU 6 3.2m 71.4± 0.1 80.2± 0.1 100s 201s

Table 2: Exact match (EM) and F1 scores of various models on SQuAD (Section 4.2). We also report
the total processing time per epoch and the time spent in RNN computations. SRU outperforms other
models, and is more than five times faster than cuDNN LSTM.

nel (Algorithm 1). While the QRNN baseline in-
volves a similar amount of computation, assem-
bling all element-wise operations of both direc-
tions in SRU achieves better GPU utilization.

4.3 Machine Translation
Dataset We train translation models on the
WMT English!German dataset, a standard
benchmark for translation systems (Peitz et al.,
2014; Li et al., 2014; Jean et al., 2015). The
dataset consists of 4.5 million sentence pairs. We
obtain the pre-tokenized dataset from the Open-
NMT project (Klein et al., 2017). The sentences
were tokenized using the word-piece model (Wu
et al., 2016b), which generates a shared vocabu-
lary of about 32,000 tokens. Newstest-2014 and
newstest-2017 are provided and used as the vali-
dation and test sets.5

Setup We use the state-of-the-art Transformer
model of Vaswani et al. (2017) as our base archi-
tecture. In the base model, a single Transformer
consists of a multi-head attention layer and a bot-
tleneck feed-forward layer. We substitute the feed-
forward network using our SRU implementation:

base: W · ReLU_layer(x) + b
ours: W · SRU_layer(x) + b .

The intuition is that SRU can better capture se-
quential information as a recurrent network, and
potentially achieve better performance while re-
quiring fewer layers.

We keep the model configuration the same as
Vaswani et al. (2017): the model dimension is

5
https://github.com/OpenNMT/

OpenNMT-tf/tree/master/scripts/wmt

dmodel = 512, the feed-forward and SRU layer has
inner dimensionality dff = dsru = 2048, and posi-
tional encoding (Gehring et al., 2017) is applied on
the input word embeddings. The base model with-
out SRU has 6 layers, while we set the number of
layers to 4 and 5 when SRU is added. Following
the original setup, we use a dropout probability 0.1
for all components, except the SRU in the 5-layer
model, for which we use a dropout of 0.2 as we
observe stronger over-fitting in training.

We use a single NVIDIA Tesla V100 GPU for
each model. The published results were obtained
using 8 GPUs in parallel, which provide a large ef-
fective batch size during training. To approximate
the setup, we update the model parameters ev-
ery 5⇥5120 tokens and use 16,000 warm-up steps
following OpenNMT suggestions. We train each
model for 40 epochs (250,000 steps), and perform
3 independent trials for each model configuration.
A single run takes about 3.5 days with a Tesla
V100 GPU.

Results Table 3 shows the translation results.
When SRU is incorporated into the architecture,
both the 4-layer and 5-layer model outperform the
Transformer base model. For instance, our 5-
layer model obtains an average improvement of
0.7 test BLEU score and an improvement of 0.5
BLEU score by comparing the best results of each
model achieved across three runs. SRU also ex-
hibits more stable performance, with smaller vari-
ance over 3 runs. Figure 4 further compares the
validation accuracy of different models. These re-
sults confirm that SRU is better at sequence mod-
eling compared to the original feed-forward net-
work (FFN), requiring fewer layers to achieve sim-

https://github.com/OpenNMT/OpenNMT-tf/tree/master/scripts/wmt
https://github.com/OpenNMT/OpenNMT-tf/tree/master/scripts/wmt


4477

Model # layers Size BLEU score Speed HoursValid Test (toks/sec) per epoch

Transformer (base) 6 76m 26.6±0.2 (26.9) 27.6±0.2 (27.9) 20k 2.0
Transformer (+SRU) 4 79m 26.7±0.1 (26.8) 27.8±0.1 (28.3) 22k 1.8
Transformer (+SRU) 5 90m 27.1±0.0 (27.2) 28.3±0.1 (28.4) 19k 2.1

Table 3: English!German translation results (Section 4.3). We perform 3 independent runs for each
configuration. We select the best epoch based on the valid BLEU score for each run, and report the
average results and the standard deviation over 3 runs. In addition, we experiment with averaging model
checkpoints and use the averaged version for evaluation, following (Vaswani et al., 2017). We show the
best BLEU results achieved in brackets.

3.8

3.9

4.1

4.2

4.3

4.0 4.3 4.5 4.8 5.0

Table 1

Base model (6) w/ SRU (5, 0.2) w/ SRU (4, 0.1) w/ SRU (5, 0.1, 
1536)

8.8449 6.9806

6.8904 5.7221

6.0114 5.1309

5.5672 4.8197

5.3095 4.6361

5.1364 4.5104

5.0100 4.4275

4.9129 4.3571

4.8346 4.2995

4.7704 4.2550

4.7163 4.2146

4.6698 4.1893

4.6295 4.1635

4.5939 4.1360

4.5623 4.1260

4.5339 4.1007

4.5084 4.0810

4.4852 4.0714

4.4638 4.0579

4.4443 4.0455

4.4261 4.0365

4.4094 4.0272

4.3939 4.0191

4.3791 4.0091

4.3656 4.0035

4.3527 3.9950

4.3406 3.9850

4.3293 3.9784

4.3188 3.9771

4.3085 3.9825

4.2989 3.9752

4.2896 3.9656

4.2809 3.9641

4.2726 3.9540

4.2645 3.9517

4.2568 3.9482

4.2495 3.9456

4.2423 3.9421

4.2357 3.9353

8.0749 6.4272

6.4581 5.4060

5.6984 4.8829

5.2985 4.6175

5.0637 4.4721

4.9053 4.3722

4.7891 4.2944

4.6997 4.2504

4.6281 4.2073

4.5686 4.1802

4.5186 4.1461

4.4760 4.1203

4.4386 4.0945

4.4060 4.0821

4.3768 4.0678

4.3508 4.0517

4.3272 4.0476

4.3056 4.0331

4.2861 4.0280

4.2681 4.0205

4.2512 4.0098

4.2359 4.0094

4.2216 4.0000

4.2080 3.9928

4.1957 3.9873

4.1839 3.9876

67%

68%

70%

71%

72%

1 10 20 30 40

Base model (6)
w/ SRU (4, 0.1)
w/ SRU (5, 0.2)

Train PPL

Va
lid

Train-valid perplexity Valid accuracy

Epoch

67%

68%

70%

71%

72%

1 10 20 30 40

Base model
w/ SRU (4 layer)
w/ SRU (5 layer)

Valid accuracy

Epoch

3.8

3.9

4.1

4.2

4.3

4.0 4.3 4.5 4.8 5.0

Base model
w/ SRU (5 layer)
w/ SRU (4 layer)

Train-valid perplexity

Va
lid

Train PPL

�1

Figure 4: Mean validation accuracy (y-axis) of dif-
ferent translation models after each training epoch
(x-axis).

ilar accuracy. Finally, adding SRU does not affect
the parallelization or speed of Transformer – the
4-layer model exhibits 10% speed improvement,
while the 5-layer model is only 5% slower com-
pared to the base model. We present more results
and discussion in Appendix B.3.

4.4 Character-level Language Modeling

Dataset We use Enwik8, a large dataset for
character-level language modeling. Following
standard practice, we use the first 90M characters
for training and the remaining 10M split evenly for
validation and test.

Setup Similar to previous work, we use a batch
size of 128 and an unroll size of 100 for trun-
cated backpropagation during training. We also
experiment with an unroll size of 256 and a batch
size of 64 such that each training instance has
longer context. We use a non-zero highway bias
br = �3 that is shown useful for training lan-
guage model (Zilly et al., 2017). Previous meth-
ods employ different optimizers and learning rate
schedulers for training. For simplicity and consis-
tency, we use the Adam optimizer and the same

learning rate scheduling (i.e., Noam scheduling)
as the translation experiments. We train a maxi-
mum of 100 epochs (about 700,000 steps).

We compare various recurrent models and use
a parameter budget similar to previous methods.
In addition, we experiment with the factorization
trick (Kuchaiev and Ginsburg, 2017) to reduce the
total number of parameters without decreasing the
performance. See details in Appendix B.

Results Table 4 presents the results of SRU
and other recurrent models. The 8-layer SRU
model achieves validation and test bits per char-
acter (BPC) of 1.21, outperforming previous best
reported results of LSTM, QRNN and recurrent
highway networks (RHN). Increasing the layer of
SRU to 12 and using a longer context of 256 char-
acters in training further improves the BPC to 1.19

4.5 Ablation Analysis

We perform ablation analyses on SRU by succes-
sively disabling different components:

(1) Remove the point-wise multiplication term
v � ct�1 in the forget and reset gates. The
resulting variant involves less recurrence and
has less representational capacity.

(2) Disable the scaling correction by setting the
constant ↵ = 1.

(3) Remove the skip connections.

We train model variants on the classification and
question answering datasets. Table 5 and Figure 5
confirm the impact of our design decisions – re-
moving these components result in worse classifi-
cation accuracies and exact match scores.



4478

Model Size # layers Unroll size Valid Test Time

MI-LSTM (Wu et al., 2016c) 17m 1 100 - 1.44 -
HM-LSTM (Chung et al., 2016) 35m 3 100 - 1.32 -
LSTM (Melis et al., 2017) 46m 4 50 1.28 1.30 -
RHN (Zilly et al., 2017) 46m 10 50 - 1.27 -
FS-LSTM (Mujika et al., 2017) 47m 4 100 - 1.25 -
QRNN (Merity et al., 2018) 26m 4 200 - 1.33 -
LSTM (Merity et al., 2018) 47m 3 200 - 1.23 -

SRU 37m 6 100 1.29 1.30 28min
SRU 37m 10 100 1.26 1.27 29min
SRU (with projection) 37m 6 100 1.25 1.26 29min
SRU (with projection) 47m 8 100 1.21 1.21 39min
SRU (with projection) 49m 12 256 1.19 1.19 41min

Table 4: Validation and test BPCs of different recurrent models on Enwik8 dataset. The last column
presents the training time per epoch. For SRU with projection, we set the projection dimension to 512.

Model 4 layers 6 layers

SRU (full) 70.7 71.4
� remove v � ct�1 70.6 71.1
� remove ↵-scaling 70.3 71.0
� remove highway 69.4 69.1

Table 5: Ablation analysis on SQuAD. Compo-
nents are successively removed and the EM scores
are averaged over 4 runs.

Table 1

CR CR SUBJ SUBJ MR MR Trec Trec MPQA MPQA

Full (v2) 85.284 84.874 95.389 93.533 83.257 82.301 92.823 94.033 90.14659 90.05592667
- scaling , - c[t-1] 86.78 84.106 94.763 93.473 82.240 82.061 92.284 93.807 91.501 89.732

- highway 85.863 84.115 94.756 93.497 82.771 82.314 91.165 93.093 91.354 90.087

- c[t-1] 0.8490.8360.9530.9350.8310.8180.9220.939
84.9 83.6 95.3 93.5 83.1 81.8 92.2 93.9

CR CR SUBJ SUBJ MR MR Trec Trec

Full (v2) 85.3 84.9 95.4 93.5 83.3 82.3 92.8 94.0
- c[t-1] 84.9 83.6 95.3 93.5 83.1 81.8 92.2 93.9
- scaling 86.8 84.1 94.8 93.5 82.2 82.1 92.3 93.8
- highway 85.9 84.1 94.8 93.5 82.8 82.3 91.2 93.1

CR SUBJ MR Trec

Full (v2) 85.3 95.4 83.3 92.8
- c[t-1] 84.9 95.3 83.1 92.2
- scaling 86.8 94.8 82.2 92.3
- highway 85.9 94.8 82.8 91.2

CR CR SUBJ SUBJ MR MR Trec Trec

CR CR SUBJ SUBJ MR MR Trec Trec

CR CR SUBJ SUBJ MR MR Trec Trec

CR SUBJ MR Trec

91.2

82.8

94.8

85.9

92.2

83.1

95.3

84.9

92.8

83.3

95.4

85.3

�1

Figure 5: Ablation analysis on the classification
datasets. Average validation results are presented.
We compare the full SRU implementation (left
blue), the variant without v � ct�1 multiplication
(middle green) and the variant without highway
connection (right yellow).

5 Discussion

This work presents Simple Recurrent Unit (SRU),
a scalable recurrent architecture that operates as
fast as feed-forward and convolutional units. We
confirm the effectiveness of SRU on multiple nat-
ural language tasks ranging from classification to

translation. We open source our implementation to
facilitate future NLP and deep learning research.

Trading capacity with layers SRU achieves
high parallelization by simplifying the hidden-to-
hidden dependency. This simplification is likely to
reduce the representational power of a single layer
and hence should be balanced to avoid perfor-
mance loss. However, unlike previous work that
suggests additional computation (e.g., n-gram fil-
ters) within the layer (Balduzzi and Ghifary, 2016;
Bradbury et al., 2017), we argue that increasing
the depth of the model suffices to retain modeling
capacity. Our empirical results on various tasks
confirm this hypothesis.

Acknowledgement

We thank Alexander Rush and Yoon Kim for
help with machine translation experiments, and
Danqi Chen for help with SQuAD experiments.
We thank Adam Yala, Howard Chen, Jeremy
Wohlwend, Lili Yu, Kyle Swanson and Kevin
Yang for providing useful feedback on the paper
and the SRU implementation. A special thanks to
Hugh Perkins for his support on the experimental
environment setup and Runqi Yang for answering
questions about his code.

References

Fabio Anselmi, Lorenzo Rosasco, Cheston Tan, and
Tomaso A. Poggio. 2015. Deep convolutional net-
works are hierarchical kernel machines. CoRR,
abs/1508.01084.



4479

Jeremy Appleyard, Tomás Kociský, and Phil Blunsom.
2016. Optimizing performance of recurrent neural
networks on gpus. CoRR, abs/1604.01946.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proceedings of
the International Conference on Learning Represen-

tations.

David Balduzzi and Muhammad Ghifary. 2016.
Strongly-typed recurrent neural networks. In Inter-
national Conference on Machine Learning.

James Bradbury, Stephen Merity, Caiming Xiong, and
Richard Socher. 2017. Quasi-recurrent neural net-
works. In Proceedings of the International Confer-
ence on Learning Representations.

Danqi Chen, Adam Fisch, Jason Weston, and Antoine
Bordes. 2017. Reading wikipedia to answer open-
domain questions. In Proceedings of the Annual
Meeting of the Association for Computational Lin-

guistics.

Yining Chen, Sorcha Gilroy, Kevin Knight, and
Jonathan May. 2018. Recurrent neural networks as
weighted language recognizers. In Proceedings of
the Conference of the North American Chapter of

the Association for Computational Linguistics: Hu-

man Language Technologies.

Kyunghyun Cho, Bart van Merrienboer, ÃĞaglar
GülÃğehre, Dzmitry Bahdanau, Fethi Bougares,
Holger Schwenk, and Yoshua Bengio. 2014. Learn-
ing phrase representations using rnn encoder–
decoder for statistical machine translation. In Pro-
ceedings of the Conference on Empirical Methods in

Natural Language Processing.

Junyoung Chung, Sungjin Ahn, and Yoshua Bengio.
2016. Hierarchical multiscale recurrent neural net-
works. CoRR, abs/1609.01704.

Alexis Conneau, Douwe Kiela, Holger Schwenk, Loïc
Barrault, and Antoine Bordes. 2017. Supervised
learning of universal sentence representations from
natural language inference data. In Proceedings of
the Conference on Empirical Methods in Natural

Language Processing.

Amit Daniely, Roy Frostig, and Yoram Singer. 2016.
Toward deeper understanding of neural networks:
The power of initialization and a dual view on ex-
pressivity. In Advances In Neural Information Pro-
cessing Systems.

Greg Diamos, Shubho Sengupta, Bryan Catanzaro,
Mike Chrzanowski, Adam Coates, Erich Elsen,
Jesse Engel, Awni Hannun, and Sanjeev Satheesh.
2016. Persistent rnns: Stashing recurrent weights
on-chip. In International Conference on Machine
Learning.

Yarin Gal and Zoubin Ghahramani. 2016. A theoret-
ically grounded application of dropout in recurrent
neural networks. In Advances in Neural Information
Processing Systems.

Jonas Gehring, Michael Auli, David Grangier, Denis
Yarats, and Yann Dauphin. 2017. Convolutional se-
quence to sequence learning. In International Con-
ference on Machine Learning.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difficulty of training deep feedforward neural
networks. In Proceedings of the international con-
ference on artificial intelligence and statistics.

Priya Goyal, Piotr Dollár, Ross B. Girshick, Pieter No-
ordhuis, Lukasz Wesolowski, Aapo Kyrola, Andrew
Tulloch, Yangqing Jia, and Kaiming He. 2017. Ac-
curate, large minibatch SGD: Training imagenet in
1 hour. CoRR, abs/1706.02677.

Klaus Greff, Rupesh Kumar Srivastava, Jan
Koutnx00EDk, Bas R. Steunebrink, and
Jx00FCrgen Schmidhuber. 2017. Lstm: A
search space odyssey. IEEE Transactions on Neural
Networks and Learning Systems, 28.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. 2015. Delving deep into rectifiers: Surpass-
ing human-level performance on imagenet classifi-
cation. In Proceedings of the IEEE international
conference on computer vision.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. 2016. Deep residual learning for image recog-
nition. In Proceedings of the IEEE conference on
computer vision and pattern recognition.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and what’s next. In Proceedings of the An-
nual Meeting of the Association for Computational

Linguistics.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural computation, 9.

Minqing Hu and Bing Liu. 2004. Mining and summa-
rizing customer reviews. In Proceedings of the tenth
ACM SIGKDD international conference on Knowl-

edge discovery and data mining.

Ozan Irsoy and Claire Cardie. 2014. Opinion mining
with deep recurrent neural networks. In Proceedings
of the Conference on Empirical Methods in Natural

Language Processing.

Sébastien Jean, Kyunghyun Cho, Roland Memisevic,
and Yoshua Bengio. 2015. On using very large tar-
get vocabulary for neural machine translation. In
Proceedings of the Annual Meeting of the Associa-

tion for Computational Linguistics and the Interna-

tional Joint Conference on Natural Language Pro-

cessing.



4480

Nal Kalchbrenner, Edward Grefenstette, and Phil Blun-
som. 2014. A convolutional neural network for
modelling sentences. In Proceedings of the Annual
Meeting of the Association for Computational Lin-

guistics.

Yoon Kim. 2014. Convolutional neural networks for
sentence classification. In Proceedings of the Em-
pirical Methods in Natural Language Processing.

Yoon Kim, Yacine Jernite, David A Sontag, and
Alexander M. Rush. 2016. Character-aware neural
language models. In Proceedings of the AAAI Con-
ference on Artificial Intelligence.

Diederik Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. In Proceedings
of the International Conference on Learning Repre-

sentations.

Guillaume Klein, Yoon Kim, Yuntian Deng, Jean
Senellart, and Alexander Rush. 2017. Opennmt:
Open-source toolkit for neural machine translation.
In Proceedings of ACL 2017, System Demonstra-
tions.

Oleksii Kuchaiev and Boris Ginsburg. 2017. Fac-
torization tricks for lstm networks. CoRR,
abs/1703.10722.

Quoc V. Le, Navdeep Jaitly, and Geoffrey E. Hinton.
2015. A simple way to initialize recurrent networks
of rectified linear units. CoRR, abs/1504.00941.

Kenton Lee, Omer Levy, and Luke S. Zettlemoyer.
2017. Recurrent additive networks. CoRR,
abs/1705.07393.

Tao Lei, Regina Barzilay, and Tommi Jaakkola. 2015.
Molding cnns for text: non-linear, non-consecutive
convolutions. In Proceedings of the Conference on
Empirical Methods in Natural Language Process-

ing. Association for Computational Linguistics.

Tao Lei, Wengong Jin, Regina Barzilay, and Tommi
Jaakkola. 2017. Deriving neural architectures from
sequence and graph kernels. International Confer-
ence on Machine Learning.

Liangyou Li, Xiaofeng Wu, Santiago Cortes Vaillo, Jun
Xie, Andy Way, and Qun Liu. 2014. The DCU-
ICTCAS MT system at WMT 2014 on german-
english translation task. In Proceedings of the Ninth
Workshop on Statistical Machine Translation.

Xin Li and Dan Roth. 2002. Learning question classi-
fiers. In Proceedings of the international conference
on Computational linguistics-Volume 1. Association
for Computational Linguistics.

Minh-Thang Luong, Hieu Pham, and Christopher D.
Manning. 2015. Effective approaches to attention-
based neural machine translation. In Empirical
Methods in Natural Language Processing. Associ-
ation for Computational Linguistics.

Hongyuan Mei, Mohit Bansal, and R. Matthew Walter.
2016. What to talk about and how? selective gener-
ation using lstms with coarse-to-fine alignment. In
Proceedings of the Conference of the North Amer-

ican Chapter of the Association for Computational

Linguistics: Human Language Technologies.

Gábor Melis, Chris Dyer, and Phil Blunsom. 2017. On
the state of the art of evaluation in neural language
models. CoRR, abs/1707.05589.

Stephen Merity, Nitish Shirish Keskar, and Richard
Socher. 2018. An analysis of neural language mod-
eling at multiple scales. CoRR, abs/1803.08240.

Yajie Miao, Jinyu Li, Yongqiang Wang, Shi-Xiong
Zhang, and Yifan Gong. 2016. Simplifying long
short-term memory acoustic models for fast training
and decoding. In IEEE International Conference on
Acoustics, Speech and Signal Processing.

Dipendra Misra, John Langford, and Yoav Artzi. 2017.
Mapping instructions and visual observations to ac-
tions with reinforcement learning. In Proceedings
of the Conference on Empirical Methods in Natural

Language Processing.

Asier Mujika, Florian Meier, and Angelika Steger.
2017. Fast-slow recurrent neural networks. In Ad-
vances in Neural Information Processing Systems.

Bo Pang and Lillian Lee. 2004. A sentimental edu-
cation: Sentiment analysis using subjectivity sum-
marization based on minimum cuts. In Proceedings
of the annual meeting on Association for Computa-

tional Linguistics.

Bo Pang and Lillian Lee. 2005. Seeing stars: Ex-
ploiting class relationships for sentiment categoriza-
tion with respect to rating scales. In Proceedings of
the annual meeting on association for computational

linguistics.

Stephan Peitz, Joern Wuebker, Markus Freitag, and
Hermann Ney. 2014. The RWTH aachen german-
english machine translation system for wmt 2014.
In Proceedings of the Ninth Workshop on Statistical
Machine Translation.

Hao Peng, Roy Schwartz, Sam Thomson, and Noah A.
Smith. 2018. Rational recurrences. In Empirical
Methods in Natural Language Processing.

P. Rajpurkar, J. Zhang, K. Lopyrev, and P. Liang. 2016.
Squad: 100,000+ questions for machine comprehen-
sion of text. In Empirical Methods in Natural Lan-
guage Processing.

Min Joon Seo, Aniruddha Kembhavi, Ali Farhadi,
and Hannaneh Hajishirzi. 2016. Bidirectional at-
tention flow for machine comprehension. CoRR,
abs/1611.01603.

Noam Shazeer, Azalia Mirhoseini, Krzysztof Maziarz,
Andy Davis, Quoc Le, Geoffrey Hinton, and Jeff
Dean. 2017. Outrageously large neural networks:



4481

The sparsely-gated mixture-of-experts layer. arXiv
preprint arXiv:1701.06538.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Y. Ng,
and Christopher Potts. 2013. Recursive deep mod-
els for semantic compositionality over a sentiment
treebank. In Proceedings of the Conference on Em-
pirical Methods in Natural Language Processing.

Rupesh K Srivastava, Klaus Greff, and Jürgen Schmid-
huber. 2015. Training very deep networks. In Ad-
vances in neural information processing systems.

Alane Suhr and Yoav Artzi. 2018. Situated mapping
of sequential instructions to actions with single-step
reward observation. In Proceedings of the Annual
Meeting of the Association for Computational Lin-

guistics.

Alane Suhr, Srinivasan Iyer, and Yoav Artzi. 2018.
Learning to map context-dependent sentences to ex-
ecutable formal queries. In Proceedings of the Con-
ference of the North American Chapter of the Asso-

ciation for Computational Linguistics: Human Lan-

guage Technologies.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In Advances in Neural Information Pro-
cessing Systems.

Sida Wang and Christopher Manning. 2013. Fast
dropout training. In International Conference on
Machine Learning.

Wenhui Wang, Nan Yang, Furu Wei, Baobao Chang,
and Ming Zhou. 2017. Gated self-matching net-
works for reading comprehension and question an-
swering. In Proceedings of the Annual Meeting of
the Association for Computational Linguistics.

Janyce Wiebe, Theresa Wilson, and Claire Cardie.
2005. Annotating expressions of opinions and emo-
tions in language. Language resources and evalua-
tion.

Huijia Wu, Jiajun Zhang, and Chengqing Zong. 2016a.
An empirical exploration of skip connections for se-
quential tagging. In Proceedings of the Interna-
tional Conference on Computational Linguisticss.

Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V.
Le, Mohammad Norouzi, Wolfgang Macherey,
Maxim Krikun, Yuan Cao, Qin Gao, Klaus
Macherey, Jeff Klingner, Apurva Shah, Melvin
Johnson, Xiaobing Liu, ÅĄukasz Kaiser, Stephan
Gouws, Yoshikiyo Kato, Taku Kudo, Hideto
Kazawa, Keith Stevens, George Kurian, Nishant
Patil, Wei Wang, Cliff Young, Jason Smith, Ja-
son Riesa, Alex Rudnick, Oriol Vinyals, Greg Cor-
rado, Macduff Hughes, and Jeffrey Dean. 2016b.
Google’s neural machine translation system: Bridg-
ing the gap between human and machine translation.
CoRR, abs/1609.08144.

Yuhuai Wu, Saizheng Zhang, Ying Zhang, Yoshua
Bengio, and Ruslan R Salakhutdinov. 2016c. On
multiplicative integration with recurrent neural net-
works. In Advances in Neural Information Process-
ing Systems.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
2014. Recurrent neural network regularization.
CoRR, abs/1409.2329.

Yingjie Zhang and Byron C. Wallace. 2017. A sensi-
tivity analysis of (and practitioners’ guide to) convo-
lutional neural networks for sentence classification.
In Proceedings of the International Joint Conference
on Natural Language Processing.

Yuchen Zhang, Jason D. Lee, and Michael I. Jordan.
2016. `1-regularized neural networks are improp-
erly learnable in polynomial time. In International
Conference on Machine Learning.

Han Zhao, Zhengdong Lu, and Pascal Poupart. 2015.
Self-adaptive hierarchical sentence model. In Pro-
ceedings of the International Joint Conference on

Artificial Intelligence.

Julian Georg Zilly, Rupesh Kumar Srivastava, Jan
Koutník, and Jürgen Schmidhuber. 2017. Recurrent
highway networks. In International Conference on
Machine Learning.

Barret Zoph and Quoc V. Le. 2016. Neural archi-
tecture search with reinforcement learning. CoRR,
abs/1611.01578.


