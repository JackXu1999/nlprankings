



















































Distributional semantics for ontology verification


Proceedings of the Fourth Joint Conference on Lexical and Computational Semantics (*SEM 2015), pages 30–39,
Denver, Colorado, June 4–5, 2015.

Distributional semantics for ontology verification ∗

Julien Corman
IRIT, University of Toulouse
julien.corman@irit.fr

Nathalie Aussenac-Gilles
CNRS

IRIT, University of Toulouse
aussenac@irit.fr

Laure Vieu
CNRS

IRIT, University of Toulouse
vieu@irit.fr

Abstract

As they grow in size, OWL ontologies tend to
comprise intuitively incompatible statements,
even when they remain logically consistent.
This is true in particular of lightweight on-
tologies, especially the ones which aggregate
knowledge from different sources. The article
investigates how distributional semantics can
help detect and repair violation of common
sense in consistent ontologies, based on the
identification of consequences which are un-
likely to hold if the rest of the ontology does.
A score evaluating the plausibility for a con-
sequence to hold with regard to distributional
evidence is defined, as well as several methods
in order to decide which statements should be
preferably amended or discarded. A conclu-
sive evaluation is also provided, which con-
sists in extending an input ontology with ran-
domly generated statements, before trying to
discard them automatically.

1 Introduction

Ontology learning from texts deals with the auto-
mated extraction of knowledge from linguistic ev-
idence. This article investigates a slightly differ-
ent problem, which is how Natural Language Pro-
cessing may provide hints for the identification of
statements of an input ontology which are unlikely
to hold if the rest of it does. As a minimal exam-
ple, consider the following set ∆ of statements, from
DBpedia (Mendes et al., 2012), and assume that ∆ is

∗ The research reported here was supported by a Marie
Curie FP7 Career Integration Grant, Grant Agreement Number
PCIG13-GA-2013-618550.

a subset of a larger set of statements K (for instance
DBpedia itself, or some subset of it) :

Ex 1.
∆ = { (1) keyPerson(Caixa Bank, CEO),

(2) keyPerson(BrookField Office Properties,
Peter Munk)
(3) occupation(Peter Munk, CEO) }

There is a clear violation of common sense in ∆ :
the individual CEO must be both a key person of
Caixa Bank, and the occupation of another individ-
ual (Peter Munk), who is himself a key person of
some company. Detecting such cases within (larger)
sets of logical statements is of particular interest in
OWL, which facilitates the aggregation of knowl-
edge from multiple sources with overlapping signa-
tures, yielding datasets in which several incompati-
ble understandings of a same individual or predicate
may coexist. This easily leads to undesired infer-
ences, even when the dataset is logically consistent.1

But as the example illustrates, the problem may also
occur within a single knowledge base, especially if
it has been built semi-automatically, and/or is issued
from a collaborative effort.

Another problem of interest consists in deciding
which statement(s) should be preferably discarded
or amended in order to get rid of the nonsense. In
example 1, without further information, it would be
intuitively relevant to discard or modify either (1) or
(2). Unfortunately though, ∆ alone does not give
any indication of which of the two should be prefer-
ably discarded. But the whole input ontology K ⊃

1and coherent in the Description Logics sense, i.e. whose
signature contains unsatisfiable DL atomic concepts/OWL
named classes

30



∆ may. To keep the example simple, let us assume
that Peter Munk, CEO and occupation do not ap-
pear in K \∆. Then a reasonable assumption is that
the overall understanding of keyPerson within K
should be the decisive factor. If it generally ranges
over person functions (i.e. if in most instances of the
relation according to K, the second argument is a
person function), then it is to be understood as “has
as a key person someone whose function is”, and
(2) should be preferably discarded. Alternatively, if
keyPerson generally ranges over human beings,
then (1) should be preferably discarded.

The article investigates the use of linguistic evi-
dence to solve both of these problems : identifying
violations of common sense, and selecting the state-
ment(s) to be preferably amended or discarded. This
may be viewed as a small paradigm shift, in that
it questions an assumption commonly made in the
knowledge extraction literature, namely that manu-
ally crafted knowledge strictly prevails over the one
obtained from linguistic sources. By default, the
case of a consistent2 input ontology K will be stud-
ied, but section 6 discusses the application of the ap-
proach to an inconsistent K as well.

As a concrete contribution, section 5 evaluates
the adaptation of relatively simple techniques issued
from named entity classification/ontology popula-
tion, and based on distributional semantics. To il-
lustrate how this works, let us assume that the only
other appearance of keyPerson within K is the
following OWL statement :

(4) hasRange(keyPerson, Person)

i.e. in FOL :

(4) ∀xy(keyPerson(x, y)→ Person(y))
Then K |= ψ1 = Person(CEO), and K |=

ψ2 = Person(Peter Munk). Assume also that
there are other instances of Person according to
K, and that most of them are actually human be-
ings (like Peter Munk). Then ψ1 is an undesirable
consequence of K, whereas ψ2 on the other hand
reinforces it.

Distributional semantics characterizes a word (or
possibly a multi word unit) by some algebraic rep-
resentation of the linguistic contexts with which it is
observed. These representations have already been

2and coherent (see footnote 1)

used for ontology population, for instance by (Tanev
and Magnini, 2008), the main intuition being that
individuals denoted by linguistic terms with similar
contexts tend to instantiate the same classes. The
underlying linguistic phenomenon is known as se-
lectional preference, i.e. the fact that some contexts
tend to select or rule out certain categories of in-
dividuals : e.g. the context “X was born in” tends
to select a human being, whereas “X was launched”
tends to rule it out. Back to the example, one can
expect the similarity between the distributional rep-
resentation of the term “C.E.O” and other terms de-
noting instances of Person according to K to be
relatively low, hindering the plausibility of ψ1 with
regard to K. In other words, ψ1 should stand as an
outlier among consequences of K, and therefore is
probably undesirable. Conversely, the similarity be-
tween “Peter Munk” and terms denoting other in-
stances of Person should be relatively high. For
simplicity, suppose that (1), (2), (3) and (4) are the
only 4 statements of K which are candidate for re-
moval. Then in order to give up the belief in ψ1
while preserving ψ2, it is necessary to discard (1),
and retain (2) and (4). It is also sufficient to discard
(1), i.e. discarding (3) as well would result in an un-
necessary information loss. So in this case, the ev-
idence provided by distributional semantics should
suggest the removal of (1), or at least its modifica-
tion, which is also intuitively the correct solution.

Section 4 formalizes this approach, by defining a
score which estimates the plausibility of some con-
sequences a subbases Γ of K, given distributional
evidence. Section 5 then provides an original eval-
uation of this strategy, based on the prior exten-
sion of a small OWL ontology with randomly gener-
ated statements. The approach is evaluated for both
problems, i.e. the identification of undesired con-
sequences and statements. Performances of several
forms of distributional representations are also com-
pared. Section 6 discusses immediate applications,
in particular for (consistent and inconsistent) ontol-
ogy debugging. Finally, section 7 considers possi-
ble extensions of this framework, as well as their
limitations. Section 2 is a brief overview of related
works in the fields of ontology learning and debug-
ging, whereas section 3 introduces notational con-
ventions, and lists some preliminary requirements to
be met by the input K.

31



2 State of the art

Ontology learning from texts (Cimiano, 2006;
Buitelaar et al., 2005) aims to automatically build or
enriching a set of logical statements out of linguistic
evidence, and is closely related to the field of infor-
mation extraction. The work presented here borrows
from a subtask called ontology population (which it-
self borrows from named entity classification), but
only when the individuals and concepts of inter-
est are already known (Cimiano and Völker, 2005;
Tanev and Magnini, 2008; Giuliano and Gliozzo,
2008), which is not standard. A comparison may
also be drawn with the use of linguistic evidence by
(Suchanek et al., 2009) for information extraction in
the presence of conflicting data.

But the objective of the present work is different,
pertaining to ontology debugging, which covers a
wide range of techniques, from syntactic verifica-
tions (Poveda-Villalón et al., 2012) to anti-patterns
detection (Roussey and Zamazal, 2013), both based
on common modeling mistakes, or the submission
of models (Ferré and Rudolph, 2012; Benevides
et al., 2010) or consequences (Pammer, 2010) of
the input ontology to the user. As discussed in
section 6, the framework depicted here presents an
interesting complementarity with debugging tech-
niques developed in the Description Logics com-
munity, prototypically based on diagnosis (Friedrich
and Shchekotykhin, 2005; Kalyanpur et al., 2006;
Qi et al., 2008; Ribeiro and Wassermann, 2009), be-
cause they require the prior identification of some
undesired consequence of K (be it ⊥). But distribu-
tional evidence may also provide a principled way
of selecting most relevant diagnoses among a poten-
tially large number of candidates, as well as an al-
ternative to their exhaustive computation, which has
been shown costly by (Schlobach, 2005).

3 Conventions and presuppositions

The prototypical input is a set of statements in OWL
DL or OWL 2, although the approach may be gener-
alized to other representation languages. OWL DL
and OWL 2 are based on Description Logics (DL),
which are themselves decidable fragments of first-
order logic (FOL). The OWL notation is preferred
to the DL one for readability, and FOL translations
are given when not obvious.

An ontology is just understood here as a (finite)
set of logical statements. A class will designate a
named class in OWL, i.e. a FOL unary predicate,
like Person, whereas a named individual, or just
individual, designates a constant, like Peter Munk.

The input ontologyK must provide English terms
denoting some of its named individuals (e.g. the
term “Peter Munk”). These terms are prototypically
named entities, but may also occasionally be com-
mon nouns (or common noun phrases), as shown
in example 1 with “C.E.O”. There may be multiple
terms for a same individual. The approach cannot
handle polysemy though, in particular the fact that
some individuals of K may have homonyms (within
K or not), for instance that the term “JFK” can stand
for a politician, airport or movie. Ideally, no dis-
tributional representation should be built for indi-
viduals of K with potential homonyms. Some of
them may be identified with simple strategies, like
checking the existence of a Wikipedia disambigua-
tion page. On the opposite, labels for classes of
K (prototypically common nouns or common noun
phrases, which are arguably more ambiguous) are
never used during the process.

4 Proposition

Given a subbase Γ of the input ontology K (possi-
bly K itself), the ontology verification strategy pre-
sented in introduction relies on the evaluation of a
set ΨΓ of consequences of Γ. This section first de-
fines a score scΓ(ψ) for each ψ ∈ ΨΓ, which intu-
itively evaluates the plausibility of ψ wrt Γ, provided
some distributional representation for each named
individual appearing in ΨΓ. Then it discusses how
this score can be used to select statements of the in-
put ontology K which, according to distributional
evidence, should be preferably discarded, or at least
amended.

4.1 Plausibility of a consequence ψ ∈ ΨΓ
For the experiments described in section 5, ΨΓ is
the set of consequences of Γ of the form A(e) or
¬A(e), with e a constant (like CEO) and A a unary
predicate (like Person), and for which linguistic
occurrences of a term denoting e could be retrieved.
Possible extension of ΨΓ with other types of formu-
las is discussed in section 7.

32



Let ψ be a formula of ΨΓ, of the form
A(e), e.g. ψ = Person(CEO) or ψ =
Person(Peter Munk). Then instΓ(A) will des-
ignate all instances of A according to Γ for
which linguistic occurrences could be retrieved, i.e.
instΓ(A) = {e′ | A(e′) ∈ ΨΓ}, and instΓ(A) \ {e}
will be called the support set for A(e). Similarly,
instΓ(>) will designate all named individuals ap-
pearing in ΨΓ.

Let sim(e1, e2) be a measure of similarity be-
tween the distributional representations of individ-
uals e1 and e2 (prototypically the cosine similar-
ity between some vector representations of the lin-
guistic contexts of e1 and e2). Then for each e′ ∈
instΓ(A) \ {e}, if sim(e, e′) is lower than what
could be expected if e′ was a random individual of
instΓ(>) \ {e} (i.e. not necessarily an instance of
A), the hypothesis that A(e) is an outlier within ΨΓ
will be reinforced.

For instance, in example 1, let ψ =
Person(CEO) and Γ = K. Then the sup-
port set instΓ(A) \ {e} is composed of all other
instances of Person according to Γ. For each indi-
vidual e′ of this support set, if sim(CEO, e′) is lower
than what can be expected for a random individual
of K with linguistic occurrences (and different
from CEO), then the confidence in Person(CEO)
should decline. Conversely, if sim(e, e′) is higher
that expected, the hypothesis that ψ is in line with
ΨΓ will be reinforced.

Here is a cost-efficient and relatively simple
method to compute a plausibility score scΓ(A(e)).
Let S = instΓ(A)\{e} designate the support set for
Γ and e, and |S| the cardinality of S, i.e. the number
of other instances of A according to Γ. And let us
assume a set W of |S| randomly chosen elements
of instΓ(T ) \ {e}, i.e. of |S| individuals which are
different from e, but not necessarily instances of A.
Finally, let the random variable XΓe,|S| model the

expected value of
∑
e′∈W

sim(e,e′)
|S| , i.e. the mean of the

similarities between e and each individual of W .
In other words, if |S| individuals were randomly
chosen instead of those of the support set, XΓe,|S|
models what the average similarity between e and
these individuals can be expected to be. Then the
plausibility scΓ(A(e)) of A(e) can be defined by :

Definition 4.1. If S = instΓ(A) \ {e}, then
scΓ(A(e)) = p(XΓe,|S| ≤

∑
e′∈S

sim(e,e′)
|S| )

scΓ(A(e)) estimates of how surprisingly high the
similarity between e and the individuals of the sup-
port set S is, considering the overall similarity be-
tween e and the individuals of Γ.

For the evaluation described in section 5, the
random variable XΓe,|S| was assumed to follow a
beta distribution Beta(α, β), which intuitively al-
lows taking the size |S| of the support set into ac-
count. For instance, if S = {e′}, i.e. |S| = 1,
then ceteris paribus a high similarity between e
and e′ will be less informative than an equally high
average similarity between e and all elements of
a large S. Stated another way, the lower |S| is,
the more uniform the distribution of XΓe,|S| should
be. This can be obtained by setting XΓe,|S| ∼
Beta(m|S|+ 1, (1−m)|S|+ 1), where m is the
average similarity between e and all other individu-
als of the signature of Γ, i.e. m =

∑
e′∈Γ\{e}

sim(e,e′)
|Γ|−1 .

A possible interrogation here is the choice of
instΓ(A) \ {e} as the support set for A(e). For in-
stances, if ψ = Person(Peter Munk), a case could
be made for using instΓ(¬A) as well, i.e. for ex-
ploiting the (dis)similarity between Peter Munk and
individuals which, according to K, are instances of
¬Person.3 This is quite unrealistic though from
a linguistic point of view, which can be intuitively
seen in this example by replacing Peter Munk with
CEO. Assume for instance that Thelonious Monk
and Beijing are (reliable) instances of Person
and ¬Person respectively according to Γ. There
is no reason to expect that sim(CEO,Beijing) >
sim(CEO,Thelonious Monk). In other words, it is
implausible to assume that elements of instΓ(¬A)
should a priori share similar contexts.

Interestingly enough, and for the same reason,
the support set for a consequence of Γ of the
form ¬A(e) is not instΓ(¬A), but instΓ(A), which
yields :

Definition 4.2. If S = instΓ(A), then
scΓ(¬A(e)) = p(XΓe,|S| ≥

∑
e′∈S

sim(e,e′)
|S| )

3i.e. Γ |= ¬Person(e′) not only Γ 6|= Person(e′)

33



4.2 Linguistic compliance of Γ

This does not directly address the second problem
mentioned in introduction though. For practical on-
tology verification, it is also desirable to identify the
cause of this nonsense, i.e. statements (axioms in the
DL terminology) which are intuitively problematic.
For instance, in example 1, computing scΓ(ψ) for
each ψ ∈ ΨK may signal that the consequence ψ1
is unlikely to hold wrt the larger ontology K. And
discarding either (1) or (4) is sufficient to get rid of
the belief in ψ. But given the additional assump-
tions made about K, discarding the former is prefer-
able, in that discarding the latter would also result in
the loss of ψ2. In other words, some subbases of K
(likeK\(1) here) are more relevant than others (e.g.
K \ (4)), which can be simply captured as follows.
Let comp(Γ) be an estimation of the compliance of
a subbase Γ of K with the gathered linguistic evi-
dence. A straightforward option consists in setting
comp(Γ) to be the mean of the scores of evaluated
consequences for Γ, i.e. :

Definition 4.3. comp(Γ) =
∑

ψ∈ΨΓ
scΓ(ψ)
|ΨΓ|

Then a strict partial order ≺ over 2K can sim-
ply be defined by Γ1 ≺ Γ2 iff either comp(Γ1) <
comp(Γ2), or (comp(Γ1) = comp(Γ2) and Γ1 ⊂
Γ2),4 and a subbase Γ of K can be viewed as opti-
mal if it is maximal wrt ≺.5

In practice though, identifying optimal subbases
is a non trivial task. To see this, note that the func-
tion to be maximized is not directly a function of
the statements in Γ, but of ΨΓ, i.e. some of the
consequences of Γ. So even if one could identify
a subset Ψ′ of ΨK which maximizes this function,
there may not exist a subbase Γ of K such that
ΨΓ = Ψ′. Another difficulty comes from the fact
that for two subbases Γ1 and Γ2 of K, and a con-
sequence ψ ∈ ΨΓ1 ∩ ΨΓ2 , it doesn’t hold in gen-
eral that scΓ1(ψ) = scΓ2(ψ), because the support
set for ψ in Γ1 may differ from its support set in

4The assumption is made that a minimum of syntactic in-
formation should be lost whenever possible, i.e. Γ1 and Γ2
are primarily viewed as bases, not as theories. In particular,
if Cn(Γ1) = Cn(Γ2), but Γ1 6⊆ Γ2 and Γ2 6⊆ Γ1, then Γ1 and
Γ2 are not comparable wrt≺. Redundancies in this view should
also be preserved when possible, i.e. if Cn(Γ1) = Cn(Γ2) and
Γ1 ⊂ Γ2, then Γ1 ≺ Γ2 still holds.

5There may be several several optimal subbases.

Γ2. In particular, it may be the case that Γ1 ⊆ Γ2
but scΓ1(ψ) > scΓ2(ψ), which greatly reduces the
possible uses of monotonicity (if Γ1 ⊆ Γ2, then
Cn(Γ1) ⊆ Cn(Γ2)) to optimize the exploration of
2K . More generally, if the optimal subbases of K
are small (say twice smaller that K), it can be right-
fully argued that dropping so many statements for
the sake of linguistic evidence is not a viable debug-
ging strategy.

Therefore a more plausible application scenario
is one in which the search space has been previously
circumscribed, either by setting a maximal (small)
number of statements to discard, or by identifying a
set of potentially erroneous statements, through ax-
iom pinpointing, as explained in section 6. This is
also why the evaluation presented in section 5 fo-
cuses on the simplest possible case, i.e. the removal
from K of one statement only, whereas the integra-
tion of distributional evidence to more complex de-
bugging strategies is discussed in section 6.

As an alternative to the function comp, and in or-
der to avoid the fact that a same consequence may
have different plausibility scores wrt two subbases
of K, one may choose to discard unlikely conse-
quences based on their respective scores in K, i.e.
to use the score compK(Γ),6 defined by :

Definition 4.4. compK(Γ) =
∑

ψ∈ΨΓ
scK(ψ)
|ΨΓ|

This solution is arguably less satisfying, but more
amenable to optimizations. A trivial example is that
of a subbase Γ1 with max

ψ∈ΨΓ1
scK(ψ) < compK(Γ2)

for some already evaluated subbase Γ2, in which
case no subbase of Γ1 can be optimal wrt ≺.

Additionally, instead of taking the mean of the
scores of evaluated consequences of Γ, one may
want to penalize the subbases of K with the most
unlikely consequences, which gives a standard (to-
tal) lexicographic ordering �lex on 2K , defined as
follows. Let ωΓ = ω1Γ, .., ω

|ΨΓ|
Γ be the vector of

formulas of ΨΓ order by increasing score scΓ, and
let scΓ(ωΓ) = scΓ(ω1Γ), .., scΓ(ω

|ΨΓ|
Γ ). Then �lex

is defined by Γ1 �lex Γ2 iff either scΓ1(ωΓ1) =
scΓ2(ωΓ2), or (there is a 1 ≤ i ≤ |ΨΓ2 | such that
scΓ1(ω

j
Γ1

) = scΓ2(ω
j
Γ2

) for all 1 ≤ j < i, and either
scΓ1(ω

i
Γ1

) < scΓ2(ω
i
Γ2

) or |ΨΓ1 | = i − 1). Then
6or more generally compΓ′(Γ), for some Γ

′ ⊇ Γ

34



as previously, a strict partial order ≺ over 2K can
be defined by Γ1 ≺ Γ2 iff either Γ1 ≺lex Γ2, or
(Γ1 =lex Γ2 and Γ1 ⊂ Γ2).

Again, scK(ψ) may be used instead of scΓ(ψ),
yielding the lexical ordering �lexK . This last possi-
bility corresponds to a relatively intuitive operation,
which consists in giving up in priority the most im-
plausible consequences of K. All four possibilities
are evaluated in what follows.

5 Evaluation

The dataset used for this evaluation is a fragment
of the fisheries ontology from the NEON project.7

It has been automatically built out of 10 randomly
selected named individuals, applying a module ex-
traction procedure, followed by a trimming algo-
rithm. The fragment contains 1038 (logical) state-
ments, and involves 71 named individuals (mostly
geographical or administrative entities), the least ex-
pressive underlying DL being SI.

The linguistic input is a small corpus of approxi-
mately 6300 web pages, retrieved with a search en-
gine, using the labels of named individuals of F as
queries. The HTML documents were cleaned with
the BootCat library (Baroni and Bernardini, 2004).

The construction of the distributional representa-
tions of the named individuals of F was basic, the
use of more elaborate methods (SVD,. . . ) being left
for future work. The approach presented in this ar-
ticle remains generic enough to be applied to most
existing distributional frameworks, the only require-
ment being a real-valued similarity measure.

Two different forms of linguistic contexts were
alternatively tested. The first option considers as a
context any n-gram (2 ≤ n ≤ 5) without punc-
tuation mark which immediately precedes or fol-
lows a term t denoting an individual of F . The
other option is a more customized one, extracting se-
quences of lemmatized words (lemmaPOS in what
follows) surrounding t, in a shifting window of 3
to 5 tokens + the size of t, ignoring certain cat-
egories of word. Part-of-speech tagging was per-
formed thanks to the Stanford Parser (Toutanova
et al., 2003), with a pre-trained model for English.
If Cont designates the set of contexts observed with
at least 2 individuals, then an individual was rep-

7http://www.neon-project.org/nw/Ontologies

resented by the vector of its respective frequencies
with each context c ∈ Cont. Different possibilities
were compared to weight these frequencies. The
pointwise mutual information (PMI) was used in a
standard way for n-grams and lemmaPOS contexts
(with possible negative resulting frequencies set to
0). Following (Giuliano and Gliozzo, 2008), the
self-information self(c) was also used for n-grams,
defined by self(c) = − log p(c), the probability
p(c) being estimated thanks to the Microsoft Web
N-gram Services. A combined weighting by PMI
and self-information was also tested for n-grams.
These alternative settings are represented by capi-
tal letters in tables 1 and 2 : LP for lemmaPOS with
PMI, and NP, NS and NPS for n-grams with PMI,
self-information and both respectively.

The ontology F has been extended for the sake
of the evaluation, with statements randomly gener-
ated out of its signature. The underlying assumption
is that adding such statements to F is very likely
to generate violations of common sense (although
nothing prevents in theory the generation of plausi-
ble statements too). The goal for the evaluation was
then to automatically retrieve proper consequences
of each extension of F on the one hand, and the ran-
dom statements themselves on the other hand.

To prevent any misunderstanding, it should be
emphasized that this is not a realistic application
case. The input ontology was selected for its quality,
and degraded through random statement generation,
allowing an arguably artificial, but also very objec-
tive evaluation procedure (the only bias may come
from randomly generated statements which are ac-
tually plausible). By contrast, using a non modified
input dataset, and evaluating whether or not the ax-
ioms/consequences spotted by the algorithm are ac-
tually erroneous is a complex and subjective task,
with a possibly low inter-annotator agreement.

The generation procedure randomly selects a
statement φ ∈ F , and yields a statement φ′ with the
same syntactic structure as φ, but in which individ-
uals and predicates have been replaced by random
individuals and predicates appearing in F . For in-
stance, if φ = ∀xy(A(x) ∧ r(x, y)→ ¬B(y)), then
φ′ = ∀xy(C(x) ∧ s(x, y) → ¬D(y)), with C and
D (resp. s) randomly chosen among classes (resp.
binary predicates) of the signature of F .

100 randomly generated statements φ1, . . . , φ100

35



rank p-val
LP 4.15 / 216.1 <0.001
NP 9.73 / 216.1 <0.001
NS 7.33 / 216.1 <0.001
NPS 5.59 / 216.1 <0.001

Table 1: Average ranking among ΨKi of the lowest-
ranked formula of ΨrandKi , and p-value for the rankings of
all formulas of all ΨrandKi

were added independently to F , yielding 100 in-
put ontologies K1, . . . ,K100, such that each Ki was
consistent, and that there was at least one conse-
quence of the form A(e) or ¬A(e) entailed by Ki
but not by F , with e sharing at least one linguistic
context with some other individual of F . All 100
input ontologies are available online.8

The first part of the evaluation was performed
as follows. For each Ki and each ψ ∈ ΨKi , the
plausibility scKi(ψ) was computed as in definitions
4.1/4.2, and ΨKi was ordered by increasing plausi-
bility.9 Within ΨKi are consequences which were
not initially entailed by F , but have been obtained
after the extension of F with the random statement
φi. So in a sense, these consequences are ran-
domly generated too, and therefore one may expect
many of them to convey absurd information (for in-
stance Architect(Belgium)), or at least to be out-
liers (like Person(CEO) in ex 1) within ΨKi . Let
ΨrandKi designate these additional consequences, i.e.
ΨrandKi = ΨKi \ ΨF . If ψ ∈ ΨrandKi , and if scKi(ψ) is
actually lower than for most other formulas of ΨKi ,
this would indicate that the plausibility score, as for-
mulated in definitions 4.1/4.2, is actually a good es-
timator.

In order to evaluate this, column “rank” in table
1 gives the average ranking (for all 100 ontologies)
within ΨKi of the formula ψi ∈ ΨrandKi with low-
est score. The lower this ranking, the more efficient
the plausibility score is at detecting outlier conse-
quences. Column “pVal” gives the probability (t-
test) for the cumulated rankings of all formulas in all
ΨrandKi to be as low as the observed ones, if all conse-
quences in all ΨKi had been randomly ordered.

8http://www.irit.fr/~Julien.Corman/index en.php
9 The ranking was a strict ordering : if two consequences

had the same score, one of them was randomly designated as
strictly lower ranked.

Results are convincing, with a significant p-value
for all four settings. For most ontologies (75/100),
there was only one formula in ΨrandKi . A closer look
at the data revealed that, for the best setting (LP),
in most of theses cases (57/75), the only formula in
ΨrandKi was also the one with lowest plausibility in
ΨKi , over 216.1 on average, i.e. the only randomly
generated consequence was also the least plausible
one according to linguistic evidence. This is very
encouraging, especially considering the relatively
small number of named individuals (71) in F , i.e.
the fact that the support to evaluate the plausibility of
a consequence ψ ∈ ΨKi was limited. On the other
hand, performances were generally poor when the
cardinality of ΨrandKi was important (> 0.25 ∗ |ΨKi |),
which may be explained by the fact that support sets
for some classes of F were significantly modified
after the extension of F with φi.

As for the settings, unsurprisingly, the two most
beneficial (but unfortunately incompatible) factors
were the use of lemmatized contexts on the one hand
(LP), and the queries over the Web N-gram corpus
on the other hand (NS and NPS)

The second part of the evaluation focused on the
retrieval of the random statements φ1, .., φ100, for
the LP setting only, because it gave the best re-
sults in the previous experiment. For each extended
base Ki, all immediate subbases Γi,1, ..,Γi,|F |+1 of
Ki were generated, i.e. each Γi,j was such that
Ki = Γi,j ∪ {φj} for some statement φj of Ki.
The different Γi,j were ordered by decreasing com-
pliance score comp(Γi,j) (resp. compKi(Γi,j)),
or by decreasing lexicographic ordering �lex (resp.
�lexKi ).10 Intuitively, this yields a ranking on Ki
where the least reliable statements wrt linguistic ev-
idence should appear first : if φj ∈ Ki, and if the
subbase of Ki obtained by discarding φj (i.e. Γi,j)
has a higher linguistic compliance score than Ki,
then discarding Γi,j can be viewed as an improve-
ment over Ki. And if Γi,j is among the best ranked
subbases of Ki, then φj is among the least reliable
statements of Ki wrt distributional evidence. For in-
stance, in example 1, one may expect the subbase
K \ (1) to have a maximal linguistic compliance
score among immediate subbases of K (or to be

10Again, the ranking was randomly turned into a strict order-
ing (see footnote 9).

36



rank p-val
comp(Γ) 7.86 / 80.03 < 0.001
compKi(Γ) 8.05 / 80.03 < 0.001
�lex 6.51 / 80.03 < 0.001
�lexKi 2.47 / 80.03 < 0.001

Table 2: Average ranking of the randomly generated
statement φi for each Ki, and p-value for the rankings
of all φi

maximal wrt the lexicographic ordering), such that
(1) is the best candidate for removal. So back to the
test data, if Ki = F ∪ {φi}, i.e. if φi is, among the
|F+1| statements ofKi, the one which has been ran-
domly generated, and if Γi,i = Ki \ φi is among the
best ranked immediate subbases of Ki, this would
indicate that the linguistic compliance score in def-
initions 4.3 (resp. 4.4), or the corresponding lexi-
cographic ordering �lex (resp. �lexKi ) is actually a
good estimator of faulty statements.

An additional precaution was taken in order to
avoid artificially good results. For most statements
φj ∈ Ki, discarding φj did not have any impact
on the set ΨΓi,j of consequences to be evaluated,
i.e. ΨΓi,j = ΨKi , and therefore comp(Γi,j) =
comp(Ki). Let ∆i ⊆ Ki be the set of statements
whose removal did have an impact instead (on av-
erage, there were 79.3 statements in ∆i). Then the
compliance of a subbase Γi,j of Ki was evaluated
only if φj ∈ ∆i, i.e. only if the removal of φj made a
difference. Ki was also added to this set of evaluated
subbases, yielding a ranking of 79.03 + 1 = 80.03
bases on average.

Results are again positive. Column “rank” in table
2 gives the average ranking of Γi,i, i.e. the base ob-
tained after the removal of the randomly generated
statement φi. Both lexicographic orderings outper-
formed the compliance scores (i.e. the mean of plau-
sibility scores), and the best configuration was the
fourth presented in section 4.2, using scKi(ψ) as a
plausibility score instead of scΓi,j (ψ).

6 Applications

This section describes a few concrete use cases of
the propositions made in section 4. A first basic
but useful application is the identification of unde-
sired consequences of a consistent input ontology

K. As illustrated by example 1, violations of com-
mon sense often go unnoticed in publicly available
OWL datasets, even though effective procedures can
detect inconsistency11 in most DLs. This is corre-
lated with the overall sparse usage of negation in
OWL, yielding ontologies which are consistent by
default rather than by design. The identification of
such cases can be very simply performed, by return-
ing to the user the formulas of ΨK with lower plausi-
bility scores, like Person(CEO) in example 1. Ax-
iom pinpointing algorithms (Schlobach and Cornet,
2003; Kalyanpur et al., 2007; Horridge, 2011) may
then be used to compute all justifications for each
returned consequence ψ, i.e. all (set-inclusion) min-
imal subsets of K which have ψ as a consequence.

In a more automated fashion, the greedy trimming
approach described in (Corman et al., 2015) returns
n statements of K which are candidate for removal,
n being given as a parameter, by incrementally se-
lecting the immediate subbase of Γ with maximal
linguistic compliance score, starting with Γ = K.

But inconsistent12 ontology debugging may also
benefit from distributional evidence. As discussed
in section 2, state-of-the-art approaches to ontology
debugging suffer from the number of candidate out-
puts, i.e. of (set-inclusion) maximal consistent sub-
sets of K, as well as from the cost of their compu-
tation. If the set J of justifications for the inconsis-
tency of K is known though, and if some (discrim-
inant enough) preference relation �a over

⋃J can
be obtained, then prioritized base revision, as it is
defined in (Nebel, 1992), provides a principled and
computationally attractive solution to these prob-
lems. Even if the whole process cannot be depicted
here, �a may actually be obtained through distri-
butional evidence, by evaluating, for each statement
φ ∈ ⋃J , the plausibility of some consequences of
candidate subbases in which φ does or does not ap-
pear. The support set in this case is reduced to con-
sequences of the “safe” part of K, i.e. K \⋃J .
7 Extensions

A first straightforward extension of this framework
consists in taking more complex classes into ac-

11or incoherence (see footnote1)
12or incoherent (see footnote 1), or for which a set of unde-

sired consequences has already been identified

37



count. OWL (and most Description Logics) fa-
vor the recursive construction of arbitrarily com-
plex classes out of the signature of Γ, and this
mechanism could naturally be used to extend ΨΓ
with more consequences of the form C(e), where
C is one of these complex classes. For instance,
in example 1, if C1 and C2 are respectively de-
fined by ∀x(C1(x) ⇔ ∃y(occupation(y, x))
and ∀x(C2(x) ⇔ ∃y(occupation(x, y)), then
ΨK can be extended “for free” with C1(CEO) and
C2(Peter Munk). Unfortunately, if Ψ+Γ is the set of
all consequences of Γ which can be built this way,
there is in general no finite subset ΨΓ of Ψ+Γ such
that ΨΓ |= ψ for all ψ ∈ Ψ+Γ . Therefore the com-
plex classes to be used must be selected, which is
not trivial. Intuitively, some complex classes are
more relevant than other (e.g. the class of “phys-
ical objects owned by someone” may be linguisti-
cally relevant, but probably not “Moldavian or Mus-
lim lawyers whose father lives in an apartment”).

Another simple variation of the framework pre-
sented here consists in setting ΨΓ to be all con-
sequences of Γ of the form e1 6= e2, i.e. the
fact that that e1 and e2 are not the same individ-
ual according to Γ. The unique name assumption
is not made in OWL, which means that two dis-
tinct named individuals can be interpreted identi-
cally, and therefore these consequences do not hold
by default. They may be explicitly stated in Γ
(owl:differentIndividuals(e1, e2)), but are in most
cases entailed by Γ, provided it contains some form
of negation (e.g. instances of two disjoint classes
cannot be the same individual). If Γ1 and Γ2 are
two subbases of K such that Γ1 |= e1 6= e2, but
Γ2 6|= e1 6= e2, and if the similarity between e1 and
e2 is lower than expected, then ceteris paribus, Γ1
will be preferred to Γ2.

Conclusion

This article is centered on the use of distributional
representations of (labels of) named individuals of
an input ontology K, in order to identify and repair
violations of commonsense within K. For a set of
statements Γ ⊆ K, and ΨΓ a specific set of con-
sequences of Γ, a score scΓ(ψ) is attributed to each
ψ ∈ ΨΓ, which evaluates the plausibility of ψ wrt Γ
according to distributional evidence. Several meth-

ods based on this plausibility score are then pro-
posed in order to compare two subbases Γ1 and Γ2 of
K, leading to the identification of potentially erro-
neous statements. An evaluation is provided, which
consists in extending a test ontology with randomly
generated statements before trying to spot them au-
tomatically, with significant results. A more thor-
ough evaluation is still required though, testing in
particular the impact of a higher number of named
individuals and/or classes. Scalability of the ap-
proach may also be limited by its heavy reliance on a
reasoner. Finally, potential improvements may come
from using more elaborated distributional represen-
tations, like the one described in (Mikolov et al.,
2013).

38



References

Baroni, M. and S. Bernardini (2004). BootCaT:
Bootstrapping Corpora and Terms from the Web.
In LREC proceedings.

Benevides, A., G. Guizzardi, B. Braga, and
J. Almeida (2010). Validating modal aspects
of OntoUML conceptual models using automat-
ically generated visual world structures. Journal
of Universal Computer Science 16(20).

Buitelaar, P., P. Cimiano, and B. Magnini (2005).
Ontology Learning from Text: Methods, Evalua-
tion And Applications. IOS Press.

Cimiano, P. (2006). Ontology learning and popula-
tion from text: algorithms, evaluation and appli-
cations. Springer.

Cimiano, P. and J. Völker (2005). Towards large-
scale, open-domain and ontology-based named
entity classification. In RANLP proceedings.

Corman, J., N. Aussenac-Gilles, and L. Vieu (2015).
Trimming a consistent OWL knowledge base, re-
lying on linguistic evidence. In LangAndOnto
proceedings.

Ferré, S. and S. Rudolph (2012). Advocatus Dia-
boli–Exploratory Enrichment of Ontologies with
Negative Constraints. EKAW proceedings.

Friedrich, G. and K. Shchekotykhin (2005). A gen-
eral diagnosis method for ontologies. In ISWC
proceedings.

Giuliano, C. and A. Gliozzo (2008). Instance-based
ontology population exploiting named-entity sub-
stitution. In COLING proceedings.

Horridge, M. (2011). Justification based explana-
tion in ontologies. Ph. D. thesis, the University of
Manchester.

Kalyanpur, A., B. Parsia, M. Horridge, and E. Sirin
(2007). Finding all justifications of OWL DL en-
tailments. In The Semantic Web. Springer.

Kalyanpur, A., B. Parsia, E. Sirin, and B. Cuenca-
Grau (2006). Repairing unsatisfiable concepts in
OWL ontologies. In ESWC proceedings.

Mendes, P. N., M. Jakob, and C. Bizer (2012). DB-
pedia: A Multilingual Cross-domain Knowledge
Base. In LREC proceedings.

Mikolov, T., K. Chen, G. Corrado, and J. Dean
(2013). Efficient estimation of word representa-
tions in vector space. ICLR proceedings.

Nebel, B. (1992). Syntax-based approaches to belief
revision. Belief revision 29, 52–88.

Pammer, V. (2010). Automatic Support for Ontol-
ogy Evaluation. Ph. D. thesis, Graz University of
Technology.

Poveda-Villalón, M., M. C. Suárez-Figueroa, and
A. Gómez-Pérez (2012). Did you validate your
ontology? OOPS! In ESWC proceedings.

Qi, G., P. Haase, Z. Huang, Q. Ji, J. Z. Pan, and
J. Völker (2008). A kernel revision operator for
terminologies - algorithms and evaluation. In
ISWC proceedings.

Ribeiro, M. M. and R. Wassermann (2009). Base
revision for ontology debugging. Journal of Logic
and Computation 19(5).

Roussey, C. and O. Zamazal (2013). Antipattern
Detection: How to Debug an Ontology without
a Reasoner. In WODOOM 2013 proceeding.

Schlobach, S. (2005). Diagnosing terminologies. In
AAAI proceedings.

Schlobach, S. and R. Cornet (2003). Non-standard
reasoning services for the debugging of descrip-
tion logic terminologies. In IJCAI proceedings.

Suchanek, F. M., M. Sozio, and G. Weikum (2009).
SOFIE: a self-organizing framework for informa-
tion extraction. In International World Wide Web
conference proceedings.

Tanev, H. and B. Magnini (2008). Weakly super-
vised approaches for ontology population. In
conference on Ontology Learning and Population
proceedings.

Toutanova, K., D. Klein, C. D. Manning, and
Y. Singer (2003). Feature-rich part-of-speech
tagging with a cyclic dependency network. In
NAACL proceedings.

39


