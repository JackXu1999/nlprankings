



















































Reasoning with Dependency Structures and Lexicographic Definitions Using Unit Graphs


Proceedings of the Second International Conference on Dependency Linguistics (DepLing 2013), pages 167–176,
Prague, August 27–30, 2013. c© 2013 Charles University in Prague, Matfyzpress, Prague, Czech Republic

Reasoning with Dependency Structures and Lexicographic Definitions
using Unit Graphs

Maxime Lefrançois and Fabien Gandon
Wimmics, Inria, I3S, CNRS, UNSA

2004 rte des Lucioles, BP. 93, 06902 Sophia Antipolis, France
{maxime.lefrancois,fabien.gandon}@inria.fr

Abstract

We are interested in a graph-based Knowl-
edge Representation (KR) formalism that
would allow for the representation, manip-
ulation, query, and reasoning over depen-
dency structures, and linguistic knowledge
of the lexicon in the Meaning-Text Theory
framework. Neither the semantic web for-
malisms nor the conceptual graphs appear
to be suitable for this task, and this led to
the introduction of the new Unit Graphs
(UG) framework. In this paper we will
overview the foundational concepts of this
framework: the UGs are defined over a
UG-support that contains: i) a hierarchy
of unit types which is strongly driven by
the actantial structure of unit types, ii) a
hierarchy of circumstantial symbols, and
iii) a set of unit identifiers. Based on these
foundational concepts and on the defini-
tion of UGs, this paper justifies the use
of a deep semantic representation level to
represent meanings of lexical units. Rules
over UGs are then introduced, and lexi-
cographic definitions of lexical units are
added to the hierarchy of unit types. Fi-
nally this paper provides UGs with seman-
tics (in the logical sense), and pose the en-
tailment problem, so as to enable the rea-
soning in the UGs framework.

1 Introduction

We are interested in a graph-based Knowledge
Representation (KR) formalism that would allow
for the representation, manipulation, query, and
reasoning over dependency structures and linguis-
tic knowledge of the Explanatory Combinatorial
Dictionary (ECD), which is the lexicon at the core
of the Meaning-Text Theory (MTT) (Mel’čuk,
2006).

Most past or current projects that aimed at im-
plementing the ECD did so in a lexicographic
perspective. One important example is the RE-
LIEF project (Lux-Pogodalla and Polguère, 2011),
which aims at representing a lexical system graph
named RLF (Polguère, 2009), where lexical units
are interlinked by paradigmatic and syntagmatic
links of lexical functions (Mel’čuk, 1996). In
the RELIEF project, the description of Lexical
Functions is based on a formalization proposed by
Kahane and Polguère (2001). Moreover, lexico-
graphic definitions start to be partially formalized
in the RELIEF project using the markup type that
has been developed in the Definiens project (Bar-
que and Polguère, 2008; Barque et al., 2010).

One exception is the proprietary linguistic pro-
cessor ETAP-3 that implements a variety of ECD
for Natural Language Processing (Apresian et
al., 2003; Boguslavsky et al., 2004). Linguistic
knowledge are asserted, and linguistic and gram-
matical rules are directly formalized in first order
logic.

Adding to these formalization works, our goal is
to propose a formalization from a knowledge engi-
neering perspective, compatible with standard KR
formalisms. The term formalization here means
not only make non-ambiguous, but also make op-
erational, i.e., such that it supports logical oper-
ations (e.g., knowledge manipulation, query, rea-
soning). We thus adopt a knowledge engineer-
ing approach applied to the domain of the MTT.
The semantic web formalisms and the Concep-
tual Graphs formalism both seem to fit this task,
but they actually present strong incompatibili-
ties with the description of linguistic predicates
(Lefrançois, 2013). These issues led to the in-
troduction of the new graph-based Unit Graphs
(UGs) KR formalism. In the UGs framework, the
linguistic predicates are represented by unit types,
and are described in a structure called the unit
types hierarchy. Unit types specify through their

167



actantial structure, i.e., actant slots, the ways in
which their instances may be linked to other units
in a UG.

The main research question of this paper is the
following: What semantics can be attributed to
UGs, and how can we define the entailment prob-
lem for UGs ?

The rest of this paper is organized as follows.
We will first overview the issues of existing graph-
based KR formalisms that led to the introduction
of the new UGs framework (§2). The foundational
concepts of this framework are then introduced
(§3). From these foundational concepts we define
the lexicographic definitions of Lexical Unit Types
(LexUTs) (§4). Finally we provide UGs with se-
mantics (in the logical sense), and pose the entail-
ment problem (§5).

2 The Unit Graphs Formalism

At first sight, two existing KR formalisms seem in-
teresting for representing dependency structures:
semantic web formalisms (RDF1, RDFS2, OWL3,
SPARQL4), and Conceptual Graphs (CGs) (Sowa,
1984; Chein and Mugnier, 2008). Both for-
malisms are based on directed labelled graph
structures, and some research has been done to-
wards using them to represent dependency struc-
tures and knowledge of the lexicon (OWL in
(Lefrançois and Gandon, 2011; Boguslavsky,
2011), CGs at the conceptual level in (Bohnet and
Wanner, 2010)). Yet authors in (Lefrançois, 2013)
showed that neither of these KR formalisms can
represent linguistic predicates. Let us list the main
drawbacks of these existing formalisms:

• The RDF is insufficient because its semantics
is limited to that of oriented labelled graphs.
• In RDFS, OWL and the CGs, there is a strong

distinction between concept types and rela-
tions. Yet, a linguistic predicate may be con-
sidered both as a concept type as it is instan-
tiated in dependency structures, and as a rela-
tion as its instances may link other instances.
• RDFS and OWL only model binary relations,

which is not the case of most linguistic pred-
1RDF - Resource Description Framework,

c.f., http://w3.org/RDF/
2RDFS - RDF Schema,

c.f., http://www.w3.org/TR/rdf-schema/
3OWL - Web Ontology Language,

c.f., http://www.w3.org/TR/owl2-overview/
4SPARQL, c.f.,

http://www.w3.org/TR/sparql11-overview/

icates. One would need to use reification of
n-ary relations, but then no semantics is at-
tributed to such relations.
• CGs support n-ary relations, but the inheri-

tance mechanism of relation types is such that
two relations with different arities must be in-
comparable. Yet the Semantic Actant Slots
(SemASlots) of a lexical unit are determined
by linguistic criteria and may thus differ from
those of the lexical unit from which its sense
derives (Mel’čuk, 2004, p. 38). One thus
cannot use the natural inheritance mechanism
of CGs to model the meaning specialization
of predicates.

As the CGs formalism is the closest to the se-
mantic networks, the following choice has been
made to overcome these issues: Modify the CGs
formalism basis, and define transformations to the
RDF syntax for sharing knowledge and publish-
ing over the web of data. As we are to represents
linguistic units of different nature (e.g., seman-
tic units, lexical units, grammatical units, words),
term unit has been chosen to be used in a generic
manner, and the result of this adaptation is thus the
Unit Graphs (UGs) framework.

3 Unit Graphs

For a specific Lexical Unit L, (Mel’čuk, 2004, p.
5) distinguishes considering L in language (i.e., in
the lexicon), or in speech (i.e., in an utterance).
KR formalisms and the Unit Graphs (UGs) for-
malism also make this distinction using types. In
this paper and in the UGs formalism, there is thus
a clear distinction between units (e.g., semantic
unit, lexical unit), which will be represented in the
UGs, and their types (e.g., semantic unit type, lex-
ical unit type), which are roughly classes of units
for which specific features are shared. It is those
types that specify through actant slots how their
instances (i.e., units) are to be linked to other units
in a UG.

3.1 Support

Following the example of CGs, UGs are defined
over a so-called support.

Definition 1. A UG support is denoted S def=
(T , C,M) and is composed of a hierarchy of unit
types T , a hierarchy of circumstantial symbols C,
and a set of unit identifiers M.

Let us briefly introduce the components of S.
168



First, unit types and their actantial structure are
described in a structure called hierarchy and de-
noted T . Whether they are semantic, lexical or
grammatical, unit types have Actant Slots (ASlots)
with symbols. Moreover, ASlots may be optional,
obligatory, or prohibited (Lefrançois and Gandon,
2013a). Let us briefly introduce two of the com-
ponents of T , and leave details for section 3.3.

• The core of T is the set of so-called Prim-
itive Unit Types (PUTs), denoted T. Now
a unit type may consist of several conjoint
PUTs. In particular, it may be a lexical
PUT and multiple grammatical PUTs, like
{def, plur, CAT}. To represent this, we intro-
duce the set T∩ of possible Conjunctive Unit
Types (CUTs) over T as the powerset5 of T.
• T contains a set of binary relation symbols of

type predicate-argument called Actant Sym-
bols (ASymbols), and denoted ST . ST con-
tains numbers for the semantic unit types, and
other ”classical” symbols for the other lev-
els under consideration (e.g, roman numer-
als I to VI for the MTT’s Deep Syntactic
level). Every unit type has an actantial struc-
ture that consists in a set of optional, oblig-
atory and prohibited ASlots associated with
some ASymbols. The actantial structure of a
PUT specify how units of this type shall be
linked to other units through so-called actan-
tial relations in a dependency structure.

Second, there exists dependencies other than ac-
tantial: circumstantial relations (Mel’čuk, 2004).
Circumstantial relations are considered of type
instance-instance contrary to actantial relations.
Example of such relations are the deep syntactic
representation relations ATTR, COORD, APPEND
of the MTT, but we may also use such relations
to represent communicative dependencies for in-
stance. Circumstantial relations are labelled by
symbols chosen in a set of so-called Circumstan-
tial Symbols (CSymbols), denoted SC , and their
classes and usage are described in a hierarchy
denoted C. Section 3.4 details the hierarchy of
CSymbols.

Finally, one actually needs symbols to identify
units. We thus introduce a set of so-called unit
identifiers, denoted M. Every element of M iden-
tifies a specific unit, but multiple elements of M
may identify the same unit.

5The powerset of X is the set of all subsets of X: 2X

3.2 Definition of UGs

The UGs represent different types of dependency
structures (e.g., semantic, syntactic). In a UG, unit
nodes that are typed are interlinked by dependency
relations that are either actantial or circumstantial.

Definition 2. A UG G defined over a support S
is a tuple denoted G def= (U, l, A,C,Eq) where U
is the set of unit nodes, l is a labelling mapping
over U , A and C are respectively actantial and cir-
cumstantial triples, and Eq is a set of asserted unit
node equivalences.

Let us detail the components of G.
U is the set of unit nodes. Every unit node

represents a specific unit, but multiple unit nodes
may represent the same unit. Unit nodes are typed
and marked so as to respectively specify what
CUT they have and what unit they represent. The
marker of a unit node is a set of unit identifiers,
for mathematical reasons. The set of unit node
markers is denoted M∩ and is the powerset5 of
M. If a unit node is marked by ∅, it is said to be
generic, and the represented unit is unknown. On
the other hand, if a unit node is marked {m1,m2},
then the unit identifiers m1 and m2 actually iden-
tify the same unit. l is thus a labelling mapping
over U that assigns to each unit node u ∈ U a
couple l(u) = (t∩,m∩) ∈ T∩×M∩ of a CUT and
a unit node marker. We denote t∩ = type(u) and
m∩ = marker(u). Unit nodes are illustrated by
rectangles with their label written inside.
A is the set of actantial triples (u, s, v) ∈ U ×

ST × U . For all a = (u, s, v) ∈ A, the unit
represented by v fills the ASlot s of the unit rep-
resented by u. We denote u = governor(a),
s = symbol(a) and v = actant(a). We also
denote arc(a) = (u, v). Actantial triples are il-
lustrated by double arrows.
C is the set of circumstantial triples (u, s, v) ∈

U × SC × U . For all c = (u, s, v) ∈ C, the unit
represented by u governs the unit represented by v
with respect to s. We denote u = governor(c),
s = symbol(c) and v = circumstantial(c).
We also denote arc(c) = (u, v). Circumstantial
triples are illustrated by simple arrows.
Eq ⊆ U2 is the set of so-called asserted unit

node equivalences. For all couple (u1, u2) in
Eq, u1 and u2 represent the same unit. The Eq
relation is not an equivalence relation over unit
nodes6. We thus distinguish explicit and implicit

6An equivalent relation is a reflexive, symmetric, and

169



knowledge. Asserted unit node equivalences are
illustrated by dashed arrows.

For instance, figure 1a is a semantic represen-
tation of sentence Peter tries to push the cat. in
which units are typed by singletons and ASym-
bols are numbers, in accordance with the MTT.
Figure 1b is a simplified deep syntactic represen-
tation of Peter is gently pushing the cat. In this
figure unit nodes u2 and u4 are typed by single-
tons, and only unit node u2 is not generic and has
a marker: {Peter}. P is composed of (u1, I, u2)
and (u1, II, u3), where I and II are ASymbols. C
is composed of (u1, ATTR, u4) where ATTR is a
CSymbol. In the relation Eq there is (u1, u1),
(u2, u2), and (u3, u3).

(Peter) (try)

(push) (cat)

1
2

1

2

(a) Semantic representation of sentence Peter tries to push the
cat.

{PUSH,present, progressive}

MAN:Peter {CAT,def} GENTLY

u1

u2 u3 u4

I II ATTR

(b) Deep syntactic representation of sentence Peter is gently
pushing the cat.

Figure 1: Examples of Unit Graphs.

UGs so defined are the core dependency struc-
tures of the UG mathematical framework. Before
we present what they may be used for in more de-
tails, let us look more closely into components of
the support on which UGs are defined: the unit
types hierarchy and the CSymbols hierarchy.

3.3 Unit Types Hierarchy
As already stated in section 3.1, unit types and
their actantial structure is described in the unit
types hierarchy which is denoted T .
Definition 3. A hierarchy of unit
types, denoted T , is a tuple T def=
(TD,ST , γγγ,γγγ1, γγγ0, CA,⊥uA, {ςςςt}t∈T) that enables
to construct a pre-ordered7 set of Conjunctive

transitive relation.
7A pre-order is a reflexive and transitive binary relation.

Unit Types (CUTs) T∩ with optional, obligatory,
or prohibited ASlots.

This structure has been thoroughly described
in (Lefrançois and Gandon, 2013a; Lefrançois,
2013). Let us overview its components.
TD is a set of declared Primitive Unit Types

(PUTs). This set is partitioned into linguistic
PUTs of different nature (e.g., deep semantic, se-
mantic, lexical). ST is a set of Actant Symbols
(ASymbols). γγγ (resp1. γγγ1, resp2. γγγ0) assigns to
every s ∈ ST its radix8 (resp1. obligat9, resp2.
prohibet10) unit type γγγ(s) (resp1. γγγ1(s), resp2.
γγγ0(s)) that introduces (resp1. makes obligatory,
resp2. makes prohibited) an Actant Slot (ASlot)
of symbol s.

The set of Primitive Unit Types (PUTs) is de-
noted T and defined as the disjoint union of TD,
the range of γγγ, γγγ1 and γγγ0, plus the prime univer-
sal PUT > and the prime absurd PUT ⊥. T is
then pre-ordered by a relation . which is com-
puted from the set of asserted PUTs comparisons
CA ⊆ T2. t1 . t2 models the fact that the PUT t1
is more specific than the PUT t2. A unit type may
consist of several conjoint PUTs. We introduce the
set T∩ of possible Conjunctive Unit Types (CUTs)
over T as the powerset5 of T. The set⊥uA is the set
of declared absurd CUTs that can not be instanti-
ated.

The actantial structure of a unit type t∩ is a set
of ASlots, whose symbols are chosen in the set ST ,
and that may be optional, obligatory, or prohibited.
Moreover, ASlots are signed. The signature of t∩

for one of its ASlots s is denoted ςςς∩t∩(s), and char-
acterises the type of the unit that fills this slot. The
set of signatures of t∩ is computed from the set of
PUTs signatures {ςςςt}t∈T.

Finally the pre-order . over T is extended to a
pre-order

∩
. over T∩ as defined by Lefrançois and

Gandon (2013a). Lefrançois and Gandon (2013b)
proved that in the hierarchy of unit types, if t∩1

∩
.

t∩2 then the actantial structure of t
∩
1 is more spe-

cific than that of t∩2 , except for some degenerated
cases. Thus as one goes down the hierarchy of unit
types, an ASlot with symbol s is introduced by the
radix {γγγ(s)} and first defines an optional ASlot for
any unit type t∩ more specific than {γγγ(s)}, as long

8radix is a latin word that means (root).
9obligat is the conjugated form of the latin verb obligo, 3p

sing. pres., (it makes mandatory).
10prohibet is the conjugated form of the latin verb pro-

hibeo, 3p sing. pres., (it prohibits).

170



as t∩ is not more specific than the obligat {γγγ1(s)}
(resp. the prohibet {γγγ0(s)}) of s. If that happens,
the ASlot becomes obligatory (resp. prohibited).
Moreover, the signature of an ASlot may only be-
come more specific.

3.4 Circumstantial Symbols Hierarchy

As for any slot in a predicate, one ASlot of a unit
may be filled by only one unit at a time. Now,
one may also encounter dependencies of another
type in some dependency structures: circumstan-
tial dependencies (Mel’čuk, 2004). Circumstantial
relations are considered of type instance-instance
contrary to actantial relations. Example of such
relations are the deep syntactic representation re-
lations ATTR, COORD, APPEND of the MTT.

We thus introduce a finite set of so-called Cir-
cumstantial Symbols (CSymbols) SC which is a set
of binary relation symbols. In order to classify
SC in sets and subsets, we introduce a partial or-
der

C. over SC .
C. is the reflexo-transitive closure

of a set of asserted comparisons CSC ⊆ T2. Fi-
nally, to each CSymbol is assigned a signature that
specifies the type of units that are linked through
a relation having this symbol. The set of sig-
natures of CSymbol {σσσs}s∈SC is a set of cou-
ples of CUTs: {(domain(s), range(s))}s∈SC . As
one goes down the hierarchy of PUTs, we impose
that the signature of a CSymbol may only become
more specific. We may hence introduce the hierar-
chy of CSymbols:

Definition 4. The hierarchy of Circumstantial
Symbols, denoted C def= (SC ,CSC , T , {σσσs}s∈SC), is
composed of a finite set of CSymbols SC , a set of
declared comparisons of CSymbols CSC , a hierar-
chy of unit types T , and a set of signatures of the
CSymbols {σσσs}s∈SC .

3.5 UG Homomorphisms

Unit Graphs have an underlying oriented labelled
graph. It is thus convenient for reasoning ap-
plications to introduce the notion of UGs homo-
morphism. Recall that for non-labelled graphs,
an homomorphism from H to G, is an edge-
preserving mapping from nodes of H to nodes
of G. We will thus introduce the notion of
homomorphism of UGs, based on homomor-
phism of their underlying oriented labelled graphs.
Let us first introduce the notion of UGs map-
ping. Let H = (Uh, lh, Ah, Ch, Eqh) and G =
(Ug, lg, Ag, Cg, Eqg) be two UGs defined over the

same support.

Definition 5. A UGs mapping f from H to G,
written f : H → G, corresponds to a mapping
of their underlying oriented labelled graphs, i.e., a
mapping f : Uh → Ug from the unit nodes of H
to the unit nodes of G.

Then there is a homomorphism of UGs if there
is a homomorphism of their underlying oriented
labelled graphs. To define such a homomorphism,
one needs to choose pre-orders over labels for unit
nodes and arcs. We use inclusion for unit node
markers,

∩
. for types, and C. for circumstantial re-

lations.

Definition 6. There is a homomorphism fromH to
G if and only if there exists a mapping π : H → G
such that all of the following is true:

• ∀u ∈ Uh, marker(u) ⊆ marker(π(u));
• ∀u ∈ Uh, type(π(u)) ∩. type(u);
• (u, s, v) ∈ Ah ⇒ (π(u), s, π(v)) ∈ Ag;
• (u, s, v) ∈ Ch ⇒ ∃c ∈ Cg, arc(c) =
(π(u), π(v)) and symbol(c)

C. s;
• (u, v) ∈ Eqh ⇒ (π(u), π(v)) ∈ Eqg.

4 Rules and Lexicographic Definitions

Now that we have defined the core structures of
the UGs framework, and before we introduce se-
mantics of UGs, we need to sketch some advance
concepts of the UGs framework. Namely, the deep
semantic representation level (§4.1), rules (§4.2),
and unit types definitions (§4.3)

4.1 The deep-surface semantic interface
In the MTT, semantic ASymbols are numbers. For
instance, the french lexical unit INSTRUMENT (en:
instrument) has a SemASlot 1 that corresponds to
the activity for which the instrument is designed.
PEIGNE (en: comb) has a more specific meaning
than INSTRUMENT, and also two SemASlots: 1
correspond to the person that uses the comb, and
2 is a split variable11 that corresponds either to the
hair or to the person that is to be combed.

As the specialization of PUTs implies the spe-
cialization of their actantial structure, the pre-
order over semantic unit types can not correspond
to a meaning specialization relation. Lefrançois
and Gandon (2013a) hence defined a deeper level
of representation for the MTT: the deep semantic
level. At the deep semantic level, the pre-order

11See (Mel’čuk, 2004, p.43) for details about split Se-
mASlots

171



over unit types may correspond to a meaning spe-
cialization relation. The Deep Semantic Unit Type
(DSemUT) associated with a Lexical Unit Type
(LexUT) L is denoted /L\, and the set of ASym-
bols that is used to symbolize ASlots is a set of se-
mantic roles (e.g., agent, experiencer, object).
For instance, the DSemUT /instrument\ associ-
ated with the LexUT INSTRUMENT may have
an ASlot arbitrarily symbolized activity, which
would be inherited by the DSemUT /peigne\.
Then /peigne\ also introduces three new ASlots:
one arbitrarily symbolized possessor that corre-
sponds to the ASlot 1 of (peigne), and two arbitrar-
ily symbolized combedhair, and combedperson
that correspond to the ASlot 2 of (peigne).

4.2 Rules
One question one may ask at this point is: how
to represent the correspondence between the ac-
tantial structure of a DSemUT, and the actantial
structure of its associated Surface Semantic Unit
Type (SSemUT)? First and parallel with CGs, we
will define λ-UGs that enable to distinguish some
generic unit nodes of a UG.
Definition 7. A λ-UG L = {u1, . . . , un}G of size
n defined over a support S is composed of a UG
G = (U, l, A,C,Eq), and a set of n generic unit
nodes of G, {u1, . . . , un}, denoted the free nodes
of L.
λ-UG are actually generalized UGs, and a UG

may be considered as a λ-UG of size 0. A rule
may then be simply represented by two λ-UGs and
a bijection between their free nodes.

Definition 8. A rule is a triple R def= (H,C, κ)
where H and C are two λ-UGs of the same size
defined over the same support, H is denoted the
hypothesis, C the conclusion, and κ is a bijection
from free nodes of H to free nodes of C.

A rule is said to be applicable to a UG G if and
only if there exists a homomorphism from H to
G. Let π be such a homomorphism from H to G.
The application of R on G with respect to π is the
UG obtained by merging C in G with respect to
π ◦ κ−1, i.e.,

1. add C to G;
2. for all (uc, ug) ∈ π ◦ κ−1, merge uc

and ug as follows: (i) add a new node u,
with type(u) = type(uc) ∪ type(ug) and
marker(u) = marker(uc) ∪marker(ug);
(ii) replace uc and ug by u in any dependency
triple in A ∪ C and in any element of Eq.

Among other, rules enable to represent corre-
spondences between representations of two adja-
cent levels, and they shall be automatically gen-
erated from the dictionary. Let us just note two
issues with the definition of rules for the moment:

• in the correspondence between actantial
structures of /peigne\ and (peigne), the
ASlot 2 of (peigne) may correspond either to
the ASlot combedhair or to combedperson
of /peigne\. One thus need to define two
different correspondence rules, one that as-
sumes slot combedhair is filled, and one that
assumes slot combedperson is filled.
• if a LexUT has an optional SemASlot, then

one would need two different correspondence
rules between its associated DSemUT and
SSemUT: one that assumes the ASlot is filled
and one that assumes the ASlot is not filled.

These remarks are valid not only at the deep-
surface semantic interface, and the number of
rules would grow in case of several optional
ASlots, several split ASlots, or optional split Se-
mASlots for instance. The semantic web SPARQL
query language has OPTIONAL and UNION con-
structors that we could draw inspiration from to
extend the definition of rules so as to factorize
these cases. Now for the purpose of our presenta-
tion we will hold on the simple definition of rules
given above, and rely on the fact that we do have
means to compute all the possible correspondence
rules.

4.3 Unit Types Hierarchy with Definitions

We formalize the notion of definition of a Primi-
tive Unit Type (PUT) and include a set of PUTs
definitions in the definition of the unit types hier-
archy. Definitions are of special interest to rep-
resent lexicographic definitions of a LexUT L,
which corresponds to the definition of its associ-
ated DSemUT /L\. Informally, a definition de-
fines an equivalence between two λ-UG defined
over the same support. One of them has a cen-
tral free unit node typed with the defined PUT and
some of its ASlots filled by free unit nodes. The
other λ-UG is called the expansion of t. There is
no circumstantial triple in these two λ-UG because
they must not be part of the lexicographic defini-
tion of a LexUT.

Definition 9. A definitionDt of a PUT t is a triple
Dt

def
= (D−t , D

+
t , κ) where:

172



• D−t = {u−t , v−1 , . . . , v−n }(U−, l−, A−,∅,∅)
contains only free unit nodes;
• u−t is called the the central unit node of D−t ,

and is typed {t};
• the actantial triples of A− are of the form
(u−t , si, v

−
i ) where the set of si is a subset of

the ASlots of t;
• for all (u−t , si, v−i ) ∈ A−, the type of v−i cor-

responds to the signature of t for its ASlot si;
• D+t = {u+t , v+1 , . . . , v+n }(U+, l+, A+,∅,∅)

is called the expansion of t;
• κ is a bijection from {u−t , v−1 , . . . , v−n } to
{u+t , v+1 , . . . , v+n }, such that κ(u−t ) = u+t ,
and for all i, κ(v−i ) = v

+
i ;

• the type of u+t is called the genus of t and is
denoted genus(t).

Figure 2 is an example of lexicographic defini-
tion of PEIGNE: an instrument that a person X uses
to detangle the hair Y1 of a person Y2.

/peigne\

/person\/hair\/person\

possessorcombedperson

combedhair

/instrument\

/person\

/detangle\

/person\

/hair\

activity

agent object

partof

Figure 2: Lexicographic definition of PEIGNE.

Intuitively, a definition corresponds to two re-
ciprocal rules: (D−t , D

+
t , κ) and (D

+
t , D

−
t , κ

−1).
If there is the defined PUT in a UG then one may
infer its definition, and vice versa. Again, there
is currently an issue with the definitions with op-
tional ASlots. In fact, one would need two differ-
ent definitions, one with the ASlot filled, and one
with the ASlot not filled. For the purpose of our
presentation we will hold on the simple definition
of definitions given above, and simply represent
multiple definitions for a given PUT.

A set of PUTs definitions D may thus be added
to the unit types hierarchy:

Definition 10. A hierarchy of unit
types, denoted T , is a tuple T def=
(TD,ST , γγγ,γγγ1, γγγ0, CA,⊥uA, {ςςςt}t∈T,D) that

enables to construct a pre-ordered7 set of unit
types T∩ with their actantial structure, and with D
being definitions of some PUTs.

5 Semantics of UGs

5.1 Closure of a UG
The UGs framework makes the open-world as-
sumption, which means that a UG along with the
support on which it is defined represents explicit
knowledge, and that additional knowledge may be
inferred. Consider the UG G = (U, l, A,C,Eq)
defined over the support S illustrated in figure 3a.
Some knowledge in G is implicit:

1. two unit nodes u1 and u2 share a common
unit marker Mary, so one may infer that
they represent the same unit. (u1, u2) may
be added to Eq.

2. every PUT is a subtype of >, so one could
add > to all the types of unit nodes in G.

3. there are two unit nodes v1 and v2 that fill the
same ASlot activity of the unit node typed
/instrument\. So one may infer that v1 and
v2 represent the same unit. Said otherwise,
(v1, v2) may be added to Eq.

4. one may recognize the expansion of /peigne\

as defined in figure 2, so this type may
be made explicit in the unit node typed
/instrument\.

Each of the rules behind these cases explicit
knowledge in G. More generally, table 1 lists a
set of rules that one may use to explicit knowledge
in any UG. Cases 1 to 4 respectively correspond to
rules mrk-eq, u-typ, a-fp, and def-. The complete
set of rules defines the axiomatization of the UGs
semantics.

Definition 11 (Closing a UG). The process of ap-
plying the set of rules of figure 1 on G until none
of them has any effect is called closing G, and re-
sults in cl(G).

Figure 3b illustrates the closure of G, where all
of the inferable knowledge has been made explicit.

173



u-typ For all u ∈ U , and type(u) ∩. t∩ . . . . . . . . . . . . . . . . . . . . . Add t∩ in type(u)
u-bot For all u ∈ U , if ⊥ ∈ type(u), . . . . . . . . . . . . . . . . . . . . . . Error: inconsistency !
eq-ref For all u ∈ U . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add (u, u) in Eq
eq-sym For all (u1, u2) ∈ Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add (u2, u1) in Eq
eq-trans For all (u1, u2) and (u2, u3) ∈ Eq . . . . . . . . . . . . . . . . . . . Add (u1, u3) in Eq
eq-typ For all (u1, u2) ∈ Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add type(u1) in type(u2)
eq-mrk For all (u1, u2) ∈ Eq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add marker(u1) in marker(u2)
mrk-eq For all u1, u2 ∈ U , if marker(u1) ∩marker(u2) 6= ∅, Add (u1, u2) in Eq
a-eq-g For all (u1, s, v) ∈ A and (u1, u2) ∈ Eq . . . . . . . . . . . . . . Add (u2, s, v) in A
a-eq-a For all (u, s, v1) ∈ A and (v1, v2) ∈ Eq . . . . . . . . . . . . . . Add (u, s, v2) in A
a-fp For all (u, s, v1) and (u, s, v2) ∈ A . . . . . . . . . . . . . . . . . . . Add (v1, v2) in Eq
a-radix For all (u, s, v) ∈ A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add γγγ(s) in type(u)
a-obl For all u ∈ U and s ∈ ST , if γγγ1(s) ∈ type(u) . . . . . . . . Ensure there exists (u, s, v) in A
a-pro For all (u, s, v) ∈ A, if γγγ0(s) ∈ type(u), . . . . . . . . . . . . . . Error: inconsistency !
a-sig For all (u, s, v) ∈ A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add ςςς∩type(u)(s) in type(v)
c-eq-g For all (u1, s, v) ∈ C and (u1, u2) ∈ Eq . . . . . . . . . . . . . . Add (u2, s, v) in C
c-eq-c For all (u, s, v1) ∈ C and (v1, v2) ∈ Eq . . . . . . . . . . . . . . Add (u, s, v2) in C
c-dom For all (u, s, v) ∈ C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add domain(s) in type(u)
c-rng For all (u, s, v) ∈ C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Add range(s) in type(v)
c-sop For all (u, s1, v) ∈ C and s1

C. s2 . . . . . . . . . . . . . . . . . . . . Add (u, s2, v) in C
def+ For all Dt ∈ D, if (D−t , D+t , κ) is applicable and (D+t , D−t , κ−1) is not, apply (D−t , D+t , κ)
def- For all Dt ∈ D, if (D+t , D−t , κ−1) is applicable and (D−t , D+t , κ) is not, apply (D+t , D−t , κ−1)

Table 1: Semantics of the Unit Graphs.

/instrument\

/person\:Mary

/do\ /detangle\

/person\:Mary

/hair\
activity activity

agent

object

partof

u1 u2

v2v1

(a) Incomplete deep semantic representation G

{/peigne\,/instrument\,>}

{/person\,>}:Mary

{/detangle\,/do\,>} {/detangle\,/do\,>}

{/person\,>}:Mary

{/hair\,>}
activity activity

combedperson combedperson

possessor possessor

combedhair

agent agentagent agent

partof partof

object object

(b) Closure of the unit graph G

Figure 3: Closure of a UG.

{>, /person\}:Peter
u

{>, /person\, /woman\}
v

{>, /person\, /woman\} {>, /person\, /woman\} {/woman\}

mother mother mother

Figure 4: Illustration of an infinite closure of a simple Unit Graph

174



5.2 Reasoning with Homomorphisms
Now that we provided UGs with semantics and
that we have means to explicit knowledge, we
will define the prime decision problem of the UGs
framework: Considering two UGs G and H de-
fined over the same support S, does the knowledge
of G entails the knowledge of H ? The notion of
entailment may intuitively be defined for UGs as
follows: G entails H if and only if cl(G) includes
H .

There are two issues with this definition of en-
tailment. The first is that one needs to define what
is the precise meaning of inclusion of a UG. The
second is that cl(G) may be infinite, thus prevent-
ing decidability of entailment.

The answer to the first issue is straightforward
as we already defined the UGs homomorphism.
cl(G) includes H if and only if there is a homo-
morphism from H to cl(G).

Now, the second issue is more problematic.
Indeed, the closure of a finite UG may be in-
finite, thus preventing decidability of the deci-
sion problem. This problem is illustrated on a
simple example in figure 4, suppose one asserts
that deep semantic PUTs /person\ has a oblig-
atory ASlot mother with ςςς/person\(mother) =
/woman\, and of course, /woman\ . /person\.
Consider the UG G = ({u}, l,∅,∅, {(u, u)}),
such that marker(u) = Peter and type(u) =
{>, /person\}. One knows that the unit repre-
sented by u should have a unit of type /woman\

that fills its obligatory ASlot mother. So
rule add-a is applicable and one could add a
unit node v to represent that argument, with
(u,mother, v) ∈ A. Rule u-typ will then make
v be of type {>, /person\, /woman\}, and rule
add-a is again applicable on v. Thus cl(G)
is an infinite chain of unit nodes having type
{>, /person\, /woman\} and that fill the ASlot
mother of one another.

In the set of inference rules of table 1, only three
rules add unit nodes to the UG when triggered:
add-g,def- and def+. An open problem is thus to
find a sufficient condition on the unit types hier-
archy and the set of definitions so that we are en-
sured that the closure of a finite UG is finite.

6 Conclusion

We studied how to formalize, in a knowledge en-
gineering perspective, the dependency structures
and the linguistic predicates, in order to repre-

sent, manipulate, query, and reason with linguistic
knowledge.

We provided a rationale the introduction of the
new graph-based Unit Graphs (UGs) KR formal-
ism, and gave an overview of the foundational
concepts of the UGs framework. The linguistic
predicates are represented by unit types, and are
described in a unit types hierarchy. Circumstantial
relations are another kind of dependency relation
that are described in a hierarchy, and along with a
set of unit identifiers these two structures form a
UGs support on which UGs may be defined. As
UG have an underlying oriented labelled graph,
one could introduce the notion of UG homomor-
phism which is useful to define the applicability
of rules and the entailment problem.

The strong coherence in the unit types hierarchy
justifies the introduction of a deep semantic rep-
resentation level that is deeper than the semantic
level, and in which one may represent the actual
meaning of Lexical Unit Type (LexUT). It is at the
deep semantic level that the lexicographic defini-
tions of LexUTs shall be represented, and we gave
a definition of the definition of the associated Deep
Semantic Unit Type (DSemUT) of a LexUT.

Once we added a set of unit types definitions
in the unit types hierarchy, we introduced the se-
mantics of UGs and we posed the entailment prob-
lem for UGs. A UGs along with the support on
which it is defined represents explicit knowledge,
and additional knowledge may be inferred. We in-
troduced a set of entailment rules that one may use
to compute the closure cl(G) of a UGG, i.e., make
explicit all of the knowledge that is implicit. We
then defined the entailment problem of H by G
as a directed labelled graphs homomorphism prob-
lem between H , and the closure of G: cl(G). In
case cl(G) is finite, the entailment problem is thus
NP-complete.

In this paper we also sketched two directions for
future research:

• Many rules may be needed to represent
correspondences between the deep seman-
tic and the semantic representation levels in
case some Semantic ASlots are optional or
split. More research is needed to adapt the
SPARQL OPTIONAL and UNION construc-
tors in these cases. The same can be said
about definitions of DSemUTs that have op-
tional ASlots.
• The closure may be infinite for finite UGs. If

175



that occurs it makes the closure undecidable,
along with the entailment problem. We are
currently working of the definition of restric-
tions of the unit types hierarchy and the set of
definitions in order to ensure that any UG has
a finite closure.

References

Juri Apresian, Igor Boguslavsky, Leonid Iomdin,
Alexander Lazursky, Vladimir Sannikov, Victor
Sizov, and Leonid Tsinman. 2003. ETAP-3 linguis-
tic processor: A full-fledged NLP implementation
of the MTT. In First International Conference on
Meaning–Text Theory (MTT’2003), pages 279–288.

Lucie Barque and Alain Polguère. 2008. Enrichisse-
ment formel des définitions du Trésor de la Langue
Française informatisé (TLFi) dans une perspective
lexicographique. Lexique, 22.

Lucie Barque, Alexis Nasr, and Alain Polguère. 2010.
From the Definitions of the ’Trésor de la Langue
Française’ To a Semantic Database of the French
Language. In Fryske Akademy, editor, Proceedings
of the XIV Euralex International Congress, Fryske
Akademy, pages 245–252, Leeuwarden, Pays-Bas.
Anne Dykstra et Tanneke Schoonheim, dir.

Igor Boguslavsky, Leonid Iomdin, and Viktor Sizov.
2004. Multilinguality in ETAP-3: reuse of lexical
resources. In Gilles Sérasset, editor, Proc. COLING
2004 Multilingual Linguistic Ressources, pages 1–8,
Geneva, Switzerland. COLING.

Igor Boguslavsky. 2011. Semantic Analysis Based
on Linguistic and Ontological Resources. In Igor
Boguslavsky and Leo Wanner, editors, Proceedings
of the 5th International Conference on Meaning-
Text Theory (MTT’2011), pages 25–36, Barcelona,
Spain. INALCO.

Bernd Bohnet and Leo Wanner. 2010. Open source
graph transducer interpreter and grammar develop-
ment environment. In Proceedings of the Seventh
International Conference on Language Resources
and Evaluation (LREC’10), pages 19–21, Valletta,
Malta. European Language Resources Association
(ELRA).

Michel Chein and Marie-Laure Mugnier. 2008.
Graph-based Knowledge Representation: Computa-
tional Foundations of Conceptual Graphs. Springer-
Verlag New York Incorporated.

Sylvain Kahane and Alain Polguère. 2001. Formal
foundation of lexical functions. In Proceedings of
ACL/EACL 2001 Workshop on Collocation, pages
8–15.

Maxime Lefrançois and Fabien Gandon. 2011. ILexi-
cOn: Toward an ECD-Compliant Interlingual Lex-
ical Ontology Described with Semantic Web For-
malisms. In Igor Boguslavsky and Leo Wanner, ed-
itors, Proceedings of the 5th International Confer-
ence on Meaning-Text Theory (MTT’2011), pages
155–164, Barcelona, Spain. INALCO.

Maxime Lefrançois and Fabien Gandon. 2013a. The
Unit Graphs Framework: A graph-based Knowl-
edge Representation Formalism designed for the
Meaning-Text Theory. In Proceedings of the 6th
International Conference on Meaning-Text Theory
(MTT’2013), Prague, Czech Republic.

Maxime Lefrançois and Fabien Gandon. 2013b. The
Unit Graphs Mathematical Framework. Research
Report RR-8212, Inria.

Maxime Lefrançois. 2013. Représentation des con-
naissances du DEC: Concepts fondamentaux du for-
malisme des Graphes d’Unités. In Proceedings of
the 15ème Rencontre des Étudiants Chercheurs en
Informatique pour le Traitement Automatique des
Langues (RECITAL’2013), Les Sables d’Olonne,
France.

Veronika Lux-Pogodalla and Alain Polguère. 2011.
Construction of a French Lexical Network: Method-
ological Issues. In Proceedings of the International
Workshop on Lexical Resources, Ljubljana.

Igor Mel’čuk. 1996. Lexical Functions: A Tool for
the Description of Lexical Relations in a Lexicon.
In Leo Wanner, editor, Lexical Functions in Lexi-
cography and Natural Language Processing, pages
37–102. Benjamins Academic Publishers, Amster-
dam/Philadelphia.

Igor Mel’čuk. 2004. Actants in Semantics and Syntax
I: Actants in Semantics. Linguistics, 42(1):247–291.

Igor Mel’čuk. 2006. Explanatory combinatorial dic-
tionary. Open Problems in Linguistics and Lexicog-
raphy, pages 225–355.

Alain Polguère. 2009. Lexical systems: graph models
of natural language lexicons. Language resources
and evaluation, 43(1):41–55.

John F Sowa. 1984. Conceptual structures: infor-
mation processing in mind and machine. System
programming series. Addison-Wesley Pub., Read-
ing, MA.

176


