



















































MathQA: Towards Interpretable Math Word Problem Solving with Operation-Based Formalisms


Proceedings of NAACL-HLT 2019, pages 2357–2367
Minneapolis, Minnesota, June 2 - June 7, 2019. c©2019 Association for Computational Linguistics

2357

MathQA: Towards Interpretable Math Word Problem Solving
with Operation-Based Formalisms

Aida Amini1, Saadia Gabriel1, Shanchuan Lin1, Rik Koncel-Kedziorski1,
Yejin Choi1,2, and Hannaneh Hajishirzi1,2

1University of Washington
2Allen Institute for AI

{amini91, skgabrie, linsh, kedzior, yejin, hannaneh}@cs.washington.edu

Abstract

We introduce a large-scale dataset of math
word problems and an interpretable neural
math problem solver that learns to map prob-
lems to operation programs. Due to an-
notation challenges, current datasets in this
domain have been either relatively small in
scale or did not offer precise operational an-
notations over diverse problem types. We
introduce a new representation language to
model precise operation programs correspond-
ing to each math problem that aim to im-
prove both the performance and the inter-
pretability of the learned models. Using
this representation language, our new dataset,
MathQA, significantly enhances the AQuA
dataset with fully-specified operational pro-
grams. We additionally introduce a neu-
ral sequence-to-program model enhanced with
automatic problem categorization. Our exper-
iments show improvements over competitive
baselines in our MathQA as well as the AQuA
datasets. The results are still significantly
lower than human performance indicating that
the dataset poses new challenges for future re-
search. Our dataset is available at: https:
//math-qa.github.io/math-QA/.

1 Introduction

Answering math word problems poses unique
challenges for logical reasoning over implicit or
explicit quantities expressed in text. Math word-
problem solving requires extraction of salient in-
formation from natural language narratives. Auto-
matic solvers must transform the textual narratives
into executable meaning representations, a process
that requires both high precision and, in the case of
story problems, significant world knowledge.

As shown by the geometry question in Figure 1,
math word problems are generally narratives de-
scribing the progress of actions and relations over
some entities and quantities. The operation pro-

An artist wishes to paint a circular region on a square poster that
is 3.4 feet on a side. if the area of the circular region is to be 1/2

the area of the poster, what must be the radius of the circular
region in feet?

Math word problem

Square_area(3.4)

Operation 1

Multiply(11.56, 0.5)

Operation 2

Divide(5.78, const_pi)

Operation 3

Sqrt(1.8343)

Operation 4

3.4 
0.5

3.4 
0.5 

11.56

3.4, 0.5, 11.56, 5.78

Output == 1.3543

3.4 
0.5 

11.56 
5.78 

1.8343

Figure 1: Example of a math word problem aligned
with representation language by crowd-sourced anno-
tation

gram underlying the problem in Figure 1 high-
lights the complexity of the problem-solving task.
Here, we need the ability to deduce implied con-
stants (pi) and knowledge of domain-specific for-
mulas (area of the square).

In this paper, we introduce a new operation-
based representation language for solving math
word problems. We use this representation lan-
guage to construct MathQA1, a new large-scale,
diverse dataset of 37k English multiple-choice
math word problems covering multiple math do-
main categories by modeling operation programs
corresponding to word problems in the AQuA
dataset (Ling et al., 2017). We introduce a neu-
ral model for mapping problems to operation pro-
grams with domain categorization.

1The dataset is available at: https://math-qa.
github.io/math-QA/

https://math-qa.github.io/math-QA/
https://math-qa.github.io/math-QA/
https://math-qa.github.io/math-QA/
https://math-qa.github.io/math-QA/


2358

Most current datasets in this domain are small
in scale (Kushman et al., 2014) or do not offer pre-
cise operational annotations over diverse problem
types (Ling et al., 2017). This is mainly due to
the fact that annotating math word problems pre-
cisely across diverse problem categories is chal-
lenging even for humans, requiring background
math knowledge for annotators. Our representa-
tion language facilitates the annotation task for
crowd-sourcing and increases the interpretability
of the proposed model.

Our sequence-to-program model with catego-
rization trained on our MathQA dataset outper-
forms previous state-of-the-art on the AQuA test
set in spite of the smaller training size. These re-
sults indicate the superiority of our representation
language and the quality of the formal annotations
in our dataset. Our model achieves competitive
results on MathQA, but is still lower than human
performance indicating that the dataset poses new
challenges for future research. Our contributions
are as follows:
• We introduce a large-scale dataset of math word

problems that are densely annotated with oper-
ation programs
• We introduce a new representation language

to model operation programs corresponding to
each math problem that aim to improve both
the performance and the interpretability of the
learned models.
• We introduce a neural architecture leveraging

a sequence-to-program model with automatic
problem categorization, achieving competitive
results on our dataset as well as the AQuA
dataset

2 Background and Related Work

Large-Scale Datasets Several large-scale math
word problem datasets have been released in re-
cent years. These include Dolphin18K (Huang
et al., 2016), Math23K (Wang et al., 2017) and
AQuA. We choose the 2017 AQUA-RAT dataset
to demonstrate use of our representation language
on an existing large-scale math word problem
solving dataset. The AQuA provides over 100K
GRE- and GMAT-level math word problems. The
problems are multiple choice and come from a
wide range of domains.

The scale and diversity of this dataset makes
it particularly suited for use in training deep-
learning models to solve word problems. However

there is a significant amount of unwanted noise
in the dataset, including problems with incorrect
solutions, problems that are unsolvable without
brute-force enumeration of solutions, and ratio-
nales that contain few or none of the steps re-
quired to solve the corresponding problem. The
motivation for our dataset comes from the fact
we want to maintain the challenging nature of the
problems included in the AQuA dataset, while re-
moving noise that hinders the ability of neuralized
models to learn the types of signal neccessary for
problem-solving by logical reasoning.
Additional Datasets Several smaller datasets
have been compiled in recent years. Most of these
works have focused on algebra word problems, in-
cluding MaWPS (Koncel-Kedziorski et al., 2016),
Alg514 (Kushman et al., 2014), and DRAW-1K
(Upadhyay and Chang, 2017). Many of these
datasets have sought to align underlying equations
or systems of equations with word problem text.
While recent works like (Liang et al., 2018; Locas-
cio et al., 2016) have explored representing math
word problems with logical formalisms and reg-
ular expressions, our work is the first to provide
well-defined formalisms for representing interme-
diate problem-solving steps that are shown to be
generalizable beyond algebra problems.

Solving with Handcrafted Features Due to spar-
sity of suitable data, early work on math word
problem solving used pattern-matching to map
word problems to mathematical expressions (Bo-
brow, 1964; Charniak, 1968, 1969), as well as
non-neural statistical modeling and semantic pars-
ing approaches (Liguda and Pfeiffer, 2012).

Some effort has been made on parsing the prob-
lems to extract salient entities (Hosseini et al.,
2017). This approach views entities as contain-
ers, which can be composed into an equation tree
representation. The equation tree representation is
changed over time by operations implied by the
problem text.

Many early works focused on solving addi-
tion and subtraction problems (Briars and Larkin,
1984; Dellarosa, 1986; Bakman, 2007). As word
problems become more diverse and complex, we
require models capable of solving simultaneous
equation systems. This has led to an increas-
ing focus on finding semantic alignment of math
word problems and mentions of numbers (Roy and
Roth, 2018). The main idea behind those work is
to find all possible patterns of equations and rank



2359

them based on the problem.

Neural Word Problem Solvers Following the in-
creasing availability of large-scale datasets like
AQuA, several recent works have explored deep
neural approaches to math word problem solv-
ing (Wang et al., 2017). Our representation lan-
guage is motivated by exploration of using inter-
mediate formalisms in the training of deep neural
problem-solving networks, as is done in the work
of (Huang et al., 2018b) to solve problems with
sequence to sequence models. While this work fo-
cused on single-variable arithmetic problems, our
work introduces a formal language of operations
for covering more complex multivariate problems
and systems of equations.

Interpretability of Solvers While the statisti-
cal models with handcrafted features introduced
by prior work are arguably “interpretable” due
to the relative sparsity of features as well as
the clear alignments between inputs and outputs,
new neuralized approaches present new challenges
to model interpretability of math word problem
solvers (Huang et al., 2018a). While this area is
relatively unexplored, a prior approach to increas-
ing robustness and interpretability of math word
problem-solving models looks at using an adver-
sarial dataset to determine if models are learn-
ing logical reasoning or exploiting dataset biases
through pattern-matching (Liang et al., 2018).

3 Representing Math Word Problems

A math word problem consists of a narrative that
grounds mathematical formalisms in real-world
concepts. Solving these problems is a challenge
for both humans and automatic methods like neu-
ral network-based solvers, since it requires logical
reasoning about implied actions and relations be-
tween entities. For example, in Figure 2, opera-
tions like addition and division are not explicitly
mentioned in the word problem text, but they are
implied by the question. As we examine the con-
text of a math word problem, we have to select
arguments for operations based on which values
are unimportant for solving the problem and which
are salient. In Figure 2, the numeric value “100”
appears in the context but does not appear in the
underlying equation.

By selecting implied operations and arguments,
we can generate a program of intermediate steps
for solving a math word problem. Each step in-

Equation

If Lily's test scores are 85 , 89 , 80 and 95
out of 100 in 4 different subjects , what

will be her average score?

( 85 + 89 + 80 + 95 ) / 4 

Context and Question

a = 85 + 89

Step 1 

b = a + 80 

Step 2

c = b + 95  c / 4

Step 3  Step 4 

Intermediate steps for solving math problem

Figure 2: Example of a math word problem with its un-
derlying equation and intermediate steps for problem-
solving

volves a mathematical operation and its related ar-
guments. In Figure 2, there are three addition op-
erations and one division. As illustrated in the fig-
ure, operations can be dependant to the previous
ones by the values they use as arguments. Every
math word problem can be solved by sequentially
executing these programs of dependent operations
and arguments.

We define formalisms for expressing these se-
quential operation programs with a domain-aware
representation language. An operation program
in our representation language is a sequence with
n operations. The general form is shown below.
Each operation oi takes in a list of arguments a of
length i:

o1(a1)o2(a2)...on(an) (1)

Given this general definition, the problem in Fig-
ure 2 has the following representation2:

add1(85, 89)add2(174, 80)

add3(254, 95)divide4(349, 4)
(2)

Our representation language consists of 58 op-
erations and is designed considering the following
objectives.

• Correctness → Operation programs should
result in the correct solution when all oper-
ations are executed.

• Domain-awareness → Operation problems
should make use of both math knowledge and

2Here the arguments 174, 254 and 349 are the outputs of
operations 1, 2 and 3 respectively.



2360

domain knowledge associated with subfields
like geometry and probability to determine
which operations and arguments to use.

• Human interpretability → Each operation
and argument used to obtain the correct so-
lution should relate to part of the input word
problem context or a previous step in the op-
eration program.

Learning logical forms has led to success in other
areas of semantic parsing (Cheng et al., 2017;
Zelle and Mooney, 1996; Zettlemoyer and Collins,
2007, 2005) and is a natural representation for
math word problem-solving steps. By augment-
ing our dataset with these formalisms, we are able
to cover most types of math word problems3. In
contrast to other representations like simultane-
ous equations, our formalisms ensure that every
problem-solving step is aligned to a previous one.
There are three advantages to this approach. First,
we use this representation language to provide hu-
man annotators with clear steps for how a partic-
ular problem should be solved with math and do-
main knowledge. Second, our formalisms provide
neural models with a continuous path to execute
operations for problems with systems of equa-
tions, instead of forcing models to align equations
before problem solving. This reduces the possi-
bility of intermediate errors being propagated and
leading to a incorrect solution. Finally, by hav-
ing neural models generate a solution path in our
representation language before computing the fi-
nal solution, we are able to reconstruct the logi-
cal hops inferred by the model output, increasing
model interpretability.

4 Dataset

Our dataset (called MathQA) consists of 37,200
math word problems, corresponding lists of
multiple-choice options and aligned operation pro-
grams. We use problems in the AQuA dataset and
carefully annotate those problems with formal op-
eration programs.

Math problems are first categorized into math
domains using term frequencies (more details in
Section 5.2). These domains are used to prune
the search space of possible operations to align
with the word problem text. Figure 3 shows

3We omit high-order polynomials and problems where the
solutions are entirely nonnumeric.

Category #Prob. Avg #words #Vocab Avg #ops
Geometry 3,316 34.3 1,839 4.8
Physics 9,830 37.3 3,340 5.0
Probability 663 38.9 937 5.0
Gain-Loss 4,377 34.3 1,533 5.7
General 17,796 38.6 6,912 5.1
Other 1,277 31.3 1,425 4.7
All 37,259 37.9 6,664 5.3

Table 1: Statistics for our dataset; the total number of
operations in the dataset is 58.

the category-based hierarchies for operation for-
malisms.

We use crowdsourcing to carefully align prob-
lems with operation programs (Section 4.1). Ta-
ble 1 shows overall statistics of the dataset.4

4.1 Annotation using Crowd Workers
Annotating GRE level math problems can be a
challenging and time consuming task for humans.
We design a dynamic annotation platform to an-
notate math word problems with formal opera-
tion programs. Our annotation platform has the
following properties: (a) it provides basic math
knowledge to annotators, (b) it is dynamic by it-
eratively calculating intermediate results after an
operation submission, and (c) it employs quality
control strategies.

Dynamic Annotation Platform The annotators
are provided with a problem description, a list of
operations related to the problem category, and a
list of valid arguments. They iteratively select op-
erations and arguments until the problem is solved.

• Operation Selection The annotators are in-
structed to sequentially select an operation from
the list of operations in the problem category.
Annotators are provided with math knowledge
by hovering over every operation and getting
the related hint that consists of arguments, for-
mula and a short explanation of the operation.

• Argument Selection After selecting the oper-
ation the list of valid arguments are presented
4We also experimented with an automatic dynamic pro-

gramming approach to annotation that generates operation
programs for problems using numbers in the AQuA ratio-
nales. Due to the noise in the rationales, only 61% of those
problems pass our human validation. This is mainly due to
the fact that the rationales are not complete programs and fail
to explicitly describe all important numbers and operations
required to solve the problem. To maintain interpretability
of operation paths, we did not include automatic annotations
from our dataset and focus on operation programs derived by
crowdsourcing.



2361

Geometry PhysicsGain-Loss ProbabilityGeneral Other

Gain Percent

gain_amount()

...

loss_amount()

3D 2D...

volume_cube() circle_areasurface_cone()

multiply() log() gcd() units_digit() speed()

Operations

Constants

Count Geometry Numeric Probability

months_per_year hours_in_day pi right_angle twice dozen die_space coin_space

arg0 arg0 arg0 arg0 arg1 arg0

arg0 arg1arg0 arg1 arg0 arg0 arg0

permutation(). . . . . .

arg1 arg0

. . . . . . . . .. . .. . .

Categorization Hierarchy  
for Constants 

Figure 3: Category-based Hierarchies for Operation Formalisms

to the annotators to choose from. Valid argu-
ments consist of numbers in the problem, con-
stants in the problem category, and the previous
calculations. The annotators are restricted to se-
lect only from these valid arguments to prevent
having noisy and dangling numbers. After sub-
mission of an operation and the corresponding
arguments, the result of the operation is auto-
matically calculated and will be added as a new
valid argument to the argument list.

• Program Submission To prevent annotators
from submitting arbitrary programs, we en-
force restrictions to the final submission. Our
platform only accepts programs which include
some numbers from the problem, and whose fi-
nal calculation is very close to the correct nu-
meric solution.

High Quality Crowd Workers We dynami-
cally evaluate and employ high-quality annotators
through a collection of quality-control questions.
We take advantage of the annotation platform in
Figure Eight.5 The annotators are randomly eval-
uated through a pre-defined set of test questions,
and they have to maintain an accuracy threshold
to be able to continue their annotations. If an an-
notator’s accuracy drops below a threshold, their
previous annotations are labeled as untrusted and
will be added to the pool of annotations again.

Alignment Validation To further evaluate the
quality of the annotated programs, we leverage a
validation strategy to check whether the problems
and annotated programs are aligned or not. Ac-
cording to this strategy, at least 2 out of 3 valida-
tors should rank the operation program as valid
for it to be selected. The validation accuracy is
94.64% across categories.

5https://www.figure-eight.com

5 Models

We develop encoder-decoder neural models to
map word problems to a set of feasible operation
programs. We match the result of the executed op-
eration program against the list of multiple-choice
options given for a particular problem. The match-
ing solution is the final model output.

We frame the problem of aligning an operation
program with a math word problem as a neural
machine translation (NMT) task, where the word
problem x and gold operation program y form a
parallel text pair. The vocabulary of y includes
all possible operations and arguments in our rep-
resentation language.

5.1 Sequence-to-Program

For our initial sequence-to-program model, we
follow the attention-based NMT paradigm of
(Bahdanau et al., 2015; Cho et al., 2014). We
encode the source word problem text x =
(x1, x2, ..., xM ) using a bidirectional RNN en-
coder θenc. The decoder θdec predicts a distribu-
tion over the vocabulary and input tokens to gener-
ate each operation or argument in the target opera-
tion program. For our sequence-to-program model
vocabulary, we use informed generation, in which
the program tokens are generated separately from
the vocabulary of operations O or arguments A.

The encoded text is represented by a se-
quence of d-dimensional hidden states henc =
(henc1 , h

enc
2 , .., h

enc
M ), where M is the length of the

input text. A context vector ai is computed by
taking the weighted sum of the attention model
weights αt,i for each timestep t ∈ (1, 2, ..., T ) and
each encoder hidden state henci :

ai =
∑M

i=1 αt,ih
enc
i .

We compute the d-dimensional decoder hidden



2362

Multiply 50 <eos>...

Multiply 167

Figure 4: Architecture of sequence-to-program model with categorization. Shown with example problem “If the
average marks of three batches of 62 , 60 and 45 students respectively is 50 , 55 , 60 , then the average marks of
all the students is.”

state hdeci using a LSTM recurrent layer:

hdeci = LSTM(h
dec
i−1, yi−1, ai) (3)

At each timestep, we make a prediction for an
operator opi or argument argik, where k corre-
sponds to the index of the argument in operator
i’s argument list. This prediction is conditioned
on the previous tokens (y1, ..., yi−1) and the in-
put x to decode an entire operation program y =
(y1, y2, ..., yN ) of length N :

P (y|x) =
N∏
i=1

P (yi|y<i,x) (4)

P (yi|y<i,x) = g(f(hdeci , yi, ai)) (5)

Here f is a 1-layer feed-forward neural network
and g is the softmax function. During train-
ing time, we minimize the negative log-likelihood
(NLL) using the following objective:

L(θenc, θdec) = −logP (y|x; θenc, θdec) (6)

At test time, we only observe the input text when
predicting operation programs:

ŷ = argmaxyP (y|x) (7)

5.2 Categorized Sequence-to-Program Model
We extend our base sequence-to-program model
to integrate knowledge of math word problem do-
main categories. We modify the RNN decoder lay-
ers that compute the decoder hidden state to be

category-aware. Here, the category label c is de-
terministically computed by the category extractor
(explained below). It functions as a hard decision
switch that determines which set of parameters to
use for the hidden state computation:

hdeci = LSTMc(h
dec
i−1, yi−1, ai) (8)

The updated objective function from equation (7)
is shown below:

L(θenc, θdecc ) = −logP (y|x; θenc, θdecc ) (9)

The full model architecture is shown in Figure 4.

Domain-Specific Category Extraction We first
construct a lexicon of n-grams relating to a specific
domain. The lexicon is a list consisting of domain-
specific categories and associated n-grams. For
each domain category c in the lexicon, we se-
lect associated n-grams nc that occur frequently in
word problems belonging to domain category c,
but rarely appear in other domain categories. We
compute n-gram frequency fpc as the number of
n-grams associated with a category c appearing in
the text of a word problem p. We obtain a list
of potential categories for p by choosing all cat-
egories for which fpc > 0, and then assign a cat-
egory label to p based on which category has the
highest n-gram frequency.

5.3 Solving Operation Programs
Once a complete operation program has been de-
coded, each operator in the program is executed



2363

sequentially along with its predicted set of argu-
ments to obtain a possible solution. For each word
problem p and options o, we generate a beam of
the top n decoded operation programs. We exe-
cute each decoded program g to find the solution
from the list of options o of the problem. We first
choose options that are within a threshold of the
executed value of g. We select g as the predicted
solution by checking the number of selected op-
tions and the minimum distance between the exe-
cuted value of g and a possible option for p. For
the problems in AQuA that do not belong in any
category of MathQA, we randomly choose an op-
tion.

6 Experimental Setup

6.1 Datasets

Our dataset consists of 37k problems which are
randomly split in (80/12/8)% training/dev/test
problems. Our dataset significantly enhances the
AQuA dataset by fully annotating a portion of
solvable problems in the AQuA dataset into for-
mal operation programs.

We carefully study the AQuA dataset. Many
of the problems are near-duplicates with slight
changes to the math word problem stories or nu-
merical values since they are expanded from a set
of 30,000 seed problems through crowdsourcing
(Ling et al., 2017). These changes are not al-
ways reflected in the rationales, leading to incor-
rect solutions. There are also some problems that
are not solvable given current math word prob-
lem solving frameworks because they require a
level of reasoning not yet modeled by neural net-
works. Sequence problems, for example, require
understanding of patterns that are difficult to intuit
without domain knowledge like sequence formu-
las, and can only be solved automatically through
brute-force or guessing. Table 2 shows a full
breakdown of the AQuA dataset by solvability.6

6.2 Annotation Details

We follow the annotation strategy described in
Section 4 to formally annotate problems with op-
eration programs. 7

6There is overlap between unsolvable subsets. For exam-
ple, a sequence problem may also be a duplicate of another
problem in the AQuA dataset.

7We tried two other strategies of showing extra informa-
tion (rationales or end solutions) to annotators to facilitate
solving problems. However, our manual validation showed

Subset Train Valid
Unsolvable - No Words 37 0
Unsolvable - Sequence 1,991 4
Unsolvable - Requires Options 6,643 8
Unsolvable - Non-numeric 10,227 14
Duplicates 17,294 0
Solvable 65,991 229
Total 97,467 254

Table 2: Full original AQuA solvability statistics.

Annotator Agreements and Evaluations Our
expert evaluation of the annotation procedure for
a collection of 500 problems shows that 92% of
the annotations are valid. Additionally, it has 87%
agreement between the expert validation and the
crowd sourcing validation task.

Annotation Expansion The AQuA dataset con-
sists of a group of problems which share simi-
lar characteristics. These problems can be solved
with similar operation programs. We find closely
similar problems, replace numeric values with
generic numbers, and expand annotations to cover
more problems from the AQuA dataset. For simi-
larity, we use Levenshtein distance with a thresh-
old of 4 words in edit distance.

6.3 Model and Training Details

We use the official python implementation of
OpenNMT (Klein et al.). We choose a LSTM-
based encoder-decoder architecture. We use
Adam optimizer (Kingma and Ba, 2015), and the
learning rate for training is 0.001. The hidden size
for the encoder and decoder is set to d = 100.
Both the encoder and decoder have 2 layers. The
word embedding vectors are randomly initialized.
At inference time, we implemented a beam search
with beam size of 200 for AQuA and 100 for
MathQA.

The program vocabulary consists of the opera-
tions O in our representation language and valid
arguments A. For valid arguments, we do not use
their actual values since the space is very large. In-
stead, we keep a list of numbers according to their
source. Constants are predefined numbers that are
available to all problems. Problem numbers are
added to the list according to their order in the
problem text. Calculated numbers in the interme-

that annotators mostly used those extra information to artifi-
cially build an operation program without reading the prob-
lem.



2364

square_area(n0) divide(#0,n1) divide(#1,const_pi) sqrt(#2)

an artist wishes to paint a circular region on a square poster
that is 3.4 feet on a side . if the area of the region is to be 1 / 2
the area of the poster , what must be the radius of the circular

region in feet ?

Operation Sequence

Word Problem

3.4 .5

Figure 5: Example of an operation program generated by our Seq2prog model with categorization

Model MathQA AQuA
Random 20.0 20.0
AQuA Model - 36.4
Seq2prog 51.9 33.0
Seq2prog + cat 54.2 37.9

Table 3: Experimental results for accuracy on our
MathQA and AQuA test sets

diate steps are added to the list according to the
operation order.

7 Experimental Results

7.1 Results
Table 3 compares the performance of our
sequence-to-program models trained on MathQA
with baselines on MathQA and AQuA test sets.
The base model is referred to as “Seq2prog,” while
our model with categorization is “Seq2prog + cat.”
For accuracy, the performance was measured in
terms of how well the model would perform on
an actual math test.

We observe improvement for our “Seq2prog +
cat” model despite the fact that our training data
is proportionally smaller than the AQuA dataset,
and our model is much simpler than the state-of-
the-art model on this dataset. This indicates the ef-
fectiveness of our formal representation language
to incorporate domain knowledge as well as the
quality of the annotations in our dataset.

7.2 Analysis
Qualitative Analysis Table 5 and Figure 5 show
some examples of problems solved by our method.
We analyzed 50 problems that are solved wrongly
by our system on the MathQA dataset. Table 4
summarizes four major categories of errors.

The most common type of errors are problems
that need complicated or long chain of mathemat-
ical reasoning. For example, the first problem in
Table 4 requires reasoning that goes beyond one
sentence. Other errors are due to limitations in our

representation language. For example, the second
problem in Table 4 requires the factorization op-
eration which is not defined in our representation
language. Future work can investigate more do-
mains of mathematics such as logic, number fac-
tors, etc. Some errors are due to the slightly noisy
nature of our categorization strategy. For example,
the third problem in Table 4 is mistakenly catego-
rized as belonging to physics domain due to the
presence of words m, cm, liter in the problem text,
while the correct category for the problem is ge-
ometry. The final category of errors are due to
problems that do not have enough textual context
or erroneous problems (e.g., fourth problem in Ta-
ble 4).

Impact of Categorization Table 3 indicates that
our category-aware model outperforms the base
model on both AQuA and MathQA datasets. The
gain is relatively small because the current model
only uses categorization decisions as hard con-
straints at decoding time. Moreover, the prob-
lem categorization might be noisy due to our use
of only one mathematical interpretation for each
domain-specific n-gram. For example, the pres-
ence of the words “square” or “cube” in the text of
a math word problem indicate that the word prob-
lem is related to the geometry domain, but these
unigrams can also refer to an exponential opera-
tion (n2 or n3).

To measure the effectiveness of our categoriza-
tion strategy, we used human annotation over 100
problems. The agreement between human anno-
tators is 84% and their agreement with our model
is 74.5%. As a future extension of this work, we
would like to also consider the context in which
domain-specific n-grams appear.

Discussions As we mentioned in section 3, the
continuous nature of our formalism allows us to
solve problems requiring systems of equations.
However, there are other types of word prob-



2365

Error type Problem
Hard problems (45%) Jane and Ashley take 8 days and 40 days respectively to complete a project when they

work on it alone. They thought if they worked on the project together, they would
take fewer days to complete it. During the period that they were working together,
Jane took an eight day leave from work. This led to Jane’ s working for four extra
days on her own to complete the project. How long did it take to finish the project?

Limitation in representation lan-
guage (25%)

How many different positive integers are factors of 25?

Categorization errors (12.5%) A cistern of capacity 8000 litres measures externally 3.3 m by 2.6 m by 1.3 m and its
walls are 5 cm thick. The thickness of the bottom is:

Incorrect or insufficient problem
text) (17.5%)

45 x ? = 25 % of 900

Table 4: Examples of mistakes made by our system. The reason of the errors are underlined.

Problem : A rectangular field is to be fenced on three
sides leaving a side of 20 feet uncovered. if the area of
the field is 10 sq. feet, how many feet of fencing will be
required?
Operations : divide(10,20), multiply(#0,
const_2), add(20, 1)
Problem : How long does a train 110m long running
at the speed of 72 km/hr takes to cross a bridge 132m
length?
Operations : add(110, 132), multiply(72,
const_0.2778), divide(#0, #1),
floor(#2)

Table 5: Problems solved correctly by Seq2prog+cat
model.

lems that are currently unsolvable or have multi-
ple interpretations leading to multiple correct solu-
tions. While problems that can only be solved by
brute-force instead of logical reasoning and non-
narrative problems that do not fit the definition of
a math word problem (in Table 2 these appear as
“no word”) are removed from consideration, there
are other problems that are beyond the scope of
current models but could pose an interesting chal-
lenge for future work. One example is the domain
of sequence problems. Unlike past word problem-
solving models, our models incorporate domain-
specific math knowledge, which is potentially ex-
tensible to common sequence and series formulas.

8 Conclusion

In this work, we introduced a representation lan-
guage and annotation system for large-scale math
word problem-solving datasets that addresses un-
wanted noise in these datasets and lack of for-
mal operation-based representations. We demon-
strated the effectiveness of our representation lan-
guage by transforming solvable AQuA word prob-
lems into operation formalisms. Experimental re-

sults show that both our base and category-aware
sequence-to-program models outperform base-
lines and previous results on the AQuA dataset
when trained on data aligned with our representa-
tion language. Our representation language pro-
vides an extra layer of supervision that can be
used to reduce the influence of statistical bias in
datasets like AQuA. Additionally, generated op-
eration programs like the examples in figure 5
demonstrate the effectiveness of these operation
formalisms for representing math word problems
in a human interpretable form.

The gap between the performance of our mod-
els and human performance indicates that our
MathQA still maintains the challenging nature of
AQuA problems. In future work, we plan to ex-
tend our representation language and models to
cover currently unsolvable problems, including se-
quence and high-order polynomial problems.

Acknowledgements This research was sup-
ported by ONR (N00014-18-1-2826), NSF (IIS
1616112), Allen Distinguished Investigator
Award, and gifts from Google, Allen Institute for
AI, Amazon, and Bloomberg. We thank Marti
A. Hearst, Katie Stasaski, and the anonymous
reviewers for their helpful comments.

References
D. Bahdanau, K. Cho, and Y. Bengio. 2015. Machine

translation by jointly learning to align and translate.
In ICLR.

Yefim Bakman. 2007. Robust understanding of word
problems with extraneous information. In arXiv
preprint math/0701393.

Daniel G Bobrow. 1964. Natural language input for a
computer problem solving system.



2366

Diane J Briars and Jill H Larkin. 1984. An integrated
model of skill in solving elementary word problems.
In Cognition and instruction 1(3), pages 245–296.

Eugene Charniak. 1968. Calculus word problems.
Ph.D. thesis, Massachusetts Institute of Technology.

Eugene Charniak. 1969. Computer solution of calcu-
lus word problems. In Proceedings of the 1st inter-
national joint conference on Artificial intelligence,
pages 303–316. Morgan Kaufmann Publishers Inc.

Jianpeng Cheng, Siva Reddy, Vijay Saraswat, and
Mirella Lapata. 2017. Learning structured natural
language representations for semantic parsing. In
Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 44–55. Association for Compu-
tational Linguistics.

Kyunghyun Cho, Bart van Merriënboer, Dzmitry Bah-
danau, and Yoshua Bengio. 2014. On the properties
of neural machine translation: Encoderdecoder ap-
proaches. In Proceedings of SSST-8, Eighth Work-
shop on Syntax, Semantics and Structure in Statisti-
cal Translation, pages 103–111.

Denise Dellarosa. 1986. A computer simulation of
childrens arithmetic word-problem solving. In Be-
havior Research Methods, Instruments, Computers
18(2), pages 147–154.

Mohammad Javad Hosseini, Hannaneh Hajishirzi,
Oren Etzioni, and Nate Kushman. 2017. Learning
to solve arithmetic word problems with verb catego-
rization. In Proceedings of the 2014 Conference on
Empirical Methods in Natural Language Processing
(EMNLP).

Danqing Huang, Jing Liu, Chin-Yew Lin, and Jian Yin.
2018a. Neural math word problem solver with rein-
forcement learning. In Proceedings of the 27th In-
ternational Conference on Computational Linguis-
tics, pages 213–223.

Danqing Huang, Shuming Shi, Chin-Yew Lin, Jian Yin,
and Wei-Ying Ma. 2016. How well do comput-
ers solve math word problems? large-scale dataset
construction and evaluation. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics (ACL).

Danqing Huang, Jin-Ge Yao, Chin-Yew Lin, Qingyu
Zhou, and Jian Yin. 2018b. Using intermediate rep-
resentations to solve math word problems. In Pro-
ceedings of the 56th Annual Meeting of the Associa-
tion for Computational Linguistics.

Diederik P. Kingma and Jimmy Ba. 2015. Adam: A
method for stochastic optimization. In the 3rd Inter-
national Conference for Learning Representations
(ICLR).

G. Klein, Y. Kim, Y. Deng, J. Senellart, and A. M.
Rush. Opennmt: Open-source toolkit for neural ma-
chine translation. ArXiv e-prints.

Rik Koncel-Kedziorski, Subhro Roy, Aida Amini, Nate
Kushman, and Hannaneh Hajishirzi. 2016. Mawps:
A math word problem repository. In NAACL.

Nate Kushman, Yoav Artzi, Luke Zettlemoyer, and
Regina Barzilay. 2014. Learning to automatically
solve algebra word problems. In Proceedings of the
52nd Annual Meeting of the Association for Compu-
tational Linguistics (ACL).

Chao-Chun Liang, Yu-Shiang Wong, Yi-Chung Lin,
and Keh-Yih Su. 2018. A meaning-based statistical
english math word problem solver. In Proceedings
of NAACL-HLT 2018.

Christian Liguda and Thies Pfeiffer. 2012. Modeling
math word problems with augmented semantic net-
works. In International Conference on Application
of Natural Language to Information Systems, pages
247–252. Springer.

Wang Ling, Dani Yogatama, Chris Dyer, and Phil Blun-
som. 2017. Program induction by rationale genera-
tion: Learning to solve and explain algebraic word
problems. In Proceedings of ACL.

Nicholas Locascio, Karthik Narasimhan, Eduardo
DeLeon, Nate Kushman, and Regina Barzilay. 2016.
Neural generation of regular expressions from nat-
ural language with minimal domain knowledge.
In Proceedings of the 2016 Conference on Em-
pirical Methods in Natural Language Processing
(EMNLP), pages 247–252. Association for Compu-
tational Linguistics.

Subhro Roy and Dan Roth. 2018. Mapping to declar-
ative knowledge for word problem solving. In Pro-
ceedings of NAACL-HLT 2018.

Shyam Upadhyay and Ming-Wei Chang. 2017. An-
notating derivations: A new evaluation strategy and
dataset for algebra word problems. In Proceedings
of the 15th Conference of the European Chapter of
the Association for Computational Linguistics.

Yan Wang, Xiaojiang Liu, and Shuming Shi. 2017.
Deep neural solver for math word problems. In Pro-
ceedings of the 2017 Conference on Empirical Meth-
ods in Natural Language Processing (EMNLP).

John M. Zelle and Raymond J. Mooney. 1996. Learn-
ing to parse database queries using inductive logic
programming. In AAAI/IAAI, pages 1050–1055.
AAAI Press/MIT Press.

Luke Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classification with probabilistic categorial gram-
mars. In UAI 05, Proceedings of the 21st Confer-
ence in Uncertainty in Artificial Intelligence, pages
658–666.

Luke Zettlemoyer and Michael Collins. 2007. Online
learning of relaxed ccg grammars for parsing to log-
ical form. In Proceedings of the 2007 Joint Con-
ference on Empirical Methods in Natural Language



2367

Processing and Computational Natural Language
Learning (EMNLPCoNLL), pages 678–687. Associ-
ation for Computational Linguistics.


