











































Text Generation with Exemplar-based Adaptive Decoding


Proceedings of NAACL-HLT 2019, pages 2555–2565
Minneapolis, Minnesota, June 2 - June 7, 2019. c©2019 Association for Computational Linguistics

2555

Text Generation with Exemplar-based Adaptive Decoding

Hao Peng⇤ Ankur P. Parikh} Manaal Faruqui} Bhuwan Dhingra|⇤ Dipanjan Das}
 Paul G. Allen School of Computer Science & Engineering, University of Washington, Seattle, WA

} Google AI Language, New York, NY
| School of Computer Science, Carnegie Mellon University, Pittsburgh, PA

hapeng@cs.washington.edu, {aparikh,mfaruqui,dipanjand}@google.com,
bdhingra@andrew.cmu.edu

Abstract
We propose a novel conditioned text gener-
ation model. It draws inspiration from tra-
ditional template-based text generation tech-
niques, where the source provides the con-
tent (i.e., what to say), and the template influ-
ences how to say it. Building on the success-
ful encoder-decoder paradigm, it first encodes
the content representation from the given in-
put text; to produce the output, it retrieves
exemplar text from the training data as “soft
templates,” which are then used to construct
an exemplar-specific decoder. We evaluate
the proposed model on abstractive text sum-
marization and data-to-text generation. Em-
pirical results show that this model achieves
strong performance and outperforms compara-
ble baselines.

1 Introduction

Conditioned text generation is the essence of
many natural language processing (NLP) tasks,
e.g., text summarization (Mani, 1999), machine
translation (Koehn, 2009), and data-to-text gener-
ation (Kukich, 1983; McKeown, 1992; Reiter and
Dale, 1997). In its common neural sequence-to-
sequence formulation (Sutskever et al., 2014; Cho
et al., 2014), an encoder-decoder architecture is
used. The decoder generates the text autoregres-
sively, token-by-token, conditioning on the feature
representations encoded from the source, typically
with attention (Bahdanau et al., 2015) and copy
mechanisms (Gu et al., 2016; See et al., 2017).
This paradigm is capable of generating fluent ab-
stractive text, but in an uncontrolled and some-
times unreliable way, often producing degenerate
outputs and favoring generic utterances (Vinyals
and Le, 2015; Li et al., 2016).

The encoder-decoder approach differs con-
siderably from earlier template-based meth-

⇤ Work done during internship at Google.

ods (Becker, 2002; Foster and White, 2004; Re-
iter et al., 2005; Gatt and Reiter, 2009, inter alia),
where the source content is filled into the slots
of a handcrafted template. These solutions of-
fer higher generation precision compared to neu-
ral approaches (Wiseman et al., 2017), but tend
to lack the naturalness of neural systems, and are
less scalable to open domain settings, where the
number of required templates can be prohibitively
large.

To sidestep the scalability problems with hand-
crafted templates, it has been proposed to use simi-
lar training samples as exemplars, to guide the de-
coding process (Gu et al., 2018; Guu et al., 2018;
Weston et al., 2018; Pandey et al., 2018; Cao et al.,
2018a, inter alia).1 In general, existing methods
accomplish this by (a) using traditional informa-
tion retrieval (IR) techniques for exemplar extrac-
tion (e.g., TF-IDF), and then (b) concatenating the
exemplar to the source as additional inputs, allow-
ing the decoder to attend over and copy from both.

We propose a different strategy for using exem-
plars. For motivation, Figure 1 shows a source-
target pair together with its exemplar from the Gi-
gaword dataset (Graff et al., 2003). The target is a
summary of the source sentence, and the exemplar
is retrieved from the training set (§3.2).2 There
is word overlap between the exemplar and the de-
sired output, which would be easily captured by an
attention/copy mechanism (e.g. Norway and aid).
Despite this, ideally, the model should also exploit
the structural and stylistic aspects to produce an
output with a similar sentence structure, even if
the words are different.

Indeed, in traditional templates, the source

1The term exemplar indicates a training instance used to
help generation. We aim to distinguish from “templates,”
since here no explicit slot-filling procedure is involved.

2We use the training target as the exemplar, whose source
is most similar to the current input. §3.2 describes the details.



2556

Source: Norway said Friday it would

give Zimbabwe 40 million kroner (7.02

million dollars, 4.86 million euros)

in aid to help the country deal with

a lack of food and clean drinking

water and a cholera outbreak.

Exemplar: Norway boosts earthquake

aid to Pakistan.

Target: Norway grants aid of 4.86

million euros to Zimbabwe.

Figure 1: A source-target pair from Gigaword training
set, along with its exemplar.

is supposed to determine “what to say,” while
the templates aim to address “how to say it,”
reminiscent of the classical content selection and
surface realization pipeline (Reiter and Dale,
1997). For instance, an ideal template for this
example might look as follows:

grants aid of to

In the neural formulation, the “how to say
it” aspect is primarily controlled by the decoder.

Inspired by the above intuition, we propose
exemplar-based adaptive decoding, where a cus-
tomized decoder is constructed for each exem-
plar. This is achieved by letting the exemplars
to directly influence decoder parameters through
a reparameterization step (§3.1). The adaptive de-
coder can be used as a drop-in replacement in the
encoder-decoder architecture. It offers the poten-
tial to better incorporate the exemplars’ structural
and stylistic aspects into decoding, without exces-
sive increase in the amount of parameters or com-
putational overhead.

We empirically evaluate our approach on ab-
stractive text summarization and data-to-text gen-
eration (§4), on which most of the recent efforts on
exemplar-guided text generation have been stud-
ied. On three benchmark datasets, our approach
outperforms comparable baselines, and achieves
performance competitive with the state of the art.
The proposed method can be applicable in many
other conditioned text generation tasks. Our im-
plementation is available at https://homes.
cs.washington.edu/˜hapeng.

2 Background

This section lays out the necessary background
and notations for further technical discussion.
We begin with conditioned text generation and
the encoder-decoder framework (Sutskever et al.,
2014; Cho et al., 2014). In the interest of the no-

tation clarity, §3 will use an Elman network (El-
man, 1990) as a running example for the decoder,
which is briefly reviewed in §3. The proposed
technique generalizes to other neural network ar-
chitectures (§3.3).

Conditioned text generation and the encoder-
decoder architecture. Our discussion centers
around conditioned text generation, i.e., the model
aims to output the target y = y1y2 . . . yT given
the source input x = x1x2 . . . xS , both of which
are sequences of tokens. Each token xi, yi takes
one value from a vocabulary V . x and y could
vary depending on the tasks, e.g., they will respec-
tively be articles and summaries for text summa-
rization; and for data-to-text generation, x would
be structured data, which can sometimes be lin-
earized (Lebret et al., 2016; Wiseman et al., 2018,
inter alia), and y is the output text. We aim to
learn a (parameterized) conditional distribution of
the target text y given the source x,

p
�
y | x

�
=

TY

t=1

p
�
yt | y<t,x

�
, (1)

where y<t = y1 . . . yt�1 is the prefix of y up to
the (t� 1)th token (inclusive).

The probability of each target token is usually
estimated with a softmax function:

p (yt | y<t,x) =
exph>t�1wytP
y exph

>
t�1wy

. (2)

wy denotes a learned vector for token y 2 V . ht�1
depends on y<t and x, and is computed by a func-
tion which we will describe soon.

A typical implementation choice for computing
ht is the encoder-decoder architecture (Sutskever
et al., 2014). More specifically, an encoder g✓
first gathers the feature representations from the
source x; then a decoder f� is used to compute
the ht feature vectors:

ht = f�
⇣
yt,ht�1,g✓(x)

⌘
. (3)

✓ and � are, respectively, the collections of pa-
rameters for the encoder and the decoder, both
of which can be implemented as recurrent neu-
ral networks (RNNs) such as LSTMs (Hochre-
iter and Schmidhuber, 1997) or GRUs (Cho et al.,
2014), or the transformer (Vaswani et al., 2017).
In Sutskever et al. (2014), the dependence of f�
on g✓ is made by using the last hidden state of the
encoder as the initial state of the decoder. Such
dependence can be further supplemented with at-

https://homes.cs.washington.edu/~hapeng
https://homes.cs.washington.edu/~hapeng


2557

tention (Bahdanau et al., 2015) and copy mecha-
nisms (Gu et al., 2016; See et al., 2017), as we
will do in this work.
§3 introduces how we use exemplars to inform

decoding, by dynamically constructing the de-
coder’s parameters �. For the notation clarity, we
will use the Elman network as a running example,
reviewed below.

Elman networks. Given input sequence x, an
Elman network (Elman, 1990) computes the hid-
den state at time step t from the previous one and
the current input token by

ht = tanh
�
Pht�1 +Qvt

�
, (4)

where P and Q are learned d ⇥ d parameter ma-
trices (with d being the hidden dimension), and vt
is the embedding vector for token xt. We omit the
bias term for clarity.

3 Method

This section introduces the proposed method in
detail. Our aim is to use exemplars to inform the
decoding procedure (i.e., how to say it). To ac-
complish this, we reparameterize the decoder’s pa-
rameters with weighted linear sums, where the co-
efficients are determined by an exemplar. The de-
coder is adaptive, in the sense that its parameters
vary according to the exemplars. The adaptive de-
coder can be used as a drop-in replacement in the
encoder-decoder architecture. Before going into
details, let us first overview the high-level genera-
tion procedure of our model. Given source text x,
the model generates an output as follows:

1. Run a standard encoder to gather the content
representations g✓(x) from the source.

2. Retrieve its exemplar zx, and compute
exemplar-specific coefficients (§3.2).

3. Construct the adaptive decoder parameters
� (§3.1), using the coefficients computed at
step 2. Then the output is generated by
applying the adaptive decoder followed by
a softmax, just as in any other encoder-
decoder architecture.

Aiming for a smoother transition, we will first de-
scribe step 3 in §3.1, and then go back to discuss
step 2 in §3.2. For clarity, we shall assume that the
decoder is implemented as an Elman network (El-
man, 1990; Equation 4). The proposed technique
generalizes to other neural network architectures,
as we will discuss later in §3.3.

3.1 Reparameterizing the RNN Decoder

At its core, the exemplar-specific adaptive decoder
involves a reparameterization step, which we now
describe. We focus on the parameters of the Elman
network decoder, i.e., P and Q in Equation 4.

Parameter construction with linear sums. We
aim to reparameterize the pair of matrices (P,Q),
in a way that they are influenced by the exemplars.

Let us first consider an extreme case, where one
assigns a different pair of parameter matrices to
each exemplar, without any sharing. This leads
to an unreasonably large amount of parameters,
which are difficult to estimate reliably.3

We instead construct P and Q from a set of pre-
defined parameters matrices. Take P for example,
it is computed as the weighted sum of Pi matrices:

P =
rX

i=1

�iPi, (5)

where Pi 2 Rd⇥d, with d being the size of the
hidden states. r is a hyperparameter, determining
the number of Pi matrices to use.4 The summa-
tion is weighted by the coefficients �i, which are
computed from the exemplar zx. For clarity, the
dependence of both P and �i on zx is suppressed
when the context is clear.

Equation 5 constructs the decoder’s parameter
matrix P using a linear combination of {Pi}ri=1.
The exemplar informs this procedure through
the coefficients �i’s, the detailed computation of
which is deferred to §3.2. The other matrix Q can
be similarly constructed by Q =

P
i �iQi.

Rank-1 constraints. In the above formulation,
the number of parameters is still r times more than
a standard Elman network, which can lead to over-
fitting with a limited amount of training data. Be-
sides, it would be more interesting to compare the
adaptive decoder to a standard RNN under a com-
parable parameter budget. Therefore we want to
further limit the amount of parameters. This can
be achieved by forcing the ranks of Pi and Qi to
be 1, since it then takes 2d parameters to form each
of them, instead of d2. More formally, we upper-

3 The amount of parameters grows linearly with the num-
ber of possible exemplars, which, as we will soon discuss in
§3.2, can be as large as the training set.

4Instead of choosing r empirically, we set it equal to d
in the experiments. Please see the end of §3.1 for a related
discussion.



2558

bound their ranks by construction:

Pi = u
(p)
i ⌦ v

(p)
i . (6)

a ⌦ b = ab> denotes the outer product of two
vectors; u(p)i and v

(p)
i are learned d-dimensional

vectors. Each Qi can be similarly constructed by
a separate set of vectors Qi = u

(q)
i ⌦ v

(q)
i .

Let Up,Vp 2 Rd⇥r denote the stack of u(p)i ,
v(p)i vectors, i.e.,

Up =
h
u(p)1 , . . . ,u

(p)
r

i
, (7a)

Vp =
h
v(p)1 , . . . ,v

(p)
r

i
. (7b)

Equations 5 and 6 can be compactly written as

P = Up ⇤ V
>
p . (8)

where ⇤ is the diagonal matrix built from the r-
dimensional coefficient vector � = [�1, . . . ,�r]>:

⇤ = diag(�) =

2

64
�1

. . .
�r

3

75 . (9)

The construction of Q is similar, but with a differ-
ent set of parameters matrices Uq and Vq:5

Q = Uq ⇤ V
>
q . (10)

Note that, despite their similarities to SVD at a
first glance, Equations 8 and 10 are not perform-
ing matrix factorization. Rather, we are learn-
ing {Up,Vp,Uq,Vq} directly; P, Q, {Pi}, and
{Qi} are never explicitly instantiated (Peng et al.,
2017, 2018c).

To summarize, we reparameterize P and Q as
interpolations of rank-1 matrices. By the fact
that rank(A + B)  rank(A) + rank(B), the
ranks of P and Q are upper-bounded by r. As
pointed out by Krueger and Memisevic (2017), the
parameter matrices of a trained RNN tend to have
full rank. Therefore, in the experiments, we set
r equal to the hidden size d, aiming to allow the
adaptive decoder to use full-rank matrices in the
recurrent computation. Yet, if one holds a priori
beliefs that the matrices should have lower ranks,
using r < d could be desirable. When r = d, an
adaptive RNN constructed by the above approach
has 4d2 parameters, which is comparable to the
2d2 parameters in a standard Elman network.6

5The bias term in the Elman network b can be constructed
as b = B�, with B being a learned d⇥ r matrix.

6This does not include the bias term, which contributes
additional d2 parameters to the former, and d to the latter.

3.2 Incorporating Exemplars
We now discuss the computation of coefficients �,
through which the exemplars inform the decoder
construction (Equations 8 and 10). Before detail-
ing the neural network architecture, we begin by
describing the exemplar retrieval procedure.

Retrieving exemplars zx. Intuitively, similar
source texts should hold similar targets. There-
fore, given source input x, we use the training
target as its exemplar zx, whose source is most
similar to x.7 To compute the similarities between
source texts, we use bag-of-words (BOW) features
and cosine similarity. We extract the top-1 exem-
plar for each instance. This step is part of the pre-
processing, and we do not change the exemplars
as the training proceeds.

There are, of course, many other strategies
to get the exemplars, e.g., using handcrafted or
heuristically created hard templates (Reiter et al.,
2005; Becker, 2002; Foster and White, 2004, in-
ter alia), randomly sampling multiple training in-
stances (Guu et al., 2018), or learning a neural
reranker (Cao et al., 2018a). Using more sophisti-
cally extracted exemplars is definitelly interesting
to explore, which we defer to future work.

Computing coefficients. Next we describe the
computation of �, the r-dimensional coefficient
vector, which is used to construct the adaptive de-
coder (Equations 8 and 10).

Intuitively, the rank-1 matrices (Pi’s and Qi’s
in Equation 6 and thereafter) can be seen as cap-
turing different aspects of the generated text. And
� determines how much each of them contributes
to the adaptive decoder construction. A natural
choice to calculate � is to use the similarities be-
tween the exemplar and each of the aspects.

To accomplish this, we run a RNN encoder over
zx, and use the last hidden state as its vector rep-
resentation a.8 We further associate each (Pi,Qi)
pair with a learned vector ci; and then �i is com-
puted as the similarity between a and ci, using an
inner product �i = a>ci. More compactly,

� = Ca, (11)

with C = [c1, . . . , cr]>.
7 The source of an exemplar is only used in the retrieval

and never fed into the encoder-decoder model. For a training
instance, we additionally disallow using its own target as the
exemplar.

8For clarity, the dependence of a on the exemplar zx is
suppressed, just as �.



2559

Algorithm 1 Adaptive decoder construction.
1: procedure (x)
2: Retrieve the exemplar zx . §3.2
3: Compute zx’s representation a . §3.2
4: Compute coefficients � . Eq.11
5: Construct the decoder f� . Eqs.8, 10
6: end procedure

Closing this section, Algorithm 1 summarizes
the procedure to construct an adaptive decoder.

3.3 Discussion.

Although we’ve based our discussion on Elman
networks so far, it is straightforward to apply
this method to its gated variants (Hochreiter and
Schmidhuber, 1997; Cho et al., 2014, inter alia),
and other quasi-/non-recurrent neural architec-
tures (Bradbury et al., 2017; Vaswani et al., 2017;
Peng et al., 2018a, inter alia). Throughout the ex-
periments, we will be using an adaptive LSTM
decoder (§4). As a drop-in replacement in the
encoder-decoder architecture, it introduces a rea-
sonable amount of additional parameters and com-
putational overhead, especially when one uses a
small encoder for the exemplar (i.e., the sizes
of the ci vectors in Equation 11 are small). It
can benefit from the highly-optimized GPU imple-
mentations, e.g., CuDNN, since it uses the same
recurrent computation as a standard nonadaptive
RNN.

In addition to the neural networks, the adap-
tive decoder requires access to the full training
set due to the retrieval step. In this sense it is
semi-parametric.9 The idea to dynamically con-
struct the parameters is inspired by Hypernet-
works (Ha et al., 2017) and earlier works therein.
It proves successful in tasks such as classifica-
tion (Jia et al., 2016; Liu et al., 2017) and machine
translation (Platanios et al., 2018). Many recent
template-based generation models include the ex-
emplars as content in addition to the source, and
allow the decoder to attend over and copy from
both (Gu et al., 2018; Guu et al., 2018; Weston
et al., 2018; Pandey et al., 2018; Cao et al., 2018a,
inter alia). We compare to this approach in the
experiments, and show that our model offers fa-

9 Nothing prohibits adaptively constructing other compo-
nents of the model, e.g., the encoder g✓ . Yet, our motivation
is to use exemplars to inform how to say it, which is primar-
ily determined by the decoder (in contrast, the encoder relates
more to selecting the content).

NYT Giga Wikibio

# inst.
Train 92K 3.8M 583K
Dev. 9K 190K 73K
Test 9,706 1,951 73K

Avg. len. Src. 939.0 31.4 N/ATgt. 48.6 8.2 26.0

Table 1: Number of instances and average text lengths
for the datasets used in the experiments. The lengths
are averaged over training instances.

vorable performance, and that they can potentially
be combined to achieve further improvements.

4 Experiments

This section empirically evaluates the proposed
model on two sets of text generation tasks: ab-
stractive summarization (§4.2) and data-to-text
generation (§4.3). Before heading into the exper-
imental details, we first describe the architectures
of the compared models in §4.1.

4.1 Compared Models
In addition to previous works, we compare to the
following baselines, aiming to control for con-
founding factors due to detailed implementation
choices.

• SEQ2SEQ. The encoder-decoder architec-
ture enhanced with attention and copy mech-
anisms. The encoder is implemented with
a bi-directional LSTM (BiLSTM; Hochreiter
and Schmidhuber, 1997; Schuster and Pali-
wal, 1997; Graves, 2012), and the decoder a
uni-directional one. We tie the input embed-
dings of both the encoder and the decoder, as
well as the softmax weights (Press and Wolf,
2017). We use beam search during evalua-
tion, with length penalty (Wu et al., 2016).

• ATTEXP. It is based on SEQ2SEQ. It en-
codes, attends over, and copies from the ex-
emplars, in addition to the source inputs.

Our model using the adaptive decoder (ADADEC)
closely builds upon SEQ2SEQ. It uses a dynami-
cally constructed LSTM decoder, and does not use
attention or copy mechanisms over the encoded
exemplars. The extracted exemplars are the same
as those used by ATTEXP. To ensure fair com-
parisons, we use comparable training procedures
and regularization techniques for the above mod-
els. The readers are referred to the appendix for
further details such as hyperparameters.



2560

4.2 Text Summarization
Datasets. We empirically evaluate our model on
two benchmark text summarization datasets:

• Annotated Gigaword corpus (Gigaword;
Graff et al., 2003; Napoles et al., 2012). Gi-
gaword contains news articles sourced from
various news services over the last two
decades. To produce the dataset, we follow
the split and preprocessing by Rush et al.
(2015), and pair the first sentences and the
headlines in the news articles. It results in
a 3.8M/190K/1,951 train/dev./test split. The
average lengths of the source and target texts
are 31.4 and 8.2, respectively.

• New York Times Annotated Corpus
(NYT; Sandaus, 2008). It contains news
articles published between 1996 and 2007
by New York Times. We use the split and
preprocessing by Durrett et al. (2016).10

Following their effort, we evaluate on a
smaller portion of the test set, where the
gold summaries are longer than 50 tokens.
We further randomly sample 9,000 instances
from the training data for validation, result-
ing in a 91,834/9,000/3,452 train/dev./test
split. Compared to Gigaword, the inputs and
targets in NYT are much longer (averaging
939.0 and 48.6, respectively).

Table 1 summarizes some statistics of the datasets.
We note that some recent works use a differ-
ent split of the NYT corpus (Paulus et al., 2018;
Gehrmann et al., 2018), and thus are not compara-
ble to the models in Table 3. We decide to use the
one by Durrett et al. (2016) because their prepro-
cessing script is publicly available.

For both datasets, we apply byte-paired encod-
ing (BPE; Sennrich et al., 2016), which proves to
improve the generation of proper nouns (Fan et al.,
2018).

Empirical results. Table 2 compares the models
on Gigaword test set in ROUGE F1 (Lin, 2004).11

By using adaptive decoders, our model
(ADADEC) improves over SEQ2SEQ by more
than 1.1 ROUGE scores. Cao et al. (2018b) and
the FULL model by Cao et al. (2018a) hold the
best published results. The former uses extensive
handcrafted features and relies on external infor-
mation extraction and syntactic parsing systems;

10https://github.com/gregdurrett/
berkeley-doc-summarizer.

11Version 1.5.5 of the official script.

Model RG-1 RG-2 RG-L

Open-NMT 35.0 16.6 32.4
†Cao et al., 2018a (BASIC) 36.0 17.1 33.2
†Cao et al., 2018a (FULL) 37.0 19.0 34.5
?Cao et al. (2018b) 37.3 17.6 34.2

This work (SEQ2SEQ) 35.8 17.5 33.5
†This work (ATTEXP) 36.0 17.7 33.1
†This work (ADADEC) 37.3 18.5 34.7

Table 2: Text summarization performance in
ROUGE F1 scores (dubbed as RG-X) on Gigaword
test set (§4.2). † denotes the models using retrieved
exemplars, while ? uses handcrafted features. Bold
font indicates best performance. Open-NMT numbers
are taken from Cao et al. (2018a).

while the latter uses additional encoding, atten-
tion and copy mechanisms over the exemplars
extracted using a novel neural reranker. ADADEC
achieves better or comparable performance to
the state-of-the-art models, without using any
handcrafted features or reranking techniques. The
BASIC model by Cao et al. (2018a) ablates the
reranking component from their FULL model, and
uses the top exemplar retrieved by the IR system.
Therefore it is a more comparable baseline to
ours. ADADEC outperforms it by more than 1.3
ROUGE scores. Surprisingly, we do not observe
interesting improvements by ATTEXP over the
sequence-to-sequence baseline. We believe that
our model can benefit from better extracted
exemplars by, e.g., applying a reranking system.
Such exploration is deferred to future work.

The NYT experimental results are summarized
in Table 3. We follow previous works and re-
port limited-length ROUGE recall values.12 Dur-
rett et al. (2016) is an extractive model, and Paulus
et al. (2018) an abstractive approach based on rein-
forcement learning. Our ADADEC model outper-
forms both. We observe similar trends when com-
paring ADADEC to the SEQ2SEQ and ATTEXP
baselines, with the exception that ATTEXP does
improve over SEQ2SEQ.

4.3 Data-to-text Generation
Data-to-text generation aims to generate textual
descriptions of structured data, which can be

12 Following Durrett et al. (2016) and Paulus et al. (2018),
we truncate the predictions to the lengths of the gold sum-
maries, and evaluate ROUGE recall, instead of F1 on full-
length predictions.

https://github.com/gregdurrett/berkeley-doc-summarizer
https://github.com/gregdurrett/berkeley-doc-summarizer


2561

Model ROUGE-1 ROUGE-2

Durrett et al. (2016) 42.2 24.9
Paulus et al. (2018) 42.9 26.0

This work (SEQ2SEQ) 41.9 25.1
†This work (ATTEXP) 42.5 25.7
†This work (ADADEC) 43.2 26.4

Table 3: NYT text summarization test performance
in ROUGE recall values. This is a smaller portion of
the original test data, after filtering out instances with
summaries shorter than 50 tokens (§4.2; Durrett et al.,
2016). † denotes the models using retrieved exemplars,
and bold font indicates best performance.

seen as a table consisting of a collection of
records (Liang et al., 2009). For a given entity,
each record is an (attribute, value) tuple. Figure 2
shows an example for entity Jacques-Louis David.
The table specifies the entity’s properties with tu-
ples (born, 30 August 1748), (nationality, French),
and so forth. The table is paired with a description,
which the model is supposed to generate using the
table as input. We refer the readers to Lebret et al.
(2016) for more details about the task.

Dataset and implementation details. We use
the Wikibio dataset (Lebret et al., 2016). It is au-
tomatically constructed by pairing the tables and
the opening sentences of biography articles from
English Wikipedia. We follow the split and pre-
processing provided along with the dataset, with
around 583K/73K/73K train/dev./test instances.
Following Lebret et al. (2016), we linearize the
tables, such that we can conveniently train the
sequence-to-sequence style models described in
§4.1. Table 1 summarizes some statistics of the
dataset.

In contrast to the text summarization experi-
ment (§4.2), we do not apply BPE here. Fur-
ther, the word embeddings are initialized with
GloVe (Pennington et al., 2014; fixed during
training), and not tied with the softmax weights.
In addition to the models introduced in §4.1, we
additionally compare to ADADEC+ATTEXP, aim-
ing to study whether the adaptive decoder can fur-
ther benefit from attention and copy mechanisms
over the exemplars.

Empirical results. Following Liu et al. (2018)
we report ROUGE-4 and BLEU scores (Papineni

Jacques-Louis David (30 August 1748 – 29
December 1825) was a French painter in the
Neoclassical style.

Figure 2: A training instance from the Wikibio dataset.
It consists of a collections of records for Jacques-Louis
David (top), and a piece of textual description (bottom).

et al., 2002).13 Table 4 summarizes the data-
to-text generation results on the Wikibio test set.
Overall, we observe similar trends to those in
the summarization experiment (§4.2): by attend-
ing over and copying from the exemplars, AT-
TEXP improves upon the SEQ2SEQ baseline by
around 0.6 absolute scores. Also utilizing ex-
emplar information, our ADADEC model out-
performs SEQ2SEQ by a larger margin: 1.3 for
ROUGE-4 and 1.1 for BLEU. We further study
whether we can get further improvements by com-
bining both. ADADEC+ATTEXP achieves around
0.5 absolute improvements over ADADEC, less
than those by ATTEXP over SEQ2SEQ. This pro-
vides evidence that, to some extend, the ways AT-
TEXP and ADADEC incorporate exemplar infor-
mation might be complementary. Wiseman et al.
(2018) is a template-motivated model based on a
semi-Markov model. Liu et al. (2018) hold the
current state-of-the-art results. They encode the
table structures by using (a) position and filed em-
beddings, and (b) structure-aware attention and
gating techniques. These techniques are beyond
the scope of this work, which focuses mainly on
the decoding end.

13We use the script by Lin (2004) to calculate the
ROUGE score, and the mteval script for BLEU: https://
github.com/moses-smt/mosesdecoder/blob/
master/scripts/generic/mteval-v13a.pl.

https://github.com/moses-smt/mosesdecoder/blob/master/scripts/generic/mteval-v13a.pl
https://github.com/moses-smt/mosesdecoder/blob/master/scripts/generic/mteval-v13a.pl
https://github.com/moses-smt/mosesdecoder/blob/master/scripts/generic/mteval-v13a.pl


2562

Model RG-4 BLEU

Wiseman et al. (2018) 38.6 34.8
Liu et al. (2018) 41.7 44.7

This work (SEQ2SEQ) 39.3 42.5
†This work (ATTEXP) 40.0 43.1
†This work (ADADEC) 40.6 43.6
†This work (ADADEC+ATTEXP) 41.1 44.1

Table 4: Data-to-text generation performance in
ROUGE-4 and BLEU on the Wikibio test set (§4.3). †
indicates the models using retrieved exemplars.

5 Analysis

We now qualitatively evaluate our model, by
studying how its outputs are affected by using
different exemplars. Figure 3 shows two ran-
domly sampled Gigaword development instances.
It compares the outputs by ADADEC (i.e., without
attention/copy over exemplars; §4.1) when receiv-
ing different exemplars, controlling for the same
source inputs. In each example, Exemplar 1
is retrieved by the system (i.e., a training target;
§3.2); while the remaining ones are produced by
the authors, by modifying the first one in styles
and sometimes introducing distractions in the con-
tent.

In the top example, the model includes peo-
ple into the subject (Three vs. Three people) un-
der the influence by Exemplar 2; Exemplar
3 changes the tense and adds some distraction
by changing the place from Britain to Canada.
The model follows the tense switch, but gets con-
fused by the distraction, and decides to let a train
in southern Europe collide into North America,
which it should not. Looking at the bottom exam-
ple, the model in general follows the exemplar in
using noun adjuncts or prepositional phrases (e.g.,
new home sales vs. sales of new homes), except
the first one. Perhaps confused by the distraction
in Exemplar 3, the model makes a judgment on
the specific amount of growth, but gets it wrong.

6 Related Work

Exemplar-based generation. Partly inspired by
traditional template-based generation (Kukich,
1983; Reiter and Dale, 1997, inter alia), many re-
cent efforts have been devoted to augmenting text
generation models with retrieved exemplars (Ho-
dosh et al., 2013; Mason and Charniak, 2014;
Song et al., 2016; Lin et al., 2017, inter alia).

Source: A Portuguese train derailed

in the northern region of Oporto on

Wednesday, killing three people...

Exemplar 1: Two die in a Britain

train collision.

Output 1: Three killed in Portuguese

train derailment.

Exemplar 2: Two people were

killed in Britain train collision.

Output 2: Three people killed in
Portuguese train derailment.

Exemplar 3: A train collision in

Canada killed two people.

Output 3: Portuguese train derails

in northern Mexico killing three.
Source: Sales of new homes in the

U.S. increased by 11.8 percent in

May, the biggest gain in 26 years...

Exemplar 1: U.S. sales of new homes

up strongly in March.

Output 1: US new home sales rise

11.8 percent in May.

Exemplar 2: The sales of new homes

in the U.S. grow strongly.

Output 2: Sales of new homes in US
rise in May.

Exemplar 3: U.S. economic statis-

tics: new home sales grow by 2.5

percent.

Output 3: US new home sales grow 26
percent in May.

Figure 3: Two randomly sampled Gigaword devel-
opment instances used for qualitative evaluation (§5).
Exemplar 1’s are retrieved by the system (§3.2),
while the remaining ones are produced by the authors.
Notable exemplars changes are highlighted in bold
purple, and output changes in italic yellow.

Without committing to an explicit slot-filling pro-
cess, a typical method is to include exemplars
as additional inputs to the sequence-to-sequence
models (Gu et al., 2018; Pandey et al., 2018; Guu
et al., 2018, inter alia). Wiseman et al. (2018)
took a different approach and used a semi-Markov
model to learn templates.

Dynamic parameter construction. The idea of
using a smaller network to generate weights for a
larger one dues back to Stanley et al. (2009) and
Koutnik et al. (2010), mainly under the evolution
computing context. It is later revisited with rep-
resentation learning (Moczulski et al., 2015; Fer-
nando et al., 2016; Al-Shedivat et al., 2017, in-
ter alia), and successfully applied to classifica-



2563

tion (Jia et al., 2016; Liu et al., 2017) and machine
translation (Platanios et al., 2018). It also relates to
the meta-learning set-up (Thrun and Pratt, 1998).

7 Conclusion

We presented a text generation model using
exemplar-informed adaptive decoding. It repa-
rameterizes the decoder using the information
gathered from retrieved exemplars. We experi-
mented with text summarization and data-to-text
generation, and showed that the proposed model
achieves strong performance and outperforms
comparable baselines on both. The proposed
model can be applicable in other conditioned text
generation tasks. We release our implementa-
tion at https://homes.cs.washington.
edu/˜hapeng.

Acknowledgments

We thank Antonios Anastasopoulos, Ming-Wei
Chang, Michael Collins, Jacob Devlin, Yichen
Gong, Luheng He, Kenton Lee, Dianqi Li,
Zhouhan Lin, Slav Petrov, Oscar Täckström,
Kristina Toutanova, and other members of the
Google AI language team for the helpful discus-
sion, and the anonymous reviewers for their valu-
able feedback.

References
Maruan Al-Shedivat, Avinava Dubey, and Eric P.

Xing. 2017. Contextual explanation networks.
arXiv:1705.10301.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proc. of ICLR.

Tilman Becker. 2002. Practical, template–based natu-
ral language generation with tag. In Proceedings of
the Sixth International Workshop on Tree Adjoining

Grammar and Related Frameworks.

James Bradbury, Stephen Merity, Caiming Xiong, and
Richard Socher. 2017. Quasi-Recurrent Neural Net-
work. In Proc. of ICLR.

Ziqiang Cao, Wenjie Li, Sujian Li, and Furu Wei.
2018a. Retrieve, rerank and rewrite: Soft template
based neural summarization. In Proc. of ACL.

Ziqiang Cao, Furu Wei, Wenjie Li, and Sujian Li.
2018b. Faithful to the original: Fact aware neural
abstractive summarization. In Proc. of AAAI.

Kyunghyun Cho, Bart Van Merriënboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger

Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using RNN encoder-decoder
for statistical machine translation. In Proc. of
EMNLP.

Greg Durrett, Taylor Berg-Kirkpatrick, and Dan Klein.
2016. Learning-based single-document summariza-
tion with compression and anaphoricity constraints.
In Proc. of ACL.

Jeffrey L. Elman. 1990. Finding structure in time.
Cognitive science, 14(2):179–211.

Angela Fan, David Grangier, and Michael Auli. 2018.
Controllable abstractive summarization. In Pro-
ceedings of the 2nd Workshop on Neural Machine

Translation and Generation.

Chrisantha Fernando, Dylan Banarse, Malcolm
Reynolds, Frederic Besse, David Pfau, Max Jader-
berg, Marc Lanctot, and Daan Wierstra. 2016.
Convolution by evolution: Differentiable pattern
producing networks. In Proceedings of the Genetic
and Evolutionary Computation Conference 2016.

Mary Ellen Foster and Michael White. 2004. Tech-
niques for text planning with xslt. In Proceeedings
of the Workshop on NLP and XML: RDF/RDFS and

OWL in Language Technology.

Albert Gatt and Ehud Reiter. 2009. SimpleNLG: A re-
alisation engine for practical applications. In Pro-
ceedings of the 12th European Workshop on Natural

Language Generation.

Sebastian Gehrmann, Yuntian Deng, and Alexander M
Rush. 2018. Bottom-up abstractive summarization.
In Proc. of EMNLP.

David Graff, Junbo Kong, Ke Chen, and Kazuaki
Maeda. 2003. English Gigaword Second Edition.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Jiatao Gu, Zhengdong Lu, Hang Li, and Victor OK
Li. 2016. Incorporating copying mechanism in
sequence-to-sequence learning. In Proc. of ACL.

Jiatao Gu, Yong Wang, Kyunghyun Cho, and Vic-
tor OK Li. 2018. Search engine guided non-
parametric neural machine translation. In Proc. of
AAAI.

Kelvin Guu, Tatsunori B Hashimoto, Yonatan Oren,
and Percy Liang. 2018. Generating sentences by
editing prototypes. TACL, 6:437–450.

David Ha, Andrew Dai, and Quoc V Le. 2017. Hyper-
networks. In Proc. of ICLR.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. 2015. Deep residual learning for image recog-
nition. In Proc. of CVPR.

https://homes.cs.washington.edu/~hapeng
https://homes.cs.washington.edu/~hapeng


2564

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Micah Hodosh, Peter Young, and Julia Hockenmaier.
2013. Framing image description as a ranking
task: Data, models and evaluation metrics. JAIR,
47(1):853–899.

Xu Jia, Bert De Brabandere, Tinne Tuytelaars, and
Luc V Gool. 2016. Dynamic filter networks. In
Proc. of NeuralIPS.

Diederik Kingma and Jimmy Ba. 2015. Adam: A
method for stochastic optimization. In Proc. of
ICLR.

Durk P Kingma, Tim Salimans, and Max Welling.
2015. Variational dropout and the local reparame-
terization trick. In Proc. of NeuralIPS.

Philipp Koehn. 2009. Statistical machine translation.
Cambridge University Press.

Jan Koutnik, Faustino Gomez, and Jürgen Schmidhu-
ber. 2010. Evolving neural networks in compressed
weight space. In Proceedings of the Annual Confer-
ence on Genetic and Evolutionary Computation.

David Krueger and Roland Memisevic. 2017. Regu-
larizing rnns by stabilizing activations. In Proc. of
ICLR.

Karen Kukich. 1983. Design of a knowledge-based re-
port generator. In Proc. of ACL.

Rémi Lebret, David Grangier, and Michael Auli. 2016.
Neural text generation from structured data with
application to the biography domain. In Proc. of
EMNLP.

Jiwei Li, Michel Galley, Chris Brockett, Jianfeng Gao,
and Bill Dolan. 2016. A diversity-promoting ob-
jective function for neural conversation models. In
Proc. of NAACL.

Percy Liang, Michael I. Jordan, and Dan Klein. 2009.
Learning semantic correspondences with less super-
vision. In Proc. of ACL.

Chin-Yew Lin. 2004. Rouge: A package for automatic
evaluation of summaries. In Text Summarization
Branches Out: Proceedings of the ACL-04 Work-

shop.

Kevin Lin, Dianqi Li, Xiaodong He, Zhengyou Zhang,
and Ming-ting Sun. 2017. Adversarial ranking for
language generation. In Proc. of NeuralIPS.

Pengfei Liu, Xipeng Qiu, and Xuanjing Huang. 2017.
Dynamic compositional neural networks over tree
structure. In Proc. of IJCAI.

Tianyu Liu, Kexiang Wang, Lei Sha, Baobao Chang,
and Zhifang Sui. 2018. Table-to-text generation by
structure-aware seq2seq learning. In Proc. of AAAI.

Minh-Thang Luong, Hieu Pham, and Christopher D.
Manning. 2015. Effective approaches to attention-
based neural machine translation. In Proc. of
EMNLP.

Inderjeet Mani. 1999. Advances in automatic text sum-
marization. MIT press.

Rebecca Mason and Eugene Charniak. 2014. Domain-
specific image captioning. In Proc. of CoNLL.

Kathleen McKeown. 1992. Text generation. Cam-
bridge University Press.

Marcin Moczulski, Misha Denil, Jeremy Appleyard,
and Nando de Freitas. 2015. ACDC: A structured
efficient linear layer. arXiv:1511.05946.

Courtney Napoles, Matthew Gormley, and Benjamin
Van Durme. 2012. Annotated gigaword. In Pro-
ceedings of the Joint Workshop on Automatic Knowl-

edge Base Construction and Web-scale Knowledge

Extraction.

Gaurav Pandey, Danish Contractor, Vineet Kumar, and
Sachindra Joshi. 2018. Exemplar encoder-decoder
for neural conversation generation. In Proc. of ACL.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei
jing Zhu. 2002. Bleu: a method for automatic eval-
uation of machine translation. In Proc. of ACL.

Romain Paulus, Caiming Xiong, and Richard Socher.
2018. A deep reinforced model for abstractive sum-
marization. In Proc. of ICLR.

Hao Peng, Roy Schwartz, Sam Thomson, and Noah A.
Smith. 2018a. Rational recurrences. In In Proc. of
EMNLP.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, and Noah A. Smith. 2018b.
Backpropagating through structured argmax using a
spigot. In Proc. of ACL.

Hao Peng, Sam Thomson, Swabha Swayamdipta, and
Noah A. Smith. 2018c. Learning joint semantic
parsers from disjoint data. In Proc. of NAACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Emmanouil Antonios Platanios, Mrinmaya Sachan,
Graham Neubig, and Tom Mitchell. 2018. Contex-
tual parameter generation for universal neural ma-
chine translation. In Proc. of EMNLP.

Ofir Press and Lior Wolf. 2017. Using the output em-
bedding to improve language models. In Proc. of
EACL.

Ehud Reiter and Robert Dale. 1997. Building applied
natural language generation systems. Natural Lan-
guage Engineering, 3(1):57–87.



2565

Ehud Reiter, Somayajulu Sripada, Jim Hunter, Jin Yu,
and Ian Davy. 2005. Choosing words in computer-
generated weather forecasts. Artificial Intelligence,
167(1-2):137–169.

Alexander M. Rush, Sumit Chopra, and Jason Weston.
2015. A neural attention model for abstractive sen-
tence summarization. In Proc. of EMNLP.

Evan Sandaus. 2008. The New York Times Annotated
Corpus. LDC corpora. Linguistic Data Consortium.

M. Schuster and K.K. Paliwal. 1997. Bidirectional
recurrent neural networks. Transactions on Signal
Proccesing, 45(11):2673–2681.

Abigail See, Peter J. Liu, and Christopher D. Manning.
2017. Get to the point: Summarization with pointer-
generator networks. In Proc. of ACL.

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Neural machine translation of rare words with
subword units. In Proc. of ACL.

Yiping Song, Rui Yan, Xiang Li, Dongyan Zhao, and
Ming Zhang. 2016. Two are better than one: An
ensemble of retrieval- and generation-based dialog
systems. arXiv:1610.07149.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overfitting. JMLR, 15(1):1929–1958.

K. O. Stanley, D. B. D’Ambrosio, and J. Gauci. 2009.
A hypercube-based encoding for evolving large-
scale neural networks. Artificial Life, 15(2):185–
212.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In Proc. of NeuralIPS.

Sebastian Thrun and Lorien Pratt, editors. 1998.
Learning to Learn. Kluwer Academic Publishers.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Ł ukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In Proc. of NeuralIPS.

Oriol Vinyals and Quoc Le. 2015. A neural conversa-
tional model. In Proc. of ICML.

Jason Weston, Emily Dinan, and Alexander Miller.
2018. Retrieve and refine: Improved sequence gen-
eration models for dialogue. In Proceedings of the
International Workshop on Search-Oriented Con-

versational AI.

Sam Wiseman, Stuart Shieber, and Alexander Rush.
2017. Challenges in data-to-document generation.
In Proc. of EMNLP.

Sam Wiseman, Stuart M Shieber, and Alexander M
Rush. 2018. Learning neural templates for text gen-
eration. In Proc. of EMNLP.

Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V.
Le, Mohammad Norouzi, Wolfgang Macherey,
Maxim Krikun, Yuan Cao, Qin Gao, Klaus
Macherey, Jeff Klingner, Apurva Shah, Melvin
Johnson, Xiaobing Liu, ukasz Kaiser, Stephan
Gouws, Yoshikiyo Kato, Taku Kudo, Hideto
Kazawa, Keith Stevens, George Kurian, Nishant
Patil, Wei Wang, Cliff Young, Jason Smith, Ja-
son Riesa, Alex Rudnick, Oriol Vinyals, Greg Cor-
rado, Macduff Hughes, and Jeffrey Dean. 2016.
Google’s neural machine translation system: Bridg-
ing the gap between human and machine translation.
arXiv:1609.08144.


