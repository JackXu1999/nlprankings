



















































Building a Production Model for Retrieval-Based Chatbots


Proceedings of the 1st Workshop on NLP for Conversational AI, pages 32–41
Florence, Italy, August 1, 2019. c©2019 Association for Computational Linguistics

32

Building a Production Model for Retrieval-Based Chatbots

Kyle Swanson1†, Lili Yu2, Christopher Fox2, Jeremy Wohlwend2, Tao Lei2
1Massachusetts Institute of Technology

2ASAPP, Inc.
swansonk@mit.edu

{liliyu, cdfox, jeremy, tao}@asapp.com

Abstract

Response suggestion is an important task for
building human-computer conversation sys-
tems. Recent approaches to conversation mod-
eling have introduced new model architectures
with impressive results, but relatively little at-
tention has been paid to whether these models
would be practical in a production setting. In
this paper, we describe the unique challenges
of building a production retrieval-based con-
versation system, which selects outputs from
a whitelist of candidate responses. To address
these challenges, we propose a dual encoder
architecture which performs rapid inference
and scales well with the size of the whitelist.
We also introduce and compare two methods
for generating whitelists, and we carry out
a comprehensive analysis of the model and
whitelists. Experimental results on a large,
proprietary help desk chat dataset, including
both offline metrics and a human evaluation,
indicate production-quality performance and
illustrate key lessons about conversation mod-
eling in practice.

1 Introduction

Predicting a response given conversational context
is a critical task for building open-domain chat-
bots and dialogue systems. Recently developed
conversational systems typically use either a gen-
erative or a retrieval approach for producing re-
sponses (Wang et al., 2013; Ji et al., 2014; Vinyals
and Le, 2015; Serban et al., 2015; Li et al., 2016;
Xing et al., 2016; Deb et al., 2019). While both
of these approaches have demonstrated strong per-
formance in the literature, retrieval methods of-
ten enjoy better control over response quality than
generative approaches. In particular, such meth-
ods select outputs from a whitelist of candidate
responses, which can be pre-screened and revised

†Work done primarily while an intern at ASAPP, Inc.

for desired qualities such as sentence fluency and
diversity.

Most previous work on retrieval models has
concentrated on designing neural architectures to
improve response selection. For instance, sev-
eral works have improved model performance by
encoding multi-turn conversation context instead
of single-turn context (Serban et al., 2015; Zhou
et al., 2016; Wu et al., 2017). More recent ef-
forts (Zhou et al., 2018; Zhang et al., 2018) have
explored using more advanced architectures, such
as the Transformer (Vaswani et al., 2017), to bet-
ter learn the mapping between the context and the
candidate responses.

Relatively little effort, however, has been de-
voted to the practical considerations of using such
models in a real-world production setting. For ex-
ample, one critical consideration rarely discussed
in the literature is the inference speed of the de-
ployed model. While recent methods introduce
rich computation, such as cross-attention (Zhou
et al., 2018), to improve the modeling between the
conversational context and candidate response, the
model outputs must be re-computed for every pair
of context and response. As a consequence, these
models are not well-suited to a production setting
where the size of the response whitelist can easily
extend into the thousands.

Another critical concern is the whitelist selec-
tion process and the associated retrieval evalua-
tion. Most prior work have reported Recall@k on
a small set of randomly selected responses which
include the true response sent by the agent (Lowe
et al., 2015; Zhou et al., 2016, 2018; Wu et al.,
2017; Zhang et al., 2018). However, this over-
simplified evaluation may not provide a useful in-
dication of performance in production, where the
whitelist is not randomly selected, is significantly
larger, and may not contain the target response.

In this paper, we explore and evaluate model



33

and whitelist design choices for building retrieval-
based conversation systems in production. We
present a dual encoder architecture that is opti-
mized to select among as many as 10,000 re-
sponses within a couple tens of milliseconds.
The model makes use of a fast recurrent net-
work implementation (Lei et al., 2018) and multi-
headed attention (Lin et al., 2017) and achieves
over a 4.1x inference speedup over traditional en-
coders such as LSTM (Hochreiter and Schmidhu-
ber, 1997). The independent dual encoding al-
lows pre-computing the embeddings of candidate
responses, thereby making the approach highly
scalable with the size of the whitelist. In addi-
tion, we compare two approaches for generating
the response candidates, and we conduct a com-
prehensive analysis of our model and whitelists on
a large, real-world help desk dataset, using human
evaluation and metrics that are more relevant to
use in a production setting.

2 Related Work

This paper extends the line of work on conversa-
tional retrieval models for multi-turn response se-
lection (Lowe et al., 2015; Al-Rfou et al., 2016;
Zhou et al., 2016, 2018; Wu et al., 2016, 2017;
Yan et al., 2016; Lu et al., 2017; Zhang et al.,
2018; Shalyminov et al., 2018; Deb et al., 2019;
Yang et al., 2019). Our model is most similar to
Lowe et al. (2015), who construct the context of
the conversation by concatenating all previous ut-
terances. They use an RNN to separately encode
the context and each candidate response, and they
then compute a matching score between the con-
text and response representations to determine the
best response for that context.

Other recent work has explored more complex
methods of incorporating information from the
context of a conversation. Serban et al. (2015) and
Zhou et al. (2016) employ a hierarchical architec-
ture in which they encode the context using RNNs
at both the word level and the utterance level. In
contrast to these models, which generate a single
context encoding, Wu et al. (2017) designed a net-
work that matches a response to each utterance in
the context individually.

While many of the models cited above imple-
ment their RNNs with an LSTM (Hochreiter and
Schmidhuber, 1997), we instead use an SRU (Lei
et al., 2018). SRU uses light recurrence, which
makes it highly parallelizable, and Lei et al. (2018)

showed that it trains 5-9x faster than cuDNN
LSTM. SRU also exhibits a significant speedup
in inference time compared to LSTM (by a factor
of 4.1x in our experiments), which is particularly
relevant in a production setting. Furthermore, Lei
et al. (2018) showed that SRU matches or exceeds
the performance of models using LSTMs or the
Transformer architecture (Vaswani et al., 2017) on
a number of NLP tasks, meaning significant speed
gains can be achieved without a drop in perfor-
mance.

Despite the abundance of prior work on re-
trieval models for dialogue, whitelist selection has
received relatively little attention. Since prac-
tical use of conversational models has typically
not been addressed, most models are evaluated on
their ability to select the correct response from a
small list of randomly sampled responses (Lowe
et al., 2015). Another option, from Wu et al.
(2017), is to use Apache Lucene1 to select a
list of response candidates relevant to each con-
text. However, neither method produces a single
whitelist that can be used for every context and
reviewed for quality. The closest work to ours
is Lu et al. (2017), who build a whitelist using a
k-means clustering of responses. We extend this
work by doing a more comprehensive analysis of
different whitelist selection methods, and we fur-
ther analyze the effect of whitelist size on perfor-
mance.

3 Model Architecture

Next we describe the architecture of our retrieval
model. The two inputs to the model are a con-
text c, which is a concatenation of all utterances
in the conversation, and a candidate response r.
In the context, we use special tokens to indicate
whether each utterance comes from the customer
or the agent. The model outputs a score s(c, r) in-
dicating the relevance of the response to the con-
text. The model architecture is described in detail
below and is illustrated in Figure 1.

3.1 Dual Encoders

At the core of our model are two neural encoders
fc and fr to encode the context and the response,
respectively. These encoders have identical archi-
tectures but learn separate weights.

Each encoder takes a sequence of tokens w =
{w1, w2, . . . , wn} as input, which is either a con-

1http://lucene.apache.org/

http://lucene.apache.org/


34

c = My phone is 
broken

r = I can help

x1 x2 x3 x4 x1 x2 x3

4-layer SRU 4-layer SRU

h1 h2 h3 h4 h1 h2 h3

Self Attention Self Attention

fc(c)

Dot Product

Context 
Encoder 

(fc)

Response 
Encoder 

(fr)

fr(r)

fastText 
embeddings

c = My phone is broken r+ = I can help r1– = That’s 
wonderful

Context 
Encoder

Response 
Encoder

Response 
Encoder

Dot Product Dot Product

rn– = Hi there buddy!

Response 
Encoder

Dot Product

...

...

...

...

fr(r1–) fr(rk–)fr(r+)fc(c)

Figure 1: (Left) The dual encoder architecture, which takes as input a context c and a response r and computes
the score s(c, r). (Right) Computing the model’s loss based on the scores between a context c, the actual agent
response r+, and k randomly sampled agent responses r−1 , . . . , r

−
k .

text or a response. Due to the prevalence of ty-
pos in both user and agent utterances in real chats,
we use fastText (Bojanowski et al., 2016) as
the word embedding method. fastText learns
both word-level and character-level features and
is therefore more robust to misspellings. We pre-
trained fastText2 embeddings on a corpus of
15M utterances from help desk conversations and
then fixed the embeddings while training the neu-
ral encoders.

Each encoder consists of a recurrent neural
network followed by a multi-headed attention
layer (Lin et al., 2017) to perform pooling. We
use multi-layer, bidirectional SRUs as the recur-
rent network. Each layer of the SRU involves the
following computation:

ft = σ(Wfxt + vf � ct−1 + bf )
ct = ft � ct−1 + (1− ft)� (Wxt)
rt = σ(Wrxt + vr � ct−1 + br)
ht = rt � ct + (1− rt)� xt

(1)

where σ is the sigmoid activation function,
W,Wf ,Wr ∈ Rdh×de are learned parameter ma-
trices, and vf , vr,bf ,bv ∈ Rdh are learned param-
eter vectors.

The multi-headed attention layer compresses
the encoded sequence h = {h1,h2, . . . ,hn} into a
single vector. For each attention head i, attention
weights are generating with the following compu-
tation:

α(i) = softmax(σ(hTW(i)a )v
(i)
a ) (2)

where σ is a non-linear activation function, W(i)a ∈
Rdh×da is a learned parameter matrix, and v(i)a ∈
Rda is a learned parameter vector.

2https://github.com/facebookresearch/
fastText

The encoded sequence representation is then
pooled to a single vector for each attention head
i by summing the attended representations:

h̃
(i)

=
n∑

j=1

α
(i)
j hj . (3)

Finally, the pooled encodings are averaged
across the nh attention heads:

h̃ =
1

nh

nh∑
i=1

h̃
(i)
. (4)

The output of the encoder is the vector f(w) = h̃.

3.2 Scoring
To determine the relevance of a response r to a
context c, our model computes a matching score
between the context encoding fc(c) and the re-
sponse encoding fr(r). This score is simply the
dot product of the encodings:

s(c, r) = fc(c) · fr(r) . (5)

3.3 Training
We optimize the model to maximize the score
between the context c and the response r+ ac-
tually sent by the agent while minimizing the
score between the context and each of k random
(“negative”) responses r−1 , . . . , r

−
k . This is ac-

complished by training the model to minimize the
cross-entropy loss:

L = −s(c, r+) + log
k∑

i=1

s(c, r−i ) . (6)

Although negative responses could be sam-
pled separately for each context-response pair,

https://github.com/facebookresearch/fastText
https://github.com/facebookresearch/fastText


35

we instead use a method inspired by Logeswaran
and Lee (2018) and share a set of negative re-
sponses across all examples in a batch. Specif-
ically, for each batch, we sample k responses
from the set of all agent responses (weighted ac-
cording to response frequency), and we use those
k responses as the negative responses for every
context-response pair in the batch. This has the
benefit of reducing the number of responses that
need to be encoded in each batch of size b from
O(bk) to O(b + k), thereby significantly acceler-
ating training.

3.4 Whitelist Generation

After training, we experimented with two meth-
ods of creating the whitelist from which our
model selects responses at inference time. For
each method, we created both a 1,000 response
whitelist and a 10,000 response whitelist. Having
a whitelist with any more than 10,000 responses
would likely make a manual review infeasible.

Frequency-Based Method. Responses that are
sent frequently are more likely to be relevant in
multiple conversations and are less likely to con-
tain errors. Therefore, one method of building
a high-quality whitelist is simply to collect mes-
sages that are sent often. We created frequency-
based whitelists by selecting the 1,000 or 10,000
most common agent responses, after accounting
for minor variations in capitalization, punctuation,
and whitespace.

Clustering-Based Method. Although selecting
responses based on frequency may help guaran-
tee quality, manual examination of the frequency
whitelists showed that they contained many redun-
dant responses. Therefore, we experimented with
a clustering-based whitelist selection method in
the hope of reducing redundancy and increasing
response diversity. Specifically, we encoded all
agent responses using our response encoder fr and
then used k-means clustering with k = 1, 000 or
k = 10, 000 to cluster the responses. We then se-
lected the most common response from each clus-
ter to create the whitelists.

4 Experiments and Results

We evaluated our model and whitelists on a large,
proprietary help desk chat dataset using several
offline metrics and a human evaluation. We par-
ticularly emphasize metrics relevant to produc-

tion, such as inference speed and Recall@k from
a large candidate set. The human evaluation il-
lustrates how our model and whitelists compare to
each other and to the responses sent by a real hu-
man agent.

4.1 Data
The help desk chat dataset used in our exper-
iments consists of 15M utterances from 595K
conversations. We randomly split the conver-
sations into train, validation, and test sets with
80%, 10%, and 10% of the conversations, re-
spectively. Since each conversation includes sev-
eral agent responses, each of which produces a
context-response example, our dataset consists of
6.6M training examples, 828K validation exam-
ples, and 828K test examples. Additional dataset
statistics are provided in Table 1. An example chat
conversation can be seen in Table 2.

4.2 Model Details
We implemented the dual encoder model using
PyTorch (Paszke et al., 2017). We use pre-trained
fastText embeddings of dimension de = 300,
a 4-layer bidirectional SRU3 with hidden size
dh = 300, and multi-headed attention with 16
heads and a hidden size of da = 64. The batch size
was 200 and we used k = 200 negative responses
for each positive response. To ensure quick encod-
ing even for long inputs, contexts were restricted
to the 500 most recent tokens and responses were
restricted to the 100 most recent tokens4. The
model was optimized using Adam (Kingma and
Ba, 2014) with the Noam learning rate schedule
from Vaswani et al. (2017). The model was
trained for 30 epochs, with each epoch limited to
10,000 training batches (2M training examples).
Training took about 32 hours on a single Tesla
V100 GPU.

4.3 Results and Analysis
AUC and AUC@p. To determine the model’s
ability to use context to distinguish between true
responses and negative responses, we use the met-
rics AUC and AUC@p. AUC is the area under the
receiver operating characteristic curve when us-
ing the score s(c, r) to determine whether each re-

3SRU code available at https://github.com/
taolei87/sru/tree/master/sru

4A context with 500 tokens contains 39 utterances on av-
erage, which is typically more than enough to understand the
topic of conversation. Almost all responses are shorter than
100 tokens.

https://github.com/taolei87/sru/tree/master/sru
https://github.com/taolei87/sru/tree/master/sru


36

Conversations 594,555
Utterances 15,217,773

Customer utterances 6,943,940
Agent utterances 8,273,833

Mean conversation length (# utterances) 25.60
Mean utterance length (# tokens) 12.70

Mean customer utterance length (# tokens) 7.53
Mean agent utterance length (# tokens) 17.15

Table 1: Summary statistics for the propriety help desk dataset.

Example Conversation
Customer: I would like to pay my bill can you
help me
Agent: I can definitely help you to pay your bill.
Are we going to work with the account logged in
now?
Customer: Yes it still says there is no money on
my account
Agent: I understand that. I have reviewed your
account and its shows here that the payment has
been posted and you’re all good until next month
service.
Customer: Oh ok thank you for all your help
Agent: You’re welcome. Anything for a valued
customer like you!

Table 2: A sample conversation from the propriety help
desk chat dataset. The sample has been lightly edited
to remove proprietary information.

sponse is the true response or a negative response.
AUC@p is the area under the portion of the ROC
curve where the false positive rate is ≤ p, renor-
malized so that the maximum AUC@p is 1.

The performance of our model according to
these AUC metrics can be seen in Table 3. The
high AUC indicates that our model can easily dis-
tinguish between the true response and negative
responses. Furthermore, the AUC@p numbers
show that the model has a relatively high true pos-
itive rate even under the difficult requirement of a
low false positive rate.

Recall and Whitelist Size. In order to deter-
mine our model’s ability to select the correct re-
sponse from a whitelist, we use recall at k from
n (Rn@k), which is the proportion of times that
the true response is ranked as one of the top k re-
sponses in a whitelist containing n candidate re-
sponses.

Table 4 shows Rn@k on the test set for dif-

Metric Validation Test
AUC 0.991 0.977

AUC@0.1 0.925 0.885
AUC@0.05 0.871 0.816
AUC@0.01 0.677 0.630

Table 3: AUC and AUC@p of our model on the propri-
ety help desk dataset.

Candidates R@1 R@3 R@5 R@10
10 0.892 0.979 0.987 1
100 0.686 0.842 0.894 0.948

1,000 0.449 0.611 0.677 0.760
10,000 0.234 0.360 0.421 0.505

Table 4: Recall@k from n response candidates for dif-
ferent values of n using random whitelists. Each ran-
dom whitelist includes the correct response along with
n− 1 randomly selected responses.

ferent values of n and k when using a random
whitelist, meaning a whitelist which contains the
true response and n − 1 randomly sampled re-
sponses5. As discussed in the introduction, most
prior work evaluate their models using a random
whitelist with n = 10 candidates. However, a
production whitelist needs to contain hundreds or
thousands of response candidates in order to pro-
vide relevant responses in a variety of contexts.
Therefore, a more meaningful metric for produc-
tion purposes is Rn@k for n ≥ 100. Table 4
shows that recall drops significantly as n grows,
meaning that the R10@k evaluation performed by
prior work may significantly overstate model per-
formance in a production setting.

Comparison Between Whitelists. An interest-
ing question we would like to address is whether

5To be precise, we sampled responses without replace-
ment weighted according to the frequency with which the re-
sponse was sent by agents.



37

Whitelist R@1 R@3 R@5 R@10 BLEU
Random 10K+ 0.252 0.400 0.472 0.560 37.71

Frequency 10K+ 0.257 0.389 0.455 0.544 41.34
Clustering 10K+ 0.230 0.376 0.447 0.541 37.59

Random 1K+ 0.496 0.663 0.728 0.805 59.28
Frequency 1K+ 0.513 0.666 0.726 0.794 67.05
Clustering 1K+ 0.481 0.667 0.745 0.835 61.88
Frequency 10K 0.136 0.261 0.327 0.420 30.46
Clustering 10K 0.164 0.292 0.360 0.457 31.47
Frequency 1K 0.273 0.465 0.550 0.658 47.13
Clustering 1K 0.331 0.542 0.650 0.782 49.26

Table 5: Recall@k for random, frequency, and cluster-
ing whitelists of different sizes. The “+” indicates that
the true response is added to the whitelist.

Whitelist R@1 Coverage
Frequency 10K 0.136 45.04%
Clustering 10K 0.164 38.38%
Frequency 1K 0.273 33.38%
Clustering 1K 0.331 23.28%

Table 6: Recall@1 versus coverage for frequency and
clustering whitelists.

a random whitelist serves as a good proxy for
whitelists generated using other methods. To this
end, we also evaluate recall on the frequency and
clustering whitelists from Section 3.4.

First, we compute recall when the true response
is added to the whitelist, as in the case of the
random whitelists described above. Second, we
compute recall only on the subset of examples for
which the true response is already contained in the
whitelist. The latter recall measure is more rele-
vant to a production setting since the true response
is not known at inference time and therefore can-
not be artificially added to the whitelist.

The results in Table 5 show that the three types
of whitelists perform comparably to each other
when the true response is added. However, in
the more realistic second case, when recall is only
computed on examples with a response already in
the whitelist, performance on the frequency and
clustering whitelists drops significantly.

Additionally, we compute the BLEU (Papineni
et al., 2002; Ward and Reeder, 2002) scores be-
tween the true responses and the best suggested
responses. The BLEU score allows us to mea-
sure the semantic similarity when the true and sug-
gested responses are not exactly matched. The
BLEU scores computed with the frequency and
clustering whitelists are slightly higher than those
computed with random whitelists.

Whitelist Great Good Bad Accept
Freq. 1K 54% 26% 20% 80%

Cluster. 1K 55% 21% 23% 77%
Freq. 10K 56% 24% 21% 80%

Cluster. 10K 57% 23% 20% 80%
Real response 60% 24% 16% 84%

Table 7: Results of the human evaluation of the re-
sponses produced by our model. A response is accept-
able if it is either good or great. Note: Numbers may
not add up to 100% due to rounding.

Recall versus Coverage. Although recall is a
good measure of performance, recall alone is not
a sufficient criterion for whitelist selection. The
recall results in Table 5 seem to indicate that the
clustering-based whitelists are strictly superior to
the frequency-based whitelists in the realistic case
when we only consider responses that are already
contained in the whitelist, but this analysis fails to
account for the frequency with which this is the
case. For instance, a whitelist may have very high
recall but may only include responses that were
sent infrequently by agents, meaning the whitelist
will perform well for a handful of conversations
but will be irrelevant in most other cases.

To quantify this effect, we introduce the notion
of coverage, which is the percent of all context-
response pairs where the agent response appears in
the whitelist, after accounting for minor deviations
in capitalization, punctuation, and whitespace. A
whitelist that contains responses that are sent more
frequently by agents will therefore have a higher
coverage.

Table 6 shows R@1 and coverage for the fre-
quency and clustering whitelists. While the clus-
tering whitelists have higher recall, the frequency
whitelists have higher coverage. This is to be ex-
pected since the frequency whitelists were specifi-
cally chosen to maximize the frequency of the in-
cluded responses. Since both recall and coverage
are necessary to provide good responses for a wide
range of conversations, these results indicate the
importance of considering the trade-off between
recall and coverage inherent in a given whitelist
selection method.

It may be interesting in future work to further
investigate these trade-offs in order to identify a
whitelist selection method that can simultaneously
optimize recall and coverage.



38

Human Evaluation. While offline metrics are
indicative of model performance, the best mea-
sure of performance is a human evaluation of the
model’s predictions. Therefore, we performed a
small-scale human evaluation of our model and
whitelists. We selected 322 contexts from the
test set and used our model to generate responses
from the Frequency 10K, Frequency 1K, Clus-
tering 10K, and Clustering 1K whitelists. Three
human annotators were shown each context fol-
lowed by five responses: one from each of the four
whitelists and the true response sent by the agent.
The annotators were blinded to the source of each
response. The annotators were asked to rate each
response according to the following categories:

Bad: The response is not relevant to the context.
Good: The response is relevant to the context but
is vague or generic.
Great: The response is relevant to the context and
directly addresses the issue at hand.

For example, three such responses for the context
“My phone is broken” would be:

Bad response: Goodbye!
Good response: I’m sorry to hear that.
Great response: I’m sorry to hear that your phone
is broken.

The results of the human evaluation are in Table
7. Our proposed system works well, selecting ac-
ceptable (i.e. good or great) responses about 80%
of the time and selecting great responses more
than 50% of the time.

Interestingly, the size and type of whitelist seem
to have little effect on performance, indicating that
all the whitelists contain responses appropriate to
a variety of conversational contexts. Since the fre-
quency whitelists are simpler to generate than the
clustering whitelists and since the 1K whitelists
contain fewer responses to manually review than
the 10K whitelists, the Frequency 1K whitelist is
the preferred whitelist for our production system.

Inference Speed. A major constraint in a pro-
duction system is the speed with which the system
can respond to users. To demonstrate the benefit
of using an SRU encoder instead of an LSTM en-
coder in production, we compared the speed with
which they encode a random conversation context
at inference time, averaged over 1,000 samples.
We used a single core of Intel Core i9 2.9 GHz

Encoder Layer Params Time
SRU 2 3.7M 14.7
SRU 4 8.0M 21.9

LSTM 2 7.3M 90.9
LSTM 4 15.9M 174.8

+rank response - - 0.9

Table 8: Inference time (milliseconds) of our model to
encode a context using an SRU or an LSTM encoder on
a single CPU core. The last row shows the extra time
needed to compare the response encoding to 10,000
cached candidate response encodings in order to find
the best response.

CPU. As seen in Table 8, an SRU encoder is over
4x faster than an LSTM encoder with a similar
number of parameters, making it more suitable for
production use.

Table 8 also highlights the scalability of using
a dual encoder architecture. Since the embed-
dings of the candidate responses are independent
from the conversation context, the embeddings of
the whitelist responses can be pre-computed and
stored as a matrix. Retrieving the best candi-
date once the context is encoded takes a negligible
amount of time compared to the time to encode the
context.

Ablation analysis. Finally, we performed an ab-
lation analysis to identify the effect of differ-
ent aspects of the model architecture and training
regime. The results are shown in Table 9, and de-
tails of the model variants are available in the Ap-
pendix.

As Table 9 shows, the training set size and
the number of negative responses for each pos-
itive response are the most important factors in
model performance. The model performs signif-
icantly worse when trained with hinge loss instead
of cross-entropy loss, indicating the importance of
the loss function. We also experimented with a hi-
erarchical encoder, where two different recurrent
neural networks are used to encode contexts, one
at the word level and one at the utterance level.
We observed no advantage to using a hierachical
encoder, despite its complexity and popularity for
encoding conversations (Serban et al., 2015; Zhou
et al., 2016). Finally, we see that a 2 layer LSTM
performs similarly to either a 4 layer or a 2 layer
SRU with a comparable number of parameters.
Since the SRU is more than 4x faster at inference
time with the same level of performance, it is the



39

Model Parameters Validation AUC@0.05 Test AUC@0.05
Base 8.0M 0.871 0.816

4L SRU→ 2L LSTM 7.3M 0.864 0.829
4L SRU→ 2L SRU 7.8M 0.856 0.829
Flat→ hierarchical 12.4M 0.825 0.559

Cross entropy→ hinge loss 8.0M 0.765 0.693
6.6M→ 1M examples 8.0M 0.835 0.694

6.6M→ 100K examples 8.0M 0.565 0.417
200→ 100 negatives 8.0M 0.864 0.647
200→ 10 negatives 8.0M 0.720 0.412

Table 9: An ablation study showing the effect of different model architectures and training regimes on performance
on the proprietary help desk dataset.

preferred encoder architecture.

5 Conclusion

In this paper, we present a fast dual encoder neural
model for retrieval-based human-computer con-
versations. We address technical considerations
specific to the production setting, and we evaluate
our model and two whitelist generation methods
on a large help desk chat dataset. We observe that
traditional offline evaluation metrics significantly
overestimate model performance, indicating the
importance of using evaluation metrics more rele-
vant to a production setting. Furthermore, we find
that our proposed model performs well, both on
offline metrics and on a human evaluation. Due
to its strong performance and its speed at infer-
ence time, we conclude that our proposed model
is suitable for use in a production conversational
system.

One important direction for future work is a
deeper analysis of the whitelist selection process.
Although our analysis found similar performance
across whitelists according to a human evaluation,
our offline metrics indicate underlying trade-offs
between different characteristics of the whitelists
such as recall and coverage. A better understand-
ing the implications of these trade-offs may lead
to improved whitelist generation methods, thereby
further improving the performance of retrieval-
based models.

Acknowledgments

We would like to thank Howard Chen for the in-
valuable conversations we had with him during the
development of our model. We would also like to
thank Anna Folinsky and the ASAPP annotation

team for their help performing the human evalua-
tion, and Hugh Perkins for his support on the ex-
perimental environment setup. Thank you as well
to Ethan Elenberg, Kevin Yang, and Adam Yala
for reviewing early drafts of this paper and provid-
ing valuable feedback. Finally, thank you to the
anonymous reviewers for their constructive feed-
back.

References
Rami Al-Rfou, Marc Pickett, Javier Snaider, Yun hsuan

Sung, Brian Strope, and Ray Kurzweil. 2016. Con-
versational contextual cues: The case of personaliza-
tion and history for response ranking. arXiv preprint
arXiv:1606.00372.

Piotr Bojanowski, Edouard Grave, Armand Joulin,
and Tomas Mikolov. 2016. Enriching word vec-
tors with subword information. arXiv preprint
arXiv:1607.04606.

Budhaditya Deb, Peter Bailey, and Milad Shok-
ouhi. 2019. Diversifying reply suggestions us-
ing a matching-conditional variational autoencoder.
arXiv preprint arXiv:1903.10630.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Zongcheng Ji, Zhengdong Lu, and Hang Li. 2014. An
information retrieval approach to short text conver-
sation. arXiv preprint arXiv:1408.6988.

Diederik P. Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980.

Tao Lei, Yu Zhang, Sida I. Wang, Hui Dai, and
Yoav Artzi. 2018. Simple recurrent units for
highly parallelizable recurrence. arXiv preprint
arXiv:1709.02755.

https://arxiv.org/abs/1606.00372
https://arxiv.org/abs/1606.00372
https://arxiv.org/abs/1606.00372
https://arxiv.org/abs/1607.04606
https://arxiv.org/abs/1607.04606
https://arxiv.org/abs/1903.10630
https://arxiv.org/abs/1903.10630
https://arxiv.org/abs/1408.6988
https://arxiv.org/abs/1408.6988
https://arxiv.org/abs/1408.6988
https://arxiv.org/abs/1412.6980
https://arxiv.org/abs/1412.6980
https://arxiv.org/abs/1709.02755
https://arxiv.org/abs/1709.02755


40

Jiwei Li, Michel Galley, Chris Brockett, Georgios P.
Spithourakis, Jianfeng Gao, and Bill Dolan. 2016.
A persona-based neural conversation model. arXiv
preprint arXiv:1603.06155.

Zhouhan Lin, Minwei Feng, Cicero Nogueira dos San-
tos, Mo Yu, Bing Xiang, Bowen Zhou, and Yoshua
Bengio. 2017. A structured self-attentive sentence
embedding. arXiv preprint arXiv:1703.03130.

Lajanugen Logeswaran and Honglak Lee. 2018. An
efficient framework for learning sentence represen-
tations. arXiv preprint arXiv:1803.02893.

Ryan Lowe, Nissan Pow, Iulian Serban, and Joelle
Pineau. 2015. The ubuntu dialogue corpus: A large
dataset for research in unstructured multi-turn dia-
logue systems.

Yichao Lu, Phillip Keung, Shaonan Zhang, Jason Sun,
and Vikas Bhardwaj. 2017. A practical approach
to dialogue response generation in closed domains.
arXiv preprint arXiv:1703.09439.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. Bleu: a method for automatic eval-
uation of machine translation. In Proceedings of
the 40th annual meeting on association for compu-
tational linguistics, pages 311–318. Association for
Computational Linguistics.

Adam Paszke, Sam Gross, Soumith Chintala, Gre-
gory Chanan, Edward Yang, Zachary DeVito, Zem-
ing Lin, Alban Desmaison, Luca Antiga, and Adam
Lerer. 2017. Automatic differentiation in pytorch.
In NIPS-W.

Iulian V. Serban, Alessandro Sordoni, Yoshua Bengio,
Aaron Courville, and Joelle Pineau. 2015. Build-
ing end-to-end dialogue systems using generative hi-
erarchical neural network models. arXiv preprint
arXiv:1507.04808.

Igor Shalyminov, Ondej Duek, and Oliver Lemon.
2018. Neural response ranking for social conver-
sation: A data-efficient approach. arXiv preprint
arXiv:1811.00967.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. arXiv preprint arXiv:1706.03762.

Oriol Vinyals and Quoc Le. 2015. A neural conversa-
tional model. arXiv preprint arXiv:1506.05869.

Hao Wang, Zhengdong Lu, Hang Li, and Enhong
Chen. 2013. A dataset for research on short-text
conversation. Proceedings of the 2013 Conference
on Empirical Methods in Natural Language Pro-
cessing, pages 935–945.

Kishore Papineni Salim Roukos Todd Ward and John
Henderson Florence Reeder. 2002. Corpus-based
comprehensive and diagnostic mt evaluation: Initial
arabic, chinese, french, and spanish results.

Bowen Wu, Baoxun Wang, and Hui Xue. 2016. Rank-
ing responses oriented to conversational relevance in
chat-bots. COLING16.

Yu Wu, Wei Wu, Chen Xing, Ming Zhou, and Zhou-
jun Li. 2017. Sequential matching network: A
new architecture for multi-turn response selection in
retrieval-based chatbots. Proceedings of the 55th
Annual Meeting of the Association for Computa-
tional Linguistics.

Chen Xing, Wei Wu, Yu Wu, Jie Liu, Yalou Huang,
Ming Zhou, and Wei-Ying Ma. 2016. Topic
aware neural response generation. arXiv preprint
arXiv:1606.08340.

Rui Yan, Yiping Song, and Hua Wu. 2016. Learning
to respond with deep neural networks for retrieval-
based human-computer conversation system. SI-
GIR, pages 55–64.

Liu Yang, Junjie Hu, Minghui Qiu, Chen Qu, Jian-
feng Gao, W. Bruce Croft, Xiaodong Liu, Ye-
long Shen, and Jingjing Liu. 2019. A hy-
brid retrieval-generation neural conversation model.
arXiv preprint arXiv:1904.09068.

Zhuosheng Zhang, Jiangtong Li, Pengfei Zhu, Hai
Zhao, and Gongshen Liu. 2018. Modeling multi-
turn conversation with deep utterance aggregation.
arXiv preprint arXiv:1806.09102.

Xiangyang Zhou, Daxiang Dong, Hua Wu, Shiqi Zhao,
Dianhai Yu, Hao Tian, Xuan Liu, and Rui Yan. 2016.
Multi-view response selection for human-computer
conversation. Proceedings of the 2016 Conference
on Empirical Methods in Natural Language Pro-
cessing, pages 372–381.

Xiangyang Zhou, Lu Li, Daxiang Dong, Yi Liu, Ying
Chen, Wayne Xin Zhao, Dianhai Yu, and Hua Wu.
2018. Multi-turn response selection for chatbots
with deep attention matching network. Proceedings
of the 56th Annual Meeting of the Association for
Computational Linguistics, pages 1118–1127.

https://arxiv.org/abs/1603.06155
https://arxiv.org/abs/1703.03130
https://arxiv.org/abs/1703.03130
https://arxiv.org/abs/1803.02893
https://arxiv.org/abs/1803.02893
https://arxiv.org/abs/1803.02893
https://arxiv.org/abs/1506.08909
https://arxiv.org/abs/1506.08909
https://arxiv.org/abs/1506.08909
https://arxiv.org/abs/1703.09439
https://arxiv.org/abs/1703.09439
https://openreview.net/forum?id=BJJsrmfCZ
https://arxiv.org/abs/1507.04808
https://arxiv.org/abs/1507.04808
https://arxiv.org/abs/1507.04808
https://arxiv.org/abs/1811.00967
https://arxiv.org/abs/1811.00967
https://arxiv.org/abs/1706.03762
https://arxiv.org/abs/1706.03762
https://arxiv.org/abs/1506.05869
https://arxiv.org/abs/1506.05869
http://www.anthology.aclweb.org/D/D13/D13-1096.pdf
http://www.anthology.aclweb.org/D/D13/D13-1096.pdf
https://www.aclweb.org/anthology/C/C16/C16-1063.pdf
https://www.aclweb.org/anthology/C/C16/C16-1063.pdf
https://www.aclweb.org/anthology/C/C16/C16-1063.pdf
http://dx.doi.org/10.18653/v1/P17-1046
http://dx.doi.org/10.18653/v1/P17-1046
http://dx.doi.org/10.18653/v1/P17-1046
https://arxiv.org/abs/1606.08340
https://arxiv.org/abs/1606.08340
http://dx.doi.org/10.1145/2911451.2911542
http://dx.doi.org/10.1145/2911451.2911542
http://dx.doi.org/10.1145/2911451.2911542
https://arxiv.org/abs/1904.09068
https://arxiv.org/abs/1904.09068
https://arxiv.org/abs/1806.09102
https://arxiv.org/abs/1806.09102
http://www.aclweb.org/anthology/D16-1036
http://www.aclweb.org/anthology/D16-1036
http://www.aclweb.org/anthology/P18-1103
http://www.aclweb.org/anthology/P18-1103


41

A Appendix

A.1 Ablation Study
Table 9 shows the results of an ablation study we
performed to identify the most important com-
ponents of our model architecture and training
regime. Each variant is described below.

Base. This is the model architecture described in
Section 3.

4L SRU → 2L LSTM. We replace the 4 layer
SRU encoder with a 2 layer LSTM encoder, which
has a comparable number of parameters when us-
ing the same hidden sizes.

4L SRU→ 2L SRU. We use an SRU with 2 layers
instead of 4 layers. In order to match parameters,
we use a hidden size of dh = 475 instead of dh =
300 in the model with 2 layers.

Flat → hierarchical. We replace the SRU en-
coder with two SRU encoders, one which operates
at the word level and one which operates at the ut-
terance level, following the architectures of Serban
et al. (2015); Wu et al. (2017).

Cross entropy→ hinge loss. Instead of using the
cross-entropy loss defined in Equation 6, we use
the hinge loss, which is defined as:

L =
k∑

i=1

|s(c, r+)− s(c, r−i ) +m| (7)

where the margin m = 0.25 encourages separa-
tion between the score of the correct response and
the score of each negative response.

6.6M→ 1M examples. We train on a dataset with
1 million examples instead of the full 6.6 million
training examples.

6.6M→ 100K examples. We trained on a dataset
with 100 thousand examples instead of the full 6.6
million training examples.

200 → 100 negatives. During training, we sam-
ple 100 negatives for each context-response pair
instead of 200 negatives.

200→ 10 negatives. During training, we sample
10 negatives for each context-response pair instead
of 200 negatives.


