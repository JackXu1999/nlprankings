




































coi00209.dvi


Concrete Models and Empirical Evaluations
for the Categorical Compositional
Distributional Model of Meaning

Edward Grefenstette∗†
Google DeepMind

Mehrnoosh Sadrzadeh∗∗†
Queen Mary University of London

Modeling compositional meaning for sentences using empirical distributional methods has been
a challenge for computational linguists. The categorical model of Clark, Coecke, and Sadrzadeh
(2008) and Coecke, Sadrzadeh, and Clark (2010) provides a solution by unifying a categorial
grammar and a distributional model of meaning. It takes into account syntactic relations
during semantic vector composition operations. But the setting is abstract: It has not been
evaluated on empirical data and applied to any language tasks. We generate concrete models
for this setting by developing algorithms to construct tensors and linear maps and instantiate
the abstract parameters using empirical data. We then evaluate our concrete models against
several experiments, both existing and new, based on measuring how well models align with
human judgments in a paraphrase detection task. Our results show the implementation of this
general abstract framework to perform on par with or outperform other leading models in these
experiments.1

1. Introduction

The distributional approach to the semantic modeling of natural language, inspired
by the notion—presented by Firth (1957) and Harris (1968)—that the meaning of a
word is tightly related to its context of use, has grown in popularity as a method
of semantic representation. It draws from the frequent use of vector-based document
models in information retrieval, modeling the meaning of words as vectors based on
the distribution of co-occurring terms within the context of a word.

Using various vector similarity metrics as a measure of semantic similarity, these
distributional semantic models (DSMs) are used for a variety of NLP tasks, from

∗ DeepMind Technologies Ltd, 5 New Street Square, London EC4A 3 TW.
E-mail: etg@google.com.

∗∗ School of Electronic Engineering and Computer Science, Queen Mary University of London, Mile End
Road, London E1 4NS, United Kingdom. E-mail: mehrnoosh.sadrzadeh@qmul.ac.uk.

† The work described in this article was performed while the authors were at the University of Oxford.
1 Support from EPSRC grant EP/J002607/1 is acknowledged.

Submission received: 26 September 2012; revised submission received: 31 October 2013;
accepted for publication: 5 April 2014.

doi:10.1162/COLI a 00209

© 2015 Association for Computational Linguistics



Computational Linguistics Volume 41, Number 1

automated thesaurus building (Grefenstette 1994; Curran 2004) to automated essay
marking (Landauer and Dumais 1997). The broader connection to information retrieval
and its applications is also discussed by Manning, Raghavan, and Schütze (2011). The
success of DSMs in essentially word-based tasks such as thesaurus extraction and con-
struction (Grefenstette 1994; Curran 2004) invites an investigation into how DSMs can
be applied to NLP and information retrieval (IR) tasks revolving around larger units of
text, using semantic representations for phrases, sentences, or documents, constructed
from lemma vectors. However, the problem of compositionality in DSMs—of how to go
from word to sentence and beyond—has proved to be non-trivial.

A new framework, which we refer to as DisCoCat, initially presented in Clark,
Coecke, and Sadrzadeh (2008) and Coecke, Sadrzadeh, and Clark (2010) reconciles
distributional approaches to natural language semantics with the structured, logical
nature of formal semantic models. This framework is abstract; its theoretical predictions
have not been evaluated on real data, and its applications to empirical natural language
processing tasks have not been studied.

This article is the journal version of Grefenstette and Sadrzadeh (2011a, 2011b),
which fill this gap in the DisCoCat literature; in it, we develop a concrete model and
an unsupervised learning algorithm to instantiate the abstract vectors, linear maps, and
vector spaces of the theoretical framework; we develop a series of empirical natural
language processing experiments and data sets and implement our algorithm on large
scale real data; we analyze the outputs of the algorithm in terms of linear algebraic
equations; and we evaluate the model on these experiments and compare the results
with other competing unsupervised models. Furthermore, we provide a linear algebraic
analysis of the algorithm of Grefenstette and Sadrzadeh (2011a) and present an in-depth
study of the better performance of the method of Grefenstette and Sadrzadeh (2011b).

We begin in Section 2 by presenting the background to the task of developing
compositional distributional models. We briefly introduce two approaches to semantic
modeling: formal semantic models and distributional semantic models. We discuss their
differences, and relative advantages and disadvantages. We then present and critique
various approaches to bridging the gap between these models, and their limitations.
In Section 3, we summarize the categorical compositional distributional framework of
Clark, Coecke, and Sadrzadeh (2008) and Coecke, Sadrzadeh, and Clark (2010) and pro-
vide the theoretical background necessary to understand it; we also sketch the road map
of the literature leading to the development of this setting and outline the contributions
of this paper to the field. In Section 4, we present the details of an implementation of this
framework, and introduce learning algorithms used to build semantic representations
in this implementation. In Section 5, we present a series of experiments designed to
evaluate this implementation against other unsupervised distributional compositional
models. Finally, in Section 6 we discuss these results, and posit future directions for this
research area.

2. Background

Compositional formal semantic models represent words as parts of logical expressions,
and compose them according to grammatical structure. They stem from classical ideas
in logic and philosophy of language, mainly Frege’s principle that the meaning of a
sentence is a function of the meaning of its parts (Frege 1892). These models relate to
well-known and robust logical formalisms, hence offering a scalable theory of meaning
that can be used to reason about language using logical tools of proof and inference.
Distributional models are a more recent approach to semantic modeling, representing

72



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

the meaning of words as vectors learned empirically from corpora. They have found
their way into real-world applications such as thesaurus extraction (Grefenstette 1994;
Curran 2004) or automated essay marking (Landauer and Dumais 1997), and have
connections to semantically motivated information retrieval (Manning, Raghavan, and
Schütze 2011). This two-sortedness of defining properties of meaning: “logical form”
versus “contextual use,” has left the quest for “what is the foundational structure of
meaning?”—a question initially the concern of solely linguists and philosophers of
language—even more of a challenge.

In this section, we present a short overview of the background to the work de-
veloped in this article by briefly describing formal and distributional approaches to
natural language semantics, and providing a non-exhaustive list of some approaches
to compositional distributional semantics. For a more complete review of the topic, we
encourage the reader to consult Turney (2012) or Clark (2013).

2.1 Montague Semantics

Formal semantic models provide methods for translating sentences of natural language
into logical formulae, which can then be fed to computer-aided automation tools to
reason about them (Alshawi 1992).

To compute the meaning of a sentence consisting of n words, meanings of these
words must interact with one another. In formal semantics, this further interaction is
represented as a function derived from the grammatical structure of the sentence. Such
models consist of a pairing of syntactic analysis rules (in the form of a grammar) with
semantic interpretation rules, as exemplified by the simple model presented on the left
of Figure 1.

The semantic representations of words are lambda expressions over parts of logical
formulae, which can be combined with one another to form well-formed logical expres-
sions. The function | − | : L → M maps elements of the lexicon L to their interpretation
(e.g., predicates, relations, domain objects) in the logical model M used. Nouns are
typically just logical atoms, whereas adjectives and verbs and other relational words
are interpreted as predicates and relations. The parse of a sentence such as “cats like
milk,” represented here as a binarized parse tree, is used to produce its semantic in-
terpretation by substituting semantic representations for their grammatical constituents
and applying β-reduction where needed. Such a derivation is shown on the right of
Figure 1.

What makes this class of models attractive is that it reduces language meaning
to logical expressions, a subject well studied by philosophers of language, logicians,
and linguists. Its properties are well known, and it becomes simple to evaluate the
meaning of a sentence if given a logical model and domain, as well as verify whether
or not one sentence entails another according to the rules of logical consequence and
deduction.

Syntactic Analysis Semantic Interpretation
S → NP VP |VP|(|NP|)
NP → cats, milk, etc. |cats|, |milk|, . . .
VP → Vt NP |Vt|(|NP|)
Vt → like, hug, etc. λyx.|like|(x, y), . . .

⇒

|like|(|cats|, |milk|)

|cats| λx.|like|(x, |milk|)

λyx.|like|(x, y) |milk|
Figure 1
A simple model of formal semantics.

73



Computational Linguistics Volume 41, Number 1

However, such logical analysis says nothing about the closeness in meaning or
topic of expressions beyond their truth-conditions and which models satisfy these truth
conditions. Hence, formal semantic approaches to modeling language meaning do not
perform well on language tasks where the notion of similarity is not strictly based on
truth conditions, such as document retrieval, topic classification, and so forth. Further-
more, an underlying domain of objects and a valuation function must be provided,
as with any logic, leaving open the question of how we might learn the meaning of
language using such a model, rather than just use it.

2.2 Distributional Semantics

A popular way of representing the meaning of words in lexical semantics is as dis-
tributions in a high-dimensional vector space. This approach is based on the distri-
butional hypothesis of Harris (1968), who postulated that the meaning of a word was
dictated by the context of its use. The more famous dictum stating this hypothesis
is the statement of Firth (1957) that “You shall know a word by the company it
keeps.” This view of semantics has furthermore been associated (Grefenstette 2009;
Turney and Pantel 2010) with earlier work in philosophy of language by Wittgenstein
(presented in Wittgenstein 1953), who stated that language meaning was equivalent to
its real world use.

Practically speaking, the meaning of a word can be learned from a corpus by looking
at what other words occur with it within a certain context, and the resulting distribution
can be represented as a vector in a semantic vector space. This vectorial representation is
convenient because vectors are a familiar structure with a rich set of ways of computing
vector distance, allowing us to experiment with different word similarity metrics. The
geometric nature of this representation entails that we can not only compare individual
words’ meanings with various levels of granularity (e.g., we might, for example, be able
to show that cats are closer to kittens than to dogs, but that all three are mutually closer
than cats and steam engines), but also apply methods frequently called upon in IR tasks,
such as those described by Manning, Raghavan, and Schütze (2011), to group concepts
by topic, sentiment, and so on.

The distribution underlying word meaning is a vector in a vector space, the basis
vectors of which are dictated by the context. In simple models, the basis vectors will
be annotated with words from the lexicon. Traditionally, the vector spaces used in
such models are Hilbert spaces (i.e., vector spaces with orthogonal bases, such that
the inner product of any one basis vector with another [other than itself] is zero). The
semantic vector for any word can be represented as the weighted sum of the basis
vectors:

−−−−−−−→
some word =

∑
i

ci
−→ni

where {−→ni }i is the basis of the vector space the meaning of the word lives in, and ci ∈ R
is the weight associated with basis vector −→ni .

The construction of the vector for a word is done by counting, for each lexicon
word ni associated with basis vector

−→ni , how many times it occurs in the context of
each occurrence of the word for which we are constructing the vector. This count is then
typically adjusted according to a weighting scheme (e.g., TF-IDF). The “context” of a
word can be something as simple as the other words occurring in the same sentence as

74



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

the word or within k words of it, or something more complex, such as using dependency
relations (Padó and Lapata 2007) or other syntactic features.

Commonly, the similarity of two semantic vectors is computed by taking their
cosine measure, which is the sum of the product of the basis weights of the vectors:

cosine(−→a ,−→b ) =
∑

i c
a
i c

b
i√∑

i (c
a
i )

2
∑

i (c
b
i )

2

where cai and c
b
i are the basis weights for

−→a and −→b , respectively. However, other
options may be a better fit for certain implementations, typically dependent on the
weighting scheme.

Readers interested in learning more about these aspects of distributional lexical
semantics are invited to consult Curran (2004), which contains an extensive overview
of implementation options for distributional models of word meaning.

2.3 Compositionality and Vector Space Models

In the previous overview of distributional semantic models of lexical semantics, we
have seen that DSMs are a rich and tractable way of learning word meaning from a
corpus, and obtaining a measure of semantic similarity of words or groups of words.
However, it should be fairly obvious that the same method cannot be applied to sen-
tences, whereby the meaning of a sentence would be given by the distribution of other
sentences with which it occurs.

First and foremost, a sentence typically occurs only once in a corpus, and hence
substantial and informative distributions cannot be created in this manner. More im-
portantly, human ability to understand new sentences is a compositional mechanism:
We understand sentences we have never seen before because we can generate sentence
meaning from the words used, and how they are put into relation. To go from word
vectors to sentence vectors, we must provide a composition operation allowing us to con-
struct a sentence vector from a collection of word vectors. In this section, we will discuss
several approaches to solving this problem, their advantages, and their limitations.

2.3.1 Additive Models. The simplest composition operation that comes to mind is straight-
forward vector addition, such that:

−→
ab = −→a +−→b

Conceptually speaking, if we view word vectors as semantic information distributed
across a set of properties associated with basis vectors, using vector addition as a
semantic composition operation states that the information of a set of lemmas in a
sentence is simply the sum of the information of the individual lemmas. Although
crude, this approach is computationally cheap, and appears sufficient for certain NLP
tasks: Landauer and Dumais (1997) show it to be sufficient for automated essay marking
tasks, and Grefenstette (2009) shows it to perform better than a collection of other simple
similarity metrics for summarization, sentence paraphrase, and document paraphrase
detection tasks.

However, there are two principal objections to additive models of composition: first,
vector addition is commutative, therefore,

−−−−−−−−−−−−→
John drank wine =

−−→
John +

−−−→
drank +

−−−→
wine =

75



Computational Linguistics Volume 41, Number 1

−−−−−−−−−−−−→
Wine drank John, and thus vector addition ignores syntactic structure completely; and
second, vector addition sums the information contained in the vectors, effectively jum-
bling the meaning of words together as sentence length grows.

The first objection is problematic, as the syntactic insensitivity of additive models
leads them to equate the representation of sentences with patently different meanings.
Mitchell and Lapata (2008) propose to add some degree of syntactic sensitivity—namely,
accounting for word order—by weighting word vectors according to their order of
appearance in a sentence as follows:

−→
ab = α−→a + β−→b

where α,β∈R. Consequently, −−−−−−−−−−−−→John drank wine=α · −−→John + β · −−−→drank + γ·−−−→wine would
not have the same representation as

−−−−−−−−−−−−→
Wine drank John = α · −−−→wine + β · −−−→drank + γ · −−→John.

The question of how to obtain weights and whether they are only used to reflect
word order or can be extended to cover more subtle syntactic information is open,
but it is not immediately clear how such weights may be obtained empirically and
whether this mode of composition scales well with sentence length and increase in
syntactic complexity. Guevara (2010) suggests using machine-learning methods such
as partial least squares regression to determine the weights empirically, but states that
this approach enjoys little success beyond minor composition such as adjective-noun
or noun-verb composition, and that there is a dearth of metrics by which to evaluate
such machine learning–based systems, stunting their growth and development.

The second objection states that vector addition leads to increase in ambiguity as
we construct sentences, rather than decrease in ambiguity as we would expect from
giving words a context; and for this reason Mitchell and Lapata (2008) suggest replacing
additive models with multiplicative models as discussed in Section 2.3.2, or combining
them with multiplicative models to form mixture models as discussed in Section 2.3.3.

2.3.2 Multiplicative Models. The multiplicative model of Mitchell and Lapata (2008) is
an attempt to solve the ambiguity problem discussed in Section 2.3.1 and provide
implicit disambiguation during composition. The composition operation proposed is
the component-wise multiplication (�) of two vectors: Vectors are expressed as the
weighted sum of their basis vectors, and the weight of the basis vectors of the com-
posed vector is the product of the weights of the original vectors; for −→a =∑i ci−→ni , and−→
b =

∑
i c

′
i
−→ni , we have

−→
ab = −→a �−→b =

∑
i

cic′i
−→ni

Such multiplicative models are shown by Mitchell and Lapata (2008) to perform better
at verb disambiguation tasks than additive models for noun-verb composition, against
a baseline set by the original verb vectors. The experiment they use to show this will
also serve to evaluate our own models, and form the basis for further experiments, as
discussed in Section 5.

This approach to compositionality still suffers from two conceptual problems:
First, component-wise multiplication is still commutative and hence word order is not
accounted for; second, rather than “diluting” information during large compositions

76



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

and creating ambiguity, it may remove too much through the “filtering” effect of
component-wise multiplication.

The first problem is more difficult to deal with for multiplicative models than for
additive models, because both scalar multiplication and component-wise multiplication
are commutative and hence α−→a � β−→b = α−→b � β−→a and thus word order cannot be
taken into account using scalar weights.

To illustrate how the second problem entails that multiplicative models do not scale
well with sentence length, we look at the structure of component-wise multiplication
again: −→a �−→b =∑i cic′i −→ni . For any i, if ci = 0 or c′i = 0, then cic′i = 0, and therefore
for any composition, the number of non-zero basis weights of the produced vector is
less than or equal to the number of non-zero basis weights of the original vectors: At
each composition step information is filtered out (or preserved, but never increased).
Hence, as the number of vectors to be composed grows, the number of non-zero
basis weights of the product vector stays the same or—more realistically—decreases.
Therefore, for any composition of the form −−−−−−−−→a1 . . . ai . . . an = −→a1 � . . .�−→ai � . . .�−→an , if
for any i, −→ai is orthogonal to −−−−−−→a1 . . . ai−1 then −−−−−−−−→a1 . . . ai . . . an = −→0 . It follows that purely
multiplicative models alone are not apt as a single mode of composition beyond noun-
verb (or adjective-noun) composition operations.

One solution to this second problem not discussed by Mitchell and Lapata (2008)
would be to introduce some smoothing factor s ∈ R+ for point-wise multiplication
such that −→a �−→b =∑i (ci + s)(c′i + s)−→ni , ensuring that information is never completely
filtered out. Seeing how the problem of syntactic insensitivity still stands in the way of
full-blown compositionality for multiplicative models, we leave it to those interested in
salvaging purely multiplicative models to determine whether some suitable value of s
can be determined.

2.3.3 Mixture Models. The problems faced by multiplicative models presented in Sec-
tion 2.3.2 are acknowledged in passing by Mitchell and Lapata (2008), who propose
mixing additive and multiplicative models in the hope of leveraging the advantage of
each while doing away with their pitfalls. This is simply expressed as the weighted sum
of additive and multiplicative models:

−→
ab = α−→a + β−→b + γ(−→a �−→b )

where α, β, and γ are predetermined scalar weights.
The problems for these models are threefold. First, the question of how scalar

weights are to be obtained still needs to be determined. Mitchell and Lapata (2008) con-
cede that one advantage of purely multiplicative models over weighted additive or
mixture models is that the lack of scalar weights removes the need to optimize the scalar
weights for particular tasks (at the cost of not accounting for syntactic structure), and
avoids the methodological concerns accompanying this requirement.

Second, the question of how well this process scales from noun-verb composition
to more syntactically rich expressions must be addressed. Using scalar weights to
account for word order seems ad hoc and superficial, as there is more to syntactic
structure than the mere ordering of words. Therefore, an account of how to build
sentence vectors for sentences such as The dog bit the man and The man was bitten by
the dog in order to give both sentences the same (or a similar) representation would
need to give a richer role to scalar weights than mere token order. Perhaps specific

77



Computational Linguistics Volume 41, Number 1

weights could be given to particular syntactic classes (such as nouns) to introduce a
more complex syntactic element into vector composition, but it is clear that this alone
is not a solution, as the weight for nouns dog and man would be the same, allowing
for the same commutative degeneracy observed in non-weighted additive models, in
which

−−−−−−−−−−−−−−→
the dog bit the man =

−−−−−−−−−−−−−−→
the man bit the dog. Introducing a mixture of weighting

systems accounting for both word order and syntactic roles may be a solution, but it is
not only ad hoc but also arguably only partially reflects the syntactic structure of the
sentence.

The third problem is that Mitchell and Lapata (2008) show that in practice, although
mixture models perform better at verb disambiguation tasks than additive models and
weighted additive models, they perform equivalently to purely multiplicative models
with the added burden of requiring parametric optimization of the scalar weights.

Therefore, whereas mixture models aim to take the best of additive and multiplica-
tive models while avoiding their problems, they are only partly successful in achieving
the latter goal, and demonstrably do little better in achieving the former.

2.3.4 Tensor-Based Models. From Sections 2.3.1–2.3.3 we observe that the need for incor-
porating syntactic information into DSMs to achieve true compositionality is pressing,
if only to develop a non-commutative composition operation that can take into account
word order without the need for adhoc weighting schemes, and hopefully richer syn-
tactic information as well.

An early proposal by Smolensky and colleagues (Smolensky 1990; Smolensky and
Legendre 2006) to use linear algebraic tensors as a composition operation solves the
problem of finding non-commutative vector composition operators. The composition of
two vectors is their tensor product, sometimes called the kronecker product when ap-

plied to vectors rather than vector spaces. For −→a ∈ V =∑i ci−→ni , and −→b ∈ W =∑j c′j−→n′j ,
we have:

−→
ab = −→a ⊗−→b =

∑
ij

cic′j
−→ni ⊗

−→
n′j

The composition operation takes the original vectors and maps them to a vector in a
larger vector space V ⊗ W, which is the tensor space of the original vectors’ spaces.
Here the second instance of ⊗ is not a recursive application of the kronecker product,
but rather the pairing of basis elements of V and W to form a basis element of V ⊗ W.
The shared notation and occasional conflation of kronecker and tensor products may
seem confusing, but is fairly standard in multilinear algebra.

The advantage of this approach is twofold: First, vectors for different words need
not live in the same spaces but can be composed nonetheless. This allows us to repre-
sent vectors for different word classes (topics, syntactic roles, etc.) in different spaces
with different bases, which was not possible under additive or multiplicative models.
Second, because the product vector lives in a larger space, we obtain the intuitive notion
that the information of the whole is richer and more complex than the information of
the parts.

Dimensionality Problems. However, as observed and commented upon by Smolensky
himself, this increase in dimensionality brings two rather large problems for tensor
based models. The first is computational: The size of the product vector space is the
product of the size of the original vector spaces. If we assume that all words live in the

78



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

same space N of dimensionality dim(N), then the dimensionality of an n-word sentence
vector is dim(N)n. If we have as many basis vectors for our word semantic space as
there are lexemes in our vocabulary (e.g., approximately 170k in English2), then the size
of our sentence vectors quickly reaches magnitudes for which vector comparison (or
even storage) are computationally intractable.3 Even if, as most DSM implementations
do, we restrict the basis vectors of word semantic spaces to the k (e.g., k = 2,000) most
frequent words in a corpus, the sentence vector size still grows exponentially with
sentence length, and the implementation problems remain.

The second problem is mathematical: Sentences of different length live in different
spaces, and if we assign different vector spaces to different word types (e.g., syntactic
classes), then sentences of different syntactic structure live in different vector spaces,
and hence cannot be compared directly using inner product or cosine measures, leaving
us with no obvious mode of semantic comparison for sentence vectors. If any model
wishes to use tensor products in composition operations, it must find some way of
reducing the dimensionality of product vectors to some common vector space so that
they may be directly compared.

One notable method by which these dimensionality problems can be solved in
general are the holographic reduced representations proposed by Plate (1991). The
product vector of two vectors is projected into a space of smaller dimensionality by
circular convolution to produce a trace vector. The circular correlation of the trace vector
and one of the original vectors produces a noisy version of the other original vector.
The noisy vector can be used to recover the clean original vector by comparing it with a
predefined set of candidates (e.g., the set of word vectors if our original vectors are word
meanings). Traces can be summed to form new traces effectively containing several vec-
tor pairs from which original vectors can be recovered. Using this encoding/decoding
mechanism, the tensor product of sets of vectors can be encoded in a space of smaller
dimensionality, and then recovered for computation without ever having to fully repre-
sent or store the full tensor product, as discussed by Widdows (2008).

There are problems with this approach that make it unsuitable for our purposes,
some of which are discussed in Mitchell and Lapata (2010). First, there is a limit to
the information that can be stored in traces, which is independent of the size of the
vectors stored, but is a logarithmic function of their number. As we wish to be able
to store information for sentences of variable word length without having to directly
represent the tensored sentence vector, setting an upper bound to the number of vectors
that can be composed in this manner limits the length of the sentences we can represent
compositionally using this method.

Second, and perhaps more importantly, there are restrictions on the nature of
the vectors that can be encoded in such a way: The vectors must be independently
distributed such that the mean Euclidean length of each vector is 1. Such conditions
are unlikely to be met in word semantic vectors obtained from a corpus; and as the
failure to do so affects the system’s ability to recover clean vectors, holographic re-
duced representations are not prima facie usable for compositional DSMs, although it
is important to note that Widdows (2008) considers possible application areas where
they may be of use, although once again these mostly involve noun-verb and adjective-
noun compositionality rather than full blown sentence vector construction. We retain

2 Source: http://www.oxforddictionaries.com/page/howmanywords.
3 At four bytes per integer, and one integer per basis vector weight, the vector for John loves Mary

would require roughly (170, 000 · 4)3 ≈ 280 petabytes of storage, which is over ten times the data Google
processes on a daily basis according to Dean and Ghemawat (2008).

79



Computational Linguistics Volume 41, Number 1

from Plate (1991) the importance of finding methods by which to project the tensored
sentence vectors into a common space for direct comparison, as will be discussed further
in Section 3.

Syntactic Expressivity. An additional problem of a more conceptual nature is that using
the tensor product as a composition operation simply preserves word order. As we
discussed in Section 2.3.3, this is not enough on its own to model sentence meaning. We
need to have some means by which to incorporate syntactic analysis into composition
operations.

Early work on including syntactic sensitivity into DSMs by Grefenstette (1992)
suggests using crude syntactic relations to determine the frame in which the distri-
butions for word vectors are collected from the corpus, thereby embedding syntac-
tic information into the word vectors. This idea was already present in the work of
Smolensky, who used sums of pairs of vector representations and their roles, obtained
by taking their tensor products, to obtain a vector representation for a compound. The
application of these ideas to DSMs was studied by Clark and Pulman (2007), who
suggest instantiating the roles to dependency relations and using the distributional
representations of words as the vectors. For example, in the sentence Simon loves red
wine, Simon is the subject of loves, wine is its object, and red is an adjective describing
wine. Hence, from the dependency tree with loves as root node, its subject and object as
children, and their adjectival descriptors (if any) as their children, we read the following

structure:
−−−→
loves ⊗−−→subj ⊗−−−−→Simon ⊗−→obj ⊗−−−→wine ⊗−→adj ⊗−→red. Using the equality relation for

inner products of tensor products:

〈−→a ⊗−→b | −→c ⊗−→d 〉 = 〈−→a | −→c 〉 × 〈−→b | −→d 〉

We can therefore express inner-products of sentence vectors efficiently without ever
having to actually represent the tensored sentence vector:

〈−−−−−−−−−−−−→Simon loves red wine | −−−−−−−−−−−−−−→Mary likes delicious rosé〉

= 〈−−→loves ⊗−→subj ⊗−−→Simon ⊗−→obj ⊗−−→wine ⊗−→adj ⊗−→red | −→likes ⊗−→subj ⊗−−→Mary ⊗−→obj ⊗−→rosé ⊗−→adj ⊗−−−−→delicious〉

= 〈−−→loves | −→likes〉× 〈−→subj | −→subj〉 × 〈−−→Simon | −−→Mary〉 × 〈−→obj | −→obj〉 × 〈−−→wine | −→rosé〉× 〈−→adj | −→adj 〉 × 〈−→red | −−−−→delicious〉

= 〈−−→loves | −→likes〉× 〈−−→Simon | −−→Mary〉× 〈−−→wine | −→rosé〉 × 〈−→red | −−−−→delicious〉

This example shows that this formalism allows for sentence comparison of sentences
with identical dependency trees to be broken down to term-to-term comparison without
the need for the tensor products to ever be computed or stored, reducing computation
to inner product calculations.

However, although matching terms with identical syntactic roles in the sentence
works well in the given example, this model suffers from the same problems as the
original tensor-based compositionality of Smolensky (1990) in that, by the authors’
own admission, sentences of different syntactic structure live in spaces of different
dimensionality and thus cannot be directly compared. Hence we cannot use this to
measure the similarity between even small variations in sentence structure, such as the
pair “Simon likes red wine” and “Simon likes wine.”

2.3.5 SVS Models. The idea of including syntactic relations to other lemmas in word
representations discussed in Section 2.3.4 is applied differently in the structured vector

80



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

space model presented by Erk and Padó (2008). They propose to represent word mean-
ings not as simple vectors, but as triplets:

w = (v, R, R−1)

where v is the word vector, constructed as in any other DSM, R and R−1 are selectional
preferences, and take the form of R → D maps where R is the set of dependency
relations, and D is the set of word vectors. Selectional preferences are used to encode
the lemmas that w is typically the parent of in the dependency trees of the corpus in the
case of R, and typically the child of in the case of R−1.

Composition takes the form of vector updates according to the following protocol.
Let a = (va, Ra, R−1a ) and b = (vb, Rb, R

−1
b ) be two words being composed, and let r be the

dependency relation linking a to b. The vector update procedure is as follows:

a′ = (va � R−1b (r), Ra − {r}, R−1a )
b′ = (vb � Ra(r), Rb, R−1b − {r})

where a′, b′ are the updated word meanings, and � is whichever vector composition
(addition, component-wise multiplication) we wish to use. The word vectors in the
triplets are effectively filtered by combination with the lemma which the word they
are being composed with expects to bear relation r to, and this relation between the
composed words a and b is considered to be used and hence removed from the domain
of the selectional preference functions used in composition.

This mechanism is therefore a more sophisticated version of the compositional
disambiguation mechanism discussed by Mitchell and Lapata (2008) in that the com-
bination of words filters the meaning of the original vectors that may be ambiguous
(e.g., if we have one vector for bank); but contrary to Mitchell and Lapata (2008), the
information of the original vectors is modified but essentially preserved, allowing for
further combination with other terms, rather than directly producing a joint vector for
the composed words. The added fact that R and R−1 are partial functions associated
with specific lemmas forces grammaticality during composition, since if a holds a
dependency relation r to b which it never expects to hold (for example a verb having
as its subject another verb, rather than the reverse), then Ra and R

−1
b are undefined for r

and the update fails. However, there are some problems with this approach if our goal
is true compositionality.

First, this model does not allow some of the “repeated compositionality” we need
because of the update of R and R−1. For example, we expect that an adjective composed
with a noun produces something like a noun in order to be further composed with a verb
or even another adjective. However, here, because the relation adj would be removed
from R−1b for some noun b composed with an adjective a, this new representation b

′
would not have the properties of a noun in that it would no longer expect composition
with an adjective, rendering representations of simple expressions like “the new red
car” impossible. Of course, we could remove the update of the selectional preference
functions from the compositional mechanism, but then we would lose this attractive
feature of grammaticality enforcement through the partial functionality of R and R−1.

Second, this model does little more than represent the implicit disambiguation that
is expected during composition, rather than actually provide a full blown compositional
model. The inability of this system to provide a novel mechanism by which to obtain

81



Computational Linguistics Volume 41, Number 1

a joint vector for two composed lemmas—thereby building towards sentence vectors—
entails that this system provides no means by which to obtain semantic representations
of larger syntactic structures that can be compared by inner product or cosine measure
as is done with any other DSM. Of course, this model could be combined with the
compositional models presented in Sections 2.3.1–2.3.3 to produce sentence vectors, but
whereas some syntactic sensitivity would have been obtained, the word ordering and
other problems of the aforementioned models would still remain, and little progress
would have been made towards true compositionality.

We retain from this attempt to introduce compositionality in DSMs that including
information obtained from syntactic dependency relations is important for proper dis-
ambiguation, and that having some mechanism by which the grammaticality of the
expression being composed is a precondition for its composition is a desirable feature
for any compositional mechanism.

2.4 Matrix-Based Compositionality

The final class of approaches to vector composition we wish to discuss are three
matrix-based models.

Generic Additive Model. The first is the Generic Additive Model of Zanzotto et al. (2010).
This is a generalization of the weighted additive model presented in Section 2.3.1.
In this model, rather than multiplying lexical vectors by fixed parameters α and β
before adding them to form the representation of their combination, they are instead
the arguments of matrix multiplication by square matrices A and B:

−→
ab = A−→a + B−→b

Here, A and B represent the added information provided by putting two words into
relation.

The numerical content of A and B is learned by linear regression over triplets
(−→a ,−→b ,−→c ) where −→a and −→b are lexical semantic vectors, and −→c is the expected output
of the combination of −→a and −→b . This learning system thereby requires the provision of
labeled data for linear regression to be performed. Zanzotto et al. (2010) suggest several
sources for this labeled data, such as dictionary definitions and word etymologies.

This approach is richer than the weighted additive models because the matrices
act as linear maps on the vectors they take as “arguments,” and thus can encode more
subtle syntactic or semantic relations. However, this model treats all word combinations
as the same operation—for example, treating the combination of an adjective with its
argument and a verb with its subject as the same sort of composition. Because of the
diverse ways there are of training such supervised models, we leave it to those who
wish to further develop this specific line of research to perform such evaluations.

Adjective Matrices. The second approach is the matrix-composition model of Baroni and
Zamparelli (2010), which they develop only for the case of adjective-noun composition,
although their approach can seamlessly be used for any other predicate-argument com-
position. Contrary to most of the earlier approaches proposed, which aim to combine
two lexical vectors to form a lexical vector for their combination, Baroni and Zamparelli
suggest giving different semantic representations to different types, or more specifically
to adjectives and nouns.

82



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

In this model, nouns are lexical vectors, as with other models. However, embracing
a view of adjectives that is more in line with formal semantics than with distributional
semantics, they model adjectives as linear maps taking lexical vectors as input and pro-
ducing lexical vectors as output. Such linear maps can be encoded as square matrices,
and applied to their arguments by matrix multiplication. Concretely, let Madjective be the
matrix encoding the adjective’s linear map, and −−→noun be the lexical semantic vector for
a noun; their combination is simply

−−−−−−−−−→
adjective noun = Madjective ×−−→noun

Similarly to the Generic Additive Model, the matrix for each adjective is learned
by linear regression over a set of pairs (−−→noun,−→c ) where the vectors −−→noun are the lexical
semantic vectors for the arguments of the adjective in a corpus, and −→c is the semantic
vector corresponding to the expected output of the composition of the adjective with
that noun.

This may, at first blush, also appear to be a supervised training method for learn-
ing adjective matrices from “labeled data,” seeing how the expected output vectors
are needed. However, Baroni and Zamparelli (2010) work around this constraint by
automatically producing the labeled data from the corpus by treating the adjective-
noun compound as a single token, and learning its vector using the same distributional
learning methods they used to learn the vectors for nouns. This same approach can be
extended to other unary relations without change and, using the general framework
of the current article, an extension of it to binary predicates has been presented in
Grefenstette et al. (2013), using multistep regression. For a direct comparison of the
results of this approach with some of the results of the current article, we refer the
reader to Grefenstette et al. (2013).

Recursive Matrix-Vector Model. The third approach is the recently developed Recursive
Matrix-Vector Model (MV-RNN) of Socher et al. (2012), which claims the two matrix-
based models described here as special cases. In MV-RNN, words are represented as a
pairing of a lexical semantic vector −→a with an operation matrix A. Within this model,
given the parse of a sentence in the form of a binarized tree, the semantic representation
(−→c , C) of each non-terminal node in the tree is produced by performing the following
two operations on its children (−→a , A) and (−→b , B).

First, the vector component −→c is produced by applying the operation matrix of one
child to the vector of the other, and vice versa, and then projecting both of the products
back into the same vector space as the child vectors using a projection matrix W, which
must also be learned:

−→c = W ×
[

B ×−→a
A ×−→b

]

Second, the matrix C is calculated by projecting the pairing of matrices A and B back
into the same space, using a projection matrix WM, which must also be learned:

C = WM ×
[

A
B

]

83



Computational Linguistics Volume 41, Number 1

The pairing (−→c , C) obtained through these operations forms the semantic representation
of the phrase falling under the scope of the segment of the parse tree below that node.

This approach to compositionality yields good results in the experiments described
in Socher et al. (2012). It furthermore has appealing characteristics, such as treating
relational words differently through their operation matrices, and allowing for recursive
composition, as the output of each composition operation is of the same type of object
as its inputs. This approach is highly general and has excellent coverage of different
syntactic types, while leaving much room for parametric optimization.

The principal mathematical difference with the compositional framework presented
subsequently is that composition in MV-RNN is always a binary operation; for exam-
ple, to compose a transitive verb with its subject and object one would first need to
compose it with its object, and then compose the output of that operation with the
subject. The framework we discuss in this article allows for the construction of larger
representations for relations of larger arities, permitting the simultaneous composition
of a verb with its subject and object. Whether or not this theoretical difference leads to
significant differences in composition quality requires joint evaluation. Additionally,
the description of MV-RNN models in Socher et al. (2012) specifies the need for a
source of learning error during training, which is easy to measure in the case of label
prediction experiments such as sentiment prediction, but non-trivial in the case of
paraphrase detection where no objective label exists. A direct comparison to MV-RNN
methods within the context of experiments similar to those presented in this article has
been produced by Blacoe and Lapata (2012), showing that simple operations perform
on par with the earlier complex deep learning architectures produced by Socher and
colleagues; we leave direct comparisons to future work. Early work has shown that the
addition of a hidden layer with non-linearities to these simple models will improve the
results.

2.5 Some Other Approaches to Distributional Semantics

Domains and Functions. In recent work, Turney (2012) suggests modeling word repre-
sentations not as a single semantic vector, but as a pair of vectors: one containing the
information of the word relative to its domain (the other words that are ontologically
similar), and another containing information relating to its function. The former vector
is learned by looking at what nouns a word co-occurs with, and the latter is learned
by looking at what verb-based patterns the word occurs in. Similarity between sets of
words is not determined by a single similarity function, but rather through a combi-
nation of comparisons of the domain components of words’ representations with the
function components of the words’ representations. Such combinations are designed
on a task-specific basis. Although Turney’s work does not directly deal with vector
composition of the sort we explore in this article, Turney shows that similarity measures
can be designed for tasks similar to those presented here. The particular limitation of
his approach, which Turney discusses, is that similarity measures must be specified for
each task, whereas most of the compositional models described herein produce repre-
sentations that can be compared in a task-independent manner (e.g., through cosine
similarity). Nonetheless, this approach is innovative, and will merit further attention in
future work in this area.

Language as Algebra. A theoretical model of meaning as context has been proposed in
Clarke (2009, 2012). In that model, the meaning of any string of words is a vector built

84



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

from the occurrence of the string in a corpus. This is the most natural extension of
distributional models from words to strings of words: in that model, one builds vectors
for strings of words in exactly the same way as one does for words. The main problem,
however, is that of data sparsity for the occurrences of strings of words. Words do
appear repeatedly in a document, but strings of words, especially for longer strings,
rarely do so; for instance, it hardly happens that an exact same sentence appears more
than once in a document. To overcome this problem, the model is based on the hypo-
thetical concept of an infinite corpus, an assumption that prevents it from being applied
to real-world corpora and experimented within natural language processing tasks. On
the positive side, the model provides a theoretical study of the abstract properties of
a general bilinear associative composition operator; in particular, it is shown that this
operator encompasses other composition operators, such as addition, multiplication,
and even tensor product.

3. DisCoCat

In Section 2, we discussed lexical DSMs and the problems faced by attempts to provide
a vector composition operation that would allow us to form distributional sentence rep-
resentations as a function of word meaning. In this section, we will present an existing
formalism aimed at solving this compositionality problem, as well as the mathematical
background required to understand it and further extensions, building on the features
and failures of previously discussed attempts at syntactically sensitive compositionality.

Clark, Coecke, and Sadrzadeh (2008) and Coecke, Sadrzadeh, and Clark (2010)
propose adapting a category theoretic model, inspired by the categorical compositional
vector space model of quantum protocols (Abramsky and Coecke 2004), to the task
of compositionality of semantic vectors. Syntactic analysis in the form of pregroup
grammars—a categorial grammar—is given categorical semantics in order to be repre-
sented as a compact closed category P (a concept explained subsequently), the objects of
which are syntactic types and the morphisms of which are the reductions forming the
basis of syntactic analysis. This syntactic category is then mapped onto the semantic
compact closed category FVect of finite dimensional vector spaces and linear maps.
The mapping is done in the product category FVect × P via the following procedure.
Each syntactic type is interpreted as a vector space in which semantic vectors for words
with that particular syntactic type live; the reductions between the syntactic types are
interpreted as linear maps between the interpreted vector spaces of the syntactic types.

The key feature of category theory exploited here is its ability to relate in a canonical
way different mathematical formalisms that have similar structures, even if the original
formalisms belong in different branches of mathematics. In this context, it has enabled
us to relate syntactic types and reductions to vector spaces and linear maps and obtain
a mechanism by which syntactic analysis guides semantic composition operations.

This pairing of syntactic analysis and semantic composition ensures both that
grammaticality restrictions are in place as in the model of Erk and Padó (2008) and
syntactically driven semantic composition in the form of inner-products provide the im-
plicit disambiguation features of the compositional models of Erk and Padó (2008) and
Mitchell and Lapata (2008). The composition mechanism also involves the projection of
tensored vectors into a common semantic space without the need for full representation
of the tensored vectors in a manner similar to Plate (1991), without restriction to the
nature of the vector spaces it can be applied to. This avoids the problems faced by other
tensor-based composition mechanisms such as Smolensky (1990) and Clark and Pulman
(2007).

85



Computational Linguistics Volume 41, Number 1

The word vectors can be specified model-theoretically and the sentence space can be
defined over Boolean values to obtain grammatically driven truth-theoretic semantics
in the style of Montague (1974), as proposed by Clark, Coecke, and Sadrzadeh (2008).
Some logical operators can be emulated in this setting, such as using swap matrices for
negation as shown by Coecke, Sadrzadeh, and Clark (2010). Alternatively, corpus-based
variations on this formalism have been proposed by Grefenstette et al. (2011) to obtain
a non-truth theoretic semantic model of sentence meaning for which logical operations
have yet to be defined.

Before explaining how this formalism works, in Section 3.3, we will introduce the
notions of pregroup grammars in Section 3.1, and the required basics of category theory
in Section 3.2.

3.1 Pregroup Grammars

Presented by Lambek (1999, 2008) as a successor to his syntactic calculus (Lambek 1958),
pregroup grammars are a class of categorial type grammars with pregroup algebras
as semantics. Pregroups are particularly interesting within the context of this work
because of their well-studied algebraic structure, which can trivially be mapped onto the
structure of the category of vector spaces, as will be discussed subsequently. Logically
speaking, a pregroup is a non-commutative form of Linear Logic (Girard 1987) in which
the tensor and its dual par coincide; this logic is sometimes referred to as Bi-Compact
Linear Logic (Lambek 1999). The formalism works alongside the general guidelines of
other categorial grammars, for instance, those of the combinatory categorial grammar
(CCG) designed by Steedman (2001) and Steedman and Baldridge (2011). They consist
of atomic grammatical types that combine to form compound types. A series of CCG-
like application rules allow for type-reductions, forming the basis of syntactic analysis.
As our first step, we show how this syntactic analysis formalism works by presenting
an introduction to pregroup algebras.

Pregroups. A pregroup is an algebraic structure of the form (P,≤, ·, 1, (−)l, (−)r). Its
elements are defined as follows:

� P is a set {a, b, c, . . .}.
� The relation ≤ is a partial ordering on P.
� The binary operation · is an associative, non-commutative monoid

multiplication with the type − · − : P × P → P, such that if a, b ∈ P then
a · b ∈ P. In other words, P is closed under this operation.

� 1 ∈ P is the unit, satisfying a · 1 = a = 1 · a for all a ∈ P.
� (−)l and (−)r are maps with types (−)l : P → P and (−)r : P → P such that

for any a ∈ P, we have that al, ar ∈ P. The images of these maps are
referred to as the left and the right adjoints. These are unique and satisfy
the following conditions:

– Reversal: if a ≤ b then bl ≤ al (and similarly for ar, br).
– Ordering: a · ar ≤ 1 ≤ ar · a and al · a ≤ 1 ≤ a · al.
– Cancellation: alr = a = arl.
– Self-adjointness of identity: 1r = 1 = 1l.
– Self-adjointness of multiplication: (a · b)r = br · ar.

86



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

As a notational simplification we write ab for a · b, and if abcd ≤ cd we write abcd →
cd and call this a reduction, omitting the identity wherever it might appear. Monoid
multiplication is associative, so parentheses may be added or removed for notational
clarity without changing the meaning of the expression as long as they are not directly
under the scope of an adjoint operator.

An example reduction in pregroup might be:

aarbclc → bclc → b

We note here that the reduction order is not always unique, as we could have reduced as
follows: aarbclc → aarb → b. As a further notational simplification, if there exists a chain
of reductions a → . . . → b we may simply write a → b (in virtue of the transitivity of
partial ordering relations). Hence in our given example, we can express both reduction
paths as aarbclc → b.

Pregroups and Syntactic Analysis. Pregroups are used for grammatical analysis by freely
generating the set P of a pregroup from the basic syntactic types n, s, . . . , where here
n stands for the type of both a noun and a noun phrase and s for that of a sentence.
The conflation of nouns and noun phrases suggested here is done to keep the work
discussed in this article as simple as possible, but we could of course model them as
different types in a more sophisticated version of this pregroup grammar. As in any
categorial grammar, words of the lexicon are assigned one or more possible types
(corresponding to different syntactic roles) in a predefined type dictionary, and the
grammaticality of a sentence is verified by demonstrating the existence of a reduction
from the combination of the types of words within the sentence to the sentence type s.

For example, having assigned to noun phrases the type n and to sentences the type s,
the transitive verbs will have the compound type nrsnl. We can read from the type of
a transitive verb that it is the type of a word which “expects” a noun phrase on its left
and a noun phrase on its right, in order to produce a sentence. A sample reduction of
John loves cake with John and cake being noun phrases of type n and loves being a verb of
type nrsnl is as follows:

n(nrsnl)n → s

We see that the transitive verb has combined with the subject and object to reduce to a
sentence. Because the combination of the types of the words in the string John loves cake
reduces to s, we say that this string of words is a grammatical sentence. As for more
examples, we recall that intransitive verbs can be given the type nrs such that John sleeps
would be analyzed in terms of the reduction n(nrs) → s. Adjectives can be given the
type nnl such that red round rubber ball would be analyzed by (nnl)(nnl)(nnl)n → n. And
so on and so forth for other syntactic classes.

Lambek (2008) presents the details of a slightly more complex pregroup grammar
with a richer set of types than presented here. This grammar is hand-constructed and
iteratively extended by expanding the type assignments as more sophisticated gram-
matical constructions are discussed. No general mechanism is proposed to cover all
such types of assignments for larger fragments (e.g., as seen in empirical data). Pregroup
grammars have been proven to be learnable by Béchet, Foret, and Tellier (2007), who
also discuss the difficulty of this task and the nontractability of the procedure. Because
of these constraints and lack of a workable pregroup parser, the pregroup grammars

87



Computational Linguistics Volume 41, Number 1

we will use in our categorical formalism are derived from CCG types, as we explain in
the following.

Pregroup Grammars and Other Categorial Grammars. Pregroup grammars, in contrast with
other categorial grammars such as CCG, do not yet have a large set of tools for parsing
available. If quick implementation of the formalism described later in this paper is
required, it would be useful to be able to leverage the mature state of parsing tools
available for other categorial grammars, such as the Clark and Curran (2007) statistical
CCG parser, as well as Hockenmaier’s CCG lexicon and treebank (Hockenmaier 2003;
Hockenmaier and Steedman 2007). In other words, is there any way we can translate at
least some subset of CCG types into pregroup types?

There are some theoretical obstacles to consider first: Pregroup grammars and CCG
are not equivalent. Buszkowski (2001) shows pregroup grammars to be equivalent to
context-free grammars, whereas Joshi, Vijay-Shanker, and Weir (1989) show CCG to be
weakly equivalent to more expressive mildly context-sensitive grammars. However, if
our goal is to exploit the CCG used in Clark and Curran’s parser, or Hockenmaier’s
lexicon and treebank, we may be in luck: Fowler and Penn (2010) prove that some
CCGs, such as those used in the aforementioned tools, are strongly context-free and thus
expressively equivalent to pregroup grammars. In order to be able to apply the parsing
tools for CCGs to our setting, we use a translation mechanism from CCG types to pre-
group types based on the Lambek-calculus-to-pregroup-grammar translation originally
presented in Lambek (1999). In this mechanism, each atomic CCG type X is assigned a
unique pregroup type x; for any X/Y in CCG we have xyl in the pregroup grammar; and
for any X\Y in CCG we have yrx in pregroup grammar. Therefore, by assigning NP to n
and S to s we could, for example, translate the CCG transitive verb type (S\NP)/NP into
the pregroup type nrsnl, which corresponds to the pregroup type we used for transitive
verbs in Section 3.1. Wherever type replacement (e.g., N → NP) is allowed in CCG we
set an ordering relation in the pregroup grammar (e.g., n̄ ≤ n, where n̄ is the pregroup
type associated with N). Because forward and backward slash “operators” in CCG are
not associative whereas monoid multiplication in pregroups is, it is evident that some
information is lost during the translation process. But because the translation we need
is one-way, we may ignore this problem and use CCG parsing tools to obtain pregroup
parses. Another concern lies with CCG’s crossed composition and substitution rules.
The translations of these rules do not in general hold in a pregroup; this is not a surprise
as pregroups are a simplification of the Lambek Calculus and these rules did not hold
in the Lambek Calculus either, as shown in Moortgat (1997), for example. However, for
the phenomena modeled in this paper, the CCG rules without the backward cross rules
will suffice. In general for the case of English, one can avoid the use of these rules by
overloading the lexicon and using additional categories. To deal with languages that
have cross dependancies, such as Dutch, various solutions have been suggested (e.g.,
see Genkin, Francez, and Kaminski 2010; Preller 2010).

3.2 Categories

Category theory is a branch of pure mathematics that allows for a general and uniform
formulation of various different mathematical formalisms in terms of their main struc-
tural properties using a few abstract concepts such as objects, arrows, and combinations
and compositions of these. This uniform conceptual language allows for derivation
of new properties of existing formalisms and for relating these to properties of other
formalisms, if they bear similar categorical representation. In this function, it has been

88



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

at the center of recent work in unifying two orthogonal models of meaning, a qualitative
categorial grammar model and a quantitative distributional model (Clark, Coecke, and
Sadrzadeh 2008; Coecke, Sadrzadeh, and Clark 2010). Moreover, the unifying categori-
cal structures at work here were inspired by the ones used in the foundations of physics
and the modeling of quantum information flow, as presented in Abramsky and Coecke
(2004), where they relate the logical structure of quantum protocols to their state-based
vector spaces data. The connection between the mathematics used for this branch of
physics and those potentially useful for linguistic modeling has also been noted by
several sources, such as Widdows (2005), Lambek (2010), and Van Rijsbergen (2004).

In this section, we will briefly examine the basics of category theory, monoidal
categories, and compact closed categories. The focus will be on defining enough ba-
sic concepts to proceed rather than provide a full-blown tutorial on category theory
and the modeling of information flow, as several excellent sources already cover both
aspects (e.g., Mac Lane 1998; Walters 1991; Coecke and Paquette 2011). A categories-
in-a-nutshell crash course is also provided in Clark, Coecke, and Sadrzadeh (2008) and
Coecke, Sadrzadeh, and Clark (2010).

The Basics of Category Theory. A basic category C is defined in terms of the following
elements:

� A collection of objects ob(C).
� A collection of morphisms hom(C).
� A morphism composition operation ◦.

Each morphism f has a domain dom( f ) ∈ ob(C) and a codomain codom( f ) ∈ ob(C).
For dom( f ) = A and codom( f ) = B we abbreviate these definitions as f : A → B. Despite
the notational similarity to function definitions (and sets and functions being an ex-
ample of a category), it is important to state that nothing else is presupposed about
morphisms, and we should not treat them a priori as functions.

The following axioms hold in every category C :

� For any f : A → B and g : B → C there exists h : A → C and h = g ◦ f .
� For any f : A → B, g : B → C and h : C → D, ◦ satisfies

(h ◦ g) ◦ f = h ◦ (g ◦ f ).
� For every A ∈ ob(C) there is an identity morphism idA : A → A such

that for any f : A → B, f ◦ idA = f = idB ◦ f .

We can model various mathematical formalisms using these basic concepts, and
verify that these axioms hold for them. For example, category Set with sets as objects and
functions as morphisms, or category Rel with sets as objects and relations as morphisms,
category Pos with posets as objects and order-preserving maps as morphisms, and
category Group with groups as objects and group homomorphisms as morphisms, to
name a few.

The product C × D of two categories C and D is a category with pairs (A, B) as
objects, where A ∈ ob(C) and B ∈ ob(D). There exists a morphism (f, g) : (A, B) → (C, D)
in C × D if and only if there exists f : A → C ∈ hom(C) and g : B → D ∈ hom(D). Product
categories allow us to relate objects and morphisms of one mathematical formalism to
those in another, in this example those of C to D.

89



Computational Linguistics Volume 41, Number 1

Compact Closed Categories. A monoidal category C is a basic category to which we add a
monoidal tensor ⊗ such that:

� For all A, B ∈ ob(C) there is an object A ⊗ B ∈ ob(C).
� For all A, B, C ∈ ob(C), we have (A ⊗ B) ⊗ C = A ⊗ (B ⊗ C).
� There exists some I ∈ ob(C) such that for any A ∈ ob(C), we have

I ⊗ A = A = A ⊗ I.
� For f : A → C and g : B → D in hom(C) there is f ⊗ g : A ⊗ B → C ⊗ D in

hom(C).
� For f1 : A → C, f2 : B → D, g1 : C → E and g2 : D → F the following

equality holds:

(g1 ⊗ g2) ◦ ( f1 ⊗ f2) = (g1 ◦ f1) ⊗ (g2 ◦ f2)
The product category of two monoidal categories has a monodial tensor, defined point-
wisely by (a, A) ⊗ (b, B) := (a ⊗ b, A ⊗ B).

A compact closed category C is a monoidal category with the following additional
axioms:

� Each object A ∈ ob(C) has left and right “adjoint” objects Al and Ar in
ob(C).

� There exist four structural morphisms for each object A ∈ ob(C):
– ηlA : I → A ⊗ Al.
– ηrA : I → Ar ⊗ A.
– �lA : A

l ⊗ A → I.
– �rA : A ⊗ Ar → I.

� The previous structural morphisms satisfy the following equalities:

– (1A ⊗ �lA) ◦ (ηlA ⊗ 1A) = 1A.
– (�rA ⊗ 1A) ◦ (1A ⊗ ηrA) = 1A.
– (1Ar ⊗ �rA) ◦ (ηr ⊗ 1Ar ) = 1Ar .
– (�lA ⊗ 1Al ) ◦ (1Al ⊗ ηlA) = 1Al .

Compact closed categories come equipped with complete graphical calculi, sur-
veyed in Selinger (2010). These calculi visualize and simplify the axiomatic reasoning
within the category to a great extent. In particular, Clark, Coecke, and Sadrzadeh
(2008) and Coecke, Sadrzadeh, and Clark (2010) show how they depict the pregroup
grammatical reductions and visualize the flow of information in composing meanings
of single words and forming meanings for sentences. Although useful at an abstract
level, these calculi do not play the same simplifying role when it comes to the concrete
and empirical computations; therefore we will not discuss them in this article.

A very relevant example of a compact closed category is a pregroup algebra P.
Elements of a pregroup are objects of the category, the partial ordering relation provides
the morphisms, 1 is I, and monoidal multiplication is the monoidal tensor.

Another very relevant example is the category FVect of finite dimensional Hilbert
spaces and linear maps over R—that is, vector spaces over R with orthogonal bases
of finite dimension, and an inner product operation 〈− | −〉 : A × A → R for every
vector space A. The objects of FVect are vector spaces, and the morphisms are linear

90



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

maps between vector spaces. The unit object is R and the monoidal tensor is the linear
algebraic tensor product. FVect is degenerate in its adjoints, in that for any vector space
A, we have Al = Ar = A∗, where A∗ is the dual space of A. Moreover, by fixing a basis we
obtain that A∗ ∼= A. As such, we can effectively do away with adjoints in this category,
and “collapse” �l, �r, ηl, and ηr maps into “adjoint-free” � and η maps. In this category,
the �maps are inner product operations, �A : A ⊗ A → R, and the η maps η : R → A ⊗ A
generate maximally entangled states, also referred to as Bell-states.

3.3 A Categorical Passage from Grammar to Semantics

In Section 3.2 we showed how a pregroup algebra and vector spaces can be modeled
as compact closed categories and how product categories allow us to relate the objects
and morphisms of one category to those of another. In this section, we will present how
Clark, Coecke, and Sadrzadeh (2008) and Coecke, Sadrzadeh, and Clark (2010) suggest
building on this by using categories to relate semantic composition to syntactic analysis
in order to achieve syntax-sensitive composition in DSMs.

3.3.1 Syntax Guides Semantics. The product category FVect × P has as object pairs (A, a),
where A is a vector space and a is a pregroup grammatical type, and as morphism pairs
( f,≤) where f is a linear map and ≤ a pregroup ordering relation. By the definition of
product categories, for any two vector space-type pairs (A, a) and (B, b), there exists
a morphism (A, a) → (B, b) only if there is both a linear map from A into B and a
partial ordering a → b. If we view these pairings as the association of syntactic types
with vector spaces containing semantic vectors for words of that type, this restriction
effectively states that a linear map from A to B is only “permitted” in the product
category if a reduces to b.

Both P and FVect being compact closed, it is simple to show that FVect × P is as well,
by considering the pairs of unit objects and structural morphisms from the separate
categories: I is now (R, 1), and the structural morphisms are (�A, �la), (�A, �

r
a), (ηA,η

l
a),

and (ηA,ηra). We are particularly interested in the � maps, which are defined as follows
(from the definition of product categories):

(�A, �lA) : (A ⊗ A, ala) → (R, 1) (�A, �rA) : (A ⊗ A, aar) → (R, 1)

This states that whenever there is a reduction step in the grammatical analysis of a
sentence, there is a composition operation in the form of an inner product on the
semantic front. Hence, if nouns of type n live in some noun space N and transitive
verbs of type nlsnr live in some space N ⊗ S ⊗ N, then there must be some structural
morphism of the form:

(�N ⊗ 1S ⊗ �N, �rn1s�ln) : (N ⊗ (N ⊗ S ⊗ N) ⊗ N, n(nrsnl)n) → (S, s)

We can read from this morphism the functions required to compose a sentence with a
noun, a transitive verb, and an object to obtain a vector living in some sentence space S,
namely, (�N ⊗ 1S ⊗ �N ).

The form of a syntactic type is therefore what dictates the structure of the semantic
space associated with it. The structural morphisms of the product category guarantee
that for every syntactic reduction there is a semantic composition morphism provided
by the product category: syntactic analysis guides semantic composition.

91



Computational Linguistics Volume 41, Number 1

3.3.2 Example. To give an example, we give syntactic type n to nouns, and nrs to intran-
sitive verbs. The grammatical reduction for kittens sleep, namely, nnrs → s, corresponds
to the morphism �rn ⊗ 1s in P. The syntactic types dictate that the noun

−−−−→
kittens lives

in some vector space N, and the intransitive verb
−−−→
sleep in N ⊗ S. The reduction mor-

phism gives us the composition morphism (�N ⊗ 1S), which we can apply to
−−−−→
kittens

⊗−−−→sleep.
Because we can express any vector as the weighted sum of its basis vectors, let

us expand
−−−−→
kittens =

∑
i c

kittens
i

−→ni and
−−−→
sleep =

∑
ij c

sleep
ij

−→ni ⊗−→sj ; then we can express the
composition as follows:

−−−−−−−−→
kittens sleep = (�N ⊗ 1S)(

−−−−→
kittens ⊗−−−→sleep)

= (�N ⊗ 1S)
⎛
⎝∑

i

ckittensi
−→ni ⊗

∑
jk

csleepjk
−→nj ⊗−→sk

⎞
⎠

= (�N ⊗ 1S)
⎛
⎝∑

ijk

ckittensi c
sleep
jk

−→ni ⊗−→nj ⊗−→sk

⎞
⎠

=
∑

ijk

ckittensi c
sleep
jk 〈−→ni | −→nj 〉−→sk

=
∑

ik

ckittensi c
sleep
ik

−→sk

In these equations, we have expressed the vectors in their explicit form, we have
consolidated the sums by virtue of distributivity of linear algebraic tensor product over
addition, we have applied the tensored linear maps to the vector components (as the
weights are scalars), and finally, we have simplified the indices since 〈−→ni | −→nj 〉 = 1 if−→ni = −→nj and 0 otherwise. As a result of these, we have obtained a vector that lives in
sentence space S.

Transitive sentences can be dealt with in a similar fashion:

−−−−−−−−−−−−−→
kittens chase mice

= (�N ⊗ 1S ⊗ �N)(
−−−−→
kittens ⊗−−−→chase ⊗−−→mice)

= (�N ⊗ 1S ⊗ �N)
⎛
⎝∑

i

ckittensi
−→ni ⊗

⎛
⎝∑

jkl

cchasejkl
−→nj ⊗−→sk ⊗−→nl

⎞
⎠⊗∑

m

cmicem
−→nm

⎞
⎠

= (�N ⊗ 1S ⊗ �N)
⎛
⎝∑

ijklm

ckittensi c
chase
jkl c

mice
m

−→ni ⊗−→nj ⊗−→sk ⊗−→nl ⊗−→nm

⎞
⎠

=
∑
ijklm

ckittensi c
chase
jkl c

mice
m 〈−→ni | −→nj 〉−→sk 〈−→nl | −→nm〉

=
∑
ikm

ckittensi c
chase
ikm c

mice
m

−→sk

92



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

In both cases, it is important to note that the tensor product passed as argument
to the composition morphism, namely,

−−−−→
kittens ⊗−−−→sleep in the intransitive case and−−−−→

kittens ⊗−−−→chase ⊗−−→mice in the transitive case, never needs to be computed. We can
treat the tensor products here as commas separating function arguments, thereby
avoiding the dimensionality problems presented by earlier tensor-based approaches to
compositionality.

3.4 This Article and the DisCoCat Literature

As elaborated on in Section 2.3.4, the first general setting for pairing meaning vec-
tors with syntactic types was proposed in Clark and Pulman (2007). The setting of a
DisCoCat generalized this by making the meaning derivation process rely on a syntactic
type system, hence overcoming its central problem whereby the vector representations
of strings of words with different grammatical structure lived in different spaces. A
preliminary version of a DisCoCat was developed in Clark, Coecke, and Sadrzadeh
(2008), a full version was elaborated on in Coecke, Sadrzadeh, and Clark (2010), where,
based on the developments of Preller and Sadrzadeh (2010), it was also exemplified
how the vector space model may be instantiated in a truth theoretic setting where
meanings of words were sets of their denotations and meanings of sentences were their
truth values. A nontechnical description of this theoretical setting was presented in
Clark (2013), where a plausibility truth-theoretic model for sentence spaces was worked
out and exemplified. The work of Grefenstette et al. (2011) focused on a tangential
branch and developed a toy example where neither words nor sentence spaces were
Boolean. The applicability of the theoretical setting to a real empirical natural language
processing task and data from a large scale corpus was demonstrated in Grefenstette
and Sadrzadeh (2011a, 2011b). There, we presented a general algorithm to build vector
representations for words with simple and complex types and the sentences containing
them; then applied the algorithm to a disambiguation task performed on the British
National Corpus (BNC). We also investigated the vector representation of transitive
verbs and showed how a number of single operations may optimize the performance.
We discuss these developments in detail in the following sections.

4. Concrete Semantic Spaces

In Section 3.3 we presented a categorical formalism that relates syntactic analysis
steps to semantic composition operations. The structure of our syntactic representation
dictates the structure of our semantic spaces, but in exchange, we are provided with
composition functions by the syntactic analysis, rather than having to stipulate them
ad hoc. Whereas the approaches to compositional DSMs presented in Section 2 either
failed to take syntax into account during composition, or did so at the cost of not being
able to compare sentences of different structure in a common space, this categorical
approach projects all sentences into a common sentence space where they can be directly
compared. However, this alone does not give us a compositional DSM.

As we have seen in the previous examples, the structure of semantic spaces varies
with syntactic types. We therefore cannot construct vectors for different syntactic types
in the same way, as they live in spaces of different structure and dimensionality. Further-
more, nothing has yet been said about the structure of the sentence space S into which
expressions reducing to type s are projected. If we wish to have a compositional DSM

93



Computational Linguistics Volume 41, Number 1

that leverages all the benefits of lexical DSMs and ports them to sentence-level distribu-
tional representations, we must specify a new sort of vector construction procedure.

In the original formulation of this formalism by Clark, Coecke, and Sadrzadeh
(2008) and Coecke, Sadrzadeh, and Clark (2010), examples of how such a compositional
DSM could be used for logical evaluation are presented, where S is defined as a Boolean
space with True and False as basis vectors. However, the word vectors used are hand-
written and specified model-theoretically, as the authors leave it for future research to
determine how such vectors might be obtained from a corpus. In this section, we will
discuss a new way of constructing vectors for compositional DSMs, and of defining
sentence space S, in order to reconcile this powerful categorical formalism with the
applicability and flexibility of standard distributional models.

4.1 Defining Sentence Space

Assume the following sentences are all true:

1. The dogs chased the cats.

2. The dogs annoyed the cats.

3. The puppies followed the kittens.

4. The train left the station.

5. The president followed his agenda.

If asked which sentences have similar meaning, we would most likely point to the
pair (1) and (3), and perhaps to a lesser degree (1) and (2), and (2) and (3). Sentences (4)
and (5) obviously speak of a different state of the world as the other sentences.

If we compare these by truth value, we obviously have no means of making such
distinctions. If we compare these by lexical similarity, (1) and (2) seem to be a closer
match than (1) and (3). If we are classifying these sentences by some higher order
relation such as “topic,” (5) might end up closer to (3) than (1). What, then, might cause
us to pair (1) and (3)?

Intuitively, this similarity seems to be because the subjects and objects brought into
relation by similar verbs are themselves similar. Abstracting away from tokens to some
notion of property, we might say that both (1) and (3) express the fact that something
furry and feline and furtive is being pursued by something aggressive (or playful)
and canine. Playing along with the idea that lexical distributional semantics present
concepts (word meanings) as “messy bundles of properties,” it seems only natural to
have the way these properties are acted upon, qualified, and related as the basis for
sentence-level distributional representations. In this respect, we here suggest that the
sentence space S, instead of qualifying the truth value of a sentence, should express
how the properties of the semantic objects within are qualified or brought into relation
by verbs, adjectives, and other predicates and relations.

More specifically, we examine two suggestions for defining the sentence space,
namely, SI ∼= N for sentences with intransitive verbs and ST ∼= N ⊗ N for sentences
with transitive verbs. These definitions mean that the sentence space’s dimensions are
commensurate with either those of N, or those of N ⊗ N. These are by no means the
only options, but as we will discuss here, they offer practical benefits.

In the case of SI, the basis elements are labeled with unique basis elements of N,
hence, −→s1 = −→n1 , −→s2 = −→n2, and so on. In the case of ST, the basis elements are labeled with

94



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

unique ordered pairs of elements from N, for example, −→s1 =
−−−−→
(n1, n1),

−→s2 =
−−−−→
(n2, n1),

−→s3 =−−−−→
(n1, n2), and so on, following the same matrix flattening structure used in the proof of
the equal cardinality of N and Q. Because of the isomorphism between ST and N ⊗ N, we
will use the notations

−−−−→
(ni, nj) and

−→ni ⊗−→nj interchangeably, as both constitute appropriate
ways of representing the basis elements of such a space. To propagate this distinction
on the syntactic level, we define types sI and sT for intransitive and transitive sentences,
respectively.

In creating this distinction, we lost one of the most appealing features of the frame-
work of Coecke, Sadrzadeh, and Clark (2010), namely, the result that all sentence vectors
live in the same sentence space. A mathematical solution to this two-space problem was
suggested in Grefenstette et al. (2011), and a variant of the models presented in this
article permitting the non-problematic projection into a single sentence space (S ∼= N)
has been presented by Grefenstette et al. (2013). Keeping this separation allows us to
deal with both the transitive and intransitive cases in a simpler manner, and because
the experiments in this article only compare intransitive sentences with intransitive
sentences, and transitive sentences with transitive sentences, we will not address the
issue of unification here.

4.2 Noun-Oriented Types

While Lambek’s pregroup types presented in Lambek (2008) include a rich array of
basic types and hand-designed compound types in order to capture specific grammatic
properties, for the sake of simplicity we will use a simpler set of grammatical types
for experimental purposes, similar to some common types found in the CCG-bank
(Steedman 2001).

We assign a basic pregroup type n for all nouns, with an associated vector space N
for their semantic representations. Furthermore, we will treat noun-phrases as nouns,
assigning to them the same pregroup type and semantic space.

CCG treats intransitive verbs as functions NP\S that consume a noun phrase and
return a sentence, and transitive verbs as functions (NP\S)/NP that consume a noun
phrase and return an intransitive verb function, which in turn consumes a noun phrase
and returns a sentence. Using our distinction between intransitive sentences, we give
intransitive verbs the type nrsI associated with the semantic space N ⊗ SI, and transitive
verbs the type nrsTnl associated with the semantic space N ⊗ ST ⊗ N.

Adjectives, in CCG, are treated as functions NP/NP, consuming a noun phrase and
returning a noun phrase; and hence we give them the type nnl and associated semantic
space N ⊗ N.

With the provision of a learning procedure for vectors in these semantic spaces, we
can use these types to construct sentence vector representations for simple intransitive
verb–based and transitive verb–based sentences, with and without adjectives applied
to subjects and objects.

4.3 Learning Procedures

To begin, we construct the semantic space N for all nouns in our lexicon (typically lim-
ited by the words available in the corpus used). Any distributional semantic model can
be used for this stage, such as those presented in Curran (2004), or the lexical semantic
models used by Mitchell and Lapata (2008). It seems reasonable to assume that higher
quality lexical semantic vectors—as measured by metrics such as the WordSim353 test

95



Computational Linguistics Volume 41, Number 1

of Finkelstein et al. (2001)—will produce better relational vectors from the procedure
designed subsequently. We will not test the hypothesis here, but note that it is an
underlying assumption in most of the current literature on the subject (Erk and Padó
2008; Mitchell and Lapata 2008; Baroni and Zamparelli 2010).

Building upon the foundation of the thus constructed noun vectors, we construct
semantic representations for relational words. In pregroup grammars (or other com-
binatorial grammars such as CCG), we can view such words as functions, taking as
arguments those types present as adjoints in the compound pregroup type, and return-
ing a syntactic object whose type is that of the corresponding reduction. For example,
an adjective nnl takes a noun or noun phrase n and returns a noun phrase n from the
reduction (nnl)n → n. It can also compose with another adjective to return an adjective
(nnl)(nnl) → nnl. We wish for our semantic representations to be viewed in the same
way, such that the composition of an adjective with a noun (1N ⊗ �N)((N ⊗ N) ⊗ N) can
be viewed as the application of a function f : N → N to its argument of type N.

To learn the representation of such functions, we assume that their meaning can
be characterized by the properties that their arguments hold in the corpus, rather than
just by their context as is the case in lexical distributional semantic models. To give
an example, rather than learning what the adjective angry means by observing that
it co-occurs with words such as fighting, aggressive, or mean, we learn its meaning by
observing that it typically takes as argument words that have the property of being
(i.e., co-occur with words such as) fighting, aggressive, and mean. Whereas in the lexical
semantic case, such associations might only rarely occur in the corpus, in this indirect
method we learn what properties the adjective relates to even if they do not co-occur
with it directly.

In turn, through composition with its argument, we expect the function for such
an adjective to strengthen the properties that characterize it in the object it takes as
argument. If, indeed, angry is characterized by arguments that have high basis weights
for basis elements corresponding to the concepts (or context words) fighting, aggressive,
and mean, and relatively low counts for semantically different concepts such as passive,
peaceful, and loves, then when we apply angry to dog the vector for the compound
angry dog should contain some of the information found in the vector for dog. But this
vector should also have higher values for the basis weights of fighting, aggressive, and
mean, and correspondingly lower values for the basis weights of passive, peaceful, and
loves.

To turn this idea into a concrete algorithm for constructing the semantic repre-
sentation for relations of any arity, as first presented in Grefenstette et al. (2011), we
examine how we would deal with this for binary relations such as transitive verbs. If
a transitive verb of semantic type N ⊗ ST ⊗ N is viewed as a function f : N × N → ST
that expresses the extent to which the properties of subject and object are brought into
relation by the verb, we learn the meaning of the verb by looking at what properties are
brought into relation by its arguments in a corpus. Recall that the vector for a verb v,−→v ∈ N ⊗ ST ⊗ N, can be expressed as the weighted sum of its basis elements:

−→v =
∑

ijk

cvijk
−→ni ⊗−→sj ⊗−→nk

We take the set of vectors for the subject and object of v in the corpus to be argv =
{(−−−−→SUBJl,

−−−→
OBJl )}l. We wish to calculate the basis weightings {cvijk}ijk for v. Exploiting our

earlier definition of the basis {sj}j of ST, which states that for any value of i and k there

96



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

is some value of j such that sj = (ni, nk), we define Δijk = 1 if indeed sj = (ni, nk) and 0
otherwise. Using all of this, we define the calculation of each basis weight cvijk as:

cvijk =
∑

l

Δijkc
SUBJl
i c

OBJl
k

This allows for a full formulation of −→v as follows:
−→v =

∑
l

∑
ijk

Δijkc
SUBJl
i c

OBJl
k

−→ni ⊗−→sj ⊗−→nk

The nested sums here may seem computationally inefficient, seeing how this
would involve computing size(argv) × dim(N)2 × dim(S) = size(argv) × dim(N)4 prod-
ucts. However, using the decomposition of basis elements of S into pairs of basis
elements of N (effectively basis elements of N ⊗ N), we can remove the Δijk term and
ignore all values of j where sj �= (ni, nk), because the basis weight for this combination
of indices would be 0. Hence we simplify:

−→v =
∑

l

∑
ik

cSUBJli c
OBJl
k

−→ni ⊗
−−−−→
(ni, nk) ⊗−→nk

This representation is still bloated: We perform fewer calculations, but still obtain a
vector in which all the basis weights where sj �= (ni, nk) are 0, hence where only dim(N)2
of the dim(N)4 values are non-zero. In short, the vector weights for −→v are, under this
learning algorithm, entirely characterized by the values of a dim(N) by dim(N) matrix,
the entries of which are products cSUBJli c

OBJl
k where i and k have become row and column

indices.
Using this and our definition of ST as a space isomorphic to N ⊗ N, we can formu-

late a compact expression of −→v as follows. Let the kronecker product of two vectors−→u ,−→w ∈ N, written −→u ⊗−→w ∈ N ⊗ N, be as follows:
−→u ⊗−→w =

∑
ij

cui c
w
j
−→ni ⊗−→nj

Equipped with this definition, we can formulate the compact form of −→v :

−→v =
∑

l

∑
ik

cSUBJli c
OBJl
k

−→ni ⊗−→nk

=
∑

l

−−−→
SUBJl ⊗

−−→
OBJl

In short, we are only required to iterate through the corpus once, taking for each
instance of a transitive verb v the kronecker product of its subject and object, and
summing these across all instances of v. It is simple to see that no information was
discarded relative to the previous definition of −→v : The dimensionality reduction by a
factor of dim(N)2 simply discards all basis elements for which the basis weight was 0 by
default.

97



Computational Linguistics Volume 41, Number 1

This raises a small problem though: This compact representation can no longer be
used in the compositional mechanism presented in Section 3.3, as the dimensions of−→v no longer match those that it is required to have according to its syntactic type.
However, a solution can be devised if we return to the sample calculation shown in
Section 3.3.2 of the composition of a transitive verb with its arguments. The composition
reduces as follows:

(�N ⊗ 1S ⊗ �N)(
−−−→
SUBJ ⊗−→v ⊗−−→OBJ) =

∑
ikm

cSUBJi c
v
ikmc

OBJ
m

−→sk

where the verb v is represented in its non-compact form. If we introduce the compact-
ness given to us by our isomorphism ST ∼= N ⊗ N we can express this as

−−−−−−−−→
SUBJ v OBJ =

∑
im

cSUBJi c
v
imc

OBJ
m

−→ni ⊗−→nm

where v is represented in its compact form. Furthermore, by introducing the component
wise multiplication operation �:

−→u �−→v =
∑

i

cui c
v
i
−→ni

we can show the general form of transitive verb composition with the reduced verb
representation to be as follows:

−−−−−−−−→
SUBJ v OBJ =

∑
im

cSUBJi c
v
imc

OBJ
m

−→ni ⊗−→nm

=

(∑
im

cvim
−→ni ⊗−→nm

)
�
(∑

im

cSUBJi c
OBJ
m

−→ni ⊗−→nm
)

= −→v �
(−−−→

SUBJ ⊗−−→OBJ
)

To summarize what we have done with transitive verbs:

1. We have treated them as functions, taking two nouns and returning a
sentence in a space ST ∼= N ⊗ N.

2. We have built them by counting what properties of subject and object
noun vectors are related by the verb in transitive sentences in a corpus.

3. We have assumed that output properties were a function of input properties
by the use of the Δijk function—for example, the weights associated with
ni from the subject argument and with nk from the object argument only
affect the “output” weight for the sentence basis element −→sj = −→ni ⊗−→nk .

4. We have shown that this leads to a compact representation
of the verb’s semantic form, and an optimized learning procedure.

5. We have shown that the composition operations
of our formalism can be adapted to this compact representation.

98



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

The compact representation and amended composition operation hinge on the
choice of ST ∼= N ⊗ N as output type for N ⊗ N as an input type (the pair of arguments
the verb takes), justifying our choice of a transitive sentence space. In the intransitive
case, the same phenomenon can be observed, since such a verb takes as argument a
vector in N and produces a vector in SI ∼= N. Furthermore, our choice to make all other
types dependent on one base type—namely, n (with associated semantic space N)—
yields the same property for every relational word we wish to learn: The output type is
the same as the concatenated (on the syntactic level) or tensored (on the semantic level)
input types. It is this symmetry between input and output types that guarantees that
any m-ary relation, expressed in the original formulation as an element of tensor space
N ⊗ . . .⊗ N︸ ︷︷ ︸

2m

, has a compact representation in N ⊗ . . .⊗ N︸ ︷︷ ︸
m

, where the ith basis weight

of the reduced representation stands for the degree to which the ith element of the input
vector affects the ith element of the output vector.

This allows the specification of the generalized learning algorithm for reduced rep-
resentations, first presented in Grefenstette and Sadrzadeh (2011a), which is as follows.
Each relational word P with grammatical type π and m adjoint types α1,α2, · · ·,αm is en-
coded as an (r × . . .× r) multi-dimensional array with m degrees of freedom (i.e., a rank
m tensor). Because our vector space N has a fixed basis, each such array is represented
in vector form as follows:

−→
P =

∑
ij · · ·ζ︸ ︷︷ ︸

m

cij···ζ (
−→n i ⊗−→n j ⊗ · · · ⊗ −→n ζ)︸ ︷︷ ︸

m

This vector lives in the tensor space N ⊗ N ⊗ · · · ⊗ N︸ ︷︷ ︸
m

. Each cij···ζ is computed according

to the procedure described in Figure 2.

Linear algebraically, this procedure corresponds to computing the following

−→
P =

∑
k

(−→w1 ⊗−→w2 ⊗ · · · ⊗ −→wm)k

1) Consider a sequence of words containing a relational word P and its arguments w1,
w2, · · · , wm, occurring in the same order as described in P’s grammatical type π.
Refer to these sequences as P-relations. Suppose there are k of them.
2) Retrieve the vector −→w l of each argument wl.
3) Suppose w1 has weight c1i on basis vector

−→n i, w2 has weight c2j on basis vector −→n j, · · · ,
and wm has weight cmζ on basis vector

−→n ζ. Multiply these weights

c1i × c2j × · · · × cmζ
4) Repeat the above steps for all the k P-relations, and sum the corresponding weights

cij···ζ =
∑

k

(
c1i × c2j × · · · × cmζ

)
k

Figure 2
Procedure for learning weights for matrices of words P with relational types π of m arguments.

99



Computational Linguistics Volume 41, Number 1

The general formulation of composing a relational word P with its arguments
arg1, . . . , argm is now expressed as

−→
P � (−−→arg1 ⊗ . . .⊗−−→argm)

For example, the computation of furry cats nag angry dogs would correspond to the
following operations:

−−−−−−−−−−−−−−−−−−→
furry cats nag angry dogs = −−→nag �

((−−−→
furry �−→cat

)
⊗
(−−−→angry �−−→dog))

This generalized learning algorithm effectively extends the coverage of our ap-
proach to any sentence for which we have a pregroup parse (e.g., as might be obtained
by our translation mechanism from CCG). For example, determiners would have a
type nnl, allowing us to model them as matrices in N ⊗ N; adverbs would be of type
(nrs)r(nrs), and hence be elements of S ⊗ N ⊗ N ⊗ S. We could learn them using the
procedure defined earlier, although for words like determiners and conjunctions, it is
unclear whether we would want to learn such logical words or design them by hand,
as was done in Coecke, Sadrzadeh, and Clark (2010) for negation. Nonetheless, the pro-
cedure given here allows us to generalize the work presented in this article to sentences
of any length or structure based on the pregroup types of the words they contain.

4.4 Example

To conclude this section with an example taken from Grefenstette and Sadrzadeh
(2011a), we demonstrate how the meaning of the word show might be learned from a
corpus and then composed.

Suppose there are two instances of the verb show in the corpus:
s1 = table show result
s2 = map show location

The vector of show is

−−−→
show =

−−→
table ⊗−−−→result + −−→map ⊗−−−−−→location

Consider a vector space N with four basis vectors far, room, scientific, and elect. The
TF/IDF-weighted values for vectors of selected nouns (built from the BNC) are as
shown in Table 1.
Part of the matrix compact representation of show is presented in Table 2.

Table 1
Sample weights for selected noun vectors.

i −→ni table map result location master dog
1 far 6.6 5.6 7 5.9 4.3 5.5
2 room 27 7.4 1.0 7.3 9.1 7.6
3 scientific 0 5.4 13 6.1 4.1 0
4 elect 0 0 4.2 0 6.2 0

100



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

Table 2
Sample semantic matrix for show.

far room scientific elect
far 79.24 47.41 119.96 27.72
room 232.66 80.75 396.14 113.2
scientific 32.94 31.86 32.94 0
elect 0 0 0 0

As a sample computation, the weight c11 for vector (
−→n1,−→n1 ), that is, (

−→
far,

−→
far), is computed

by multiplying weights of table and result on
−→
far (6.6 × 7), multiplying weights of map

and location on
−→
far (5.6 × 5.9), and then adding these (46.2 + 33.04) and obtaining the

total weight 79.24. Similarly, the weight c21 for vector (
−→n2,−→n1 ), that is, (−−−→room,

−→
far), is

computed by multiplying the weight of −−−→room for table by the weight of −→far for result
(27 × 7), then multiplying the weight of −−−→room for map by the weight of −→far for location
(7.4 × 5.9), and then adding these (189 + 43.66) to obtain the total weight of 232.66.

We now wish to compute the vector for the sentence [the] master shows [his] dog,
omitting the determiner and possessive for simplicity, as we have left open the question
as to whether or not we would want to learn them using the generalized procedure
from Section 4.3 or specify them by design due to their logical structure. The calculation
according to the vectors in Table 1 and the matrix in Table 2 will be:

−−−−−−−−−−−−→
master show dog

=
−−−→
show �

(−−−−→
master ⊗−−→dog

)

=

⎡
⎢⎢⎣

79.24 47.41 119.96 27.72
232.66 80.75 396.14 113.2
32.94 31.86 32.94 0

0 0 0 0

⎤
⎥⎥⎦�

⎡
⎢⎢⎣

23.65 32.68 0 0
50.05 69.16 0 0
22.55 31.16 0 0
34.1 47.12 0 0

⎤
⎥⎥⎦

=

⎡
⎢⎢⎣

1,874.03 1,549.36 0 0
11,644.63 5,584.67 0 0

742.80 992.76 0 0
0 0 0 0

⎤
⎥⎥⎦

Row-wise, flattening the final matrix representation gives us the result we seek,
namely, the sentence vector in ST for [the] master showed [his] dog:

−−−−−−−−−−−−→
master show dog = [1,874, 1,549, 0, 0, 11,645, 5,585, 0, 0, 743, 993, 0, 0, 0, 0, 0, 0]

5. Experiments

Evaluating compositional models of semantics is no easy task: First, we are trying
to evaluate how well the compositional process works; second, we also are trying
to determine how useful the final representation—the output of the composition—is,
relative to our needs.

101



Computational Linguistics Volume 41, Number 1

The scope of this second problem covers most phrase and sentence-level semantic
models, from bag-of-words approaches in information retrieval to logic-based formal
semantic models, via language models used for machine translation. It is heavily task
dependent, in that a representation that is suitable for machine translation may not be
appropriate for textual inference tasks, and one that is appropriate for IR may not be
ideal for paraphrase detection. Therefore this aspect of semantic model evaluation ide-
ally should take the form of application-oriented testing. For instance, to test semantic
representations designed for machine translation purposes, we should use a machine
translation evaluation task.

The DisCoCat framework (Clark, Coecke, and Sadrzadeh 2008; Coecke, Sadrzadeh,
and Clark 2010), described in Section 3, allows for the composition of any words of
any syntactic type. The general learning algorithm presented in Section 4.3 technically
can be applied to learn and model relations of any semantic type. However, many
open questions remain, such as how to deal with logical words, determiners, and
quantification, and how to reconcile the different semantic types used for sentences
with transitive and intransitive sentences. We will leave these questions for future work,
briefly discussed in Section 6. In the meantime, we concretely are left with a way of
satisfactorily modeling only simple sentences without having to answer these bigger
questions.

With this in mind, in this section we present a series of experiments centered around
evaluating how well various models of semantic vector composition perform (along
with the one described in Section 4) in a phrase similarity comparison task. This task
aims to test the quality of a compositional process by determining how well it forms a
clear joint meaning for potentially ambiguous words. The intuition here is that tokens,
on their own, can have several meanings; and that it is through the compositional
process—through giving them context—that we understand their specific meaning. For
example, bank itself could (among other meanings) mean a river bank or a financial
bank; yet in the context of a sentence such as The bank refunded the deposit, it is likely we
are talking about the financial institution.

In this section, we present three data sets designed to evaluate how well word-sense
disambiguation occurs as a byproduct of composition. We begin by describing the first
data set, based around noun-intransitive verb phrases, in Section 5.1. In Section 5.2,
we present a data set based around short transitive-verb phrases (a transitive verb
with subject and object). In Section 5.3, we discuss a new data set, based around short
transitive-verb phrases where the subject and object are qualified by adjectives. We leave
discussion of these results for Section 6.

5.1 First Experiment

This first experiment, originally presented in Mitchell and Lapata (2008), evaluates
the degree to which an ambiguous intransitive verb (e.g., draws) is disambiguated by
combination with its subject.

Data set Description. The data set4 comprises 120 pairs of intransitive sentences, each of
the form NOUN VERB. These sentence pairs are generated according to the following

4 Available at http://homepages.inf.ed.ac.uk/s0453356/results.

102



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

procedure, which will be the basis for the construction of the other data sets discussed
subsequently:

1. A number of ambiguous intransitive verbs (15, in this case) are selected
from frequently occurring verbs in the corpus.

2. For each verb V, two mutually exclusive synonyms V1 and V2 of the verb
are produced, and each is paired with the original verb separately (for a
total of 30 verb pairs). These are generated by taking maximally distant
pairs of synonyms of the verb on WordNet, but any method could be used
here.

3. For each pair of verb pairs (V, V1) and (V, V2), two frequently occurring
nouns N1 and N2 are picked from the corpus, one for each synonym of V.
For example, if V is glow and the synonyms V1 and V2 are beam and burn,
we might choose face as N1, because a face glowing and a face beaming
mean roughly the same thing; and fire as N2, because a fire glowing and a
fire burning mean roughly the same thing.

4. By combining the nouns with the verb pairs, we form two high similarity
triplets (V, V1, N1) and (V, V2, N2), and two low similarity triplets
(V, V1, N2) and (V, V2, N1).

The last two steps can be repeated to form more than four triplets per pair of verb
pairs. In Mitchell and Lapata (2008), eight triplets are generated for each pair of verb
pairs, obtaining a total of 120 triplets from the 15 original verbs. Each triplet, along with
its HIGH or LOW classification (based on the choice of noun for the verb pair) is an
entry in the data set, and can be read as a pair of sentences: (V, Vi, N) translates into the
intransitive sentences N V and N Vi.

Finally, the data set is presented, without the HIGH/LOW ratings, to human an-
notators. These annotators are asked to rate the similarity of meaning of the pairs of
sentences in each entry on a scale of 1 (low similarity) to 7 (high similarity). The final
form of the data set is a set of lines each containing:

� A (V, Vi, N) triplet.
� A HIGH or LOW label for that triplet.
� An annotator identifier and the annotator’s score for that triplet.

Sample sentences from this data set are shown in Table 3.

Table 3
Example entries from the intransitive data set without annotator score, first experiment.

Sentence 1 Sentence 2

butler bow butler submit
head bow head stoop
company bow company submit
government bow government stoop

103



Computational Linguistics Volume 41, Number 1

Evaluation Methodology. This data set is used to compare various compositional distribu-
tional semantic models, according to the following procedure:

1. For each entry in the data set, the representation of the two sentences
N V and N Vi formed from the entry triple (V, Vi, N), which we
will name S1 and S2, is constructed by the model.

2. The similarity of these sentences according to the model’s semantic
distance measure constitutes the model score for the entry.

3. The rank correlation of entry model scores against entry annotator scores
is calculated using Spearman’s rank correlation coefficient ρ.

The Spearman ρ scores are values between −1 (perfect negative correlation) and 1
(perfect correlation). The higher the ρ score, the higher the compositional model can be
said to produce sentence representations that match human understanding of sentence
meaning, when it comes to comparing the meaning of sentences. As such, we will rank
the models evaluated using the task by decreasing order of ρ score.

One of the principal appealing features of Spearman’s ρ is that the coefficient is
rank-based: It does not require models’ semantic similarity metrics to be normalized
for a comparison to be made. One consequence is that a model providing excellent
rank correlation with human scores, but producing model scores on a small scale (e.g.,
values between 0.5 and 0.6), will obtain a higher ρ score than a model producing model
scores on a larger scale (e.g., between 0 and 1) but with less perfect rank correlation.
If we wished to then use the former model in a task requiring some greater degree of
numerical separation (let us say 0 for non-similar sentences and 1 for completely similar
sentences), we could simply renormalize the model scores to fit the scale. By eschewing
score normalization as an evaluation factor, we minimize the risk of erroneously ranking
one model over another.

Finally, in addition to computing the rank alignment coefficient between model
scores and annotator scores, Mitchell and Lapata (2008) calculate the mean model
scores for entries labeled HIGH, and for entries labeled LOW. This information is
reported in their paper as additional means for model comparison. However, for the
same reason we considered Spearman’s ρ to be a fair means of model comparison—
namely, in that it required no model score normalization procedure and thus was
less likely to introduce error by adding such a degree of freedom—we consider the
HIGH/LOW means to be inadequate grounds for comparison, precisely because it
requires normalized model scores for comparison to be meaningful. As such, we will not
include these mean scores in the presentation of this, or any further experiments in this
article.

Models Compared. In this experiment, we compare the best and worst performing models
of Mitchell and Lapata (2008) to our own. We begin by building a vector space W
for all words in the corpus, using standard distributional semantic model construction
procedures (n-word window) with the parameters of Mitchell and Lapata (2008). These
parameters are as follows: The basis elements of this vector space are the 2,000 most
frequently occurring words in the BNC, excluding common stop words. For our evalu-
ation, the corpus was lemmatized using Carroll’s Morpha (Minnen, Carroll, and Pearce
2001), which was applied as a byproduct of our parsing of the BNC with C&C Tools
(Curran, Clark, and Bos 2007).

104



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

The context of each occurrence of a word in the corpus was defined to be five words
on either side. After the vector for each word w was produced, the basis weights cwi
associated with context word bi were normalized by the following ratio of probabilities
weighting scheme:

cwi =
P(bi|w)
P(w)

Let
−−→
verb and −−→noun be the lexical semantic vectors for the verb and the noun, from W.

It should be evident that there is no significant difference in using W for nouns in lieu
of building a separate vector space N strictly for noun vectors.

As a first baseline, Verb Baseline, we ignored the information provided by the noun
in constructing the sentence representation, effectively comparing the semantic content
of the verbs:

Verb Baseline :
−−−−−−→
noun verb =

−−→
verb

The models from Mitchell and Lapata (2008) we evaluate here are those which were
strictly unsupervised (i.e., no free parameters for composition). These are the additive
model Add, wherein

Add :
−−−−−−→
noun verb = −−→noun +−−→verb

and the multiplicative model Multiply, wherein

Multiply :
−−−−−−→
noun verb = −−→noun �−−→verb

Other models with parameters that must be optimized against a held-out section of the
data set are presented in Mitchell and Lapata (2008). We omitted them here principally
because they do not perform as well as Multiply, but also because the need to optimize
the free parameters for this and other data sets makes fair comparison with completely
unsupervised models more difficult, and less fair.

We also evaluate the Categorical model from Section 4 here, wherein

Categorical :
−−−−−−→
noun verb =

−−−→
verbcat �−−→noun

where
−−−→
verbcat is the compact representation of the relation the verb stands for, computed

according to the procedure described in Section 4.3. It should be noted that for the case
of intransitive verbs, this composition operation is mathematically equivalent to that of
the Multiply model (as component-wise multiplication � is a commutative operation),
the difference being the learning procedure for the verb vector.

For all such vector-based models, the similarity of the two sentences s1 and s2 is
taken to be the cosine similarity of their vectors, defined in Section 2.2:

similarity(s1, s2) = cosine(
−→s1 ,−→s2 )

In addition to these vector-based methods, we define an additional baseline and
an upper-bound. The additional baseline, Bigram Baseline, is a bigram-based language

105



Computational Linguistics Volume 41, Number 1

model trained on the BNC with SRILM (Stolcke 2002), using the standard language
model settings for computing log-probabilities of bigrams. To determine the semantic
similarity of sentences s1 = noun verb1 and s2 = noun verb2, we assumed sentences have
mutually conditionally independent properties, and computed the joint probability:

similarity(s1, s2) = logP(s1 ∧ s2) = log(P(s1)P(s2)) = logP(s1) + logP(s2)

The reasoning behind this baseline is as follows. The sentence formed by combining the
first verb with its arguments is, by the design of this data set, a semantically coherent
sentence (e.g., the head bowed and the government bowed both make sense). We therefore
expect language models to treat this sort of bigram as having a higher probability
than bigrams that are not semantically coherent sentences (and therefore unlikely to
be observed in the corpus). A similar (relative) high probability is to be expected when
the sentence formed by taking the second verb in each entry and combining it with
the verb yields a sentence similar to the first in meaning (e.g., as would be the case
with the head stooped), whereas the probability of a semantically incoherent sentence
(e.g., the government stooped) is expected to be low relative to that of the first sentence. By
taking the sum of log probabilities of sentences, we compute the log of the product
of the probabilities, which we expect to be low when the probability of the second
sentence is low, and high when it is high, with the probability of the first sentence
acting as a normalizing factor. To summarize, while this bigram-based measure only
tracks a tangential aspect of semantic similarity, it can be one which plays an artificially
important role in experiments with a predetermined structure such as the one described
in this section. For this reason, we use this bigram baseline for this experiment and all
that follow.

The upper bound of the data set, UpperBound, was taken to be the inter-annotator
agreement: the average of how each annotator’s score aligns with other annotator
scores, using Spearman’s ρ.

Results. The results5 of the first experiment are shown in Table 4. As expected from the
fact that Multiply and Categorical differ only in how the verb vector is learned, the
results of these two models are virtually identical, outperforming both baselines and
the Additive model by a significant margin. However, the distance from these models
to the upper bound is even greater, demonstrating that there is still a lot of progress to
be made.

5.2 Second Experiment

The first experiment was followed by a second similar experiment, in Mitchell
and Lapata (2010), covering different sorts of composition operations for binary
combinations of syntactic types (adjective-noun, noun-noun, verb-object). Such further
experiments are interesting, but rather than continue down this binary road, we now
turn to the development of our second experiment, involving sentences with larger
syntactic structures, to examine how well various compositional models cope with
more complex syntactic and semantic relations.

5 The results were state of the art when the experiments were run in 2011. The binary composition data set
used here are popular; now there are a host of new state-of-the-art systems available in the literature. We
invite the reader to check references to Mitchell and Lapata (2008) to find the current state of the art.

106



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

Table 4
Model correlation coefficients with human judgments, first experiment. p < 0.05 for each ρ.

Model ρ

Verb Baseline 0.08
Bigram Baseline 0.02

Add 0.04
Multiply 0.17
Categorical 0.17

UpperBound 0.40

This second experiment, which we initially presented in Grefenstette and
Sadrzadeh (2011a), is an extension of the first in the case of sentences centered around
transitive verbs, composed with a subject and an object. The results of the first experi-
ment did not demonstrate any difference between the multiplicative model, which takes
into account no syntactic information or word ordering, and our syntactically motivated
categorical compositional model. By running the same experiment over a new data
set, where the relations expressed by the verb have a higher arity than in the first, we
hope to demonstrate that added structure leads to better results for our syntax-sensitive
model.

Data Set Description. The construction procedure for this data set6 is almost exactly as
for the first data set, with the following differences:

� Verbs are transitive instead of intransitive.
� We arbitrarily took 10 verbs from the most frequent verbs in the BNC,

and for each verb, took two maximally distant synonyms (again, using
WordNet) to obtain 10 pairs of pairs.

� For each pair of verb pairs, we selected a set of subject and object nouns
to use as context, as opposed to just a subject noun.

� Each subject-object pair was manually chosen so that one of the verb
pairs would have high similarity in the context of that subject and
object, and the other would have low similarity. We used these choices
to annotate the entries with HIGH and LOW tags.

� Each combination of a verb pair with a subject-object pair constitutes
an entry of our data set, of which there are 200.

As a form of quality control, we inserted “gold standard” sentences in the form of
identical sentence pairs and rejected annotators who did not score these gold standard

6 The data set, reannotated by Turkers in 2013, is available at
http://www.cs.ox.ac.uk/activities/compdistmeaning/GS2013data.txt.

107



Computational Linguistics Volume 41, Number 1

Table 5
Example entries from the transitive data set without annotator score, second experiment.

Sentence 1 Sentence 2 HIGH-LOW Tag

man draw sword man attract sword LOW
report draw attention report attract attention HIGH
man draw sword man depict sword HIGH
report draw attention report depict attention LOW

sentences with a high score of 6 or 7.7 Lemmatized sentences from sample entries of this
data set and our HIGH-LOW tags for them are shown in Table 5.

The data set was passed to a group of 50 annotators on Amazon Mechanical Turk, as
for the previous data set. The annotators were shown, for each entry, a pair of sentences
created by adding the in front of the subject and object nouns and putting the verbs in
the past tense,8 and were instructed to score each pair of sentences on the same scale of
1 (not similar in meaning) to 7 (similar in meaning), based on how similar in meaning
they believed the sentence pair was.

Evaluation Methodology. The methodology for this experiment is exactly that of the
previous experiment. Models compositionally construct sentence representations, and
compare them using a distance metric (all vector-based models once again used cosine
similarity). The rank correlation of models scores with annotator scores is calculated
using Spearman’s ρ, which is in turn used to rank models.

Models Compared. The models compared in this experiment are those of the first experi-
ment, with the addition of an extra trigram-based baseline (trained with SRILM, using
the addition of log-probability of the sentence as a similarity metric), and a variation on
our categorical model, presented subsequently. With W as the distributional semantic
space for all words in the corpus, trained using the same parameters as in the first exper-
iment, and

−−→
subj,

−−→
verb,

−−−→
object ∈ W as the vectors for subject, verb, and object of a sentence,

respectively, and with verbcat as the compact representation of a transitive verb learned
using the algorithm presented in this paper, we have the following compositional
methods:

Add :
−−−−−−−−−−−−→
subject verb object =

−−−−→
subject +

−−→
verb +

−−−→
object

Multiply :
−−−−−−−−−−−−→
subject verb object =

−−−−→
subject �−−→verb �−−−→object

Categorical :
−−−−−−−−−−−−→
subject verb object =

−−−→
verbcat �

(−−−−→
subject ⊗−−−→object

)
Kronecker :

−−−−−−−−−−−−→
subject verb object =

(−−→
verb ⊗−−→verb

)
�
(−−−−→

subject ⊗−−−→object
)

7 During the 2013 reannotation of this data set, we rejected no Turker contributions, as the answers to
the gold standard sentence pairs were aligned with our expectations. We attribute this to our adding
the requirement that Turkers be based in the US or the UK and have English as the first language.

8 For example, the entry draw table eye depict would yield the sentences The table drew the eye and The table
depicted the eye.

108



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

All of these models have been explained earlier, with the exception of Kronecker.
We first presented this new addition in Grefenstette and Sadrzadeh (2011b), where
we observed that the compact representation of a verb in the DisCoCat framework,
under the assumptions presented in Section 4, can be viewed as dim(N) × dim(N)
matrices in N ⊗ N. We considered alternatives to the algorithm presented earlier for
the construction of such matrices, and were surprised by the results of the Kronecker
method, wherein we replaced the matrix learned by our algorithm with the Kronecker
product of the lexical semantic vectors for the verb. Further analysis performed since the
publication of that paper can help to understand why this method might work. Using
the following property, for any vectors −→a ,−→b ,−→c ,−→d in a vector space

(−→a ⊗−→b ) � (−→c ⊗−→d ) = (−→a �−→c ) ⊗ (−→b �−→d )

we can see that the Kronecker model’s composition operation can be expressed as

Kronecker :
−−−−−−−−−−−−→
subject verb object =

(−−→
verb �−−−−→subject

)
⊗
(−−→

verb �−−−→object
)

Bearing in mind that the cosine measure we are using as a similarity metric is equivalent
to the inner product of two vectors normalized by the product of their length

cosine(−→a ,−→b ) = 〈
−→a |−→b 〉

‖−→a ‖ × ‖−→b ‖

and the following property of the inner product of kronecker products

〈−→a ⊗−→b |−→c ⊗−→d 〉 = 〈−→a |−→c 〉 × 〈−→b |−→d 〉

we finally observe that comparing two sentences under Kronecker corresponds to the
following computation:

cosine(
−−−−−−−−−−−−→
subject verb1 object,

−−−−−−−−−−−−→
subject verb2 object)

= α
〈(−−→

verb1 ⊗
−−→
verb1

)
�
(−−−−→

subject ⊗−−−→object
)
|
(−−→

verb2 ⊗
−−→
verb2

)
�
(−−−−→

subject ⊗−−−→object
)〉

= α
〈(−−→

verb1 �
−−−−→
subject

)
⊗
(−−→

verb1 �
−−−→
object

)
|
(−−→

verb2 �
−−−−→
subject

)
⊗
(−−→

verb2 �
−−−→
object

)〉
= α

〈(−−→
verb1 �

−−−−→
subject

)
|
(−−→

verb2 �
−−−−→
subject

)〉〈(−−→
verb1 �

−−−→
object

)
|
(−−→

verb2 �
−−−→
object

)〉
where α is the normalization factor

α = 1
‖−−−−−−−−−−−−→subject verb1 object‖ × ‖

−−−−−−−−−−−−→
subject verb2 object‖

We note here that the Kronecker is effectively a parallel application of the Multiply
model, combining the subject and verb, and object and verb separately. Within the
context of this task, the comparison of two sentences boils down to how well each verb
combines with the subject multiplied by how well it combines with the object, with the

109



Computational Linguistics Volume 41, Number 1

joint product forming the overall model score. In short, it more or less constitutes the
introduction of some mild syntactic sensitivity into the multiplicative model of Mitchell
and Lapata (2008), although it remains to be seen how well this scales with syntactic
complexity (e.g., extended to ditransitive verbs, or other relations of higher arity).

The UpperBound here is, again, the inter-annotator agreement, calculated by com-
puting the pairwise alignment of each annotator with every other, and averaging the
resulting rank correlation coefficients.

Results. The results of the second experiment are shown in Table 6. The baseline scores
fall in the 0.14–0.16 range, with best results being obtained for the Bigram Baseline and
Trigram Baseline, the difference between both models not being statistically significant.
The additive model Add performs on par with the first experiment. The multiplicative
model Multiply and our Categorical model perform on par with the version used for
the intransitive experiment, but obtain a score comparable to the baselines. The best
performing model here is our newly introduced Kronecker model, which leads the pack
by a steady margin, with a score of 0.26. The inter-annotator agreement UpperBound is
much higher in this experiment than in the previous experiment, indicating even more
room for improvement.

We therefore learn here that the Categorical model continues to operate on par with
the multiplicative model, and that the Kronecker model provides the highest results,
while being as simple in its construction as the multiplicative model, requiring only the
learning of lexical vectors for the verb.

5.3 Third Experiment

The third and final experiment we present is a modified version of the second data set
presented earlier, where the nouns in each entry are under the scope of adjectives ap-
plied to them.The intuition behind the data sets presented in Section 5.1 and Section 5.2
was that ambiguous verbs are disambiguated through composition with nouns. These
nouns themselves may also be ambiguous, and a good compositional model will be
capable of separating the noise produced by other meanings through its compositional
mechanism to produce unambiguous phrase representations. The intuition behind this
data set is similar, in that adjectives provide both additional information for disam-
biguation of the nouns they apply to, but also additional semantic noise. Therefore, a

Table 6
Model correlation coefficients with human judgments, second experiment. p < 0.05 for each ρ.

Model ρ

Verb Baseline 0.13
Bigram Baseline 0.16
Trigram Baseline 0.15

Add 0.10
Multiply 0.16
Categorical 0.16
Kronecker 0.26

UpperBound 0.62

110



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

Table 7
Example entries from the adjective-transitive data set without annotator score, third experiment.

Sentence 1 Sentence 2

statistical table show good result statistical table express good result
statistical table show good result statistical table depict good result

good model will also be able to separate the useful information of the adjective from its
semantic noise when composing it with its argument, in addition to doing this when
composing the noun phrases with the verb.

Data Set Description. The construction procedure for this data set was to take the data set
from Section 5.2, and, for each entry, add a pair of adjectives from those most frequently
occurring in the corpus. The first adjective from the pair is applied to the first noun
(subject) of the entry when forming the sentences, and the second adjective is applied
to the second noun (object). For each entry, we chose adjectives which best preserved
the meaning of the phrase constructed by combining the first verb with its subject and
object.

This new data set9 was then annotated again by a group of 50 annotators using
Amazon’s Mechanical Turk service. The annotators were shown, for each entry, a pair
of sentences created by adding the in front of the subject and object noun phrases and
putting the verbs in the past tense,10 and asked to give each sentence pair a meaning
similarity score between 1 and 7, as for the previous data sets. We applied the same
quality control mechanism as in the second experiment. Some 94 users returned anno-
tations, of which we kept 50 according to our gold standard tests. We are unaware of
whether or not it was applied in the production of the first data set, but believe that this
can only lead to the production of higher quality annotations.

Sample sentences from this data set are shown in Table 7.

Evaluation Methodology. The evaluation methodology in this experiment is identical to
that of the previous experiments.

Models Compared. In this experiment, in lieu of simply comparing compositional models
“across the board” (e.g., using the multiplicative model for both adjective-noun compo-
sition and verb-argument composition), we experimented with different combinations of
models. This evaluation procedure was chosen because we believe that adjective-noun
composition need not necessarily be the same kind of compositional process as subject-
verb-object composition, and also because different models may latch onto different
semantic features during the compositional process, and it would be interesting to
see what model mixtures work well together. Naturally, this is not a viable approach
to selecting composition operations in general, as we will not have the luxury of try-
ing every combination of composition operations for every combination of syntactic
types, but it is worthwhile performing these tests to at least verify the hypothesis that

9 Available at http://www.cs.ox.ac.uk/activities/compdistmeaning/GS2012data.txt.
10 For example, the entry statistical table show express good result would yield the sentences The statistical table

showed the good result and The statistical table expressed the good result.

111



Computational Linguistics Volume 41, Number 1

operation-specific composition operations (or parameters) is a good thing. Notably, this
idea has been explored very recently, within the context of deep learning networks, by
Chen et al. (2013).

Each mixed model has two components: a verb-argument composition model and
a adjective-noun composition model. For verb-argument composition, we used the
three best models from the previous experiment, namely, Multiply, Categorical, and
Kronecker. For adjective composition we used three different methods of adjective-
noun composition. With

−−−−−→
adjective and −−→noun being the vectors for an adjective and a noun

in our distributional lexical semantic space W (built using the same procedure as the
previous experiments) and

−−→
adjcat being the compact representation in the Categorical

model, built according to the algorithm from Section 4.3, we have the following models:

AdjMult :
−−−−−−−−−→
adjective noun =

−−−−−→
adjective �−−→noun

Categorical :
−−−−−−−−−→
adjective noun =

−−−−−−→
adjectivecat �−−→noun

The third model, AdjNoun, is a holistic (non-compositional) model, wherein the
adjective-noun compound was treated as a single token, as its semantic vector−−−−−−−−−−−−→
(adjective noun)lex ∈ W was learned from the corpus using the same learning procedure
applied to construct other vectors in W. Hence, the model defines adjective-noun
“composition” as:

AdjNoun :
−−−−−−−−−→
adjective noun =

−−−−−−−−−−−−→
(adjective noun)lex

In addition to these models, we also evaluated three baselines: Verb Baseline,
Bigram Baseline, and Trigram Baseline. As in previous experiments, the verb baseline
uses the verb vector as sentence vector, ignoring the information provided by other
words. The bigram and trigram baselines are calculated from the same language model
as used in the second experiment. In both cases, the log-probability of each sentence is
calculated using SRLIM, and the sum of log-probabilities of two sentences is used as a
similarity measure.

Finally, for comparison, we also considered the full additive model:

Additive :
−−−−−→
sentence =

−−−−−→
adjective1 +

−−−→noun1 +
−−→
verb +

−−−−−→
adjective2 +

−−−→noun2

Results. The results for the third experiment are shown in Table 8. The best performing
adjective-noun combination operations for each verb-argument combination operation
are shown in bold. Going through the combined models, we notice that in most cases
the results stay the same whether the adjective-noun combination method is AdjMult or
CategoricalAdj. This is because, as was shown in the first experiment, composition of a
unary-relation such as an adjective or intransitive verb with its sole argument, under
the categorical model with reduced representations, is mathematically equivalent to
the multiplicative model. The sole difference is the way the adjective or intransitive
verb vector is constructed. We note, however, that with Categorical as a verb-argument
composition method, the CategoricalAdj outperforms AdjMult by a non-negligible
margin (0.19 vs. 0.14), indicating that the difference in learning procedure can lead to
different results depending on what other models it is combined with.

112



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

Table 8
Model correlation coefficients with human judgments, third experiment. p < 0.05 for each ρ.

Model ρ

Verb Baseline 0.20
Bigram Baseline 0.14
Trigram Baseline 0.16
Additive 0.10

Multiplicative
AdjMult 0.20
AdjNoun 0.05
CategoricalAdj 0.20

Categorical
AdjMult 0.14
AdjNoun 0.16
CategoricalAdj 0.19

Kronecker
AdjMult 0.26
AdjNoun 0.17
CategoricalAdj 0.27

Upperbound 0.48

Overall, the best results are obtained for AdjMult+Kronecker (ρ = 0.26) and
CategoricalAdj+Kronecker (ρ = 0.27). Combinations of the adjective composition
methods with other composition methods at best matches the best-performing baseline,
Verb Baseline. In all cases, the holistic model AdjNoun provides the worst results.

6. Discussion

In this article, we presented various approaches to compositionality in distributional
semantics. We discussed what mathematical operations could underlie vector combina-
tion, and several different ways of including syntactic information into the combinatory
process. We reviewed an existing compositional framework that leverages the ability to
communicate information across mathematical structures provided by category theory
in order to define a general way of linking syntactic structure to syntax-sensitive com-
position operations. We presented concrete ways to apply this framework to linguistic
tasks and evaluate it, and developed algorithms to construct semantic representations
for words and relations within this framework. In this section, we first briefly comment
upon the combined results of all three experiments, and then conclude by discussing
what aspects of compositionality require further attention, and how experiment design
should adapt towards this goal.

Results Commentary. We evaluated this framework against other unsupervised compo-
sitional distributional models, using non-compositional models and n-gram language
models as baselines, within the context of three experiments. These experiments show
that the concrete categorical model developed here, and the Kronecker-based variant

113



Computational Linguistics Volume 41, Number 1

presented alongside it, outperform all other models in each experiment save the first,
where they perform on par with what was the leading model at the time this experiment
was performed (namely, 2011). As the experiments involved progressively more syntac-
tically complicated sentences, the increased reliability of our categorical approaches rel-
ative to competing models as sentence complexity rises seems to indicate that both the
categorical and Kronecker model successfully leverage the added information provided
by additional terms and syntactic structures.

The third experiment also served to show that using different combinations of
composition operations, depending on the syntactic type of the terms being combined,
can yield better results, and that some models combine better than others. Notably,
the adjective-noun combination models AdjMult and CategoricalAdj, despite their
mathematical similarity, produce noticeably different results when combined with the
categorical verb-argument composition operation, while they perform equally with
most other verb-argument composition operations. We can conclude that different mod-
els combine different semantic aspects more prominently than others, and that through
combination we can find better performance by assuming that different kinds of compo-
sition play on different semantic properties. For example, predicates such as intersective
adjectives add information to their argument (a red ball is a ball that is also red). This
raises the question of how to design models of composition that systematically select
which operations will match the semantic aspects of the words being combined based
on their syntactic type. This is an open question, which we believe warrants further
investigation.

Overall, we observe two advantages of these models over those presented in the
early part of this article, and those evaluated in the later part. First, we have shown
that a linguistically motivated and mathematically sound framework can be imple-
mented and learned. Second, we showed that simple methods such as the Kronecker
model perform well, especially when combined with the multiplicative model (effec-
tively a unary instance of the Kronecker model) for sentences with adjectives. Con-
sidering the “simple is best” position recently argued for experimentally by Blacoe
and Lapata (2012), this is an interesting candidate for dealing with binary relation
composition.

Future Work. These experiments showcased the ability of various compositional models
to produce sentence representations that were less ambiguous than the words that
formed them. They also more generally demonstrated that concrete models could
be built from the general categorical framework and perform adequately in simple
paraphrase detection tasks. However, various aspects of compositionality were not
evaluated here. First, syntax sensitivity is not as important in these experiments as
it might be in “real” language. For instance, whereas models that treat adjectives,
nouns, and verbs differently tended to perform better than those that did not, the
actual capacity of a model to use the syntactic structure was not tested. For instance,
models that ignore word order and syntax altogether were not particularly penalized,
as might be done if some sentences were simply the reverse of another sentence they
are paired with (where syntax insensitive models would erroneously give such sentence
pairs a high similarity score). One way of testing word order while expanding the data
set was suggested by Turney (2012), who for every entry in a phrase similarity test
such as Mitchell and Lapata’s, discussed herein, creates a new entry where one of the
sentences has the order of its words reversed, and is assigned an artificial annotator
score of 1 (the minimum). This is an interesting approach, but we would prefer to
see such reversals designed into the data set and seen by annotators, for instance,

114



Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

in the recent data set presented in Pham et al. (2013). This data set has entries such
as guitar played man and man played guitar, where the subjects and objects of verbs
are indeed reversed but the two sentences do not necessarily express opposite mean-
ings; we will be looking into expanding such data sets to ones where both sentences
make sense and have opposite meanings, such as in the pair man bites dog and dog
bites man.

Furthermore, sentences all have the exact same sentence structure, and therefore
words are aligned. Models that might indirectly benefit from this alignment, such as
Kronecker, may have been given an advantage due to this, as opposed to models such
as Categorical, which are designed to compare sentences of different length or syntactic
structure, when resolving the difference between intransitive and transitive sentence
spaces as has been done in Grefenstette et al. (2011). Future experiments should aim to
do away with this automated alignment, and include sentence comparisons that would
penalize models which do not leverage syntactic information.

Furthermore, each of these experiments dealt with the comparison of a certain
type of sentence (transitive, intransitive). This was convenient for our concrete cate-
gorical model, as we defined the sentence space differently based on the valency of
the head verb. However, sentences with different sorts of verbs should be able to be
directly compared. Not only do several models, both non-syntax sensitive (additive,
multiplicative) and syntax-sensitive (Baroni and Zamparelli 2010; Socher et al. 2012),
not face this problem, as the product of composition is either naturally in the same
space as the vectors being composed or is projected back into it, but the categorical
framework the concrete categorical models were derived from does not commit us to
different sentence spaces either. The topic of how to solve this problem for the concrete
models developed here is beyond the scope of this article, but various options exist,
such as the projection of ST into SI, the embedding of SI into ST, the use of a combined
sentence space S = SI ⊕ ST, and so on. It is clear that future experiments should not
give this degree of convenience to the models being evaluated (and their designers),
by comparing sentences of different types, lengths, and structure so as to more fairly
evaluate the capacity of models to produce meaningful semantic representations in
a single space, which can be directly compared regardless of syntactic structure and
verb-type.

Finally, we mentioned at the beginning of Section 5 that evaluations need to be
application-oriented. The class of experiments presented in this article specifically see
how well disambiguation occurs as a byproduct of composition. We presented concrete
models that would offer ways of combining relations underlying verbs and adjectives,
and tested how well these relations disambiguated their arguments and were in turn
disambiguated by their arguments. We did not address other aspects of language, such
as quantification, logical operations, relative clauses, intensional clauses, embedded
sentences, and many other linguistic aspects of spoken and written language that
have complex syntactic structure and complicated semantic roles. Addressing these
sorts of problems requires determining how negation, conjunction, and other logical
relations should be modeled within compositional distributional formalisms, a problem
we share with other similar approaches. The development of newer models within the
categorical framework we based our work on, and the further development of other
approaches mentioned here, must be driven by new experimental goals different from
those offered by the task and experiments discussed in this article. Thinking not only
about how to address these aspects of language within compositional models, but how
to evaluate them, should be a priority for all those interested in further developing
this field.

115



Computational Linguistics Volume 41, Number 1

Acknowledgments
We thank the EPSRC for funding the research
leading to this article via EPSRC grant
EP/J002607/1. Furthermore, we would like
to thank John Harding and the equational
theorem prover “Prover 9”11 for checking the
identities occurred as a result of translating
CCG’s rules to the language of a pregroup
grammar. We would also like to thank
Stephen Clark, Stephen Pulman, Bob Coecke,
Karl Moritz Hermann, Richard Socher, and
Dimitri Kartsaklis for valuable discussions
and comments.

References
Abramsky, S. and B. Coecke. 2004.

A categorical semantics of quantum
protocols. In Proceedings of the 19th Annual
IEEE Symposium on Logic in Computer
Science, pages 415–425, Turku, Finland.

Alshawi, H., editor. 1992. The Core Language
Engine. MIT Press.

Baroni, M. and R. Zamparelli. 2010. Nouns
are vectors, adjectives are matrices:
Representing adjective-noun constructions
in semantic space. In Proceedings of the 2010
Conference on Empirical Methods in Natural
Language Processing, pages 1,183–1,193,
Boston, MA.

Béchet, D., A. Foret, and I. Tellier. 2007.
Learnability of Pregroup Grammars.
Studia Logica, 87(2–3), pages 225–252.

Blacoe, W. and M. Lapata. 2012.
A comparison of vector-based
representations for semantic composition.
Proceedings of the 2012 Conference on
Empirical Methods in Natural Language
Processing, Jeju Island.

Buszkowski, W. 2001. Lambek grammars
based on pregroups. In P. de Groote,
G. Morrill, and C. Retoré, editors, Logical
Aspects of Computational Linguistics.
Lecture Notes in Computer Science,
volume 2099. Springer, Berlin Heidelberg,
pages 95–109.

Chen, Danqi, Richard Socher, Christopher D.
Manning, and Andrew Y. Ng. 2013.
Learning new facts from knowledge
bases with neural tensor networks and
semantic word vectors. arXiv preprint
arXiv:1301.3618.

Clark, S. 2013. Type-driven syntax and
semantics for composing meaning vectors.
In Quantum Physics and Linguistics:
A Compositional, Diagrammatic Discourse.
Oxford University Press.

Clark, S., B. Coecke, and M. Sadrzadeh.
2008. A compositional distributional
model of meaning. In Proceedings of the
Second Quantum Interaction Symposium
(QI-2008), Oxford.

Clark, S. and J. R. Curran. 2007.
Wide-coverage efficient statistical
parsing with CCG and log-linear models.
Computational Linguistics, 33:493–552.

Clark, S. and S. Pulman. 2007. Combining
symbolic and distributional models of
meaning. In AAAI Spring Symposium on
Quantum Interaction, Stanford, USA.

Clarke, Daoud. 2009. Context-theoretic
semantics for natural language: An
overview. In Proceedings of the Workshop
on Geometrical Models of Natural Language
Semantics, pages 112–119, Edinburgh.

Clarke, Daoud. 2012. A context-theoretic
framework for compositionality in
distributional semantics. Computational
Linguistics, 38(1):41–71.

Coecke, B. and É. O. Paquette. 2011.
Categories for the practising physicist.
In B. Coecke, editor, New Structures
for Physics. Lecture Notes in Physics,
volume 813, pages 173–286, Springer,
Berlin Heidelberg.

Coecke, B., M. Sadrzadeh, and S. Clark.
2010. Mathematical Foundations for a
Compositional Distributional Model of
Meaning. Linguistic Analysis, 36:345–384.

Curran, James, Stephen Clark, and
Johan Bos. 2007. Linguistically motivated
large-scale NLP with C&C and boxer.
In Proceedings of the 45th Annual Meeting
of the Association for Computational
Linguistics Companion Volume Proceedings
of the Demo and Poster Sessions,
pages 33–36, Prague.

Curran, J. R. 2004. From distributional to
semantic similarity. Ph.D. thesis, School of
Informatics, University of Edinburgh.

Dean, Jeffrey and Sanjay Ghemawat. 2008.
MapReduce: Simplified data processing
on large clusters. Communications of the
ACM, 51(1):107–113.

Erk, Katrin and Sebastian Padó. 2008.
A structured vector space model for
word meaning in context. Proceedings
of the Conference on Empirical Methods in
Natural Language Processing - EMNLP ’08,
pages 897–906, Edinburgh.

Finkelstein, L., E. Gabrilovich, Y. Matias,
E. Rivlin, Z. Solan, G. Wolfman, and
E. Ruppin. 2001. Placing search in

11 http://www.cs.unm.edu/∼mccune/mace4/.

116

http://www.mitpressjournals.org/action/showLinks?system=10.1162%2Fcoli.2007.33.4.493
http://www.mitpressjournals.org/action/showLinks?crossref=10.1145%2F1327452.1327492
http://www.mitpressjournals.org/action/showLinks?crossref=10.1145%2F1327452.1327492
http://www.mitpressjournals.org/action/showLinks?system=10.1162%2FCOLI_a_00084
http://www.mitpressjournals.org/action/showLinks?system=10.1162%2FCOLI_a_00084


Grefenstette and Sadrzadeh Categorical Compositional Distributional Model of Meaning

context: The concept revisited.
In Proceedings of the 10th International
Conference on World Wide Web,
pages 406–414, Hong Kong.

Firth, J. R. 1957. A synopsis of linguistic
theory 1930-1955. Studies in linguistic
analysis.

Fowler, T. A. D. and G. Penn. 2010. Accurate
context-free parsing with combinatory
categorial grammar. In Proceedings of the
48th Annual Meeting of the Association for
Computational Linguistics, pages 335–344,
Uppsala.

Frege, G. 1892. Uber sinn und bedeutung.
Zeitschrift für Philosophie und philosophische
Kritik, 100(1):25–50.

Genkin, Daniel, Nissim Francez, and Michael
Kaminski. 2010. Mildly context-sensitive
languages via buffer augmented pregroup
grammars. In Z. Manna and D. A. Peled,
editors, Time for Verification, pages 144–166,
Springer-Verlag, Berlin, Heidelberg.

Girard, Jean-Yves. 1987. Linear logic.
Theoretical Computer Science, 50:1–102.

Grefenstette, E. 2009. Analysing document
similarity measures. Master’s thesis,
University of Oxford.

Grefenstette, E., G. Dinu, Y. Zhang,
M. Sadrzadeh, and M. Baroni. 2013. Multi-
step regression learning for compositional
distributional semantics. In Proceedings
of the Tenth International Conference on
Computational Semantics, Potsdam.

Grefenstette, E. and M. Sadrzadeh. 2011a.
Experimental support for a categorical
compositional distributional model
of meaning. In Proceedings of the
2011 Conference on Empirical Methods
in Natural Language Processing,
pages 1,394–1,404, Edinburgh.

Grefenstette, E. and M. Sadrzadeh. 2011b.
Experimenting with transitive verbs in
a DisCoCat. In Proceedings of the 2011
EMNLP Workshop on Geometric Models of
Natural Language Semantics, pages 62–66,
Edinburgh.

Grefenstette, E., M. Sadrzadeh, S. Clark,
B. Coecke, and S. Pulman. 2011. Concrete
sentence spaces for compositional
distributional models of meaning.
In Proceedings of the Ninth International
Conference on Computational Semantics,
pages 125–134, Oxford.

Grefenstette, G. 1992. Use of syntactic context
to produce term association lists for text
retrieval. In Proceedings of the 15th Annual
International ACM SIGIR Conference on
Research and Development in Information
Retrieval, pages 89–97, Copenhagen.

Grefenstette, G. 1994. Explorations in
automatic thesaurus discovery.

Guevara, E. 2010. A regression model of
adjective-noun compositionality in
distributional semantics. In Proceedings
of the 2010 Workshop on Geometrical
Models of Natural Language Semantics,
pages 33–37, Uppsala.

Harris, Z. S. 1968. Mathematical structures of
language. Wiley.

Hockenmaier, Julia. 2003. Data and Models
for Statistical Parsing with Combinatory
Categorial Grammar. Ph.D. thesis,
School of Informatics, University
of Edinburgh.

Hockenmaier, Julia and Mark Steedman.
2007. CCGBank: A corpus of CCG
derivations and dependency structures
extracted from the Penn treebank.
Computational Linguistics, 33(3):355–396.

Joshi, A. K., K. Vijay-Shanker, and
D. J. Weir. 1989. The convergence of
mildly context-sensitive grammar
formalisms. Working paper, University
of Pennsylvania, School of Engineering
and Applied Science, Dept. of Computer
and Information Science.

Lambek, J. 1958. The mathematics of
sentence structure. The American
Mathematical Monthly, 65(3):154–170.

Lambek, J. 1999. Type grammar revisited.
Logical Aspects of Computational Linguistics,
pages 1–27.

Lambek, J. 2008. From word to sentence.
A computational algebraic approach to
grammar. Milan, Polimetrica.

Lambek, J., 2010. Compact Monoidal
Categories from Linguistics to Physics,
pages 451–469.

Landauer, T. K. and S. T. Dumais. 1997.
A solution to Plato’s problem: The
latent semantic analysis theory
of acquisition, induction, and
representation of knowledge.
Psychological review.

Mac Lane, S. 1998. Categories for the
Working Mathematician. Springer Verlag.

Manning, C. D., P. Raghavan, and H.
Schütze. 2011. Introduction to information
retrieval. Cambridge University Press,
New York, NY.

Minnen, G., J. Carroll, and D. Pearce. 2001.
Applied morphological processing of
English. Natural Language Engineering,
7(03):207–223.

Mitchell, J. and M. Lapata. 2008. Vector-
based models of semantic composition.
In Proceedings of ACL, volume 8,
pages 236–244, Columbus, OH.

117

http://www.mitpressjournals.org/action/showLinks?crossref=10.1016%2F0304-3975%2887%2990045-4
http://www.mitpressjournals.org/action/showLinks?system=10.1162%2Fcoli.2007.33.3.355
http://www.mitpressjournals.org/action/showLinks?crossref=10.1017%2FS1351324901002728
http://www.mitpressjournals.org/action/showLinks?crossref=10.2307%2F2310058
http://www.mitpressjournals.org/action/showLinks?crossref=10.2307%2F2310058


Computational Linguistics Volume 41, Number 1

Mitchell, J. and M. Lapata. 2010.
Composition in Distributional Models
of Semantics. Cognitive Science
34(8):1388–1429.

Montague, R. 1974. English as a Formal
Language. In R. H. Thomason, editor,
Formal Semantics: The Essential Readings.

Moortgat, M. 1997. Categorial type logics.
In H. van Ditmarsch and L. S. Moss,
editors, Handbook of Logic and Language.
Elsevier, pages 93–177.

Padó, Sebastian and Mirella Lapata. 2007.
Dependency-based construction of
semantic space models. Computational
Linguistics, 33(2):161–199.

Pham, N., R. Bernardi, Y.-Z. Zhang, and
M. Baroni. 2013. Sentence paraphrase
detection: When determiners and word
order make the difference. In Proceedings
of the Towards a Formal Distributional
Semantics Workshop at IWCS 2013,
pages 21–29, Potsdam.

Plate, T. A. 1991. Holographic reduced
representations: Convolution algebra for
compositional distributed representations.
In Proceedings of the 12th International
Joint Conference on Artificial Intelligence,
pages 30–35, Hyderabad.

Preller, A. 2010. Polynomial pregroup
grammars parse context sensitive
languages. Linguistic Analysis, 36:483–516.

Preller, A. and M. Sadrzadeh. 2010. Bell
states and negative sentences in the
distributed model of meaning. In
P. Selinger, B. Coecke, P. Panangaden,
editors, Electronic Notes in Theoretical
Computer Science, Proceedings of the
6th QPL Workshop on Quantum Physics
and Logic. University of Oxford.

Selinger, P. 2010. A survey of graphical
languages for monoidal categories. New
Structures for Physics, pages 275–337.

Smolensky, P. 1990. Tensor product variable
binding and the representation of symbolic
structures in connectionist systems.
Artificial Intelligence, 46(1-2):159–216.

Smolensky, P. and G. Legendre. 2006. The
Harmonic Mind: From Neural Computation

to Optimality-Theoretic Grammar Volume I:
Cognitive Architecture. MIT Press.

Socher, R., B. Huval, C. D. Manning, and
A. Y. Ng. 2012. Semantic compositionality
through recursive matrix-vector spaces.
In Proceedings of the 2012 Conference
on Empirical Methods in Natural Language
Processing, pages 1,201–1,211, Jeju
Island.

Steedman, M. 2001. The Syntactic Process.
The MIT Press.

Steedman, M. and J. Baldridge. 2011.
Combinatory Categorial Grammar.
Wiley-Blackwell.

Stolcke, A. 2002. SRILM—An extensible
language modeling toolkit. In Seventh
International Conference on Spoken
Language Processing.

Turney, P. D. and P. Pantel. 2010. From
frequency to meaning: Vector space
models of semantics. Journal of Artificial
Intelligence Research, 37(1):141–188.

Turney, Peter D. 2012. Domain and
function: A dual-space model of
semantic relations and compositions.
Journal of Artificial Intelligence Research,
44:533–585.

Van Rijsbergen, C. J. 2004. The Geometry
of Information Retrieval. Cambridge
University Press.

Walters, R. F. 1991. Categories and Computer
Science. Cambridge University Press.

Widdows, D. 2005. Geometry and Meaning.
University of Chicago Press.

Widdows, D. 2008. Semantic vector
products: Some initial investigations.
In Proceedings of the Second Quantum
Interaction Symposium (QI-2008). College
Publications. CITESEER, Oxford.

Wittgenstein, L. 1953. Philosophical
Investigations. Blackwell.

Zanzotto, F. M., I. Korkontzelos, F. Fallucchi,
and S. Manandhar. 2010. Estimating
linear models for compositional
distributional semantics. In Proceedings
of the 23rd International Conference
on Computational Linguistics,
pages 1,263–1,271, Beijing.

118

http://www.mitpressjournals.org/action/showLinks?crossref=10.1111%2Fj.1551-6709.2010.01106.x
http://www.mitpressjournals.org/action/showLinks?crossref=10.1016%2F0004-3702%2890%2990007-M
http://www.mitpressjournals.org/action/showLinks?system=10.1162%2Fcoli.2007.33.2.161
http://www.mitpressjournals.org/action/showLinks?system=10.1162%2Fcoli.2007.33.2.161















<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles true
  /AutoRotatePages /All
  /Binding /Left
  /CalGrayProfile (Dot Gain 20%)
  /CalRGBProfile (sRGB IEC61966-2.1)
  /CalCMYKProfile (U.S. Web Coated \050SWOP\051 v2)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Warning
  /CompatibilityLevel 1.4
  /CompressObjects /Tags
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJDFFile false
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.0000
  /ColorConversionStrategy /LeaveColorUnchanged
  /DoThumbnails false
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 1048576
  /LockDistillerParams false
  /MaxSubsetPct 100
  /Optimize true
  /OPM 1
  /ParseDSCComments true
  /ParseDSCCommentsForDocInfo true
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo true
  /PreserveFlatness true
  /PreserveHalftoneInfo false
  /PreserveOPIComments false
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts true
  /TransferFunctionInfo /Apply
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 300
  /ColorImageMinResolutionPolicy /OK
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 300
  /ColorImageDepth -1
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 1.50000
  /EncodeColorImages true
  /ColorImageFilter /DCTEncode
  /AutoFilterColorImages true
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /ColorImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 30
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 30
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 300
  /GrayImageMinResolutionPolicy /OK
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 300
  /GrayImageDepth -1
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 1.50000
  /EncodeGrayImages true
  /GrayImageFilter /DCTEncode
  /AutoFilterGrayImages true
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /GrayImageDict <<
    /QFactor 0.15
    /HSamples [1 1 1 1] /VSamples [1 1 1 1]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 30
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 30
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 1200
  /MonoImageMinResolutionPolicy /OK
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 1200
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 1.50000
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile ()
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName ()
  /PDFXTrapped /False

  /Description <<
    /CHS <FEFF4f7f75288fd94e9b8bbe5b9a521b5efa7684002000500044004600206587686353ef901a8fc7684c976262535370673a548c002000700072006f006f00660065007200208fdb884c9ad88d2891cf62535370300260a853ef4ee54f7f75280020004100630072006f0062006100740020548c002000410064006f00620065002000520065006100640065007200200035002e003000204ee553ca66f49ad87248672c676562535f00521b5efa768400200050004400460020658768633002>
    /CHT <FEFF4f7f752890194e9b8a2d7f6e5efa7acb7684002000410064006f006200650020005000440046002065874ef653ef5728684c9762537088686a5f548c002000700072006f006f00660065007200204e0a73725f979ad854c18cea7684521753706548679c300260a853ef4ee54f7f75280020004100630072006f0062006100740020548c002000410064006f00620065002000520065006100640065007200200035002e003000204ee553ca66f49ad87248672c4f86958b555f5df25efa7acb76840020005000440046002065874ef63002>
    /DAN <FEFF004200720075006700200069006e0064007300740069006c006c0069006e006700650072006e0065002000740069006c0020006100740020006f007000720065007400740065002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e007400650072002000740069006c0020006b00760061006c00690074006500740073007500640073006b007200690076006e0069006e006700200065006c006c006500720020006b006f007200720065006b007400750072006c00e60073006e0069006e0067002e0020004400650020006f007000720065007400740065006400650020005000440046002d0064006f006b0075006d0065006e0074006500720020006b0061006e002000e50062006e00650073002000690020004100630072006f00620061007400200065006c006c006500720020004100630072006f006200610074002000520065006100640065007200200035002e00300020006f00670020006e0079006500720065002e>
    /DEU <FEFF00560065007200770065006e00640065006e0020005300690065002000640069006500730065002000450069006e007300740065006c006c0075006e00670065006e0020007a0075006d002000450072007300740065006c006c0065006e00200076006f006e002000410064006f006200650020005000440046002d0044006f006b0075006d0065006e00740065006e002c00200076006f006e002000640065006e0065006e002000530069006500200068006f00630068007700650072007400690067006500200044007200750063006b006500200061007500660020004400650073006b0074006f0070002d0044007200750063006b00650072006e00200075006e0064002000500072006f006f0066002d00470065007200e400740065006e002000650072007a0065007500670065006e0020006d00f60063006800740065006e002e002000450072007300740065006c006c007400650020005000440046002d0044006f006b0075006d0065006e007400650020006b00f6006e006e0065006e0020006d006900740020004100630072006f00620061007400200075006e0064002000410064006f00620065002000520065006100640065007200200035002e00300020006f0064006500720020006800f600680065007200200067006500f600660066006e00650074002000770065007200640065006e002e>
    /ESP <FEFF005500740069006c0069006300650020006500730074006100200063006f006e0066006900670075007200610063006900f3006e0020007000610072006100200063007200650061007200200064006f00630075006d0065006e0074006f0073002000640065002000410064006f0062006500200050004400460020007000610072006100200063006f006e00730065006700750069007200200069006d0070007200650073006900f3006e002000640065002000630061006c006900640061006400200065006e00200069006d0070007200650073006f0072006100730020006400650020006500730063007200690074006f00720069006f00200079002000680065007200720061006d00690065006e00740061007300200064006500200063006f00720072006500630063006900f3006e002e002000530065002000700075006500640065006e00200061006200720069007200200064006f00630075006d0065006e0074006f00730020005000440046002000630072006500610064006f007300200063006f006e0020004100630072006f006200610074002c002000410064006f00620065002000520065006100640065007200200035002e003000200079002000760065007200730069006f006e0065007300200070006f00730074006500720069006f007200650073002e>
    /FRA <FEFF005500740069006c006900730065007a00200063006500730020006f007000740069006f006e00730020006100660069006e00200064006500200063007200e900650072002000640065007300200064006f00630075006d0065006e00740073002000410064006f00620065002000500044004600200070006f007500720020006400650073002000e90070007200650075007600650073002000650074002000640065007300200069006d007000720065007300730069006f006e00730020006400650020006800610075007400650020007100750061006c0069007400e90020007300750072002000640065007300200069006d007000720069006d0061006e0074006500730020006400650020006200750072006500610075002e0020004c0065007300200064006f00630075006d0065006e00740073002000500044004600200063007200e900e90073002000700065007500760065006e0074002000ea0074007200650020006f007500760065007200740073002000640061006e00730020004100630072006f006200610074002c002000610069006e00730069002000710075002700410064006f00620065002000520065006100640065007200200035002e0030002000650074002000760065007200730069006f006e007300200075006c007400e90072006900650075007200650073002e>
    /ITA <FEFF005500740069006c0069007a007a006100720065002000710075006500730074006500200069006d0070006f007300740061007a0069006f006e00690020007000650072002000630072006500610072006500200064006f00630075006d0065006e00740069002000410064006f006200650020005000440046002000700065007200200075006e00610020007300740061006d007000610020006400690020007100750061006c0069007400e00020007300750020007300740061006d00700061006e0074006900200065002000700072006f006f0066006500720020006400650073006b0074006f0070002e0020004900200064006f00630075006d0065006e007400690020005000440046002000630072006500610074006900200070006f00730073006f006e006f0020006500730073006500720065002000610070006500720074006900200063006f006e0020004100630072006f00620061007400200065002000410064006f00620065002000520065006100640065007200200035002e003000200065002000760065007200730069006f006e006900200073007500630063006500730073006900760065002e>
    /JPN <FEFF9ad854c18cea51fa529b7528002000410064006f0062006500200050004400460020658766f8306e4f5c6210306b4f7f75283057307e30593002537052376642306e753b8cea3092670059279650306b4fdd306430533068304c3067304d307e3059300230c730b930af30c830c330d730d730ea30f330bf3067306e53705237307e305f306f30d730eb30fc30d57528306b9069305730663044307e305930023053306e8a2d5b9a30674f5c62103055308c305f0020005000440046002030d530a130a430eb306f3001004100630072006f0062006100740020304a30883073002000410064006f00620065002000520065006100640065007200200035002e003000204ee5964d3067958b304f30533068304c3067304d307e30593002>
    /KOR <FEFFc7740020c124c815c7440020c0acc6a9d558c5ec0020b370c2a4d06cd0d10020d504b9b0d1300020bc0f0020ad50c815ae30c5d0c11c0020ace0d488c9c8b85c0020c778c1c4d560002000410064006f0062006500200050004400460020bb38c11cb97c0020c791c131d569b2c8b2e4002e0020c774b807ac8c0020c791c131b41c00200050004400460020bb38c11cb2940020004100630072006f0062006100740020bc0f002000410064006f00620065002000520065006100640065007200200035002e00300020c774c0c1c5d0c11c0020c5f40020c2180020c788c2b5b2c8b2e4002e>
    /NLD (Gebruik deze instellingen om Adobe PDF-documenten te maken voor kwaliteitsafdrukken op desktopprinters en proofers. De gemaakte PDF-documenten kunnen worden geopend met Acrobat en Adobe Reader 5.0 en hoger.)
    /NOR <FEFF004200720075006b00200064006900730073006500200069006e006e007300740069006c006c0069006e00670065006e0065002000740069006c002000e50020006f0070007000720065007400740065002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e00740065007200200066006f00720020007500740073006b00720069006600740020006100760020006800f800790020006b00760061006c00690074006500740020007000e500200062006f007200640073006b0072006900760065007200200065006c006c00650072002000700072006f006f006600650072002e0020005000440046002d0064006f006b0075006d0065006e00740065006e00650020006b0061006e002000e50070006e00650073002000690020004100630072006f00620061007400200065006c006c00650072002000410064006f00620065002000520065006100640065007200200035002e003000200065006c006c00650072002000730065006e006500720065002e>
    /PTB <FEFF005500740069006c0069007a006500200065007300730061007300200063006f006e00660069006700750072006100e700f50065007300200064006500200066006f0072006d00610020006100200063007200690061007200200064006f00630075006d0065006e0074006f0073002000410064006f0062006500200050004400460020007000610072006100200069006d0070007200650073007300f5006500730020006400650020007100750061006c0069006400610064006500200065006d00200069006d00700072006500730073006f0072006100730020006400650073006b0074006f00700020006500200064006900730070006f00730069007400690076006f0073002000640065002000700072006f00760061002e0020004f007300200064006f00630075006d0065006e0074006f00730020005000440046002000630072006900610064006f007300200070006f00640065006d0020007300650072002000610062006500720074006f007300200063006f006d0020006f0020004100630072006f006200610074002000650020006f002000410064006f00620065002000520065006100640065007200200035002e0030002000650020007600650072007300f50065007300200070006f00730074006500720069006f007200650073002e>
    /SUO <FEFF004b00e40079007400e40020006e00e40069007400e4002000610073006500740075006b007300690061002c0020006b0075006e0020006c0075006f0074002000410064006f0062006500200050004400460020002d0064006f006b0075006d0065006e007400740065006a00610020006c0061006100640075006b006100730074006100200074007900f6007000f60079007400e400740075006c006f0073007400750073007400610020006a00610020007600650064006f007300740075007300740061002000760061007200740065006e002e00200020004c0075006f0064007500740020005000440046002d0064006f006b0075006d0065006e00740069007400200076006f0069006400610061006e0020006100760061007400610020004100630072006f0062006100740069006c006c00610020006a0061002000410064006f00620065002000520065006100640065007200200035002e0030003a006c006c00610020006a006100200075007500640065006d006d0069006c006c0061002e>
    /SVE <FEFF0041006e007600e4006e00640020006400650020006800e4007200200069006e0073007400e4006c006c006e0069006e006700610072006e00610020006f006d002000640075002000760069006c006c00200073006b006100700061002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e00740020006600f600720020006b00760061006c00690074006500740073007500740073006b0072006900660074006500720020007000e5002000760061006e006c00690067006100200073006b0072006900760061007200650020006f006300680020006600f600720020006b006f007200720065006b007400750072002e002000200053006b006100700061006400650020005000440046002d0064006f006b0075006d0065006e00740020006b0061006e002000f600700070006e00610073002000690020004100630072006f0062006100740020006f00630068002000410064006f00620065002000520065006100640065007200200035002e00300020006f00630068002000730065006e006100720065002e>
    /ENU (Use these settings to create Adobe PDF documents for quality printing on desktop printers and proofers.  Created PDF documents can be opened with Acrobat and Adobe Reader 5.0 and later.)
  >>
  /Namespace [
    (Adobe)
    (Common)
    (1.0)
  ]
  /OtherNamespaces [
    <<
      /AsReaderSpreads false
      /CropImagesToFrames true
      /ErrorControl /WarnAndContinue
      /FlattenerIgnoreSpreadOverrides false
      /IncludeGuidesGrids false
      /IncludeNonPrinting false
      /IncludeSlug false
      /Namespace [
        (Adobe)
        (InDesign)
        (4.0)
      ]
      /OmitPlacedBitmaps false
      /OmitPlacedEPS false
      /OmitPlacedPDF false
      /SimulateOverprint /Legacy
    >>
    <<
      /AddBleedMarks false
      /AddColorBars false
      /AddCropMarks false
      /AddPageInfo false
      /AddRegMarks false
      /ConvertColors /NoConversion
      /DestinationProfileName ()
      /DestinationProfileSelector /NA
      /Downsample16BitImages true
      /FlattenerPreset <<
        /PresetSelector /MediumResolution
      >>
      /FormElements false
      /GenerateStructure true
      /IncludeBookmarks false
      /IncludeHyperlinks false
      /IncludeInteractive false
      /IncludeLayers false
      /IncludeProfiles true
      /MultimediaHandling /UseObjectSettings
      /Namespace [
        (Adobe)
        (CreativeSuite)
        (2.0)
      ]
      /PDFXOutputIntentProfileSelector /NA
      /PreserveEditing true
      /UntaggedCMYKHandling /LeaveUntagged
      /UntaggedRGBHandling /LeaveUntagged
      /UseDocumentBleed false
    >>
  ]
>> setdistillerparams
<<
  /HWResolution [2400 2400]
  /PageSize [612.000 792.000]
>> setpagedevice

