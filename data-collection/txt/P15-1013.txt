



















































Low-Rank Regularization for Sparse Conjunctive Feature Spaces: An Application to Named Entity Classification


Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics
and the 7th International Joint Conference on Natural Language Processing, pages 126–135,

Beijing, China, July 26-31, 2015. c©2015 Association for Computational Linguistics

Low-Rank Regularization for Sparse Conjunctive Feature Spaces:
An Application to Named Entity Classification

Audi Primadhanty
Universitat Politècnica de Catalunya

primadhanty@cs.upc.edu

Xavier Carreras Ariadna Quattoni
Xerox Research Centre Europe

xavier.carreras@xrce.xerox.com

ariadna.quattoni@xrce.xerox.com

Abstract

Entity classification, like many other
important problems in NLP, involves
learning classifiers over sparse high-
dimensional feature spaces that result
from the conjunction of elementary fea-
tures of the entity mention and its context.
In this paper we develop a low-rank reg-
ularization framework for training max-
entropy models in such sparse conjunctive
feature spaces. Our approach handles con-
junctive feature spaces using matrices and
induces an implicit low-dimensional rep-
resentation via low-rank constraints. We
show that when learning entity classifiers
under minimal supervision, using a seed
set, our approach is more effective in con-
trolling model capacity than standard tech-
niques for linear classifiers.

1 Introduction

Many important problems in NLP involve learn-
ing classifiers over sparse high-dimensional fea-
ture spaces that result from the conjunction of el-
ementary features. For example, to classify an en-
tity in a document, it is standard to exploit features
of the left and right context in which the entity oc-
curs as well as spelling features of the entity men-
tion itself. These sets of features can be grouped
into vectors which we call elementary feature vec-
tors. In our example, there will be one elementary
feature vector for the left context, one for the right
context and one for the features of the mention.
Observe that, when the elementary vectors consist
of binary indicator features, the outer product of
any pair of vectors represents all conjunctions of
the corresponding elementary features.

Ideally, we would like to train a classifier that
can leverage all conjunctions of elementary fea-
tures, since among them there might be some
that are discriminative for the classification task at
hand. However, allowing for such expressive high
dimensional feature space comes at a cost: data
sparsity becomes a key challenge and controlling
the capacity of the model is crucial to avoid over-
fitting the training data.

The problem of data sparsity is even more se-
vere when the goal is to train classifiers with min-
imal supervision, i.e. small training sets. For ex-
ample, in the entity classification setting we might
be interested in training a classifier using only a
small set of examples of each entity class. This
is a typical scenario in an industrial setting, where
developers are interested in classifying entities ac-
cording to their own classification schema and can
only provide a handful of examples of each class.

A standard approach to control the capacity of a
linear classifier is to use `1 or `2 regularization on
the parameter vector. However, this type of regu-
larization does not seem to be effective when deal-
ing with sparse conjunctive feature spaces. The
main limitation is that `1 and `2 regularization can
not let the model give weight to conjunctions that
have not been observed at training. Without such
ability it is unlikely that the model will generalize
to novel examples, where most of the conjunctions
will be unseen in the training set.

Of course, one could impose a strong prior on
the weight vector so that it assigns weight to un-
seen conjunctions, but how can we build such a
prior? What kind of reasonable constraints can we
put on unseen conjunctions?

Another common approach to handle high di-
mensional conjunctive feature spaces is to manu-
ally design the feature function so that it includes

126



only a subset of “relevant” conjunctions. But de-
signing such a feature function can be time con-
suming and one might need to design a new fea-
ture function for each classification task. Ide-
ally, we would have a learning algorithm that does
not require such feature engineering and that it
can automatically leverage rich conjunctive fea-
ture spaces.

In this paper we present a solution to this prob-
lem by developing a regularization framework
specifically designed for sparse conjunctive fea-
ture spaces. Our approach results in a more effec-
tive way of controlling model capacity and it does
not require feature engineering.

Our strategy is based on:

• Employing tensors to define the scoring func-
tion of a max-entropy model as a multilinear
form that computes weighted inner products
between elementary vectors.

• Forcing the model to induce low-dimensional
embeddings of elementary vectors via low-
rank regularization on the tensor parameters.

The proposed regularization framework is based
on a simple conceptual trick. The standard ap-
proach to handle conjunctive feature spaces in
NLP is to regard the parameters of the linear
model as long vectors computing an inner prod-
uct with a high dimensional feature representation
that lists explicitly all possible conjunctions. In-
stead, the parameters of our the model will be ten-
sors and the compatibility score between an input
pattern and a class will be defined as the sum of
multilinear functions over elementary vectors.

We then show that the rank1 of the tensor has a
very natural interpretation. It can be seen as the
intrinsic dimensionality of a latent embedding of
the elementary feature vectors. Thus by impos-
ing a low-rank penalty on the tensor parameters
we are encouraging the model to induce a low-
dimensional projection of the elementary feature
vectors . Using the rank itself as a regularization
constraint in the learning algorithm would result
in a non-convex optimization. Instead, we follow
a standard approach which is to use the nuclear
norm as a convex relaxation of the rank.

In summary the main contributions of this paper
are:

1There are many ways of defining the rank of a tensor. In
this paper we matricize tensors into matrices and use the rank
of the resulting matrix. Matricization is also referred to as
unfolding.

• We develop a new regularization frame-
work for training max-entropy models in
high-dimensional sparse conjunctive feature
spaces. Since the proposed regularization im-
plicitly induces a low dimensional embed-
ding of feature vectors, our algorithm can
also be seen as a way of implicitly learning
a latent variable model.

• We present a simple convex learning al-
gorithm for training the parameters of the
model.

• We conduct experiments on learning entity
classifiers with minimal supervision. Our re-
sults show that the proposed regularization
framework is better for sparse conjunctive
feature spaces than standard `2 and `1 reg-
ularization. These results make us conclude
that encouraging the max-entropy model to
operate on a low-dimensional space is an ef-
fective way of controlling the capacity of the
model an ensure good generalization.

2 Entity Classification with Log-linear
Models

The formulation we develop in this paper applies
to any prediction task whose inputs are some form
of tuple. We focus on classification of entity men-
tions, or entities in the context of a sentence. For-
mally, our input objects are tuples x = 〈l, e, r〉
consisting of an entity e, a left context l and a right
context r. The goal is to classify x into one entity
class in the set Y .

We will use log-linear models of the form:

Pr(y | x; θ) = exp{sθ(x, y)}∑
y′ exp{sθ(x, y′)}

(1)

where sθ : X × Y → R is a scoring function of
entity tuples with a candidate class, and θ are the
parameters of this function, to be specified below.

In the literature it is common to employ a
feature-based linear model. That is, one defines a
feature function φ : X → {0, 1}n that represents
entity tuples in an n-dimensional binary feature
space2, and the model has a weight vector for each
class, θ = {wy}y∈Y . Then sθ(x, y) = φ(x) ·wy.

2In general, all models in this paper accept real-valued
feature functions. But we focus on binary indicator features
because in practice these are the standard type of features in
NLP classifiers, and the ones we use here. In fact, in this pa-
per we develop feature spaces based on products of elemen-
tary feature functions, in which case the resulting representa-
tions correspond to conjunctions of the elementary features.

127



3 Low-rank Entity Classification Models

In this section we propose a specific family of
models for classifying entity tuples.

3.1 A Low-rank Model of Left-Right
Contexts

We start from the observation that when repre-
senting tuple objects such as x = 〈l, e, r〉 with
features, we often depart from a feature represen-
tation of each element of the tuple. Hence, let
φl and φr be two feature functions representing
left and right contexts, with binary dimensions d1
and d2 respectively. For now, we will define a
model that ignores the entity mention e and makes
predictions using context features. It is natural
to define conjunctions of left and right features.
Hence, in its most general form, one can define
a matrix Wy ∈ Rd1×d2 for each class, such that
θ = {Wy}y∈Y and the score is:

sθ(〈l, e, r〉, y) = φl(l)>Wyφr(r) . (2)

Note that this corresponds to a feature-based
linear model operating in the product space of φl
and φr, that is, the score has one term for each pair
of features:

∑
i,j φl(l)[i] φr(r)[j] Wy[i, j]. Note

also that it is trivial to include elementary features
of φl and φr, in addition to conjunctions, by having
a constant dimension in each of the two represen-
tations set to 1.

In all, the model in Eq. (2) is very expressive,
with the caveat that it can easily overfit the data,
specially when we work only with a handful of la-
beled examples. The standard way to control the
capacity of a linear model is via `1 or `2 regular-
ization.

Regarding our parameters as matrices allows us
to control the capacity of the model via regulariz-
ers that favor parameter matrices with low rank.
To see the effect of these regularizers, consider
that Wy has rank k, and let Wy = UyΣyV>y
be the singular value decomposition, where Uy ∈
Rd1×k and Vy ∈ Rd2×k are orthonormal projec-
tions and Σy ∈ Rk×k is a diagonal matrix of sin-
gular values. We can rewrite the score function as

sθ(〈l, e, r〉, y) = (φl(l)>Uy) Σy (V>y φr(r)) .
(3)

In words, the rank k is the intrinsic dimensionality
of the inner product behind the score function. A
low-rank regularizer will favor parameter matrices
that have low intrinsic dimensionality. Below we

describe a convex optimization for low-rank mod-
els using nuclear norm regularization.

3.2 Adding Entity Features
The model above classifies entities based only on
the context. Here we propose an extension to make
use of features of the entity. Let T be a set of pos-
sible entity feature tags, i.e. tags that describe an
entity, such as ISCAPITALIZED, CONTAINSDIG-
ITS, SINGLETOKEN, . . . Let φe be a feature func-
tion representing entities. For this case, to simplify
our expression, we will use a set notation and de-
note by φe(e) ⊆ T the set of feature tags that de-
scribe e. Our model will be defined with one pa-
rameter matrix per feature tag and class label, i.e.
θ = {Wt,y}t∈T ,y∈Y . The model form is:
sθ(〈l, e, r〉, y) =

∑
t∈φe(e)

φl(l)>Wt,y .φr(r).

(4)

3.3 Learning with Low-rank Constraints
In this section we describe a convex procedure to
learn models of the above form that have low rank.
We will define an objective that combines a loss
and a regularization term.

Our first observation is that our parameters are
a tensor with up to four axes, namely left and right
context representations, entity features, and entity
classes. While a matrix has a clear definition of
rank, it is not the case for general tensors, and
there exist various definitions in the literature. The
technique that we use is based on matricization of
the tensor, that is, turning the tensor into a matrix
that has the same parameters as the tensor but or-
ganized in two axes. This is done by partitioning
the tensor axes into two sets, one for matrix rows
and another for columns. Once the tensor has been
turned into a matrix, we can use the standard def-
inition of matrix rank. A main advantage of this
approach is that we can make use of standard rou-
tines like singular value decomposition (SVD) to
decompose the matricized tensor. This is the main
reason behind our choice.

In general, different ways of partitioning the
tensor axes will lead to different notions of intrin-
sic dimensions. In our case we choose the left con-
text axes as the row dimension, and the rest of axes
as the column dimension.3 In this section, we will

3In preliminary experiments we tried variations, such as
having right prefixes in the columns, and left prefixes, entity
tags and classes in the rows. We only observer minor, non-
significant variations in the results.

128



denote as W the matricized version of the param-
eters θ of our models.

The second observation is that minimizing the
rank of a matrix is a non-convex problem. We
make use of a convex relaxation based on the nu-
clear norm (Srebro and Shraibman, 2005). The
nuclear norm4 of a matrix W, denoted ‖W‖?, is
the sum of its singular values: ‖W‖? =

∑
i Σi,i

where W = UΣV> is the singular value decom-
position of W. This norm has been used in several
applications in machine learning as a convex sur-
rogate for imposing low rank, e.g. (Srebro et al.,
2004).

Thus, the nuclear norm is used as a regularizer.
With this, we define our objective as follows:

argmin
W

L(W) + τR(W) , (5)

where L(W) is a convex loss function,R(W) is a
regularizer, and τ is a constant that trades off error
and capacity. In experiments we will compare nu-
clear norm regularization with `1 and `2 regulariz-
ers. In all cases we use the negative log-likelihood
as loss function, denoting the training data as D:

L(W) =
∑

(〈l,e,r〉,y)∈D
− log Pr(y | 〈l, e, r〉; W) .

(6)
To solve the objective in Eq. (5) we use a simple

optimization scheme known as forward-backward
splitting (FOBOS) (Duchi and Singer, 2009). In
a series of iterations, this algorithm performs a
gradient update followed by a proximal projec-
tion of the parameters. Such projection depends
on the regularizer used: for `1 it thresholds the pa-
rameters; for `2 it scales them; and for nuclear-
norm regularization it thresholds the singular val-
ues. This means that, for nuclear norm regulariza-
tion, each iteration requires to decompose W us-
ing SVD. See (Madhyastha et al., 2014) for details
about this optimization for a related application.

4 Related Work

The main aspect of our approach is the use of
a spectral penalty (i.e., the rank) to control the
capacity of multilinear functions parameterized
by matrices or tensors. Quattoni et al. (2014)
used nuclear-norm regularization to learn latent-
variable max-margin sequence taggers. Mad-
hyastha et al. (2014) defined bilexical distribu-

4Also known as the trace norm.

tions parameterized by matrices which result lex-
ical embeddings tailored for a particular linguis-
tic relation. Like in our case, the low-dimensional
latent projections in these papers are learned im-
plicitly by imposing low-rank constraints on the
predictions of the model.

Lei et al. (2014) also use low-rank tensor learn-
ing in the context of dependency parsing, where
like in our case dependencies are represented by
conjunctive feature spaces. While the motivation
is similar, their technical solution is different. We
use the technique of matricization of a tensor com-
bined with a nuclear-norm relaxation to obtain a
convex learning procedure. In their case they ex-
plicitly look for a low-dimensional factorization of
the tensor using a greedy alternating optimization.

Also recently, Yao et al. (2013) have framed
entity classification as a low-rank matrix comple-
tion problem. The idea is based on the fact that if
two entities (in rows) have similar descriptions (in
columns) they should have similar classes. The
low-rank structure of the matrix defines intrin-
sic representations of entities and feature descrip-
tions. The same idea was applied to relation ex-
traction (Riedel et al., 2013), using a matrix of
entity pairs times descriptions that corresponds to
a matricization of an entity-entity-description ten-
sor. Very recently Singh et al. (2015) explored al-
ternative ways of applying low-rank constraints to
tensor-based relation extraction.

Another aspect of this paper is training entity
classification models using minimal supervision,
which has been addressed by multiple works in
the literature. A classical successful approach
for this problem is to use co-training (Blum and
Mitchell, 1998): learn two classifiers that use dif-
ferent views of the data by using each other’s pre-
dictions. In the same line, Collins and Singer
(1999) trained entity classifiers by bootstraping
from an initial set of seeds, using a boosting ver-
sion of co-training. Seed sets have also been ex-
ploited by graphical model approaches. Haghighi
and Klein (2006) define a graphical model that is
soft-constrained such that the prediction for an un-
labeled example agrees with the labels of seeds
that are distributionally similar. Li et al. (2010)
present a Bayesian approach to expand an initial
seed set, with the goal of creating a gazetteer.

Another approach to entity recognition that, like
in our case, learns projections of contextual fea-
tures is the method by Ando and Zhang (2005).

129



Class Nb Mentions
10-30 Seed 10-30 40-120 640-1920 All

PER clinton, dole, arafat, yeltsin, wasim akram, lebed, dutroux, waqar you-
nis, mushtaq ahmed, croft

334 747 3,133 6,516

LOC u.s., england, germany, britain, australia, france, spain, pakistan, italy,
china

1,384 2,885 5,812 6,159

ORG reuters, u.n., oakland, puk, osce, cincinnati, eu, nato, ajax, honda 295 699 3,435 5,271
MISC russian, german, british, french, dutch, english, israeli, european, iraqi,

australian
611 1326 3,085 3,205

O year, percent, thursday, government, police, results, tuesday, soccer,
president, monday, friday, people, minister, sunday, division, week,
time, state, market, years, officials, group, company, saturday, match,
at, world, home, august, standings

5,326 11,595 31,071 36,673

Table 1: For each entity class, the seed of entities for the 10-30 set, together with the number of mentions
in the training data that involve entities in the seed for various sizes of the seeds.

They define a set of auxiliary tasks, which can be
supervised using unlabeled data, and find a projec-
tion of the data that works well as input represen-
tation for the auxiliary tasks. This representation
is then used for the target task.

More recently Neelakantan and Collins (2014)
presented another approach to gazetteer expansion
using an initial seed. A novel aspect is the use
of Canonical Correlation Analysis (CCA) to com-
pute embeddings of entity contexts, that are used
by the named entity classifier. Like in our case,
their method learns a compressed representation
of contexts that helps prediction.

5 Experiments

In this section we evaluate our regulariza-
tion framework for training models in high-
dimensional sparse conjunctive feature spaces. We
run experiments on learning entity classifiers with
minimal supervision. We focus on classification of
unseen entities to highlight the ability of the reg-
ularizer to generalize over conjunctions that are
not observed at training. We simulate minimal
supervision using the CoNLL-2003 Shared Task
data (Tjong Kim Sang and De Meulder, 2003), and
compare the performance to `1 and `2 regularizers.

5.1 Minimal Supervision Task

We use a minimal supervision setting where we
provide the algorithm a seed of entities for each
class, that is, a list of entities that is representative
for that class. The assumption is that any men-
tion of an entity in the seed is a positive example
for the corresponding class. Given unlabeled data
and a seed of entities for each class, the goal is

to learn a model that correctly classifies mentions
of entities that are not in the seed. In addition to
standard entity classes, we also consider a special
non-entity class, which is part of the classification
but is excluded from evaluation.

Note that named entity classification for unseen
entities is a challenging problem. Even in the stan-
dard fully-supervised scenario, when we measure
the performance of state-of-the-art methods on un-
seen entities, the F1 values are in the range of 60%.
This represents a significant drop with respect to
the standard metrics for named entity recognition,
which consider all entity mentions of the test set
irrespective of whether they appear in the training
data or not, and where F1 values at 90% levels are
obtained (e.g. (Ratinov and Roth, 2009)). This
suggests that part of the success of state-of-the-art
models is in storing known entities together with
their type (in the form of gazetteers or directly in
lexicalized parameters of the model).

5.2 Setting

We use the CoNLL-2003 English data, which is
annotated with four types: person (PER), location
(LOC), organization (ORG), and miscellaneous
(MISC). In addition, the data is tagged with parts-
of-speech (PoS), and we compute word clusters
running the Brown clustering algorithm (Brown et
al., 1992) on the words in the training set.

We consider annotated entity phrases as candi-
date entities, and all single nouns that are not part
of an entity as candidate non-entities (O). Both
candidate entities and non-entities will be referred
to as candidates in the remaining of this section.
We lowercase all candidates and remove the am-

130



Features Window
Bag-of-words N-grams

Lexical Cluster Lexical Cluster

Elementary features of left and right contexts
1 13.63 14.59 13.63 14.59
2 15.49 13.86 13.08 13.54
3 12.18 14.45 12.14 13.28

Only full conjunctions of left and right contexts
1 12.90 13.75 12.90 13.75
2 8.59 8.85 12.31 12.43
3 8.57 10.59 10.15 10.49

Elementary features and all conjunctions of left and right contexts
1 15.30 16.98 15.30 16.98
2 13.26 12.89 14.28 15.33
3 11.87 11.54 13.94 13.15

Table 2: Average-F1 of classification of unseen entity candidates on development data, using the 10-30
training seed and `2 regularization, for different conjunctive spaces (elementary only, full conjunctions,
all). Bag-of-words elementary features contain all clusters/PoS in separate windows to the left and to
the right of the candidate. N-grams elementary features contain all n-grams of clusters/PoS in separate
left and right windows (e.g. for size 3 it includes unigrams, bigrams and trigrams on each side).

biguous ones (i.e., those with more than one label
in different mentions).5

To simulate a minimal supervision, we create
supervision seeds by picking the n most frequent
training candidates for entity types, and the m
most frequent candidate non-entities. We create
seeds of various sizes n-m, namely 10-30, 40-120,
640-1920, as well as all of the candidates. For
each seed, the training set consists of all training
mentions that involve entities in the seed. Table 1
shows the smaller seed, as well as the number of
mentions for each seed size.

For evaluation we use the development and test
sections of the data, but we remove the instances
of candidates in the training data (i.e., that are in
the all seed). We do not remove instances that are
ambiguous in the tests. 6 As evaluation metric we
use the average F1 score computed over all entity
types, excluding the non-entity type.

5In the CoNLL-2003 English training set, only 235 can-
didates are ambiguous out of 13,441 candidates, i.e. less than
2%. This suggests that in this data the difficulty behind the
task is in recognizing and classifying unseen entities, and not
in disambiguating known entities in a certain context.

6After removing the ambiguous candidates from the train-
ing data, and removing candidates seen in the training from
the development and test sets, this is the number of mentions
(and number of unique candidates in parenthesis) in the data
used in our experiments:

training dev. test
PER 6,516 (3,489) 1,040 (762) 1,342 (925)
LOC 6,159 ( 987) 176 (128) 246 (160)
ORG 5,271 (2,149) 400 (273) 638 (358)
MISC 3,205 ( 760) 177 (142) 213 (152)

O 36,673 (5,821) 951 (671) 995 (675)

5.3 Context Representations

We refer to context as the sequence of tokens be-
fore (left context) and after (right context) a can-
didate mention in a sentence. Different classifiers
can be built using different representations of the
contexts. For example we can change the window
size of the context sequence (i.e., for a window
size of 1 we only use the last token before the men-
tion and the first token after the mention). We can
treat the left and right contexts independently of
each other, we can treat them as a unique combi-
nation, or we can use both. We can also choose to
use the word form of a token, its PoS tag, a word
cluster, or a combination of these.

Table 2 compares different context represen-
tations and their performance in classifying un-
seen candidates using maximum-entropy classi-
fiers trained with Mallet (McCallum, 2002) with
`2 regularization, using the 10-30 seed. We use
the lexical representation (the word itself) and a
word cluster representation of the context tokens
and use a window size of one to three. We use
two types of features: bag-of-words features (1-
grams of tokens in the specified window) and n-
gram features (with n smaller or equal to the win-
dow size). The performance of using word clusters
is comparable, and sometimes better, to using lexi-
cal representations. Moreover, using a longer win-
dow, in this case, does not necessarily result in bet-
ter performance. 7 In the rest of the experiments

7Our learner and feature configuration, using `2 regular-
ization, obtains state-of-the-art results on the standard evalu-

131



10-30 40-120 640-1920 All
0

40

60

14.23
17.58

27.41 28.88
14.12

17.72

27.18 28.5425.11
28.25

38.3
42.81

Seed set

AV
G

-F
1

(%
)

L1
L2
NN

(a) Only full conjunctions of left-right contexts (cluster),
window size = 1

10-30 40-120 640-1920 All
0

40

60

17.39 20.05

32.73
38.01

17.4
20.72

32.76
38.95

28.9
33.67

42.72

53.65

Seed set

AV
G

-F
1

(%
)

L1
L2
NN

(b) Only full conjunctions of entity tags and left-right contexts
(cluster), window size = 1

10-30 40-120 640-1920 All
0

60

28.57
25.3

39.52
45.04

28.48 25.91

40.45
44.2

36.87
41

56.16
60.94

Seed set

AV
G

-F
1

(%
)

L1
L2
NN

(c) Elementary features and all conjunctions of entity tags and
left-right contexts (cluster), window size = 1

10-30 40-120 640-1920 All
0

60

28.33
24.41

39.95
44.03

28.92
24.62

40.54
44.09

35.58 37.45

56.74 59.46

Seed set

AV
G

-F
1

(%
)

L1
L2
NN

(d) Elementary features and all conjunctions of entity tags and
left-right contexts (cluster), window size = 2

10-30 40-120 640-1920 All
0

20

60

30.21
27.05

39.74
44.67

29.67 27.07

39.84
45.16

37.1
41.14

57.7
61.13

Seed set

AV
G

-F
1

(%
)

L1
L2
NN

(e) Elementary features and all conjunctions of entity tags and
left-right contexts (cluster & PoS), window size = 1

10-30 40-120 640-1920 All
0

60

28.21 28.04

37.21
42.83

28.65 27.62

39.34
44.1

38.22 37.11

54.56
58.43

Seed set

AV
G

-F
1

(%
)

L1
L2
NN

(f) Elementary features and all conjunctions of entity tags and
left-right contexts (cluster & PoS), window size = 2

Figure 1: Average F1 of classification of unseen entity candidates on development data, with respect to
the size of the seed. NN refers to models with nuclear norm regularization, L1 and L2 refer to `1 and
`2 regularization. Each plot corresponds to a different conjunctive feature space with respect to window
size (1 or 2), context representation (cluster with/out PoS), using entity features or not, and combining
or not full conjunctions with lower-order conjunctions and elementary features.

• cap=1, cap=0: whether the first letter of the entity candidate is uppercase, or not
• all-low=1, all-low=0: whether all letters of the candidate are lowercase letters, or not
• all-cap1=1, all-cap1=0: whether all letters of the candidate are uppercase letters, or not
• all-cap2=1, all-cap2=0: whether all letters of the candidate are uppercase letters and periods, or not
• num-tokens=1, num-tokens=2, num-tok>2: whether the candidate consists of one token, two or more
• dummy: a tag that holds for any entity candidate, used to capture context features alone

Table 3: The 12 entity tags used to represent entity candidates. The tags all-cap1 and all-cap2 are from
(Neelakantan and Collins, 2014).

132



PER LOC ORG MISC AVG
F1PREC REC F1 PREC REC F1 PREC REC F1 PREC REC F1

10
-3

0

`1 65.69 65.40 65.55 15.38 23.58 18.62 59.33 19.44 29.28 23.36 30.05 26.28 34.93

`1 65.54 64.80 65.17 15.12 23.17 18.30 60.82 18.50 28.37 23.30 30.52 26.42 34.56

NN 72.41 74.52 73.45 14.89 21.55 17.61 49.09 21.16 17.61 31.40 38.03 34.40 38.76

40
-1

20

`1 72.16 44.07 54.72 13.38 40.24 20.08 48.89 31.19 38.09 22.03 35.68 27.24 35.03

`2 71.75 44.89 55.23 13.61 41.87 20.54 49.39 31.50 38.47 21.64 30.99 25.48 34.93

NN 75.16 61.33 67.54 13.08 20.73 16.04 49.03 35.74 41.34 29.97 47.42 36.73 40.41

64
0-

19
20 `1 79.52 62.27 69.85 23.59 44.31 30.79 55.78 47.65 51.39 19.81 30.05 23.88 43.98

`2 78.62 65.55 71.49 26.55 43.50 32.97 60.19 49.06 54.06 21.73 31.92 25.86 46.10

NN 80.73 80.55 80.64 51.91 44.31 47.81 53.82 54.08 53.95 29.14 51.17 37.14 54.88

A
ll

`1 75.58 72.48 74.00 32.84 36.18 34.43 57.28 46.24 51.17 27.93 29.11 28.51 47.03

`2 76.59 70.77 73.57 34.21 36.99 35.55 57.79 50.00 53.61 28.93 32.86 30.77 48.37

NN 73.83 90.84 81.46 64.96 36.18 46.48 72.11 44.98 55.41 37.20 43.66 40.17 55.88

Table 4: Results on the test for models trained with different sizes of the seed, using the parameters
and features that obtain the best evaluation results the development set. NN refers to nuclear norm
regularization, L1 and L2 refer to `1 and `2 regularization. Only test entities unseen at training are
considered. Avg. F1 is over PER, LOC, ORG and MISC, excluding O.

we will use the elementary features that are more
predictive and compact: clusters and PoS tags in
windows of size at most 2.

5.4 Comparing Regularizers
We compare the performance of models trained
using the nuclear norm regularizer with models
trained using `1 and `2 regularizers. To train each
model, we validate the regularization parameter
and the number of iterations on development data,
trying a wide range of values. The best performing
configuration is then used for the comparison.

Figure 1 shows results on the development set
for different feature sets. We started representing
context using cluster labels, as it is the most com-
pact representation obtaining good results in pre-
liminary experiments. We tried several conjunc-
tions: a conjunction of the left and right context,
as well as conjunctions of left and right contexts
and features of the candidate entity. We also tried
all different conjunction combinations of the con-
texts and the candidate entity features, as well as
adding PoS tags to represent contexts. To repre-
sent an entity candidate we use standard traits of
the spelling of the mention, such as capitalization,

ation. Using our richest feature set, the model obtains 76.76
of accuracy in the development, for the task of classifing enti-
ties with correct boundaries. If we add features capturing the
full entity and its tokens, then the accuracy is 87.63, which
is similar to state-of-the-art performance (the best results in
literature typically exploit additional gazetteers). Since our
evaluation focuses on unknown entities, our features do not
include information about the word tokens of entites.

1 2 3 4 5 6 7 8 9 10203040506070
0

20

40

60

28.22

43.93

50.19
54.24

58.14

61.73 61.13

dimension

AV
G

-F
1

(%
)

Figure 2: Avg. F1 on development for increasing
dimensions, using the low-rank model in Figure 1e
trained with all seeds.

the existence of symbols, as well as the number of
tokens in the candidate. See Table 3 for the defini-
tion of the features describing entity candidates.

We observe that for most conjunction settings
our regularizer performs better than the `1 and
`2 regularizers. Using the best model from each
regularizer, we evaluated on the test set. Table
4 shows the test results. For all seed sets, the
nuclear norm regularizer obtains the best aver-
age F1 performance. This shows that encourag-
ing the max-entropy model to operate on a low-
dimensional space is effective. Moreover, Figure
2 shows model performance as a function of the
number of dimensions of the intrinsic projection.
The model obtains a good performance even if
only a few intrinsic dimensions are used.

Figure 3 shows the parameter matrix of the low-

133



O PER LOC ORG MISC

Cluster

PoS

(a) Full parameter matrix of the low-rank model. The ticks in x-axis indicate the space for different entity types, while the ticks
in y-axis indicate the space for different prefix context representations.

all−
cap

1=
1

all−
cap

1=
0

all−
cap

2=
1

all−
cap

2=
0

all−
low

=1

all−
low

=0

nb−
tok

=1

nb−
tok

=2

nb−
tok

>2
cap

=1
cap

=0
dum

my

prefix=NNP

(b) The subblock for PER entity type and PoS representation of the prefixes. The ticks in x-axis indicate the space of the entity
features used, while the tick in y-axis indicates an example of a frequently observed prefix for this entity type.

Figure 3: Parameter matrix of the low-rank model in Figure 1f trained with the 10-30 seed, with respect to
observations of the associated features in training and development. Non-white conjunctions correspond
to non-zero weights: black is for conjunctions seen in both the training and development sets; blue is for
those seen in training but not in the development; red indicates that the conjunctions were observed only
in the development; yellow is for those not observed in training nor development.

rank model in Figure 1f trained with the 10-30
seed, with respect to observed features in training
and development data. Many of the conjunctions
of the development set were never observed in the
training set. Our regularizer framework is able to
propagate weights from the conjunctive features
seen in training to unseen conjunctive features that
are close to each other in the projected space (these
are the yellow and red cells in the matrix). In con-
trast, `1 and `2 regularization techniques can not
put weight on unseen conjunctions.

6 Conclusion

We have developed a low-rank regularization
framework for training max-entropy models in
sparse conjunctive feature spaces. Our formula-
tion is based on using tensors to parameterize clas-
sifiers. We control the capacity of the model using
the nuclear-norm of a matricization of the tensor.
Overall, our formulation results in a convex proce-
dure for training model parameters.

We have experimented with these techniques in

the context of learning entity classifiers. Com-
pared to `1 and `2 penalties, the low-rank model
obtains better performance, without the need to
manually specify feature conjunctions. In our
analysis, we have illustrated how the low-rank ap-
proach can assign non-zero weights to conjunc-
tions that were unobserved at training, but are sim-
ilar to observed conjunctions with respect to the
low-dimensional projection of their elements.

We have used matricization of a tensor to define
its rank, using a fixed transformation of the tensor
into a matrix. Future work should explore how to
combine efficiently different transformations.

Acknowledgements

We thank Gabriele Musillo and the anonymous re-
viewers for their helpful comments and sugges-
tions. This work has been partially funded by the
Spanish Government through the SKATER project
(TIN2012-38584-C06-01) and an FPI predoctoral
grant for Audi Primadhanty.

134



References
Rie Kubota Ando and Tong Zhang. 2005. A frame-

work for learning predictive structures from multi-
ple tasks and unlabeled data. J. Mach. Learn. Res.,
6:1817–1853, December.

Avrim Blum and Tom Mitchell. 1998. Combining
labeled and unlabeled data with co-training. In
Proceedings of the Eleventh Annual Conference on
Computational Learning Theory, COLT’ 98, pages
92–100, New York, NY, USA. ACM.

Peter F. Brown, Peter V. deSouza, Robert L. Mer-
cer, Vincent J. Della Pietra, and Jenifer C. Lai.
1992. Class-based n-gram models of natural lan-
guage. Computational Linguistics, 18:467–479.

Michael Collins and Yoram Singer. 1999. Unsuper-
vised models for named entity classification. In
Joint SIGDAT Conference on Empirical Methods in
Natural Language Processing and Very Large Cor-
pora.

John Duchi and Yoram Singer. 2009. Efficient online
and batch learning using forward backward splitting.
Journal of Machine Learning Research, 10:2899–
2934.

Aria Haghighi and Dan Klein. 2006. Prototype-driven
learning for sequence models. In Proceedings of
the Main Conference on Human Language Tech-
nology Conference of the North American Chap-
ter of the Association of Computational Linguistics,
HLT-NAACL ’06, pages 320–327, Stroudsburg, PA,
USA. Association for Computational Linguistics.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proceedings of the
52nd Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
1381–1391, Baltimore, Maryland, June. Association
for Computational Linguistics.

Xiao-Li Li, Lei Zhang, Bing Liu, and See-Kiong
Ng. 2010. Distributional similarity vs. pu learn-
ing for entity set expansion. In Proceedings of the
ACL 2010 Conference Short Papers, ACLShort ’10,
pages 359–364, Stroudsburg, PA, USA. Association
for Computational Linguistics.

Pranava Swaroop Madhyastha, Xavier Carreras, and
Ariadna Quattoni. 2014. Learning Task-specific
Bilexical Embeddings. In Proceedings of COLING
2014, the 25th International Conference on Compu-
tational Linguistics: Technical Papers, pages 161–
171, Dublin, Ireland, August. Dublin City Univer-
sity and Association for Computational Linguistics.

Andrew K. McCallum. 2002. Mallet: A machine
learning for language toolkit.

Arvind Neelakantan and Michael Collins. 2014.
Learning dictionaries for named entity recognition
using minimal supervision. In Proceedings of the

14th Conference of the European Chapter of the As-
sociation for Computational Linguistics, pages 452–
461, Gothenburg, Sweden, April. Association for
Computational Linguistics.

Ariadna Quattoni, Borja Balle, Xavier Carreras, and
Amir Globerson. 2014. Spectral regularization for
max-margin sequence tagging. In Tony Jebara and
Eric P. Xing, editors, Proceedings of the 31st Inter-
national Conference on Machine Learning (ICML-
14), pages 1710–1718. JMLR Workshop and Con-
ference Proceedings.

Lev Ratinov and Dan Roth. 2009. Design chal-
lenges and misconceptions in named entity recog-
nition. In Proceedings of the Thirteenth Confer-
ence on Computational Natural Language Learning
(CoNLL-2009), pages 147–155, Boulder, Colorado,
June. Association for Computational Linguistics.

Sebastian Riedel, Limin Yao, Andrew McCallum, and
Benjamin M. Marlin. 2013. Relation extraction
with matrix factorization and universal schemas. In
Proceedings of the 2013 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 74–84, Atlanta, Georgia, June. Association
for Computational Linguistics.

Sameer Singh, Tim Rocktäschel, and Sebastian Riedel.
2015. Towards Combined Matrix and Tensor Fac-
torization for Universal Schema Relation Extraction.
In NAACL Workshop on Vector Space Modeling for
NLP (VSM).

Nathan Srebro and Adi Shraibman. 2005. Rank, trace-
norm and max-norm. In Learning Theory, pages
545–560. Springer Berlin Heidelberg.

Nathan Srebro, Jason Rennie, and Tommi S Jaakkola.
2004. Maximum-margin matrix factorization. In
Advances in neural information processing systems,
pages 1329–1336.

Erik F. Tjong Kim Sang and Fien De Meulder.
2003. Introduction to the CoNLL-2003 Shared
Task: Language-Independent Named Entity Recog-
nition. In Proceedings of the Seventh Conference on
Natural Language Learning at HLT-NAACL 2003,
pages 142–147.

Limin Yao, Sebastian Riedel, and Andrew McCallum.
2013. Universal schema for entity type prediction.
In Proceedings of the 2013 Workshop on Automated
Knowledge Base Construction, AKBC ’13, pages
79–84, New York, NY, USA. ACM.

135


