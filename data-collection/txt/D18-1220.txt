



















































A Knowledge Hunting Framework for Common Sense Reasoning


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 1949–1958
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

1949

A Knowledge Hunting Framework for Common Sense Reasoning

Ali Emami1, Noelia De La Cruz1, Adam Trischler2, Kaheer Suleman2, and Jackie Chi Kit Cheung1

1School of Computer Science, Mila/McGill University
2Microsoft Research Montreal

{ali.emami, noelia.delacruz}@mail.mcgill.ca
{adam.trischler, kasulema}@microsoft.com

jcheung@cs.mcgill.ca

Abstract

We introduce an automatic system that
achieves state-of-the-art results on the Wino-
grad Schema Challenge (WSC), a common
sense reasoning task that requires diverse,
complex forms of inference and knowledge.
Our method uses a knowledge hunting mod-
ule to gather text from the web, which serves
as evidence for candidate problem resolutions.
Given an input problem, our system gener-
ates relevant queries to send to a search en-
gine, then extracts and classifies knowledge
from the returned results and weighs them to
make a resolution. Our approach improves F1
performance on the full WSC by 0.21 over
the previous best and represents the first sys-
tem to exceed 0.5 F1. We further demonstrate
that the approach is competitive on the Choice
of Plausible Alternatives (COPA) task, which
suggests that it is generally applicable.

1 Introduction

The importance of common-sense reasoning in
natural language processing, particularly for syn-
tactic and semantic disambiguation, has long been
recognized. Almost 30 years ago, Dahlgren et al.
(1989) proposed systems that use common sense
to disambiguate parse trees, word senses, and
quantifier scope. Although the resolution of cer-
tain ambiguities depends chiefly on linguistic pat-
terns (e.g., the number and gender of an antecedent
for pronoun disambiguation), many cases de-
pend on world knowledge, shared points of refer-
ence, and an understanding of what is plausible—
concepts often grouped under the term “common
sense.”

Various tasks have been devised to test
common-sense reasoning in automatic systems.
Two of the most popular are the Winograd Schema
Challenge (WSC) (Levesque et al., 2011) and the
Choice of Plausible Alternatives (COPA) (Roem-

mele et al., 2011). Both require a system to assess
the relative plausibility of two scenarios.

WSC problems are short passages containing a
target pronoun that must be correctly resolved to
one of two possible antecedents. They come in
pairs which differ slightly and result in adverse
correct resolutions. As an example:

(1) a. Jim yelled at Kevin because he was so
upset. (Answer: Jim)

b. Jim comforted Kevin because he was
so upset. (Answer: Kevin)

WSC problem pairs (“twins,” using the termi-
nology of Hirst (1988)) are carefully controlled
such that heuristics involving syntactic salience,
the number and gender of the antecedent, or other
simple syntactic and semantic cues are ineffec-
tive. This distinguishes the task from the standard
coreference resolution problem. Performant sys-
tems must make common sense inferences; i.e.,
that someone who yells is likely to be upset, and
that someone who is upset tends to be comforted.
Additional examples are shown in Table 1.

WSC problems are simple for people to solve
(human participants in one study performed at
92% accuracy (Bender, 2015)) but difficult for au-
tomatic systems. This is because common sense
reasoning encompasses many types of reasoning
(causal, spatio-temporal, etc.) and requires a wide
breadth of knowledge.

COPA is a related task that tests a system’s abil-
ity to recognize causality (Roemmele et al., 2011).
Each instance comprises a premise and two candi-
date causes or effects, where the correct choice is
the candidate that is more plausible.

Previous approaches to common sense reason-
ing, for instance based on logical formalisms (Bai-
ley et al., 2015) or deep neural models (Liu et al.,
2016), have solved only restricted subsets of the
WSC with high precision. They have been tailored



1950

1 a) The man couldn’t lift his son because he was so weak. (Answer: the man)
1 b) The man couldn’t lift his son because he was so heavy. (Answer: son)
2 a) The older students were bullying the younger ones, so we punished them. (Answer: the older students)
2 b) The older students were bullying the younger ones, so we rescued them. (Answer: the younger ones)

3 a) Sam tried to paint a picture of shepherds with sheep, but they ended up looking more like golfers.(Answer: shepherds)

3 b) Sam tried to paint a picture of shepherds with sheep, but they ended up looking more like dogs.(Answer: sheep)

Table 1: Examples of Winograd instances.

for manually selected subsets that demand a spe-
cific type of reasoning (Sharma et al., 2015; Liu
et al., 2016). Others have developed systems for
relaxed common sense datasets with looser con-
straints (Rahman and Ng, 2012; Peng et al., 2015;
Kruengkrai et al., 2014). In parallel, more gen-
eral work on common sense reasoning aims to de-
velop a repository of common knowledge using
semi-automatic methods (e.g., Cyc (Lenat, 1995)
and ConceptNet (Liu and Singh, 2004)). However,
such knowledge bases are necessarily incomplete.

In this work, we propose a general method to
resolve common sense problems like WSC and
COPA. Contrary to previous work, we aim to solve
all problem instances rather than a restricted sub-
set. Our method is based on on-the-fly knowl-
edge hunting and operates in four stages. First,
it parses an input problem into a representation
schema. Next it generates search queries from the
populated schema. It sends these to a search en-
gine, and the next stage parses and filters the re-
sults. Finally, it classifies and weighs the results
as evidence for respective candidate resolutions.

Our approach arises from the hypothesis that
there is too much common sense to encode it all
statically; e.g., within a knowledge base or a neu-
ral model (using existing techniques). Even mod-
ern NLP corpora composed of billions of words
are unlikely to offer good coverage of common
sense, or if they do, instances of specific knowl-
edge are likely to be “long-tailed” and difficult for
statistical systems to model effectively. Informa-
tion retrieval (IR) techniques can sidestep these
issues by returning targeted results and by using
the entire indexed internet as a knowledge source.
Scenarios that appear in natural text can offer im-
plicit or explicit evidence for the plausibility of
related scenarios in common sense problems. To
solve (1a), the following search result contains the
relevant knowledge without the original ambigu-
ity:

(2) I got really upset with her and I started to

yell at her because...

Here, the same entity, I, is the subject of both upset
and yell at, which is strong evidence for resolving
the original statement. This information can be
extracted from a syntactic parse of the retrieved
passage with standard NLP tools.

As we will demonstrate experimentally, our
knowledge hunting approach achieves an F1 score
of 0.51 on the WSC, improving significantly over
the previous state-of-the-art (0.3 F1). When tested
on the similar COPA task, a simplified knowl-
edge hunting system performs competitively with
the previous best. To our knowledge, this is the
first method that tackles multiple common sense
tasks with strong performance on each. Thus,
knowledge-hunting embodies some of the general
capabilities that we desire of automatic systems
for common sense reasoning.1

2 Related Work

There is increasing interest in using IR approaches
to address difficult coreference problems. For ex-
ample, a recent system (Rahman and Ng, 2012)
uses web query information to retrieve evidence
for the coreference decision in a Winograd-like
corpus. Other systems (Kobdani et al., 2011;
Ratinov and Roth, 2012; Bansal and Klein, 2012;
Zheng et al., 2013; Peng et al., 2015; Sharma
et al., 2015) rely on similar techniques, i.e., us-
ing search-query counts or co-occurrence statistics
and word alignment methods to relate antecedents
with pronouns.

Most recent approaches have tackled the Wino-
grad problem by simplifying it in one of two ways.
First, systems have been developed exclusively for
Rahman and Ng’s expanded Winograd-like cor-
pus. These include Rahman and Ng (2012)’s
system itself, achieving 73% accuracy, and Peng
et al. (2015)’s system (76%). Kruengkrai et al.

1Code to reproduce these results are available at
https://github.com/aemami1/Wino-Knowledge-Hunter



1951

(2014) use sentence alignment of web query snip-
pets to achieve 70% accuracy on a subset of the
expanded corpus. Many instances in this corpus
can be resolved using associations between candi-
date antecedents and the query predicate. For ex-
ample, “Lions eat zebras because they are preda-
tors.” Many of the above systems simply query
“Lions are predators” versus “zebras are preda-
tors” to make a resolution decision. This exploita-
tion is often the top contributor to such systems’
overall accuracy (Rahman and Ng, 2012), but fails
to apply in the majority (if not all) of the origi-
nal Winograd instances.2 Our work alleviates this
issue by generating search queries that are based
exclusively on the predicates of the Winograd in-
stance, not the antecedents, and by considering the
strength of the evidence.

Other systems do tackle the original, more diffi-
cult Winograd instances, but only a small, author-
selected subset. The selection is based often
on knowledge-type constraints. Sharma et al.
(2015)’s knowledge-hunting module focused on
a subset of 71 instances that exhibit causal rela-
tionships; Liu et al. (2016)’s neural association
model focused on a similar causal subset of 70
instances, for which events were extracted man-
ually; and finally, a recent system by Huang and
Luo (2017) focused on 49 instances. While these
approaches demonstrate that difficult coreference
problems can be resolved when they adhere to cer-
tain knowledge or structural constraints, they may
fail to generalize to other settings. This factor of-
ten goes unnoticed when systems are compared
only in terms of precision; accordingly, we use an
F1-driven comparison that does not enable preci-
sion boosting at the cost of recall.

Concurrently with our work, Trinh and Le
(2018) introduced a system composed of 14 en-
sembled language models, pre-trained in an unsu-
pervised manner, that achieves up to 63.7% accu-
racy on the Winograd Schema Challenge. Com-
pared to our approach, their method requires train-
ing multiple language models with vast amounts
of data, which is much more expensive.

Other Common-sense Tasks: There are vari-
ous other Turing-test alternatives that directly or
indirectly assess common-sense reasoning. These
include Pronoun Disambiguation Problems (more
generalized, Winograd-like passages without the

2This is why we do not evaluate our method directly on
the expanded corpus.

twist of a special word or twin) (Morgenstern
et al., 2016), the Narrative cloze task (Tay-
lor, 1953), or its more difficult counterpart, the
NarrativeQA Reading Comprehension Challenge
(Kočiskỳ et al., 2017).

The COPA task was proposed by Roemmele
et al. (2011), who also measured the perfor-
mance of several systems. The most successful
used Pointwise Mutual Information (PMI) statis-
tics (Church and Hanks, 1990) between words in
the premise and each alternative obtained from a
large text corpus (as an implicit way to estimate
causal association). More recent work showed that
applying the same PMI-based technique on a cor-
pus of stories yields better results (Gordon et al.,
2011). The current state-of-the-art approaches
leverage co-occurrence statistics extracted using
causal cues (Luo et al., 2016; Sasaki et al., 2017).

Extended Work: Previously, Emami et al.
(2018) proposed a similar knowledge hunting
framework to tackle the Winograd Schema Chal-
lenge. This work modifies and extends their
approach. Our modifications include a query-
filtering step and various other tweaks that im-
prove results by 0.05 F1 for our best model. In
addition, we added further experiments and an ab-
lation study that explores the performance of dif-
ferent model components. Finally, we adapted
our method to a new dataset, COPA, on which
we achieve respectable results. Accordingly, we
change the general takeaway of the previous work
from a method with strong performance on a sin-
gle dataset to one that generalizes and performs
well on various tasks.

3 Knowledge Hunting Framework

Our framework takes as input a problem instance
and processes it through four stages to make a fi-
nal coreference decision. First, it fits the instance
to a semantic representation schema. Second, it
generates a set of queries that capture the predi-
cates in the instance’s clauses and sends these to
a search engine, which retrieves text snippets that
closely match the schema. The returned snippets
are then parsed and filtered. Finally, the snippets
are resolved to their respective antecedents and the
results are mapped to a best guess for the origi-
nal instance’s resolution. We detail these stages
below, grounding our description in Winograd in-
stances.



1952

3.1 Semantic Representation Schema

The first step is to perform a partial parse of each
instance into a shallow semantic representation;
that is, a general skeleton of each of the impor-
tant semantic components in the order that they
appear. This is performed using rules related to
the syntactic parse of the sentence determined by
Stanford CoreNLP (Manning et al., 2014).

In general, Winograd instances can be separated
into a context clause, which introduces the two
competing antecedents, and a query clause, which
contains the target pronoun to be resolved. We use
the following notation to define the components in
our representation schema:

E1, E2 the candidate antecedents

PredC the context predicate

+ discourse connective

P the target pronoun

PredQ the query predicate

E1 andE2 are noun phrases in the sentence. In the
WSC, these two are specified without ambiguity.
PredC is the context predicate composed of the
verb phrase that relates both antecedents to some
event. The context contains E1, E2, and the con-
text predicate PredC . The context and the query
clauses are often connected by a discourse connec-
tive +. The query contains the target pronoun, P ,
which is also specified unambiguously. In addi-
tion, preceding or succeeding P is the query pred-
icate, PredQ, a verb phrase involving the target
pronoun. Table 2 shows sentence pairs in terms of
each of these components.

3.2 Query Generation

Based on the parse, the system generates queries
to send to a search engine. The goal is to retrieve
text snippets that resemble the original instance.
Queries are of the form:
+TermC +TermQ −“Winograd”−E1

We assume that the search queries are composed
of two components, TermC and TermQ, which
are strings that represent the events occurring in
the first (context) and second (query) clause of the
sentence, respectively. By excluding search results
that may contain Winograd or E1, we ensure that
we do not cheat by retrieving some rewording of
the original Winograd instance.

The next task is to construct two query sets, C
and Q, whose elements are possible entries for
TermC and TermQ, respectively. We identify the
root verbs in the context and query clauses, along
with any modifying adjective, using the depen-
dency parse of the sentence determined by Stan-
ford CoreNLP (Manning et al., 2014). We add the
root verbs and adjectives into the sets C and Q
along with their broader verb phrases (again iden-
tified directly using the dependency tree).

Augmenting the query set with WordNet We
use WordNet (Kilgarriff, 2000) to construct an
augmented query set that contains synonyms for
the verbs and adjectives involved in a representa-
tion. In particular, we include the synonyms listed
for the top synset of the same part of speech as the
extracted verb or adjective.

Query filtering Automated query generation
sometimes yields terms that are irrelevant to the
disambiguation task. This can add noise to the
results. To address this, we implement a seman-
tic similarity algorithm that filters root verbs and
modifying adjectives from the query sets accord-
ing to their relevance to other terms. We esti-
mate relative relevance using Wu-Palmer (Wu and
Palmer, 1994) similarity scores from WordNet and
filter as follows. For each passage, the semantic
filter (i) computes similarity scores for every pos-
sible combination of {TermC , T ermQ} (if both
TermC and TermQ are single words); (ii) deter-
mines the maximum similarity score s; and (iii)
discards any term whose highest similarity score
from step (i) is less than αs, where 0 < α < 1. We
tune α, a hyperparameter, on Rahman and Ng’s
expanded corpus (Rahman and Ng, 2012).

We hypothesize that terms in the query and con-
text clauses more pertinent to the task have higher
mutual similarity scores than irrelevant terms. To
illustrate this, consider the query sets generated
for Example 2a, Table 1: {“bullying”, “younger”,
“older”} and {“punished”}. Applying the se-
mantic filter yields the new sets {“bullying”} and
{“punished”}, where the irrelevant terms younger
and older have been removed.

Manual query construction To understand the
impact of the query generation step, we also manu-
ally produced representations for all Winograd in-
stances. We limited the size of these sets to five
to prevent a blowing-up of search space during
knowledge extraction. In Table 3, we show ex-



1953

Pair PredC E1 E2 PredQ P
Alternating Word
(POS)

1 couldn’t lift the man his son was so heavy he weak/heavy (adjective)

2 werebullying
the older
students

the younger
ones punished them

punished/rescued
(verb)

3 tried topaint shepherds sheep
ended up
looking more
like

they golfers/dogs (noun)

Table 2: Winograd sentence pairs from Table 1, parsed into the representation schema that we define.

Sentence: The trophy doesn’t fit into the brown suitcase because it is too large.

Query Generation Method C Q

Automatic {“doesn’t fit into”, “brown”, “fit” } {“large”, “is too large”}
Automatic, with synonyms {“doesn’t fit into”, “brown”, “accommo-

date”, “fit”, “suit” }
{“large”, “big”, “is too large” }

Manual {“doesn’t fit into”, “fit into”,“doesn’t fit” } {“is too large”, “too large”, “large” }

Table 3: Query generation techniques on an example Winograd sentences

amples of generated queries for C andQ using the
various techniques.

3.3 Parsing the Search Results

From the search results, we obtain a set of text
snippets that we filter for similarity to the original
problem instance. First, TermC and TermQ are
restricted to occur in the same snippet, but are
allowed to occur in any order. We filter the passed
sentences further to ensure that they contain at
least two entities that corefer. These may be
structured as follows:

E′1 Pred
′
C E

′
2 + E

′
3 Pred

′
Q

E′1 Pred
′
C E

′
2 + Pred

′
Q E

′
3

E′1 Pred
′
C + E

′
3 Pred

′
Q

E′1 Pred
′
C + Pred

′
Q E

′
3

We call these evidence sentences. They ex-
hibit a structure similar to the corresponding
Winograd instance, but with different entities
and event order. Pred′C and Pred

′
Q (resulting

from the queries TermC and TermQ, resp.)
should be similar if not identical to PredC and
PredQ from the Winograd sentence. However,
E′1, E

′
2, and E

′
3 may not have the same semantic

type, potentially simplifying their coreference
resolution. A sentence for which E′3 refers to E

′
1

is subsequently labelled evidence-agent, and one
for which E′3 refers to E

′
2, evidence-patient. The

exception to this rule is when an event occurs
in the passive voice (e.g., was called), which
reverses the conventional order of the agent and
patient. Another exception is in the case of

causative alternation, where a verb can be used
both transitively and intransitively. The latter case
can also reverse the conventional order of the
agent and patient (e.g., he opened the door versus
the door opened).

As an example of coreference simplification,
a valid evidence sentence is: He tried to call
her but she wasn’t available. Here, the sentence
can be resolved on the basis of the gender of
the antecedents; E′3 (the pronoun she) refers to
the patient, E′2. Accordingly, the sentence is
considered an evidence-patient.

3.4 Antecedent Selection

We collect and reason about the set of retrieved
sentences using a selection process that (i) re-
solves E′3 to either E

′
1 or E

′
2 using CoreNLP’s

coreference resolution module (rendering them
evidence-agent or evidence-patient); and (ii) uses
both the count and individual features of the evi-
dence sentences to resolve the original Winograd
instance. For example, the more similar evidence-
agents there are for the sentence Paul tried to call
George on the phone, but he wasn’t successful, the
more likely it is that the process would guess Paul,
the agent, to be the correct referent of the target
pronoun.

To map each sentence to either an evidence-
agent or evidence-patient, we developed a rule-
based algorithm that uses the syntactic parse of
an input sentence. This algorithm outputs an ev-
idence label along with a list of features. The fea-
tures indicate: which two entities co-refer accord-



1954

ing to Stanford CoreNLP’s resolver, and to which
category of E′1, E

′
2, or E

′
3 each belong; the token

length of the sentence’s search terms, TermC and
TermQ; the order of the sentence’s search terms;
whether the sentence is in active or passive voice;
and whether or not the verb is causative alternat-
ing. Some of these features are straightforward to
extract (like token length and order, and corefer-
ring entities given by CoreNLP), while others re-
quire various heuristics. To map each coreferring
entity in the snippet to E′1, E

′
2, or E

′
3 (correspond-

ing loosely to context subject, context object, and
query entity, respectively), we consider their posi-
tion relative to the predicates in the original Wino-
grad instance. That is, E′1 precedes TermC , E

′
2

succeeds TermC , and E′3 may precede or succeed
TermQ depending on the Winograd instance. To
determine the voice, we use a list of auxiliary
verbs and verb phrases (e.g., was, had been, is,
are being) that switch the voice from active to pas-
sive (e.g., “they are being bullied” vs “they bul-
lied”) whenever one of these precedes TermC or
TermQ (if they are verbs). Similarly, to identify
causative alternation, we use a list of causative al-
ternating verbs (e.g., break, open, shut) to identify
the phenomenon whenever TermC or TermQ is
used intransitively.

These features determine the evidence label,
evidence-agent (EA) or evidence-patient (EP), ac-
cording to the following rules:

L(e) =



EA, if E′3 refers to E
′
1, active (1)

EA, if E′3 refers to E
′
2, passive (2)

EP, if E′3 refers to E
′
2, active (3)

EP, if E′3 refers to E
′
1, passive (4)

EP, if E′3 refers to E
′
1, causative (5)

Cases (2), (4), and (5) account for the passive and
causative constructions, which alter the mapping
from syntactic role to semantic role.

In addition to determining the evidence label,
the features are used in a heuristic that generates
scores (called strengths) for each evidence sen-
tence:

Str(e) = LenScore(e) + OrderScore(e)

LenScore(e) =


2, if len(TermQ) > 1
2, if len(TermC) > 1
1, otherwise

OrderScore(e) =

{
2, if TermC ≺ TermQ
1, if TermQ ≺ TermC

As an example of scoring for an actual snip-
pet, let us consider “She tried to call for him
and then search for him herself, but wasn’t suc-
cessful,” returned for TermC=tried to call, and
TermQ=wasn’t successful.

Here, both TermQ and TermC are multi-word
search terms, and TermC precedes TermQ as in
the original Winograd sentence. Its overall ev-
idence strength is 4, the highest possible score.
On the other hand, for the retrieved snippet “Has
your husband tried Sudafed and was it success-
ful?” for TermQ=tried, and TermC=successful,
the evidence strength would be 3. We designed
the scoring system to capture the structural simi-
larity of a snippet to its corresponding Winograd
instance. We observed that a greater quantity of
snippets can be retrieved for less specific search
terms, but with increasing noise; we sought to ac-
count for this with the features described above.
Note also that our use of the word features is inten-
tional. While the weights assigned for the length
and order scores could be optimized, as parame-
ters, we consider it inappropriate to do so on the
WSC since it is widely used as a test set. We set
these weights according to our best guess and val-
idated our choices through experiments on the set
of Winograd-like sentences provided in Rahman
and Ng (2012).

We run the above four processes on all snippets
retrieved for the input Winograd instance. The
sum of strengths for the evidence-agents is finally
compared to that of the evidence-patients to make
the resolution decision.

4 Experiments and Results

We tested several versions of our framework on
the original 273 Winograd sentences (135 pairs
and one triple). These vary in the method of query
generation: automatic vs. automatic with syn-
onyms vs. manual. We compared these systems
with previous work on the basis of Precision (P),
Recall (R), and F1.

We used Stanford CoreNLP’s coreference re-
solver (Raghunathan et al., 2010) during query
generation to identify the predicates from the syn-
tactic parse, as well as during antecedent selec-
tion to retrieve the coreference chain of a candi-



1955

date evidence sentence. Python’s Selenium pack-
age was used for web-scraping and Bing-USA and
Google (top two pages per result) were the search
engines. The search results comprise a list of doc-
ument snippets that contain the queries (for exam-
ple, “yelled at” and “upset”). We extract the sen-
tence/s within each snippet that contain the query
terms, with the added restriction that the terms
should be within 70 characters of each other to en-
courage relevance.

# Correct P R F1
AGQ 77 0.56 0.28 0.38
AGQ+F 80 0.63 0.29 0.40
AGQS 114 0.57 0.42 0.48
AGQS+F 119 0.60 0.44 0.51
S2015 49 0.92 0.18 0.30
Systems with manual information:
L2017 43 0.61 0.15 0.25
MGQ 118 0.60 0.43 0.50

Table 4: Coverage and performance on the
original Winograd Schema Challenge (273

sentences).

Table 4 shows the precision, recall, and F1 of
our framework’s variants: automatically generated
queries (AGQ), automatically generated queries
with synonyms (AGQS), and manually gener-
ated queries (MGQ). We test the automatic sys-
tems with (+F) and without the semantic similar-
ity filter. We compare these to the systems of
Sharma et al. (2015) (S2015) and Liu et al. (2017)
(L2017). The system developed by Liu et al.
(2017) uses elements extracted manually from the
problem instances, so is most closely comparable
to our MGQ method. Our best automated frame-
work, AGQS+F, outperforms S2015 by 0.21 F1,
achieving much higher recall (0.44 vs 0.18). Our
results show that the framework with manually
generated queries (MGQ) performs better than its
automatic counterpart, AGQ, with an F1 of 0.50.
AGQS+F slightly outperforms MGQ despite be-
ing fully automatic.

The power of our approach lies in its general-
ity, i.e., its improved coverage of the problem set.
It produces an answer for over 70% of instances.
This surpasses previous methods, which only ad-
mit specific instance types, by nearly 50%.

The random baseline on this binary task
achieves a P/R/F1 of 0.5. We can artificially raise
the F1 performance of all systems above 0.5 by

randomly guessing an answer in cases where the
system makes no decision. For AGQS+F, for ex-
ample, if we take a random decision on the cases
(74) with no retrieved evidence, we get an accu-
racy of 57.1%. However, we think it is important
that systems are compared transparently based on
which instances they admit and when they are ca-
pable of making a prediction.

5 Error Analysis

To get a sense of the performance of our heuris-
tics in classifying evidence sentences in the an-
tecedent selection step, we manually labelled sen-
tences retrieved by the AGQS system for 40 Wino-
grad instances. The categories are evidence-
agent, evidence-patient, or neither (insufficient ev-
idence). This amounts to a total of 876 evidence
sentences. We compared these labels to those as-
signed by our system. In total, 703 of the 876 evi-
dence sentences were labelled correctly (81%). Of
the 173 incorrect cases, 110 were marked as in-
sufficient evidence. Our system is forced to label
these as agent or patient.

Evidence sentences were insufficient for a va-
riety of reasons. Most frequently, they were
structurally incomplete or grammatically incor-
rect, despite passing as valid through CoreNLP
and our initial coreference heuristics. In general,
our coreference heuristics filter strongly: over all
Winograd instances, they filter a total of 50,110 re-
trieved sentences down to only 3,097 (0.0617 ac-
ceptance rate). As for the 63 cases of sufficient
evidence sentences that were labelled incorrectly,
the issue was either errors in the coreference in-
formation from the CoreNLP pipeline or errors in
our heuristics for reasoning about the coreference
information. We show examples of these various
sources of error in supplementary Table S1. At any
rate, the corrected labels (with the 110 insufficient
evidence removed and the 63 cases corrected) did
not result in a shift in any of the 40 coreference
decisions.

In Table 5, we show a sample resolution that our
system makes on a problem instance,3 including
some evidence that was retrieved and labelled au-
tomatically and the evidence strengths that led to
the resolution. These examples reveal that, indeed,
general knowledge of what is plausible appears in
natural text. Our system successfully leverages
this knowledge for common sense reasoning.

3We provide more examples in a supplementary file.



1956

WSC Instance: The man couldn’t lift his son because he was so weak. Answer: the man (Agent)
Evidence and labels: “However I was so weak that I couldn’t lift” → EA
(query terms in bold) “She was so weak she couldn’t lift” → EA

“I could not stand without falling immediately and I was so weak that I couldn’t lift” → EA
“It hurts to lift my leg and its kind of weak” → EP

Stats and resolution: Agent evidence strength: 97
Patient evidence strength: 72
Number of scraped sentences: 109
Resolution: Agent

Table 5: Example Resolution for a WSC problem.

We also include an example evidence snip-
pet that yields a “misleading” label. Generally,
sources of misleading snippets include incomplete
or imprecise query generation (e.g. in Table 5,
querying only “lift” instead of “couldn’t lift”), er-
rors in the automatic parsing of sentences (e.g., in
supplementary Table S1.1.b, “lift” is incorrectly
labelled as a verb via the parse tree, despite being a
noun), and insufficient filtering of noisy sentences
that are not relevant to the problem instance or are
incomplete (e.g. in supplementary Table S1.2.b,
the sentence is incomplete and indicates a mislead-
ing resolution).

6 Generalization to COPA

To investigate the generality of our knowledge-
hunting approach, we adapted it to the Choice of
Plausible Alternatives (COPA). We evaluated our
basic automatic models that did not use the seman-
tic similarity filter for this check.

COPA has a slightly different form that necessi-
tates some modifications. As an example,

(3) The climbers reached the peak of the
mountain. What happened as a result?
a. They encountered an avalanche.
b. They congratulated each other.

During query generation, as before, the set C con-
tains terms extracted from the context sentence.
Instead of a single set Q as in the WSC, we gener-
ate two query sets Q1 and Q2, that contain terms
extracted for the first and second candidate sen-
tences. Because entities in the candidate sentences
can contribute to the answer (unlike in the WSC),
we modified the query generation rules to extract
more than just predicates. Specifically, the extrac-
tion procedure uses the syntactic parse tree of the
phrase to back-off from extracting the clause con-
taining the subject and verb phrase, to only the
verb phrase, to only the verbs or adjectives that
are rooted in the verb phrase. For the running
example, our system generates these three sets:

C={“The climbers reached the peak”, “reached
the peak”, “reached”}, Q1={“They encountered
an avalanche”, “encountered an avalanche”, “en-
countered”}, and Q2={“They congratulated each
other”, “congratulated each other”, “congratu-
lated”}.

We query the web for sentences that contain
terms in (C,Q1) and (C,Q2), with one added re-
striction: for problem instances in which the rela-
tion is cause, the system only extracts sentences
in which TermC precedes TermQ1 or TermQ2 ;
when the relation is result (as in our running exam-
ple), TermC succeeds TermQ1 or TermQ2 . As
for the WSC, the final decision is determined from
the evidence snippets according to their strengths.

Dev Test
Goodwin et al. (2012) – 63.4
AGQS 64.0 65.1
Gordon et al. (2011) 62.8 65.4
AGQ 65.8 66.24

Luo et al. (2016) – 70.2
Sasaki et al. (2017) – 71.2

Table 6: Model accuracy (%) on COPA.

We tuned the system’s evidence-scoring heuris-
tics on COPA’s 500 validation instances. In Ta-
ble 6, we compare our system’s performance on
the 500 test instances to previous work on the
basis of precision (which in the full-coverage
case equates to accuracy). Our simpler AGQ
method achieves 66.2% accuracy, which is re-
spectable, although not state-of-the-art. As indi-
cated by the lower performance of AGQS, syn-
onyms from WordNet did not improve perfor-
mance on COPA. Without the semantic-similarity
filtering, synonyms may add noise to the re-
trieved results. It has also been shown that multi-
word expressions are prevalent and important for
COPA (Sasaki et al., 2017), which we have not

4This precision can be inflated to 67.2 by randomly guess-
ing on the 10 examples for which there were no search results.



1957

specifically attempted to handle with our method.
We believe that this is a promising direction of im-
provement for our approach in future work.

7 Conclusion

We developed a knowledge-hunting framework to
tackle the Winograd Schema Challenge, a task
that requires common-sense knowledge and rea-
soning. Our system involves a semantic repre-
sentation schema and an antecedent selection pro-
cess that acts on web-search results. We evaluated
the performance of our framework on the original
set of WSC instances, achieving F1-performance
that significantly exceeded the previous state-of-
the-art. A simple port of our approach to COPA
suggests that it has the potential to generalize.
In the future we will study how this common-
sense reasoning technique can contribute to solv-
ing “edge cases” and difficult examples in more
general coreference tasks.

Acknowledgements

This work was supported by the Natural Sciences
and Engineering Research Council of Canada.

References
Dan Bailey, Amelia Harrison, Yuliya Lierler, Vladimir

Lifschitz, and Julian Michael. 2015. The winograd
schema challenge and reasoning about correlation.
In In Working Notes of the Symposium on Logical
Formalizations of Commonsense Reasoning.

Mohit Bansal and Dan Klein. 2012. Coreference se-
mantics from web features. In Proceedings of the
50th Annual Meeting of the Association for Compu-
tational Linguistics: Long Papers-Volume 1, pages
389–398. Association for Computational Linguis-
tics.

David Bender. 2015. Establishing a human baseline for
the winograd schema challenge. In MAICS, pages
39–45.

Kenneth Ward Church and Patrick Hanks. 1990. Word
association norms, mutual information, and lexicog-
raphy. Computational linguistics, 16(1):22–29.

Kathleen Dahlgren, Joyce McDowell, and Edward P
Stabler. 1989. Knowledge representation for com-
monsense reasoning with text. Computational lin-
guistics, 15(3):149–170.

Ali Emami, Adam Trischler, Kaheer Suleman, and
Jackie Chi Kit Cheung. 2018. A generalized knowl-
edge hunting framework for the winograd schema
challenge. In Proceedings of the 2018 Conference of
the North American Chapter of the Association for

Computational Linguistics: Student Research Work-
shop, pages 25–31.

Travis Goodwin, Bryan Rink, Kirk Roberts, and
Sanda M Harabagiu. 2012. Utdhlt: Copacetic sys-
tem for choosing plausible alternatives. In Proceed-
ings of the First Joint Conference on Lexical and
Computational Semantics-Volume 1: Proceedings of
the main conference and the shared task, and Vol-
ume 2: Proceedings of the Sixth International Work-
shop on Semantic Evaluation, pages 461–466. Asso-
ciation for Computational Linguistics.

Andrew S Gordon, Cosmin Adrian Bejan, and Kenji
Sagae. 2011. Commonsense causal reasoning using
millions of personal stories. In AAAI.

Graeme Hirst. 1988. Semantic interpretation and am-
biguity. Artificial intelligence, 34(2):131–177.

Wenguan Huang and Xudong Luo. 2017. Common-
sense reasoning in a deeper way: By discovering re-
lations between predicates. In ICAART (2), pages
407–414.

Adam Kilgarriff. 2000. Wordnet: An electronic lexical
database.

Hamidreza Kobdani, Hinrich Schütze, Michael
Schiehlen, and Hans Kamp. 2011. Bootstrapping
coreference resolution using word associations.
In Proceedings of the 49th Annual Meeting of the
Association for Computational Linguistics: Human
Language Technologies-Volume 1, pages 783–792.
Association for Computational Linguistics.

Tomáš Kočiskỳ, Jonathan Schwarz, Phil Blunsom,
Chris Dyer, Karl Moritz Hermann, Gábor Melis,
and Edward Grefenstette. 2017. The narrativeqa
reading comprehension challenge. arXiv preprint
arXiv:1712.07040.

Canasai Kruengkrai, Naoya Inoue, Jun Sugiura, and
Kentaro Inui. 2014. An example-based approach to
difficult pronoun resolution. In PACLIC, pages 358–
367.

Douglas B Lenat. 1995. Cyc: A large-scale investment
in knowledge infrastructure. Communications of the
ACM, 38(11):33–38.

Hector J Levesque, Ernest Davis, and Leora Morgen-
stern. 2011. The winograd schema challenge. In
AAAI Spring Symposium: Logical Formalizations of
Commonsense Reasoning, volume 46, page 47.

Hugo Liu and Push Singh. 2004. Conceptnet—a prac-
tical commonsense reasoning tool-kit. BT technol-
ogy journal, 22(4):211–226.

Quan Liu, Hui Jiang, Andrew Evdokimov, Zhen-Hua
Ling, Xiaodan Zhu, Si Wei, and Yu Hu. 2016. Prob-
abilistic reasoning via deep learning: Neural associ-
ation models. arXiv preprint arXiv:1603.07704.



1958

Quan Liu, Hui Jiang, Zhen-Hua Ling, Xiaodan Zhul,
Si Wei, and Yu Hu. 2017. Combing context and
commonsense knowledge through neural networks
for solving winograd schema problems.

Zhiyi Luo, Yuchen Sha, Kenny Q Zhu, Seung-won
Hwang, and Zhongyuan Wang. 2016. Common-
sense causal reasoning between short texts. In KR,
pages 421–431.

Christopher Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven Bethard, and David McClosky.
2014. The stanford corenlp natural language pro-
cessing toolkit. In Proceedings of 52nd annual
meeting of the association for computational lin-
guistics: system demonstrations, pages 55–60.

Leora Morgenstern, Ernest Davis, and Charles L Or-
tiz Jr. 2016. Planning, executing, and evaluat-
ing the winograd schema challenge. AI Magazine,
37(1):50–54.

Haoruo Peng, Daniel Khashabi, and Dan Roth. 2015.
Solving hard coreference problems. Urbana,
51:61801.

Karthik Raghunathan, Heeyoung Lee, Sudarshan Ran-
garajan, Nathanael Chambers, Mihai Surdeanu, Dan
Jurafsky, and Christopher Manning. 2010. A multi-
pass sieve for coreference resolution. In Proceed-
ings of the 2010 Conference on Empirical Methods
in Natural Language Processing, pages 492–501.
Association for Computational Linguistics.

Altaf Rahman and Vincent Ng. 2012. Resolving
complex cases of definite pronouns: the winograd
schema challenge. In Proceedings of the 2012 Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning, pages 777–789. Association for
Computational Linguistics.

Lev Ratinov and Dan Roth. 2012. Learning-based
multi-sieve co-reference resolution with knowledge.
In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learn-
ing, pages 1234–1244. Association for Computa-
tional Linguistics.

Melissa Roemmele, Cosmin Adrian Bejan, and An-
drew S Gordon. 2011. Choice of plausible alterna-
tives: An evaluation of commonsense causal reason-
ing. In AAAI Spring Symposium: Logical Formal-
izations of Commonsense Reasoning, pages 90–95.

Shota Sasaki, Sho Takase, Naoya Inoue, Naoaki
Okazaki, and Kentaro Inui. 2017. Handling multi-
word expressions in causality estimation. In IWCS
2017—12th International Conference on Computa-
tional Semantics—Short papers.

Arpit Sharma, Nguyen Ha Vo, Somak Aditya, and
Chitta Baral. 2015. Towards addressing the wino-
grad schema challenge-building and using a seman-
tic parser and a knowledge hunting module. In IJ-
CAI, pages 1319–1325.

Wilson L Taylor. 1953. “cloze procedure”: a new
tool for measuring readability. Journalism Bulletin,
30(4):415–433.

Trieu H Trinh and Quoc V Le. 2018. A simple
method for commonsense reasoning. arXiv preprint
arXiv:1806.02847.

Z Wu and M Palmer. 1994. verb semantics and lexical
selection in proceedings of the 32nd annual meet-
ing of the association for computational linguistics.
New Mexico.

Jiaping Zheng, Luke Vilnis, Sameer Singh, Jinho D
Choi, and Andrew McCallum. 2013. Dynamic
knowledge-base alignment for coreference resolu-
tion. In Proceedings of the Seventeenth Confer-
ence on Computational Natural Language Learning,
pages 153–162.


