



















































Discriminative Unsupervised Alignment of Natural Language Instructions with Corresponding Video Segments


Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 164–174,
Denver, Colorado, May 31 – June 5, 2015. c©2015 Association for Computational Linguistics

Discriminative Unsupervised Alignment of Natural Language Instructions
with Corresponding Video Segments

Iftekhar Naim1, Young Chol Song1, Qiguang Liu1, Liang Huang2,
Henry Kautz1, Jiebo Luo1 and Daniel Gildea1

1Department of Computer Science, University of Rochester, Rochester, NY 14627
2Queens College & Graduate Center, City University of New York, Flushing, NY 11367

Abstract

We address the problem of automatically
aligning natural language sentences with cor-
responding video segments without any direct
supervision. Most existing algorithms for in-
tegrating language with videos rely on hand-
aligned parallel data, where each natural lan-
guage sentence is manually aligned with its
corresponding image or video segment. Re-
cently, fully unsupervised alignment of text
with video has been shown to be feasible us-
ing hierarchical generative models. In contrast
to the previous generative models, we propose
three latent-variable discriminative models for
the unsupervised alignment task. The pro-
posed discriminative models are capable of in-
corporating domain knowledge, by adding di-
verse and overlapping features. The results
show that discriminative models outperform
the generative models in terms of alignment
accuracy.

1 Introduction

Learning to integrate natural language descriptions
with video events is attracting increasing attention
in the natural language processing and computer vi-
sion communities. The Grounded Language Learn-
ing task aims to map the meaning of natural lan-
guage expressions to their corresponding referents
in videos (e.g., objects, actions, and events) with-
out any dictionary. Most existing grounded lan-
guage learning algorithms are either supervised or
weakly-supervised. During the training stage, they
assume each video is pre-segmented to chunks of
short duration, and each video segment is manually

Label the bottle

Add 500 mL of DI 
water to the labeled 
bottle

 Transfer 1 mL of 
MgSO4 to the 
50 mL Falcon tube

Alignment of Video Segments with Text Sentences

Add 500 mL of DI water to the labeled bottle

Verb Nouns

Video Objects Touched by Hands

Figure 1: The proposed discriminative learning algorithm
aligns protocol sentences to corresponding video frames.
We incorporate features that can learn the co-occurrences
of nouns and verbs in the sentences with the objects in
the video.

aligned with a natural language sentence that de-
scribes that segment. Manually aligning each video
segment with a sentence is tedious, especially for
long videos. Therefore, it is desirable to automati-
cally align video segments with their corresponding
natural language sentences without direct supervi-
sion.

Recently, Naim et al. (2014) proposed an unsuper-
vised learning algorithm for automatically aligning
sentences in a document with corresponding video
segments. Given a sequence of natural language
instructions and an unaligned video recording of a
person following these instructions, a hierarchical
generative model was applied to align each instruc-

164



tion to its corresponding video segment, and to align
nouns in each instruction to their corresponding ob-
jects in the video. We extend this generative align-
ment framework by applying several discriminative
models with latent variables. Discriminative mod-
els are attractive as they can easily incorporate do-
main knowledge by adding many diverse, overlap-
ping, and complex features. By incorporating a large
number of features and regularizing their weights
properly, discriminative models have been shown to
outperform generative models in many natural lan-
guage processing tasks (Collins, 2002; Dyer et al.,
2011; Yu et al., 2013).

Similar to Naim et al. (2014), we applied our al-
gorithm to align the natural language instructions
for biological experiments in “wet laboratories” with
recorded videos of people performing these experi-
ments. Typically, each wetlab experiment has a pro-
tocol written in natural language, describing the se-
quence of steps necessary for that experiment. How-
ever, these instructions are often incomplete, and do
not spell out implicit assumptions and knowledge,
causing the results to be difficult to reproduce (Be-
gley and Ellis, 2012). Given a set of such wetlab
experiment protocols and associated videos, our ini-
tial goal is to infer the correct alignment between
the steps mentioned in the protocol and correspond-
ing video segments in which a person performs these
steps (Figure 1). The aligned and segmented out-
put of the system described in this paper can even-
tually be used to learn detailed visual models of cor-
rectly performed activities and to identify experi-
mental anomalies.

In this paper, we apply three latent discriminative
learning algorithms: latent conditional random field
(LCRF), latent structured perceptron (LSP), and la-
tent structured support vector machine (LSSVM) for
unsupervised alignment of video with text. We show
that discriminative models outperform the existing
generative models by incorporating diverse features.
While the previous models only considered the map-
pings of nouns to blobs, and ignored verbs, we in-
corporated the co-occurrences of verbs with blobs
as features in our model. Finally, we propose a con-
strained variant of the standard LSP and LSSVM up-
date rule, which provided better alignment accuracy
and more stable convergence on our datasets.

2 Background Research

2.1 Unsupervised Grounded Language
Learning

Most existing grounded language learning algo-
rithms for integrating language with vision rely
on either a fully supervised (Kollar et al., 2010;
Matuszek et al., 2012) or a weakly supervised
training stage (Yu and Ballard, 2004; Kate and
Mooney, 2007; Krishnamurthy and Kollar, 2013;
Yu and Siskind, 2013; Krishnamoorthy et al., 2013;
Rohrbach et al., 2013; Tellex et al., 2013). The fully
supervised methods assume that each sentence in
the training data is manually paired with the corre-
sponding image or video segment, and furthermore,
each word or phrase in a sentence is already mapped
to its corresponding blob or action in the image
or video segment. Given the detailed annotations,
these methods train a set of classifiers to recog-
nize perceptual representations for commonly used
words or phrases. After the initial fully supervised
training stage, these methods can learn the mean-
ing of new words as they are encountered. Such
detailed supervision is difficult to obtain, and as a
result most of the recent grounded language learn-
ing algorithms rely on weaker supervision (Krish-
namurthy and Kollar, 2013; Yu and Siskind, 2013;
Krishnamoorthy et al., 2013; Rohrbach et al., 2013;
Tellex et al., 2013), where each image or video
frame is manually paired with corresponding sen-
tence, but the mapping between objects and words
is not provided, and instead learned and inferred au-
tomatically as latent variables. Manually pairing
each video segment or image frame with the cor-
responding sentence can be tedious, especially for
long videos. Furthermore, these methods can be rel-
atively difficult to extend to new domains, as this
may require collecting new annotated data.

Recently, Naim et al. (2014) proposed a fully
unsupervised approach for aligning wetlab experi-
ment videos with associated text protocols, with-
out any direct supervision. They proposed a hier-
archical generative model to infer the alignment be-
tween each video segment with corresponding pro-
tocol sentence, and also the mapping of each blob
with corresponding noun in that sentence. First, it
models the generation of each video segment from
one of the sentences in the protocol using a Hidden

165



Markov Model (HMM) (Rabiner, 1989; Vogel et al.,
1996). Next, each tracked object or blob in a video
segment is generated from one of the nouns in the
corresponding sentence using IBM Model 1 (Brown
et al., 1993), a generative model frequently used in
machine translation. The IBM Model 1 probabilities
are incorporated as emission probabilities in HMM.
The transition probabilities are parameterized using
the jump size, i.e., the difference between the align-
ments of two consecutive video segments. They
also extended IBM Model 1 by introducing latent
variables for each noun, allowing some of the non-
object nouns to be unobserved in the video. While
the alignment results are encouraging, and show that
unsupervised alignment is feasible, they considered
the mappings between nouns and blobs only, and ig-
nored the verbs and other relations in the sentences.
Moreover, incorporating domain knowledge is not
straightforward in these generative models.

2.2 Discriminative Word Alignment

In machine translation, alignment of the words in
source language with the words in target language
has traditionally been done using the IBM word
alignment models (Brown et al., 1993), which are
generative models, and typically trained using Ex-
pectation Maximization (Dempster et al., 1977).
Early attempts (Blunsom and Cohn, 2006; Taskar
et al., 2005) towards discriminative word alignment
relied on supervised hand-aligned parallel corpora.
Dyer et al. (2011) first applied a latent variable con-
ditional random field (LCRF) to perform unsuper-
vised discriminative word alignment. They treated
the words’ alignments as latent variables, and for-
mulated the task as predicting the target sentence,
given the source sentence. We apply similar la-
tent variable discriminative models for unsupervised
alignment of sentences with video segments.

3 Problem Formulation and Notations

The input to our system is a dataset containing N
pairs of observations {(xi,yi)}Ni=1, where xi rep-
resents the ith experiment protocol, and yi repre-
sents a video of a person carrying out the instruc-
tions in that protocol. The protocols are not neces-
sarily unique, as we have multiple videos of different
people carrying out the same protocol.

X
i,1

 1 2  2

yi = Yi,1 Yi,2 Yi,3

X
i,2 Xi,3

3

Y
i,4

hi =

xi =

Figure 2: EachXi,m is a sentence in the protocol, consist-
ing of the nouns and verbs in the sentence, and each Yi,n
is a video chunk represented by the set of blobs touched
by hands in that chunk. The alignment hi = [1, 2, 2, 3]
maps each video chunk to the corresponding sentence.

We apply similar data preprocessing as Naim et
al. (2014). First, we parse each protocol sentence
using the two-stage Charniak-Johnson parser (Char-
niak and Johnson, 2005), and extract the head nouns
and verbs from each sentence. Let mi be the num-
ber of sentences in the protocol xi. We represent xi
as a sequence of sets xi = [Xi,1, . . . , Xi,mi ], where
Xi,m is the set of nouns and verbs in the mth sen-
tence of xi. Each video yi is segmented into a se-
quence of chunks, each one second long. For each
video chunk, we determine the set of objects touched
by the participant’s hands using automated image
segmentation and tracking. We ignore the chunks
over which no object is touched by a hand. Let ni be
the number of chunks in yi. We represent the video
yi as a sequence of sets: yi = [Yi,1, . . . , Yi,ni ], one
for each video chunk, where Yi,n is the set of ob-
jects or blobs touched by hands in the nth chunk of
yi. If VY is the set of all blobs in the videos, then
Yi,n ⊆ VY .

Our goal is to learn the alignment hi between
the sentences in xi with their corresponding video
chunks in yi (Figure 2). Formally, hi[n] ∈
{1, . . . ,mi}, for 1 ≤ n ≤ ni, where hi[n] = m
indicates that the video segment Yi,n is aligned to
the protocol sentence Xi,m.

4 Discriminative Alignment

To formulate the alignment problem as a discrim-
inative learning task, we assume the text sequence
xi as the observed input, and the video sequence
yi as the output sequence that we aim to predict.
Since the alignments are unknown, we treat them

166



as latent variables. Let hi be the hidden alignment
vector for an observation pair (xi,yi). The feature
function Φ(xi,yi,hi) maps the input observation
(xi,yi), and their latent alignment vector hi to a d-
dimensional feature vector. Our goal is to learn the
weights w ∈ Rd for these features.
4.1 Latent Variable Conditional Random Field
Given a text sequence xi and a video sequence yi
with lengths |xi| = mi and |yi| = ni, the condi-
tional probability of the video sequence is:

p(yi|xi) = p(yi, ni|xi)
= p(yi|xi, ni) p(ni|xi) (1)

Since we only aim to learn the alignments given
(xi,yi), we ignore the length probability p(ni|xi),
and consider only the first term:

p(yi|xi, ni) =
∑
hi

p(yi,hi|xi, ni) (2)

We model the conditional probability
p(yi,hi|xi, ni) using a log-linear model:

p(yi,hi|xi, ni) = exp w
T Φ(xi,yi,hi)
Z(xi, ni)

, (3)

where Z(xi, ni) =
∑

y

∑
h exp w

T Φ(xi,y,h). To
keep our models tractable, we assume our feature
function Φ decomposes linearly, similar to a linear-
chain graphical model:

Φ(xi,yi,hi) =
ni∑

n=1

φ(Xi,m, Yi,n,m, n,m′),

where hi[n] = m and hi[n − 1] = m′. There-
fore, each factor in our linear chain graph structure
depends on the alignment state for the current and
the previous video chunk. For any two consecutive
alignment states hi[n] = m and hi[n− 1] = m′, we
represent the factor potential as:

Ψ(Xi,m, Yi,n,m, n,m′) =

exp
[
wTφ(Xi,m, Yi,n,m, n,m′)

]
Our goal is to maximize the following log-

likelihood function:

L(w) =
N∑

i=1

log
∑
hi

p(yi,hi|xi, ni). (4)

The gradient of the log-likelihood function with re-
spect to the weight parameters is:

∂L

∂w
=

N∑
i=1

[
Ep(h|xi,ni,yi) [Φ(xi,yi,h)]−

Ep(y,h|xi,ni) [Φ(xi,y,h)]
]

(5)

We apply the stochastic gradient descent algo-
rithm (Vishwanathan et al., 2006) to maximize the
conditional log-likelihood. For each observation
(xi,yi), we perform forward-backward dynamic
programming to estimate the two expectation terms
in equation 5, as discussed next.

4.1.1 Estimation of Ep(h|xi,ni,yi) [Φ(xi,yi,h)]
To estimate the first expectation term in equa-

tion 5, we need to sum over all the possible align-
ment states h[n] = m, where n ∈ {1, . . . , ni} and
m ∈ {1, . . . ,mi}. Since the output sequence yi is
given, we refer to this stage as “forced” forward-
backward stage. The forward messages αFn [m] ∝
p(Yi,1, . . . , Yi,n,h[n] = m | xi) are estimated using
the following recursion:

αFn (m) =
∑
m′

αFn−1(m
′) Ψ(Xi,m, Yi,n,m, n,m′)

wherem′ is one of the predecessors of the alignment
state h[n] = m. Assuming no restrictions on the
possible alignments, the computational complexity
of each iteration on a single observation pair (xi,yi)
isO(m2inid) formi sentences, ni video chunks, and
d dimensional features. However, we allow only a
constant number of predecessor and successor states
for each alignment state, and hence the computa-
tional complexity becomes O(minid). Similarly,
we apply backward recursions, with the same com-
putational complexity.

4.1.2 Estimation of Ep(y,h|xi,ni) [Φ(xi,y,h)]
While computing the second expectation term, we

assume only xi and the number of video chunks
ni are observed, and we need to sum probabilities
over all possible alignments h[n] = m and all pos-
sible video sequences y. Again we apply forward-
backward. The computational complexity, however,
grows significantly, as we need to sum over all pos-
sible set of blobs that may be touched by hands in

167



each video segment. The forward message αn(m)
is computed as:

αn(m) =
∑
m′

αn−1(m′)
∑

Y⊆VY
Ψ(Xim, Y,m, n,m′)

There can be 2|VY | − 1 possible subset of blobs
at each of the alignment position, and the overall
computational complexity becomesO(2|VY |minid),
which is prohibitively expensive, even for a small
number of blobs. In our videos, the hands never
touch more than 3 objects at a time. So we con-
sidered only the non-empty subsets with 3 or less
elements: P = {S : S ⊆ VY , |S| ≤ 3, S 6= ∅}.
The pruning of larger subsets reduces the complex-
ity to O(|VY |3minid). We can further reduce com-
putation by decomposing the forward-backward re-
cursions to the co-occurrence features and alignment
path features:

Ψ(Xim, Y,m, n,m′) = Ψco(Xim, Y )Ψap(m,n,m′)

The potential due to alignment path features (Ψap)
does not depend on the subset of blobs, and only
depends on the current and previous alignment states
h[n] = m and h[n − 1] = m′. On the other hand,
the co-occurrence potential Ψco for a given set of
blobs Y depends only on the sentence that it is being
aligned to, and does not depend on the video chunk
index n. Therefore we can decompose the forward
recursion as:

αn(m) =
∑
m′

αn−1(m′) Ψap(m,n,m′) δ(m)

where δ(m) =
∑

Y ∈P Ψco(Xim, Y ). We can pre-
compute the values of δ(m) for each of the mi sen-
tences, which takes O(mid|VY |3) operations. Fi-
nally, we run forward recursions over all the align-
ment states using the precomputed values, and the
complexity becomes O(mid|VY |3 + minid) Simi-
larly the backward recursion becomes:

βn(m) =
∑
m′

βn+1(m′) Ψap(m′, n+1,m) δ(m′)

The alignment state transition probabili-
ties ξn(m′,m) represents the probability
p(hn−1 = m′,hn = m | xi), which can be
estimated by marginalizing over all possible sets of
blobs:

ξn(m′,m) ∝ αn−1(m′)Ψap(m,n,m′)δ(m)βn(m)

4.2 Latent Variable Structured Perceptron
Structured Perceptron (Collins, 2002) has become a
popular method for discriminative structured learn-
ing due to its relatively fast convergence rate and
theoretical convergence guarantee. Since true align-
ments are unknown, we apply the latent variable
structured perceptron algorithm (Liang et al., 2006;
Sun et al., 2009; Yu et al., 2013) for our discrimina-
tive alignment task.

We iteratively scan through our dataset, one pro-
tocol and video pair (xi,yi) at a time. First, we infer
the best alignment hForcedi for the given observation
pair (xi,yi) and the current weight vector w:

hForcedi = arg max
h

wT Φ(xi,yi,h). (6)

This step is known as Forced Decoding, as we are
given both the protocol sentences and the associated
video chunks. Forced decoding is performed using
Viterbi-like dynamic programming (Algorithm 1),
where the dynamic programming states are the
alignment states (m,n) such that h[n] = m.

Algorithm 1 Perceptron Forced-Decoding
Input: Observation pair (xi, yi) and a weight vector w.

1: mi ← length(xi), and ni ← length(yi),
2: D[m, n]← −∞ for 0 ≤ m ≤ mi and 0 ≤ n ≤ ni
3: D[0, 0]← 0
4: for m = 1 to mi do
5: for n = 1 to ni do
6: for each (m′, n− 1) ∈ Predecessors(m, n) do
7: Φ← create-features(Xi,m, Yi,n, m, n, m′)
8: if D[m′, n− 1] + wT Φ > D[m, n] then
9: D[m, n]← D[m′, n− 1] + wT Φ

10: Backpointers[m, n]← m′
11: hForcedi ← Backtrack(D, Backpointers)
12: Return hForcedi

Next, we decode both the highest scoring align-
ment ĥi and video sequence ŷi, given the protocol
xi and the number of video chunks ni.

ĥi, ŷi = arg max
h,y

wT Φ(xi,y,h) (7)

We refer to this step as Full Decoding (Algorithm 2).
The dynamic programming is similar to that for
forced decoding, except that we need to find the best
set of blobs given a set of nouns, for every protocol
sentence Xi,m:

B[m] = arg max
S∈P

wTcoΦco(Xi,m, S) (8)

168



where P is the pruned set of blobs and
Φco(Xi,m, S) is a vector containing only the
co-occurrence features, and wco contains their
corresponding weights. The detailed algorithm is
described in Algorithm 2. Finally, we update the
weight vector w:

w(new) = w(old)+Φ(xi,yi,hForcedi )−Φ(xi, ŷi, ĥi)

Algorithm 2 Perceptron Full Decoding
Input: Input protocol xi, set of all blobs VY , number of video

chunks ni, weight vector w.
1: mi ← length(xi)
2: D[m, n]← −∞ for 0 ≤ m ≤ mi and 0 ≤ n ≤ ni
3: B[m]← ∅ for 0 ≤ m ≤ mi
4: D[0, 0]← 0
5: P ← {S : S ⊂ VY , |S| ≤ 3, S 6= ∅} // precompute the

pruned list of subsets of blobs
6: for m = 1 to mi do
7: B[m]← arg maxS∈P wTcoΦco(Xi,m, S)
8: for n = 1 to ni do
9: for each (m′, n− 1) ∈ Predecessors(m, n) do

10: Φ← create-features(Xi,m, B[m], m, n, m′)
11: if D[m′, n− 1] + wT Φ > D[m, n] then
12: D[m, n]← D[m′, n− 1] + wT Φ
13: Backpointer[m, n]← m′
14: ĥi ← Backtrack(D, Backpointers)
15: ŷi ← [B[ĥi,1], . . . , B[ĥi,ni ]]
16: Return ĥi, ŷi

4.3 Constrained Decoding
During the full decoding of (ĥi, ŷi), we have no in-
formation regarding how many video chunks to as-
sign to each sentence. As a result, the full decoding
is unlikely to predict the correct video sequence, no
matter how many training iterations performed. In
practice, the unconstrained full decoding often ends
up aligning too many video chunks to one of the pro-
tocol sentences.

To address this problem, we modified the per-
ceptron update rule. Instead of performing uncon-
strained full decoding, we constrain the alignment
ĥi to be same as the forced alignment hForcedi , and
infer the best sequence of video chunks ŷConstri un-
der this constraint:

ŷConstri = arg maxy w
T Φ(xi,y,hForcedi )

We refer to this decoding step as “constrained de-
coding” (Algorithm 3), and refer to this constrained

LSP variant as LSP-C. The modified weight update
rule is:

w(new) = w(old) + Φ(xi,yi,hForcedi )−
Φ(xi, ŷConstri ,h

Forced
i )

Algorithm 3 Perceptron Constrained-Decoding
Input: Input protocol xi, set of all blobs VY , number of video

chunks ni, forced alignment hForcedi , weight vector w.
1: P ← {S : S ⊂ VY , |S| ≤ 3, S 6= ∅}
2: for n = 1 to ni do
3: m← hForcedi [n]
4: Ŷ Constri,n ← arg maxS∈P wTcoΦco(Xi,m, S)
5: Return ŷConstri = [Ŷ

Constr
i,1 , . . . , Ŷ

Constr
i,ni ]

4.4 Latent Structured SVM
Structured SVM can be formulated by extending
structured perceptron with two simple modifica-
tions: (1) incorporating a large-margin regulariza-
tion term, and (2) incorporating a general loss func-
tion, instead of the zero-one loss of perceptron. The
regularization reduces overfitting by keeping feature
weights relatively small. Let the loss-augmented full
decoding be:

(ŷi, ĥi) = arg max
y,h

wT Φ(xi,y,h) + Li(y,h),

where Li(y,h) is the loss function for the ith obser-
vation. LSSVM minimizes the following objective
function:

C(w) =
1
N

N∑
i=1

(
wT Φ(xi, ŷi, ĥi) +Li(ŷi, ĥi)−

wT Φ(xi,yi,hForcedi )
)

+
λ

2
‖w‖2,

which is non-convex and non-differentiable, and op-
timized utilizing the subgradient method (Ratliff et
al., 2007). We perform online learning, and the sub-
gradient in each iteration is:

gi(w) = Φ(xi, ŷi, ĥi)−Φ(xi,yi,hForcedi ) + λw.
Similar to LSP-C, we can obtain a constrained vari-
ant LSSVM-C, by replacing loss-augmented decod-
ing with a constrained variant, where we fix ĥi to
forced alignment hForcedi .

169



4.5 Latent Variables to Map Blobs to Nouns

Given a sentence Xi,n and a video segment Yi,m, we
further introduce additional latent variables to map
each blob in Yi,m to one of the nouns in Xi,n. These
latent variables are similar to the IBM Model 1 la-
tent variables of Naim et al. (2014). Instead of turn-
ing on the (noun, blob) co-occurrence feature for ev-
ery noun and blob in Xi,n and Yi,m, the latent vari-
ables map each blob to one of the nouns only. For
LCRF, we sum over all the latent variables for esti-
mating the expectations. For LSP and LSSVM, the
(noun,blob) feature with maximum feature weight
triggers for each blob.

5 Feature Design

The features used in our discriminative models can
be grouped in two categories: (1) co-occurrence
features, and (2) alignment path features. The co-
occurrence features depend only on a protocol sen-
tence and the video segment it aligns to. The align-
ment path features, on the other hand, do not depend
on the co-occurrence of sentence and video segment,
and instead capture general alignment properties,
e.g., jump size and the distance of an alignment state
from the diagonal.

5.1 Co-occurrence Features

The co-occurrence features included in our experi-
ments are:

• Co-occurrence of Nouns and Blobs: For each
noun in the input protocols and each blob in the
videos, we add a boolean feature (noun, blob),
which is turned on if we align a sentence con-
taining that noun with a video segment contain-
ing that blob.

• Co-occurrence of Verbs and Blobs: For each
verb in the input protocols and each blob in
the videos, we add a boolean feature. This fea-
ture captures the observation that certain verbs
are more likely to occur with certain objects
(e.g., ‘write’ co-occurs with ‘pen’, ‘aspirate’
co-occurs with ‘pipette’).

We experimented with co-occurrence features of
the form: (noun, verb, blob) triplets. However, in-
cluding these features did not provide any noticeable

gain, while significantly increasing the computation
time, as the number of features increased drastically.
Therefore, we did not include these features in our
final experiments.

5.2 Alignment Path Features
Alignment path features depend on the current align-
ment state h[n] = m, and the previous alignment
states h[n− 1] = m′. These features do not depend
on the nouns and verbs in the sentences and the blobs
in the video segments. We used the following align-
ment path features:

• Jump Size: Since we allow monotonic jumps
only, the jump sizes can be either zero or one.
Therefore, we added two features for these two
jump sizes.

• Positional Features: we added positional fea-
tures (Dyer et al., 2011) to discourage align-
ment states that are too far from the diago-
nal. For each alignment state (m,n), we es-
timate normalized distance from the diagonal
as | mmi − nni |. Again we used boolean features
by assigning this normalized distance to five
equally spaced bins.

The alignment features are not updated by the LSP-
C and LSSVM-C methods, as they assume hForcedi
and ĥi to be identical.

6 Results

Our dataset contains 12 wetlab experiment videos,
for 3 different protocols (4 videos per protocol).
Each protocol contains natural language instructions
for an actual biological experiment. On average,
each protocol has 9 steps, and 24 sentences. The
videos are recorded using an RGB-D Kinect camera,
in a mock wetlab setup. The average video length is
∼ 5 minutes. There are 34 unique nouns and 25
unique verbs in the protocols, and 22 distinct blobs
in the videos.

We follow the same data pre-processing technique
as described by Naim et al. (2014). The num-
ber of blobs is assumed to be known apriori. We
oversegment each frame into many superpixels us-
ing the SLIC Superpixels algorithm (Achanta et al.,
2012). We combine multiple adjacent superpixels
into a blob, based on a pre-trained Gaussian mixture

170



Dataset
Average Alignment Accuracy (%)

LHMM LCRF LSP LSP-C LSP-H LSSVM LSSVM-C LSSVM-H
Manual-Tracking 75.58 85.09 79.64 80.68 80.41 79.64 80.68 80.41

Auto-Tracking 64.04 65.59 61.99 63.95 65.27 61.99 63.95 65.27

Table 1: Alignment accuracy (% of video chunks aligned to the correct protocol step) for both manual and automatic
tracking data. LHMM is the existing state-of-the-art generative model. For the variants of latent perceptron (LSP) and
latent structured SVM (LSSVM), “C” indicates constrained decoding, and “H” indicates hybrid update.

color model and their boundary maps (Luo and Guo,
2003), and track each blob using a 3D Kalman filter.
In order to isolate alignment error from computer
vision tracking and segmentation error, we manu-
ally tracked and annotated each of the video seg-
ments with the set of blobs touched by hands us-
ing the video annotation tool Anvil (Kipp, 2012).
The alignment accuracies are reported both for the
manual and automated tracking datasets. Parsing er-
ror is relatively small. The Charniak-Johnson parser
correctly identified the nouns and verbs for most
sentences, except for several single-word imperative
sentences (e.g., Mix.), for which the verbs were mis-
takenly parsed as nouns.

We experimented with the latent CRF (LCRF),
latent perceptron (LSP) and its constrained vari-
ant (LSP-C), and latent SVM (LSSVM) and its
constrained variant (LSSVM-C). Furthermore, we
tried two hybrid variants LSP-H and LSSVM-H,
where we started with constrained decoding, and
later switched to full decoding. We experimented
by incorporating additional latent variables for Blob-
to-Noun mapping (Section 4.5), which significantly
improved alignment accuracy for LCRF, but de-
creased accuracy for LSP and LSSVM and their
variants. We report the best result for each model.
The discriminative algorithms are compared with
the state-of-the-art LHMM model (Naim et al.,
2014), which is a generative HMM with latent vari-
ables for blob-to-noun mapping and the observation
states of each noun.

We initialized the weights for co-occurrence and
jump size features to the log-probabilities learned by
the generative HMM model. All the other features
are initialized to zero. For both LHMM and the
discriminative models, we used monotonic jumps
as they performed better than the non-monotonic
jumps. We used the same learning rate η = 0.001√

t
(where t is the iteration number) for all the discrim-

inative models, and the LSSVM regularization con-
stant λ = 0.001. All the Perceprton and SVM vari-
ants performed “weight averaging” (Collins, 2002).
The number of iterations are set to 100 for all the
algorithms.

Table 1 shows that the discriminative models, es-
pecially LCRF and LSP-H/LSSVM-H, outperform
the generative model LHMM both on the manual-
tracking and auto-tracking datasets. For the manual-
tracking dataset, the difference between LHMM and
each of the discriminative models is statistically sig-
nificant (p-value < 0.0001). On the auto-tracking
dataset, however, the differences are not significant
(p-value > 0.1). Table 2 shows an example of an
alignment obtained by LCRF for a short segment of
a manually tracked video.

The average running time for each iteration per
video is 0.8 seconds for LHMM, 1.1 seconds for
LSP and LSSVM, and 2.5 seconds for LCRF on a
2.9 GHz Intel Core-i7 processor and 8GB RAM.

7 Discussions and Future Work

The results show that discriminative methods out-
perform the generative LHMM model on both the
manual and auto-tracking datasets. We achieved
the best overall accuracy using the LCRF model.
LCRF takes expectations over all possible alignment
states and video sequences. On the other hand, LSP
and LSSVM consider the highest scoring predic-
tion only, which is similar to the hard-decision de-
coding. With no information regarding how many
video segments to align to each sentence, LSP and
LSSVM could not correctly predict the output video
sequences during full decoding, and the weight vec-
tors did not converge. By constraining the alignment
to the forced alignment, we avoid aggressive up-
dates, which may have helped LSP-C and LSSVM-
C to learn better alignments. However, constrained
decoding has a limitation that it can not update align-

171



Start (s) End (s) Blobs in Hands Detected Nouns Detected Verbs Protocol Sentence

40.58 42.58 boat boat, scale place place the plastic boat on the scale .
42.58 42.90 boat scale zero the scale .
42.90 48.48 base spatula, base, boat measure using the spatula , measure 20 g of lb broth base

into the plastic boat .
48.48 58.95 base, spatula spatula, base, boat measure using the spatula , measure 20 g of lb broth base

into the plastic boat .
58.95 65.93 base spatula, base, boat measure using the spatula , measure 20 g of lb broth base

into the plastic boat .
65.93 80.90 boat, bottle base, bottle pour pour the lb broth base into the 1000 ml bottle .
83.80 84.80 water water add add 800 ml of di water .
84.80 88.95 water water, sink use use the di water near the sink .
88.95 96.68 water, bottle water, sink use use the di water near the sink .
96.68 104.67 water mix mix .

108.15 118.12 bottle cap, bottle, water put, shake, mix put a cap on the bottle and shake to mix
the dry ingredients with the water .

Table 2: An example of an alignment, obtained for a part of a manually tracked video. We notice several incorrect
parses, e.g., the verbs “mix” and “zero” were not detected correctly.

ment path features. LCRF sums over all possible
output and latent variables, which includes the cor-
rect solution, and hence constrained decoding is not
necessary. While the latent variables for blob-to-
noun mappings improved the alignment accuracy for
LCRF, it did not improve alignment accuracy for
LSP and LSSVM and their variants, presumably be-
cause of their hard-decision decoding approach.

Among the different variants of LSP and LSSVM,
we obtained the best accuracy with the hybrid vari-
ants (LSP-H and LSSVM-H), where we started with
constrained decoding, and then switched to standard
updates. While these hybird approaches provided
better accuracy, they still suffer from the issue of not
converging. The feature weights learned by LSSVM
and its variants were smaller than that for LSP (due
to regularization). However, they always resulted in
the same forced decoding alignments in our experi-
ments, and obtained same alignment accuracy.

Unlike the previous models, we considered the
co-occurrences of verbs with blobs in the video. The
highest weighted features include: (write, pen), (as-
pirate, pipette), which agree with our intuition. Our
immediate next step will be to automatically learn
a dictionary of hand motion patterns, and consider
the co-occurrence of these patterns with verbs in the
sentences. Some of the objects in our video are small
and thin (e.g., pen, pipette, spatula, plastic boat), and
were not reliably detected by the computer vision
segmentation and tracking system. This may be the
reason why we achieved relatively smaller improve-

ments on the auto-tracking dataset.
Our alignment models are different from the tra-

ditional discriminative approaches in that our cost
function is not same as our evaluation criteria. Al-
though our goal is to improve alignment accuracy,
the objective function that we minimize is either the
negative conditional log-likelihood (LCRF) or the
number of mis-predicted video segments (LSSVM).
Since the ground truth alignments are unknown, we
could not integrate alignment error in our objective
function. The proposed discriminative models out-
perform LHMM despite the fact that the discrimi-
native models are simpler – lacking latent variables
for the observation states of nouns. The alignment
accuracy of the discriminative models is expected to
improve even further once these latent variables are
incorporated.

8 Conclusion

We proposed three discriminative unsupervised
alignment algorithms and their novel variants us-
ing constrained decoding. The proposed algorithms
incorporate overlapping features to capture the co-
occurrences of nouns and verbs with video blobs,
and outperform the state-of-the-art latent HMM
model via discriminative training.

Acknowledgments Funded by NSF IIS-1446996,
ONR N00014-11-10417, Intel ISTCPC, DoD SBIR
N00014-12-C-0263, DARPA FA8750-13-2-0041
(DEFT), NSF IIS-1449278, and a Google Faculty
Research Award.

172



References
R. Achanta, A. Shaji, K. Smith, A. Lucchi, P. Fua, and

Sabine Susstrunk. 2012. SLIC superpixels compared
to state-of-the-art superpixel methods. IEEE Trans-
actions on Pattern Analysis and Machine Intelligence,
34(11):2274–2282.

C. Glenn Begley and Lee M. Ellis. 2012. Drug develop-
ment: Raise standards for preclinical cancer research.
Nature, 483(7391):531–533.

Phil Blunsom and Trevor Cohn. 2006. Discriminative
word alignment with conditional random fields. In
Proceedings of the 21st International Conference on
Computational Linguistics and the 44th Annual Meet-
ing of the Association for Computational Linguistics,
ACL-44, pages 65–72, Stroudsburg, PA, USA. Asso-
ciation for Computational Linguistics.

Peter F. Brown, Stephen A. Della Pietra, Vincent J. Della
Pietra, and Robert L. Mercer. 1993. The mathematics
of statistical machine translation: Parameter estima-
tion. Computational Linguistics, 19(2):263–311.

Eugene Charniak and Mark Johnson. 2005. Coarse-to-
fine n-best parsing and maxent discriminative rerank-
ing. In ACL.

Michael Collins. 2002. Discriminative training meth-
ods for Hidden Markov Models: Theory and experi-
ments with perceptron algorithms. In Proceedings of
the 2002 Conference on Empirical Methods in Natural
Language Processing.

A. P. Dempster, N. M. Laird, and D. B. Rubin. 1977.
Maximum likelihood from incomplete data via the EM
algorithm. Journal of the Royal Statistical Society,
39(1):1–21.

Chris Dyer, Jonathan Clark, Alon Lavie, and Noah A
Smith. 2011. Unsupervised word alignment with ar-
bitrary features. In Proceedings of the 49th Annual
Meeting of the Association for Computational Linguis-
tics: Human Language Technologies-Volume 1, pages
409–419. Association for Computational Linguistics.

Rohit J Kate and Raymond J Mooney. 2007. Learning
language semantics from ambiguous supervision. In
AAAI, volume 7, pages 895–900.

M Kipp. 2012. Anvil: A universal video research tool.
Handbook of Corpus Phonology. Oxford University
Press.

Thomas Kollar, Stefanie Tellex, Deb Roy, and Nicholas
Roy. 2010. Toward understanding natural language
directions. In Human-Robot Interaction (HRI), 2010
5th ACM/IEEE International Conference on, pages
259–266. IEEE.

Niveda Krishnamoorthy, Girish Malkarnenkar, Raymond
Mooney, Kate Saenko, and Sergio Guadarrama. 2013.
Generating natural-language video descriptions using
text-mined knowledge. In Proceedings of the National

Conference on Artificial Intelligence (AAAI-13), vol-
ume 2013, page 3.

Jayant Krishnamurthy and Thomas Kollar. 2013. Jointly
learning to parse and perceive: Connecting natural lan-
guage to the physical world. Transactions of the As-
soc. for Comp. Ling., 10:193–206.

Percy Liang, Alexandre Bouchard-Côté, Dan Klein, and
Ben Taskar. 2006. An end-to-end discriminative ap-
proach to machine translation. In Proceedings of the
21st International Conference on Computational Lin-
guistics and 44th Annual Meeting of the Association
for Computational Linguistics, pages 761–768, Syd-
ney, Australia, July.

Jiebo Luo and Cheng-en Guo. 2003. Perceptual group-
ing of segmented regions in color images. Pattern
Recognition, 36(12):2781 – 2792.

Cynthia Matuszek, Nicholas Fitzgerald, Luke Zettle-
moyer, Liefeng Bo, and Dieter Fox. 2012. A joint
model of language and perception for grounded at-
tribute learning. In Proceedings of the 29th Interna-
tional Conference on Machine Learning (ICML-2012),
pages 1671–1678.

Iftekhar Naim, Young Song, Qiguang Liu, Henry Kautz,
Jiebo Luo, and Daniel Gildea. 2014. Unsupervised
alignment of natural language instructions with video
segments. In Proceedings of Twenty-Eighth AAAI
Conference on Artificial Intelligence.

Lawrence R. Rabiner. 1989. A tutorial on Hidden
Markov Models and selected applications in speech
recognition. Proceedings of the IEEE, 77(2):257–286.

Nathan Ratliff, J. Andrew (Drew) Bagnell, and Martin
Zinkevich. 2007. (Online) subgradient methods for
structured prediction. In Eleventh International Con-
ference on Artificial Intelligence and Statistics (AIS-
tats), March.

M. Rohrbach, Wei Qiu, I. Titov, S. Thater, M. Pinkal, and
B. Schiele. 2013. Translating video content to natu-
ral language descriptions. In 14th IEEE International
Conference on Computer Vision (ICCV), pages 433–
440, Dec.

X. Sun, T. Matsuzaki, D. Okanohara, and J. Tsujii. 2009.
Latent variable perceptron algorithm for structured
classification. In Proceedings of the 21st Interna-
tional Joint Conference on Artificial Intelligence (IJ-
CAI 2009), pages 1236–1242.

Ben Taskar, Simon Lacoste-Julien, and Dan Klein. 2005.
A discriminative matching approach to word align-
ment. In Proceedings of the Conference on Human
Language Technology and Empirical Methods in Nat-
ural Language Processing, HLT ’05, pages 73–80,
Stroudsburg, PA, USA. Association for Computational
Linguistics.

Stefanie Tellex, Pratiksha Thaker, Joshua Joseph, and
Nicholas Roy. 2013. Learning perceptually grounded

173



word meanings from unaligned parallel data. Machine
Learning, pages 1–17.

SVN Vishwanathan, Nicol N Schraudolph, Mark W
Schmidt, and Kevin P Murphy. 2006. Accelerated
training of conditional random fields with stochastic
gradient methods. In Proceedings of the 23rd inter-
national conference on Machine learning, pages 969–
976. ACM.

Stephan Vogel, Hermann Ney, and Christoph Tillmann.
1996. HMM-based word alignment in statistical trans-
lation. In COLING-96, pages 836–841, Copenhagen,
Denmark.

Chen Yu and Dana H Ballard. 2004. On the integration
of grounding language and learning objects. In AAAI,
volume 4, pages 488–493.

Haonan Yu and Jeffrey Mark Siskind. 2013. Grounded
language learning from video described with sen-
tences. In Proceedings of the 51st Annual Meeting of
the Association for Computational Linguistics (ACL-
13), volume 1, pages 53–63.

Heng Yu, Liang Huang, Haitao Mi, and Kai Zhao.
2013. Max-violation perceptron and forced decoding
for scalable MT training. In Conference on Empirical
Methods in Natural Language Processing (EMNLP-
13).

174


