




































Global Transition-based Non-projective Dependency Parsing


Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 2664–2675
Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics

2664

Global Transition-based Non-projective Dependency Parsing

Carlos Gómez-Rodríguez
Universidade da Coruña
carlos.gomez@udc.es

Tianze Shi
Cornell University

tianze@cs.cornell.edu

Lillian Lee
Cornell University
llee@cs.cornell.edu

Abstract

Shi, Huang, and Lee (2017a) obtained
state-of-the-art results for English and
Chinese dependency parsing by com-
bining dynamic-programming implemen-
tations of transition-based dependency
parsers with a minimal set of bidirec-
tional LSTM features. However, their re-
sults were limited to projective parsing.
In this paper, we extend their approach
to support non-projectivity by providing
the first practical implementation of the
MH 4 algorithm, an Opn4q mildly non-
projective dynamic-programming parser
with very high coverage on non-projective
treebanks. To make MH 4 compatible with
minimal transition-based feature sets, we
introduce a transition-based interpretation
of it in which parser items are mapped
to sequences of transitions. We thus ob-
tain the first implementation of global de-
coding for non-projective transition-based
parsing, and demonstrate empirically that
it is more effective than its projective
counterpart in parsing a number of highly
non-projective languages.

1 Introduction

Transition-based dependency parsers are a popu-
lar approach to natural language parsing, as they
achieve good results in terms of accuracy and ef-
ficiency (Yamada and Matsumoto, 2003; Nivre
and Scholz, 2004; Zhang and Nivre, 2011; Chen
and Manning, 2014; Dyer et al., 2015; Andor
et al., 2016; Kiperwasser and Goldberg, 2016).
Until very recently, practical implementations of
transition-based parsing were limited to approx-
imate inference, mainly in the form of greedy
search or beam search. While cubic-time exact in-

ference algorithms for several well-known projec-
tive transition systems had been known since the
work of Huang and Sagae (2010) and Kuhlmann
et al. (2011), they had been considered of theoret-
ical interest only due to their incompatibility with
rich feature models: incorporation of complex fea-
tures resulted in jumps in asymptotic runtime com-
plexity to impractical levels.

However, the recent popularization of bi-
directional long-short term memory networks (bi-
LSTMs; Hochreiter and Schmidhuber, 1997) to
derive feature representations for parsing, given
their capacity to capture long-range information,
has demonstrated that one may not need to use
complex feature models to obtain good accu-
racy (Kiperwasser and Goldberg, 2016; Cross and
Huang, 2016). In this context, Shi et al. (2017a)
presented an implementation of the exact infer-
ence algorithms of Kuhlmann et al. (2011) with
a minimal set of only two bi-LSTM-based feature
vectors. This not only kept the complexity cubic,
but also obtained state-of-the-art results in English
and Chinese parsing.

While their approach provides both accurate
parsing and the flexibility to use any of greedy,
beam, or exact decoding with the same underly-
ing transition systems, it does not support non-
projectivity. Trees with crossing dependencies
make up a significant portion of many treebanks,
going as high as 63% for the Ancient Greek tree-
bank in the Universal Dependencies1 (UD) dataset
version 2.0 and averaging around 12% over all
languages in UD 2.0. In this paper, we ex-
tend Shi et al.’s (2017a) approach to mildly non-
projective parsing in what, to our knowledge, is
the first implementation of exact decoding for a
non-projective transition-based parser.

As in the projective case, a mildly non-

1http://universaldependencies.org/

http://universaldependencies.org/


2665

projective decoder has been known for several
years (Cohen et al., 2011), corresponding to
a variant of the transition-based parser of At-
tardi (2006). However, its Opn7q runtime —
or the Opn6q of a recently introduced improved-
coverage variant (Shi et al., 2018) — is still pro-
hibitively costly in practice. Instead, we seek a
more efficient algorithm to adapt, and thus de-
velop a transition-based interpretation of Gómez-
Rodríguez et al.’s (2011) MH 4 dynamic pro-
gramming parser, which has been shown to pro-
vide very good non-projective coverage in Opn4q
time (Gómez-Rodríguez, 2016). While the MH 4
parser was originally presented as a non-projective
generalization of the dynamic program that later
led to the arc-hybrid transition system (Gómez-
Rodríguez et al., 2008; Kuhlmann et al., 2011), its
own relation to transition-based parsing was not
known. Here, we show that MH 4 can be inter-
preted as exploring a subset of the search space
of a transition-based parser that generalizes the
arc-hybrid system, under a mapping that differs
from the “push computation” paradigm used by
the previously-known dynamic-programming de-
coders for transition systems. This allows us to
extend Shi et al. (2017a)’s work to non-projective
parsing, by implementing MH 4 with a minimal set
of transition-based features.

Experimental results show that our approach
outperforms the projective approach of Shi
et al. (2017a) and maximum-spanning-tree non-
projective parsing on the most highly non-
projective languages in the CoNLL 2017 shared-
task data that have a single treebank. We also
compare with the third-order 1-Endpoint-Crossing
(1EC) parser of Pitler (2014), the only other
practical implementation of an exact mildly non-
projective decoder that we know of, which also
runs in Opn4q but without a transition-based in-
terpretation. We obtain comparable results for
these two algorithms, in spite of the fact that
the MH 4 algorithm is notably simpler than 1EC.
The MH 4 parser remains effective in parsing pro-
jective treebanks, while our baseline parser, the
fully non-projective maximum spanning tree al-
gorithm, falls behind due to its unnecessarily
large search space in parsing these languages.
Our code, including our re-implementation of the
third-order 1EC parser with neural scoring, is
available at https://github.com/tzshi/
mh4-parser-acl18.

....Jack ..Dempseys ..are ..not ..an ..easy ..cichlid ..to ..breed.

compound

.

nsubj

.

cop

.

advmod

.

det

.

amod

.

root

.
mark

.

advcl

Figure 1: A non-projective dependency parse from
the UD 2.0 English treebank.

2 Non-projective Dependency Parsing

In dependency grammar, syntactic structures are
modeled as word-word asymmetrical subordinate
relations among lexical entries (Kübler et al.,
2009). These relations can be represented in a
graph. For a sentence w “ w1, ..., wn, we first de-
fine a corresponding set of nodes t0, 1, 2, ..., nu,
where 0 is an artificial node denoting the root of
the sentence. Dependency relations are encoded
by edges of the form ph,mq, where h is the head
and m the modifier of the bilexical subordinate re-
lation.2

As is conventional, we assume two more prop-
erties on dependency structures. First, each word
has exactly one syntactic head, and second, the
structure is acyclic. As a consequence, the edges
form a directed tree rooted at node 0.

We say that a dependency structure is projec-
tive if it has no crossing edges. While in the
CoNLL and Stanford conversions of the English
Penn Treebank, over 99% of the sentences are pro-
jective (Chen and Manning, 2014) — see Fig. 1 for
a non-projective English example — for other lan-
guages’ treebanks, non-projectivity is a common
occurrence (see Table 3 for some statistics). This
paper is targeted at learning parsers that can han-
dle non-projective dependency trees.

3 MH 4 Deduction System and Its
Underlying Transition System

3.1 The MH 4 Deduction System
The MH 4 parser is the instantiation for k “ 4
of Gómez-Rodríguez et al.’s (2011) more general
MH k parser. MH k stands for “multi-headed with
at most k heads per item”: items in its deduc-
tion system take the form rh1, . . . , hps for p ď k,
indicating the existence of a forest of p depen-
dency subtrees headed by h1, . . . , hp such that
their yields are disjoint and the union of their

2To simplify exposition here, we only consider the unla-
beled case. We use a separately-trained labeling module to
obtain labeled parsing results in §5.

https://github.com/tzshi/mh4-parser-acl18
https://github.com/tzshi/mh4-parser-acl18


2666

Axiom:

r0, 1s
SHIFT:

rh1, . . . , hms
rhm, hm ` 1s

phm ď nq COMBINE:
rh1, . . . , hms rhm, hm`1, . . . , hps

rh1, . . . , hps
pp ď kq

Goal:

r0, n ` 1s
LINK:

rh1, . . . , hms
rh1, . . . , hj´1, hj`1, . . . , hms

hi Ñ hjp1 ď i ď m ^ 1 ă j ă m ^ j ‰ iq

Figure 2: MH k’s deduction steps.

yields is the contiguous substring h1 . . . hp of the
input. Deduction steps, shown in Figure 2, can be
used to join two such forests that have an endpoint
in common via graph union (COMBINE); or to add
a dependency arc to a forest that attaches an inte-
rior head as a dependent of any of the other heads
(LINK).

In the original formulation by Gómez-
Rodríguez et al. (2011), all valid items of the form
ri, i ` 1s are considered to be axioms. In contrast,
we follow Kuhlmann et al.’s (2011) treatment
of MH 3: we consider r0, 1s as the only axiom
and include an extra SHIFT step to generate the
rest of the items of that form. Both formulations
are equivalent, but including this SHIFT rule
facilitates giving the parser a transition-based
interpretation.

Higher values of k provide wider coverage of
non-projective structures at an asymptotic runtime
complexity of Opnkq. When k is at its minimum
value of 3, the parser covers exactly the set of pro-
jective trees, and in fact, it can be seen as a trans-
formation3 of the deduction system described in
Gómez-Rodríguez et al. (2008) that gave rise to
the projective arc-hybrid parser (Kuhlmann et al.,
2011). For k ě 4, the parser covers an increas-
ingly larger set of non-projective structures. While
a simple characterization of these sets has been
lacking4, empirical evaluation on a large number
of treebanks (Gómez-Rodríguez, 2016) has shown
MH k to provide the best known tradeoff between
asymptotic complexity and efficiency for k ą 4.
When k “ 4, its coverage is second only to the
1-Endpoint-Crossing parser of Pitler et al. (2013).
Both parsers fully cover well over 80% of the non-
projective trees observed in the studied treebanks.

3Formally, it is a step refinement; see Gómez-Rodríguez
et al. (2011).

4This is a common issue with parsers based on the general
idea of arcs between non-contiguous heads, such as those de-
riving from Attardi (2006).

3.2 The MH 4 Transition System

Kuhlmann et al. (2011) show how the items of a
variant of MH 3 can be given a transition-based in-
terpretation under the “push computation” frame-
work, yielding the arc-hybrid projective transi-
tion system. However, such a derivation has not
been made for the non-projective case (k ą 3),
and the known techniques used to derive previous
associations between tabular and transition-based
parsers do not seem to be applicable in this case.
The specific issue is that the deduction systems of
Kuhlmann et al. (2011) and Cohen et al. (2011)
have in common that the structure of their deriva-
tions is similar to that of a Dyck (or balanced-
brackets) language, where steps corresponding to
shift transitions are balanced with those corre-
sponding to reduce transitions. This makes it pos-
sible to group derivation subtrees, and the transi-
tion sequences that they yield, into “push compu-
tations” that increase the length of the stack by
a constant amount. However, this does not seem
possible in MH 4.

Instead, we derive a transition-based interpreta-
tion of MH 4 by a generalization of that of MH 3
that departs from push computations.

To do so, we start with the MH 3 interpretation
of an item ri, js given by Kuhlmann et al. (2011).
This item represents a set of computations (tran-
sition sequences) that start from a configuration
of the form pσ, i|β,Aq (where σ is the stack and
i|β is the buffer, with i being the first buffer node)
and take the parser to a configuration of the form
pσ|i, j|β1, Aq. That is, the computation has the net
effect of placing node i on top of the previous con-
tents of the stack, and it ends in a state where the
first buffer element is j.

Under this item semantics, the COMBINE de-
duction step of the MH 3 parser (i.e., the instantia-
tion of the one in Fig. 2 for k “ 3) simply con-
catenates transition sequences. The SHIFT step
generates a sequence with a single arc-hybrid sh



2667

transition:

sh : pσ, hm|β,Aq $ pσ|hm, β, Aq

and the two possible instantiations of the COM-
BINE step when k “ 3 take the antecedent tran-
sition sequence and add a transition to it, namely,
one of the two arc-hybrid reduce transitions. Writ-
ten in the context of the node indexes used in Fig-
ure 2, these are the following:

pσ|h1|h2, h3|β,Aq $ pσ|h1, h3|β,A Y th3 Ñ h2uq
pσ|h1|h2, h3|β,Aq $ pσ|h1, h3|β,A Y th1 Ñ h2uq

where h1 and h3 respectively can be simplified out
to obtain the well-known arc-hybrid transitions:

la : pσ|h2, h3|β,Aq $ pσ, h3|β,A Y th3 Ñ h2uq
ra : pσ|h1|h2, β, Aq $ pσ|h1, β, A Y th1 Ñ h2uq

Now, we assume the following generalization
of the item semantics: an item rh1, . . . , hms
represents a set of computations that start
from a configuration of the form pσ, h1|β,Aq
and lead to a configuration of the form
pσ|h1| . . . |hm´1, hm|β1, Aq. Note that this
generalization no longer follows the “push com-
putation” paradigm of Kuhlmann et al. (2011) and
Cohen et al. (2011) because the number of nodes
pushed onto the stack depends on the value of m.

Under this item semantics, the SHIFT and COM-
BINE steps have the same interpretation as for
MH 3. In the case of the LINK step, following the
same reasoning as for the MH 3 case, we obtain
the following transitions:

la : pσ|h3, h4|β,Aq $ pσ, h4|β,A Y th4 Ñ h3uq
ra : pσ|h2|h3, β, Aq $ pσ|h2, β, A Y th2 Ñ h3uq
la1 : pσ|h2|h3, h4|β,Aq $

pσ|h3, h4|β,A Y th3 Ñ h2uq
ra1 : pσ|h1|h2|h3, β, Aq $

pσ|h1|h3, β, A Y th1 Ñ h2uq
la2 : pσ|h2|h3, h4|β,Aq $

pσ|h3, h4|β,A Y th4 Ñ h2uq
ra2 : pσ|h1|h2|h3, β, Aq $

pσ|h1|h2, β, A Y th1 Ñ h3uq

These transitions give us the MH 4 transition sys-
tem: a parser with four projective reduce tran-
sitions (la,ra,la1,ra1) and two Attardi-like, non-
adjacent-arc reduce transitions (la2 and ra2).

It is worth mentioning that this MH 4 transition
system we have obtained is the same as one of
the variants of Attardi’s algorithm introduced by
Shi et al. (2018), there called ALLs0s1. However,
in that paper they show that it can be tabularized
in Opn6q using the push computation framework.
Here, we have derived it as an interpretation of the
Opn4q MH 4 parser.

However, in this case the dynamic program-
ming algorithm does not cover the full search
space of the transition system: while each item in
the MH 4 parser can be mapped into a computation
of this MH 4 transition-based parser, the opposite
is not true. This tree:

....0 ..1 ..2 ..3 ..4 ..5.....

can be parsed by the transition system using the
computation

shp0q; shp1q; shp2q; la2p3Ñ1q; shp3q; shp4q;
la2p5Ñ3q; shp5q; rap4Ñ5q; rap2Ñ4q; rap0Ñ2q

but it is not covered by the dynamic programming
algorithm, as no deduction sequence will yield an
item representing this transition sequence. As we
will see, this issue will not prevent us from im-
plementing a dynamic-programming parser with
transition-based scoring functions, or from achiev-
ing good practical accuracy.

4 Model

Given the transition-based interpretation of the
MH 4 system, the learning objective becomes to
find a computation that gives the gold-standard
parse. For each sentence w1, . . . , wn, we train
parsers to produce the transition sequence t˚ that
corresponds to the annotated dependency struc-
ture. Thus, the model consists of two components:
a parameterized scorer Sptq, and a decoder that
finds a sequence t̂ as prediction based on the scor-
ing.

As discussed by Shi et al. (2017a), there exists
some tension between rich-feature scoring mod-
els and choices of decoders. Ideally, a globally-
optimal decoder finds the maximum-scoring tran-
sition sequence t̂ without brute-force searching
the exponentially-large output space. To keep the
runtime of our exact decoder at a practical low-
order polynomial, we want its feature set to be



2668

Features ts0,b0u ts1, s0,b0u ts2, s1, s0,b0u

UAS 49.83 85.17 85.27

Table 1: Performance of local parsing models with
varying number of features. We report average
UAS over 10 languages on UD 2.0.

minimal, consulting as few stack and buffer po-
sitions as possible. In what follows, we use s0 and
s1 to denote the top two stack items and b0 and b1
to denote the first two buffer items.

4.1 Scoring and Minimal Features
This section empirically explores the lower limit
on the number of necessary positional features.
We experiment with both local and global de-
coding strategies. The parsers take features ex-
tracted from parser configuration c, and score each
valid transition t with Spt; cq. The local parsers
greedily take transitions with the highest score un-
til termination, while the global parsers use the
scores to find the globally-optimal solutions t̂ “
argmaxt Sptq, where Sptq is the sum of scores
for the component transitions.

Following prior work, we employ bi-LSTMs for
compact feature representation. A bi-LSTM runs
in both directions on the input sentence, and as-
signs a context-sensitive vector encoding to each
token in the sentence: w1, . . . ,wn. When we need
to extract features, say, s0, from a particular stack
or buffer position, say s0, we directly use the bi-
LSTM vector wis0 , where is0 gives the index of
the subroot of s0 into the sentence.

Shi et al. (2017a) showed that feature vectors
ts0,b0u suffice for MH 3. Table 1 and Table 2
show the use of small feature sets for MH 4, for
local and global parsing models, respectively. For
a local parser to exhibit decent performance, we
need at least ts1, s0,b0u, but adding s2 on top of
that does not show any significant impact on the
performance. Interestingly, in the case of global
models, the two-vector feature set ts0,b0u already
suffices. Adding s1 to the global setting (column
“Hybrid” in Table 2) seems attractive, but entails
resolving a technical challenge that we discuss in
the following section.

4.2 Global Decoder
In our transition-system interpretation of MH k, sh
transitions correspond to SHIFT and reduce tran-
sitions reflect the LINK steps. Since the SHIFT

Features ts0,b0u Hybrid

UAS 86.79 87.27

Table 2: Performance of global parsing models
with varying number of features.

conclusions lose the contexts needed to score the
transitions, we set the scores for all SHIFT rules to
zero and delegate the scoring of the sh transitions
to the COMBINE steps, as as in Shi et al. (2017a);
for example,

rh1, h2s : v1 rh2, h3, h4s : v2
rh1, h2, h3, h4s : v1 ` v2 ` Spsh; th1,h2uq

Here the transition sequence denoted by
rh2, h3, h4s starts from a sh, with h1 and
h2 taking the s0 and b0 positions. If we further
wish to access s1, such information is not readily
available in the deduction step, apparently re-
quiring extra bookkeeping that pushes the space
and time complexity to an impractical Opn4q and
Opn5q, respectively. But, consider the scoring for
the reduce transitions in the LINK steps:

rh1, h2, h3, h4s : v
rh1, h2, h4s : v ` Spla; th2,h3,h4uq

rh1, h2, h3s : v
rh1, h3s : v ` Spla; th1,h2,h3uq

The deduction steps already keep indices for s1
(h2 in the first rule, h1 in the second) and thus pro-
vide direct access without any modification. To re-
solve the conflict between including s1 for richer
representations and the unavailability of s1 in scor-
ing the sh transitions in the COMBINE steps, we
propose a hybrid scoring approach — we use fea-
tures ts0,b0u when scoring a sh transition, and
features ts1, s0,b0u for consideration of reduce
transitions. We call this method MH 4-hybrid,
in contrast to MH 4-two, where we simply take
ts0,b0u for scoring all transitions.

4.3 Large-Margin Training

We train the greedy parsers with hinge loss,
and the global parsers with its structured version
(Taskar et al., 2005). The loss function for each
sentence is formally defined as:

max
t̂

`

Sp̂tq ` costpt˚, t̂q ´ Spt˚q
˘



2669

where the margin costpt˚, t̂q counts the number of
mis-attached nodes for taking sequence t̂ instead
of t˚. Minimizing this loss can be thought of as
optimizing for the attachment scores.

The calculation of the above loss function can
be solved as efficiently as the deduction system
if the cost function decomposes into the dynamic
program. We achieve this by replacing the scoring
of each reduce step by its cost-augmented version:

rh1, h2, h3, h4s : v
rh1, h2, h4s : v ` Spla2; th2,h3,h4uq ` ∆

where ∆ “ 1pheadpwh3q ‰ wh4q. This loss
function encourages the model to give higher con-
trast between gold-standard and wrong predic-
tions, yielding better generalization results.

5 Experiments

Data and Evaluation We experiment with the
Universal Dependencies (UD) 2.0 dataset used for
the CoNLL 2017 shared task (Zeman et al., 2017).
We restrict our choice of languages to be those
with only one training treebank, for a better com-
parison with the shared task results.5 Among these
languages, we pick the top 10 most non-projective
languages. Their basic statistics are listed in Ta-
ble 3. For all development-set results, we assume
gold-standard tokenization and sentence delimita-
tion. When comparing to the shared task results
on test sets, we use the provided baseline UDPipe
(Straka et al., 2016) segmentation. Our models do
not use part-of-speech tags or morphological tags
as features, but rather leverage such information
via stack propagation (Zhang and Weiss, 2016),
i.e., we learn to predict them as a secondary train-
ing objective. We report unlabeled attachment F1-
scores (UAS) on the development sets for better
focus on comparing our (unlabeled) parsing mod-
ules. We report its labeled variant (LAS), the main
metric of the shared task, on the test sets. For each
experiment setting, we ran the model with 5 dif-
ferent random initializations, and report the mean
and standard deviation. We detail the implementa-
tion details in the supplementary material.

Baseline Systems For comparison, we include
three baseline systems with the same underlying
feature representations and scoring paradigm. All

5When multiple treebanks are available, one can develop
domain transfer strategies, which is not the focus of this work.

the following baseline systems are trained with the
cost-augmented large-margin loss function.

The MH 3 parser is the projective instantiation
of the MH k parser family. This corresponds to
the global version of the arc-hybrid transition sys-
tem (Kuhlmann et al., 2011). We adopt the mini-
mal feature representation ts0,b0u, following Shi
et al. (2017a). For this model, we also implement
a greedy incremental version.

The edge-factored non-projective maximal
spanning tree (MST) parser allows arbitrary
non-projective structures. This decoding approach
has been shown to be very competitive in parsing
non-projective treebanks (McDonald et al., 2005),
and was deployed in the top-performing system at
the CoNLL 2017 shared task (Dozat et al., 2017).
We score each edge individually, with the features
being the bi-LSTM vectors th,mu, where h is
the head, and m the modifier of the edge.

The crossing-sensitive third-order 1EC parser
provides a hybrid dynamic program for parsing
1-Endpoint-Crossing non-projective dependency
trees with higher-order factorization (Pitler, 2014).
Depending on whether an edge is crossed, we can
access the modifier’s grandparent g, head h, and
sibling si. We take their corresponding bi-LSTM
features tg,h,m, siu for scoring each edge. This
is a re-implementation of Pitler (2014) with neural
scoring functions.

Main Results Table 4 shows the development-
set performance of our models as compared with
baseline systems. MST considers non-projective
structures, and thus enjoys a theoretical advan-
tage over projective MH 3, especially for the
most non-projective languages. However, it has
a vastly larger output space, making the selection
of correct structures difficult. Further, the scoring
is edge-factored, and does not take any structural
contexts into consideration. This tradeoff leads
to the similar performance of MST comparing to
MH 3. In comparison, both 1EC and MH 4 are
mildly non-projective parsing algorithms, limiting
the size of the output space. 1EC includes higher-
order features that look at tree-structural contexts;
MH 4 derives its features from parsing configura-
tions of a transition system, hence leveraging con-
texts within transition sequences. These consider-
ations explain their significant improvements over
MST. We also observe that MH 4 recovers more
short dependencies than 1EC, while 1EC is better
at longer-distance ones.



2670

Language Code # Sent. # Words Sentence Coverage (%) Edge Coverage (%)Proj. Ó MH 4 1EC Proj. MH 4 1EC
Basque eu 5,396 72,974 66.48 91.48 93.29 95.98 99.27 99.42

Urdu ur 4,043 108,690 76.97 95.89 95.77 98.89 99.83 99.81
Gothic got 3,387 35,024 78.42 97.25 97.58 97.04 99.73 99.75

Hungarian hu 910 20,166 79.01 98.35 97.69 98.51 99.92 99.89
Old Church Slavonic cu 4,123 37,432 80.16 98.33 98.74 97.22 99.80 99.85

Danish da 4,383 80,378 80.56 97.70 98.97 98.60 99.87 99.94
Greek el 1,662 41,212 85.98 99.52 99.40 99.32 99.98 99.98
Hindi hi 13,304 281,057 86.16 98.38 98.95 99.26 99.92 99.94

German de 14,118 269,626 87.07 99.19 99.27 99.15 99.95 99.96
Romanian ro 8,043 185,113 88.61 99.42 99.52 99.42 99.97 99.98

Table 3: Statistics of selected training treebanks from Universal Dependencies 2.0 for the CoNLL 2017
shared task (Zeman et al., 2017), sorted by per-sentence projective ratio.

Global Models Greedy Models
Lan. MH 3 MST MH 4-two MH 4-hybrid 1EC MH 3 MH 4

eu 82.07˘0.17 83.61˘0.16 82.94˘0.24 84.13˘0.13 84.09˘0.19 81.27˘0.20 81.71˘0.33
ur 86.89˘0.18 86.78˘0.13 86.84˘0.26 87.06˘0.24 87.11˘0.11 86.40˘0.16 86.05˘0.18

got 83.72˘0.19 84.74˘0.28 83.85˘0.19 84.59˘0.38 84.77˘0.27 82.28˘0.18 81.40˘0.45
hu 83.05˘0.17 82.81˘0.49 83.69˘0.20 84.59˘0.50 83.48˘0.27 81.75˘0.47 80.75˘0.54
cu 86.70˘0.30 88.02˘0.25 87.57˘0.14 88.09˘0.28 88.27˘0.32 86.05˘0.23 86.01˘0.11
da 85.09˘0.16 84.68˘0.36 85.45˘0.43 85.77˘0.39 85.77˘0.16 83.90˘0.24 83.59˘0.06
el 87.82˘0.24 87.27˘0.22 87.77˘0.20 87.83˘0.36 87.95˘0.23 87.14˘0.25 86.95˘0.25
hi 93.75˘0.14 93.91˘0.26 93.99˘0.15 94.27˘0.08 94.24˘0.04 93.44˘0.09 93.02˘0.10
de 86.46˘0.13 86.34˘0.24 86.53˘0.22 86.89˘0.17 86.95˘0.32 84.99˘0.26 85.27˘0.32
ro 89.34˘0.27 88.79˘0.43 89.25˘0.15 89.53˘0.20 89.52˘0.25 88.76˘0.30 87.97˘0.31

Avg. 86.49 86.69 86.79 87.27 87.21 85.60 85.27

Table 4: Experiment results (UAS, %) on the UD 2.0 development set. Bold: best result per language.

In comparison to MH 4-two, the richer feature
representation of MH 4-hybrid helps in all our lan-
guages.

Interestingly, MH 4 and MH 3 react differently
to switching from global to greedy models. MH 4
covers more structures than MH 3, and is naturally
more capable in the global case, even when the
feature functions are the same (MH 4-two). How-
ever, its greedy version is outperformed by MH 3.
We conjecture that this is because MH 4 explores
only the same number of configurations as MH 3,
despite the fact that introducing non-projectivity
expands the search space dramatically.

Comparison with CoNLL Shared Task Results
(Table 5) We compare our models on the test
sets, along with the best single model (#1; Dozat
et al., 2017) and the best ensemble model (#2; Shi
et al., 2017b) from the CoNLL 2017 shared task.
MH 4 outperforms 1EC in 7 out of the 10 lan-
guages. Additionally, we take our non-projective
parsing models (MST, MH 4-hybrid, 1EC) and
combine them into an ensemble. The average re-
sult is competitive with the best CoNLL submis-

sions. Interestingly, Dozat et al. (2017) uses fully
non-projective parsing algorithms (MST), and our
ensemble system sees larger gains in the more
non-projective languages, confirming the potential
benefit of global mildly non-projective parsing.

Results on Projective Languages (Table 6) For
completeness, we also test our models on the
10 most projective languages that have a single
treebank. MH 4 remains the most effective, but
by a much smaller margin. Interestingly, MH 3,
which is strictly projective, matches the perfor-
mance of 1EC; both outperform the fully non-
projective MST by half a point.

6 Related Work

Exact inference for dependency parsing can be
achieved in cubic time if the model is restricted
to projective trees (Eisner, 1996). However, non-
projectivity is needed for natural language parsers
to satisfactorily deal with linguistic phenomena
like topicalization, scrambling and extraposition,
which cause crossing dependencies. In UD 2.0,
68 out of 70 treebanks were reported to contain



2671

Same Model Architecture For Reference
Lan. MH 3 MST MH 4-hybrid 1EC Ensemble CoNLL #1 CoNLL #2

eu 78.17˘0.33 79.90˘0.08 80.22˘0.48 ą 80.17˘0.32 81.55 81.44 79.61
ur 80.91˘0.10 80.05˘0.13 80.69˘0.19 ą 80.59˘0.19 81.37 82.28 81.06

got 67.10˘0.10 67.26˘0.45 67.92˘0.29 ą 67.66˘0.20 69.83 66.82 68.34
hu 76.09˘0.25 75.79˘0.36 76.90˘0.31 ą 76.07˘0.20 79.35 77.56 76.55
cu 71.28˘0.29 72.18˘0.20 72.51˘0.23 ă 72.53˘0.27 74.38 71.84 72.35
da 80.00˘0.15 79.69˘0.24 80.89˘0.17 ą 80.83˘0.27 82.09 82.97 81.55
el 85.89˘0.29 85.48˘0.25 86.28˘0.44 ą 86.07˘0.37 87.06 87.38 86.90
hi 89.88˘0.18 89.93˘0.12 90.22˘0.12 ă 90.28˘0.21 90.78 91.59 90.40
de 76.23˘0.21 75.99˘0.23 76.46˘0.20 ą 76.42˘0.35 77.38 80.71 77.17
ro 83.53˘0.35 82.73˘0.36 83.67˘0.21 ă 83.83˘0.18 84.51 85.92 84.40

Avg. 78.91 78.90 79.57 ą 79.44 80.83 80.85 79.83

Table 5: Evaluation results (LAS, %) on the test set using the CoNLL 2017 shared task setup. The best
results for each language within each block are highlighted in bold.

Same Model Architecture For Reference
Lan. MH 3 MST MH 4-hybrid 1EC Ensemble CoNLL #1 CoNLL #2

ja 74.29˘0.10 73.93˘0.16 74.23˘0.11 74.12˘0.12 74.51 74.72 74.51
zh 63.54˘0.13 62.71˘0.17 63.48˘0.33 63.54˘0.26 64.65 65.88 64.14
pl 86.49˘0.19 85.76˘0.31 86.60˘0.26 86.36˘0.28 87.38 90.32 87.15
he 61.47˘0.24 61.28˘0.24 61.93˘0.22 61.75˘0.22 62.40 63.94 62.33
vi 41.26˘0.39 41.04˘0.19 41.33˘0.32 40.96˘0.36 42.95 42.13 41.68
bg 87.50˘0.20 87.03˘0.17 87.63˘0.17 87.56˘0.14 88.22 89.81 88.39
sk 80.48˘0.22 80.25˘0.32 81.27˘0.14 80.94˘0.25 82.38 86.04 81.75
it 87.90˘0.07 87.26˘0.23 88.06˘0.27 87.98˘0.19 88.74 90.68 89.08
id 77.66˘0.13 76.95˘0.32 77.64˘0.17 77.60˘0.18 78.27 79.19 78.55
lv 69.62˘0.55 69.33˘0.51 70.54˘0.51 69.52˘0.29 72.34 74.01 71.35

Avg. 73.02 72.55 73.27 73.03 74.18 75.67 73.89

Table 6: CoNLL 2017 test set results (LAS, %) on the most projective languages (sorted by projective
ratio; ja (Japanese) is fully projective).

non-projectivity (Wang et al., 2017).

However, exact inference has been shown to be
intractable for models that support arbitrary non-
projectivity, except under strong independence as-
sumptions (McDonald and Satta, 2007). Thus,
exact inference parsers that support unrestricted
non-projectivity are limited to edge-factored mod-
els (McDonald et al., 2005; Dozat et al., 2017).
Alternatives include treebank transformation and
pseudo-projective parsing (Kahane et al., 1998;
Nivre and Nilsson, 2005), approximate infer-
ence (e.g. McDonald and Pereira (2006); At-
tardi (2006); Nivre (2009); Fernández-González
and Gómez-Rodríguez (2017)) or focusing on sets
of dependency trees that allow only restricted
forms of non-projectivity. A number of such
sets, called mildly non-projective classes of trees,
have been identified that both exhibit good em-
pirical coverage of the non-projective phenom-
ena found in natural languages and are known to
have polynomial-time exact parsing algorithms;
see Gómez-Rodríguez (2016) for a survey.

However, most of these algorithms have not
been implemented in practice due to their pro-
hibitive complexity. For example, Corro et al.
(2016) report an implementation of the WG1
parser, a Opn7q mildly non-projective parser in-
troduced in Gómez-Rodríguez et al. (2009), but
it could not be run for real sentences of length
greater than 20. On the other hand, Pitler et al.
(2012) provide an implementation of an Opn5q
parser for a mildly non-projective class of struc-
tures called gap-minding trees, but they need to
resort to aggressive pruning to make it practical,
exploring only a part of the search space in Opn4q
time.

To the best of our knowledge, the only practi-
cal system that actually implements exact infer-
ence for mildly non-projective parsing is the 1-
Endpoint-Crossing (1EC) parser of Pitler (2013;
2014), which runs in Opn4q worst-case time like
the MH 4 algorithm used in this paper. Thus, the
system presented here is the second practical im-
plementation of exact mildly non-projective pars-



2672

ing that has successfully been executed on real
corpora.6

Comparing with Pitler (2014)’s 1EC, our parser
has the following disadvantages: (´1) It has
slightly lower coverage, at least on the treebanks
considered by Gómez-Rodríguez (2016). (´2)
The set of trees covered by MH 4 has not been
characterized with a non-operational definition,
while the set of 1-Endpoint-Crossing trees can be
simply defined.

However, it also has the following advantages:
(+1) It can be given a transition-based interpre-
tation, allowing us to use transition-based scor-
ing functions and to implement the analogous al-
gorithm with greedy or beam search apart from
exact inference. No transition-based interpreta-
tion is known for 1EC. While a transition-based
algorithm has been defined for a strict subset of
1-Endpoint-Crossing trees, called 2-Crossing In-
terval trees (Pitler and McDonald, 2015), this is
a separate algorithm with no known mapping or
relation to 1EC or any other dynamic program-
ming model. Thus, we provide the first exact in-
ference algorithm for a non-projective transition-
based parser with practical complexity. (+2) It is
conceptually much simpler, with one kind of item
and two deduction steps, while the 1-Endpoint-
Crossing parser has five classes of items and sev-
eral dozen distinct deduction steps. It is also a
purely bottom-up parser, whereas the 1-Endpoint-
Crossing parser does not have the bottom-up prop-
erty. This property is necessary for models that
involve compositional representations of subtrees
(Dyer et al., 2015), and facilitates parallelization
and partial parsing. (+3) It can be easily gener-
alized to MH k for k ą 4, providing higher cov-
erage, with time complexity Opnkq. Out of the
mildly non-projective parsers studied in Gómez-
Rodríguez (2016), MH 4 provides the maximum
coverage with respect to its complexity for k ą 4.
(+4) As shown in §5, MH 4 obtains slightly higher
accuracy than 1EC on average, albeit not by a con-
clusive margin.

It is worth noting that 1EC has recently been ex-

6Corro et al. (2016) describe a parser that enforces mildly
non-projective constraints (bounded block degree and well-
nestedness), but it is an arc-factored model, so it is subject
to the same strong independence assumptions as maximum-
spanning-tree parsers like McDonald et al. (2005) and does
not support the greater flexibility in scoring that is the main
advantage of mildly non-projective parsers over these. In-
stead, mild non-projectivity is exclusively used as a criterion
to discard nonconforming trees.

tended to graph parsing by Kurtz and Kuhlmann
(2017), Kummerfeld and Klein (2017), and Cao
et al. (2017a,b), with the latter providing a prac-
tical implementation of a parser for 1-Endpoint-
Crossing, pagenumber-2 graphs.

7 Conclusion

We have extended the parsing architecture of Shi
et al. (2017a) to non-projective dependency pars-
ing by implementing the MH 4 parser, a mildly
non-projective Opn4q chart parsing algorithm, us-
ing a minimal set of transition-based bi-LSTM
features. For this purpose, we have estab-
lished a mapping between MH 4 items and tran-
sition sequences of an underlying non-projective
transition-based parser.

To our knowledge, this is the first practical im-
plementation of exact inference for non-projective
transition-based parsing. Empirical results on a
collection of highly non-projective datasets from
Universal Dependencies show improvements in
accuracy over the projective approach of Shi
et al. (2017a), as well as edge-factored maximum-
spanning-tree parsing. The results are on par with
the 1-Endpoint-Crossing parser of Pitler (2014)
(re-implemented under the same neural frame-
work), but our algorithm is notably simpler and
has additional desirable properties: it is purely
bottom-up, generalizable to higher coverage, and
compatible with transition-based semantics.

Acknowledgments

We thank the three anonymous reviewers for their
helpful comments. CG has received funding
from the European Research Council (ERC), un-
der the European Union’s Horizon 2020 research
and innovation programme (FASTPARSE, grant
agreement No 714150), from the TELEPARES-
UDC project (FFI2014-51978-C2-2-R) and the
ANSWER-ASAP project (TIN2017-85160-C2-1-
R) from MINECO, and from Xunta de Galicia
(ED431B 2017/01). TS and LL were supported in
part by a Google Focused Research Grant to Cor-
nell University. LL was also supported in part by
NSF grant SES-1741441. Any opinions, findings,
and conclusions or recommendations expressed in
this material are those of the author(s) and do not
necessarily reflect the views of the National Sci-
ence Foundation or other sponsors.



2673

References
Daniel Andor, Chris Alberti, David Weiss, Aliaksei

Severyn, Alessandro Presta, Kuzman Ganchev, Slav
Petrov, and Michael Collins. 2016. Globally nor-
malized transition-based neural networks. In Pro-
ceedings of the 54th Annual Meeting of the Associa-
tion for Computational Linguistics (Volume 1: Long
Papers), pages 2442–2452, Berlin, Germany. Asso-
ciation for Computational Linguistics.

Giuseppe Attardi. 2006. Experiments with a multilan-
guage non-projective dependency parser. In Pro-
ceedings of the Tenth Conference on Computational
Natural Language Learning (CoNLL-X), pages 166–
170, New York City, New York, USA.

Junjie Cao, Sheng Huang, Weiwei Sun, and Xiao-
jun Wan. 2017a. Parsing to 1-endpoint-crossing,
pagenumber-2 graphs. In Proceedings of the 55th
Annual Meeting of the Association for Computa-
tional Linguistics (Volume 1: Long Papers), pages
2110–2120, Vancouver, Canada. Association for
Computational Linguistics.

Junjie Cao, Sheng Huang, Weiwei Sun, and Xiaojun
Wan. 2017b. Quasi-second-order parsing for 1-
endpoint-crossing, pagenumber-2 graphs. In Pro-
ceedings of the 2017 Conference on Empirical Meth-
ods in Natural Language Processing, pages 24–34,
Copenhagen, Denmark. Association for Computa-
tional Linguistics.

Danqi Chen and Christopher D. Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In Proceedings of the Conference on Empiri-
cal Methods in Natural Language Processing, pages
740–750, Doha, Qatar.

Shay B. Cohen, Carlos Gómez-Rodríguez, and Giorgio
Satta. 2011. Exact inference for generative proba-
bilistic non-projective dependency parsing. In Pro-
ceedings of the 2011 Conference on Empirical Meth-
ods in Natural Language Processing (EMNLP),
pages 1234–1245, Edinburgh, Scotland, UK.

Caio Corro, Joseph Le Roux, Mathieu Lacroix, An-
toine Rozenknop, and Roberto Wolfler Calvo. 2016.
Dependency parsing with bounded block degree
and well-nestedness via Lagrangian relaxation and
branch-and-bound. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 355–
366, Berlin, Germany. Association for Computa-
tional Linguistics.

James Cross and Liang Huang. 2016. Incremental
parsing with minimal features using bi-directional
LSTM. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers), pages 32–37.

Timothy Dozat, Peng Qi, and Christopher D. Manning.
2017. Stanford’s graph-based neural dependency
parser at the CoNLL 2017 shared task. In Proceed-
ings of the CoNLL 2017 Shared Task: Multilingual

Parsing from Raw Text to Universal Dependencies,
pages 20–30, Vancouver, Canada. Association for
Computational Linguistics.

Chris Dyer, Miguel Ballesteros, Wang Ling, Austin
Matthews, and Noah A. Smith. 2015. Transition-
based dependency parsing with stack long short-
term memory. In Proceedings of the 53rd Annual
Meeting of the Association for Computational Lin-
guistics and the 7th International Joint Conference
on Natural Language Processing (Volume 1: Long
Papers), pages 334–343.

Jason Eisner. 1996. Three new probabilistic models for
dependency parsing: An exploration. In Proceed-
ings of the 16th International Conference on Com-
putational Linguistics (COLING-96), pages 340–
345, Copenhagen.

Daniel Fernández-González and Carlos Gómez-
Rodríguez. 2017. A full non-monotonic transition
system for unrestricted non-projective parsing. In
Proceedings of the 55th Annual Meeting of the
Association for Computational Linguistics (Volume
1: Long Papers), pages 288–298, Vancouver,
Canada. Association for Computational Linguistics.

Carlos Gómez-Rodríguez. 2016. Restricted non-
projectivity: Coverage vs. efficiency. Computa-
tional Linguistics, 42(4):809–817.

Carlos Gómez-Rodríguez, John Carroll, and David
Weir. 2008. A deductive approach to dependency
parsing. In Proceedings of the 46th Annual Meet-
ing of the Association for Computational Linguis-
tics: Human Language Technology, pages 968–976.

Carlos Gómez-Rodríguez, John Carroll, and David
Weir. 2011. Dependency parsing schemata and
mildly non-projective dependency parsing. Compu-
tational Linguistics, 37(3):541–586.

Carlos Gómez-Rodríguez, David Weir, and John Car-
roll. 2009. Parsing mildly non-projective depen-
dency structures. In Proceedings of the 12th Con-
ference of the European Chapter of the ACL (EACL
2009), pages 291–299, Athens, Greece. Association
for Computational Linguistics.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Liang Huang and Kenji Sagae. 2010. Dynamic pro-
gramming for linear-time incremental parsing. In
Proceedings of the 48th Annual Meeting of the Asso-
ciation for Computational Linguistics (ACL), pages
1077–1086, Uppsala, Sweden.

Sylvain Kahane, Alexis Nasr, and Owen Rambow.
1998. Pseudo-projectivity: A polynomially parsable
non-projective dependency grammar. In Proceed-
ings of the 36th Annual Meeting of the Associ-
ation for Computational Linguistics and 17th In-
ternational Conference on Computational Linguis-
tics - Volume 1, pages 646–652, Montreal, Quebec,
Canada. Association for Computational Linguistics.

http://www.aclweb.org/anthology/P16-1231
http://www.aclweb.org/anthology/P16-1231
http://www.aclweb.org/anthology/W/W06/W06-2922
http://www.aclweb.org/anthology/W/W06/W06-2922
http://aclweb.org/anthology/P17-1193
http://aclweb.org/anthology/P17-1193
https://www.aclweb.org/anthology/D17-1003
https://www.aclweb.org/anthology/D17-1003
http://www.aclweb.org/anthology/D14-1082
http://www.aclweb.org/anthology/D14-1082
http://www.aclweb.org/anthology/D14-1082
http://www.aclweb.org/anthology/D11-1114
http://www.aclweb.org/anthology/D11-1114
http://www.aclweb.org/anthology/P16-1034
http://www.aclweb.org/anthology/P16-1034
http://www.aclweb.org/anthology/P16-1034
https://doi.org/10.18653/v1/P16-2006
https://doi.org/10.18653/v1/P16-2006
https://doi.org/10.18653/v1/P16-2006
http://www.aclweb.org/anthology/K/K17/K17-3002.pdf
http://www.aclweb.org/anthology/K/K17/K17-3002.pdf
https://doi.org/10.3115/v1/P15-1033
https://doi.org/10.3115/v1/P15-1033
https://doi.org/10.3115/v1/P15-1033
http://cs.jhu.edu/~jason/papers/#eisner-1996-coling
http://cs.jhu.edu/~jason/papers/#eisner-1996-coling
http://aclweb.org/anthology/P17-1027
http://aclweb.org/anthology/P17-1027
https://doi.org/10.1162/COLI_a_00267
https://doi.org/10.1162/COLI_a_00267
http://aclweb.org/anthology/P08-1110
http://aclweb.org/anthology/P08-1110
https://doi.org/10.1162/coli_a_00060
https://doi.org/10.1162/coli_a_00060
http://www.aclweb.org/anthology/E09-1034
http://www.aclweb.org/anthology/E09-1034
http://www.aclweb.org/anthology/P10-1110
http://www.aclweb.org/anthology/P10-1110
https://doi.org/10.3115/980845.980953
https://doi.org/10.3115/980845.980953


2674

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. Transactions
of the Association for Computational Linguistics,
4:313–327.

Sandra Kübler, Ryan McDonald, and Joakim Nivre.
2009. Dependency parsing, volume 2 of Synthesis
Lectures on Human Language Technologies. Mor-
gan & Claypool Publishers.

Marco Kuhlmann, Carlos Gómez-Rodríguez, and Gior-
gio Satta. 2011. Dynamic programming algorithms
for transition-based dependency parsers. In Pro-
ceedings of the 49th Annual Meeting of the Associ-
ation for Computational Linguistics: Human Lan-
guage Technologies (ACL-HLT), pages 673–682,
Portland, Oregon, USA.

Jonathan K. Kummerfeld and Dan Klein. 2017. Pars-
ing with traces: An Opn4q algorithm and a structural
representation. Transactions of the Association for
Computational Linguistics, 5:441–454.

Robin Kurtz and Marco Kuhlmann. 2017. Exploiting
structure in parsing to 1-endpoint-crossing graphs.
In Proceedings of the 15th International Conference
on Parsing Technologies, pages 78–87, Pisa, Italy.
Association for Computational Linguistics.

Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajic. 2005. Non-projective dependency pars-
ing using spanning tree algorithms. In Proceed-
ings of Human Language Technology Conference
and Conference on Empirical Methods in Natural
Language Processing, pages 523–530, Vancouver,
British Columbia, Canada. Association for Compu-
tational Linguistics.

Ryan McDonald and Giorgio Satta. 2007. On the com-
plexity of non-projective data-driven dependency
parsing. In Proceedings of the Tenth International
Conference on Parsing Technologies (IWPT), pages
121–132, Prague, Czech Republic. Association for
Computational Linguistics.

Ryan T. McDonald and Fernando C. N. Pereira. 2006.
Online learning of approximate dependency parsing
algorithms. In Proceedings of the 11th Conference
of the European Chapter of the Association for Com-
putational Linguistics, pages 81–88, Trento, Italy.
Association for Computational Linguistics.

Joakim Nivre. 2009. Non-projective dependency pars-
ing in expected linear time. In Proceedings of the
Joint Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference on
Natural Language Processing of the AFNLP, pages
351–359, Suntec, Singapore. Association for Com-
putational Linguistics.

Joakim Nivre and Jens Nilsson. 2005. Pseudo-
projective dependency parsing. In Proceedings of
the 43rd Annual Meeting of the Association for

Computational Linguistics, pages 99–106, Ann Ar-
bor, Michigan. Association for Computational Lin-
guistics.

Joakim Nivre and Mario Scholz. 2004. Deterministic
dependency parsing of English text. In Proceedings
of the 20th International Conference on Computa-
tional Linguistics, pages 64–70, Geneva, Switzer-
land. COLING.

Emily Pitler. 2014. A crossing-sensitive third-order
factorization for dependency parsing. Transactions
of the Association for Computational Linguistics,
2:41–54.

Emily Pitler, Sampath Kannan, and Mitchell Marcus.
2012. Dynamic programming for higher order pars-
ing of gap-minding trees. In Proceedings of the
2012 Joint Conference on Empirical Methods in
Natural Language Processing and Computational
Natural Language Learning, pages 478–488. Asso-
ciation for Computational Linguistics.

Emily Pitler, Sampath Kannan, and Mitchell Marcus.
2013. Finding optimal 1-endpoint-crossing trees.
Transactions of the Association of Computational
Linguistics, 1:13–24.

Emily Pitler and Ryan McDonald. 2015. A linear-time
transition system for crossing interval trees. In Pro-
ceedings of the 2015 Conference of the North Amer-
ican Chapter of the Association for Computational
Linguistics: Human Language Technologies, pages
662–671, Denver, Colorado. Association for Com-
putational Linguistics.

Tianze Shi, Carlos Gómez-Rodríguez, and Lillian Lee.
2018. Improving coverage and runtime complex-
ity for exact inference in non-projective transition-
based dependency parsers. In Proceedings of the
16th Annual Conference of the North American
Chapter of the Association for Computational Lin-
guistics: Human Language Technologies, page (in
press), New Orleans, Louisiana. Association for
Computational Linguistics.

Tianze Shi, Liang Huang, and Lillian Lee. 2017a.
Fast(er) exact decoding and global training for
transition-based dependency parsing via a minimal
feature set. In Proceedings of the 2017 Conference
on Empirical Methods in Natural Language Pro-
cessing (EMNLP), pages 12–23, Copenhagen, Den-
mark.

Tianze Shi, Felix G. Wu, Xilun Chen, and Yao Cheng.
2017b. Combining global models for parsing Uni-
versal Dependencies. In Proceedings of the CoNLL
2017 Shared Task: Multilingual Parsing from Raw
Text to Universal Dependencies, pages 31–39, Van-
couver, Canada. Association for Computational Lin-
guistics.

Milan Straka, Jan Hajic, and Jana Straková. 2016. UD-
Pipe: Trainable pipeline for processing CoNLL-U
files performing tokenization, morphological anal-
ysis, POS tagging and parsing. In Proceedings

http://aclweb.org/anthology/Q16-1023
http://aclweb.org/anthology/Q16-1023
http://aclweb.org/anthology/Q16-1023
https://doi.org/10.2200/S00169ED1V01Y200901HLT002
http://www.aclweb.org/anthology/P11-1068
http://www.aclweb.org/anthology/P11-1068
https://transacl.org/ojs/index.php/tacl/article/view/1170
https://transacl.org/ojs/index.php/tacl/article/view/1170
https://transacl.org/ojs/index.php/tacl/article/view/1170
http://www.aclweb.org/anthology/W17-6312
http://www.aclweb.org/anthology/W17-6312
http://www.aclweb.org/anthology/H/H05/H05-1066
http://www.aclweb.org/anthology/H/H05/H05-1066
http://www.aclweb.org/anthology/W/W07/W07-2216
http://www.aclweb.org/anthology/W/W07/W07-2216
http://www.aclweb.org/anthology/W/W07/W07-2216
http://aclweb.org/anthology/E/E06/E06-1011.pdf
http://aclweb.org/anthology/E/E06/E06-1011.pdf
http://www.aclweb.org/anthology/P/P09/P09-1040
http://www.aclweb.org/anthology/P/P09/P09-1040
https://doi.org/10.3115/1219840.1219853
https://doi.org/10.3115/1219840.1219853
https://doi.org/10.3115/1220355.1220365
https://doi.org/10.3115/1220355.1220365
https://transacl.org/ojs/index.php/tacl/article/view/193
https://transacl.org/ojs/index.php/tacl/article/view/193
http://www.aclweb.org/anthology/D12-1044
http://www.aclweb.org/anthology/D12-1044
http://www.aclweb.org/anthology/Q13-1002
http://www.aclweb.org/anthology/N15-1068
http://www.aclweb.org/anthology/N15-1068
https://www.aclweb.org/anthology/D17-1002
https://www.aclweb.org/anthology/D17-1002
https://www.aclweb.org/anthology/D17-1002
http://www.aclweb.org/anthology/K/K17/K17-3003.pdf
http://www.aclweb.org/anthology/K/K17/K17-3003.pdf


2675

of the Tenth International Conference on Language
Resources and Evaluation (LREC 2016), Paris,
France. European Language Resources Association
(ELRA).

Ben Taskar, Vassil Chatalbashev, Daphne Koller, and
Carlos Guestrin. 2005. Learning structured predic-
tion models: A large margin approach. In Proceed-
ings of the 22nd International Conference on Ma-
chine Learning, pages 896–903.

Hao Wang, Hai Zhao, and Zhisong Zhang. 2017. A
transition-based system for universal dependency
parsing. In Proceedings of the CoNLL 2017 Shared
Task: Multilingual Parsing from Raw Text to Uni-
versal Dependencies, pages 191–197, Vancouver,
Canada. Association for Computational Linguistics.

Hiroyasu Yamada and Yuji Matsumoto. 2003. Statis-
tical dependency analysis with Support Vector Ma-
chines. In Proceedings of the 8th International
Workshop on Parsing Technologies, pages 195–206.

Daniel Zeman, Martin Popel, Milan Straka, Jan Ha-
jic, Joakim Nivre, Filip Ginter, Juhani Luotolahti,
Sampo Pyysalo, Slav Petrov, Martin Potthast, Fran-
cis Tyers, Elena Badmaeva, Memduh Gokirmak,
Anna Nedoluzhko, Silvie Cinkova, Jan Hajic jr.,
Jaroslava Hlavacova, Václava Kettnerová, Zdenka
Uresova, Jenna Kanerva, Stina Ojala, Anna Mis-
silä, Christopher D. Manning, Sebastian Schuster,
Siva Reddy, Dima Taji, Nizar Habash, Herman Le-
ung, Marie-Catherine de Marneffe, Manuela San-
guinetti, Maria Simi, Hiroshi Kanayama, Valeria de-
Paiva, Kira Droganova, Héctor Martínez Alonso,
Çağrı Çöltekin, Umut Sulubacak, Hans Uszkor-
eit, Vivien Macketanz, Aljoscha Burchardt, Kim
Harris, Katrin Marheinecke, Georg Rehm, Tolga
Kayadelen, Mohammed Attia, Ali Elkahky, Zhuoran
Yu, Emily Pitler, Saran Lertpradit, Michael Mandl,
Jesse Kirchner, Hector Fernandez Alcalde, Jana Str-
nadová, Esha Banerjee, Ruli Manurung, Antonio
Stella, Atsuko Shimada, Sookyoung Kwak, Gustavo
Mendonca, Tatiana Lando, Rattima Nitisaroj, and
Josie Li. 2017. CoNLL 2017 shared task: Multi-
lingual parsing from raw text to Universal Depen-
dencies. In Proceedings of the CoNLL 2017 Shared
Task: Multilingual Parsing from Raw Text to Univer-
sal Dependencies, pages 1–19, Vancouver, Canada.
Association for Computational Linguistics.

Yuan Zhang and David Weiss. 2016. Stack-
propagation: Improved representation learning for
syntax. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers), pages 1557–1566, Berlin,
Germany. Association for Computational Linguis-
tics.

Yue Zhang and Joakim Nivre. 2011. Transition-based
dependency parsing with rich non-local features. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, pages 188–193, Portland, Ore-
gon, USA. Association for Computational Linguis-
tics.

https://doi.org/10.1145/1102351.1102464
https://doi.org/10.1145/1102351.1102464
http://www.aclweb.org/anthology/K17-3020
http://www.aclweb.org/anthology/K17-3020
http://www.aclweb.org/anthology/K17-3020
http://www.aclweb.org/anthology/K/K17/K17-3001.pdf
http://www.aclweb.org/anthology/K/K17/K17-3001.pdf
http://www.aclweb.org/anthology/K/K17/K17-3001.pdf
http://www.aclweb.org/anthology/P16-1147
http://www.aclweb.org/anthology/P16-1147
http://www.aclweb.org/anthology/P16-1147
http://www.aclweb.org/anthology/P11-2033
http://www.aclweb.org/anthology/P11-2033

