



















































Transition-based dependency parsing as latent-variable constituent parsing


Proceedings of the ACL Workshop on Statistical NLP and Weighted Automata, pages 21–31,
Berlin, Germany, August 12, 2016. c©2016 Association for Computational Linguistics

Transition-based dependency parsing as
latent-variable constituent parsing

Mark-Jan Nederhof
School of Computer Science

University of St Andrews, UK

Abstract

We provide a theoretical argument that
a common form of projective transition-
based dependency parsing is less powerful
than constituent parsing using latent vari-
ables. The argument is a proof that, under
reasonable assumptions, a transition-based
dependency parser can be converted to a
latent-variable context-free grammar pro-
ducing equivalent structures.

1 Introduction

Over the last decade, transition-based dependency
parsers have received much attention, to a large
extent due to Nivre (2003), Nivre and Scholz
(2004), Nivre et al. (2004) and following publica-
tions. The theory represented in these publications
seems to differ significantly from traditional au-
tomata theory, on which the theory of constituent
parsing is based. Differences lie in notation, in
terminology and in the overall conceptual frame-
work.

An explanation for this cannot immediately be
found by contrasting the foundations of depen-
dency parsing and constituent parsing. Some
of the earliest literature on dependency parsing
(Hays, 1964; Gaifman, 1965) discusses the two
kinds of parsing on an equal footing. Also more
recent literature (Carroll and Charniak, 1992;
Klein and Manning, 2004) discusses dependency
parsing as closely related to constituent parsing.
The concept of bilexical context-free grammars
(Eisner and Satta, 1999) establishes further ex-
plicit connections between phrase-structure gram-
mar and dependency grammar. See also Rambow
(2010) for a discussion about the relation between
constituent and dependency structures.

One advantage of dependency grammar is the
ease with which the definition of parse struc-

tures can be generalized from the projective case
to the non-projective case, but also this cannot
explain the divergence from the theory of con-
stituent parsing, as much the same style is used
for describing projective dependency parsing and
for non-projective dependency parsing; cf. Nivre
(2009) for the latter. Furthermore, discontinu-
ity has also been explored for constituent parsing
(Kallmeyer and Maier, 2010; van Cranenburgh et
al., 2011). Close links between discontinuous con-
stituent parsing and non-projective dependency
parsing follow from the work of, among others,
Kallmeyer and Kuhlmann (2012) and Kuhlmann
(2013).

Recent literature on dependency parsing has a
strong emphasis on parsing speed. Often, pars-
ing algorithms are close to linear-time, or close
to quadratic-time in the worst case (Covington,
2001). However, there is also a considerable body
of literature on speeding up constituent parsing
(Lavie and Tomita, 1993; Goodman, 1997; Cara-
ballo and Charniak, 1998). Deterministic parsing
algorithms for constituent parsing were proposed
by e.g. Wong and Wu (1999), Kalt (2004), Sagae
and Lavie (2005) and Nederhof and McCaffery
(2014), while the parser of Ratnaparkhi (1997) is
close to linear time; for deterministic chunk pars-
ing, see Tsuruoka and Tsujii (2005). Seneff (1989)
suggests that deterministic constituent parsing was
more or less the norm at the end of the 1980s.
Conversely, transition-based dependency parsing
has been generalized to non-deterministic parsing
(Kuhlmann et al., 2011; Huang and Sagae, 2010).

An empirical connection between constituent
parsing and dependency parsing has been es-
tablished by several investigations of conversion
between constituent structures and dependency
structures. Transformation from constituent struc-
tures to dependency structures is addressed by Lin
(1998), Collins (2003), Yamada and Matsumoto

21



(2003) and Hall and Novák (2005). Dependency
parsers have been used to perform constituent
parsing (Ma et al., 2010). Transformations from
unlabeled dependency structures to constituent
structures were discussed by Johnson (2007), and
transformations from labeled dependency struc-
tures were discussed by Miyao et al. (2008). It
has been observed that constituent parsers used to
perform dependency parsing can be at least as ac-
curate as dedicated dependency parsers, although
they are generally slower (Cer et al., 2010; Can-
dito et al., 2010).

The present article aims to elucidate part of the
relation between the theory of transition-based de-
pendency parsing and the theory of constituent
parsing. We will focus on a particular form of
constituent parsing that is based on latent-variable
probabilistic context-free grammars, which cur-
rently offers state-of-the-art accuracy. One ap-
parent complication is that there are competing
ways of obtaining such grammars, roughly di-
vided into forms of EM training (Matsuzaki et al.,
2005; Petrov et al., 2006) or of spectral learn-
ing (Narayan and Cohen, 2015). We circum-
vent this complication by looking at the general
class of non-probabilistic latent-variable context-
free grammars, and show that these have suf-
ficient formal power to subsume deterministic
transition-based dependency parsing. The impli-
cation is that latent-variable probabilistic context-
free grammars, obtained through EM training,
spectral learning, or any other method still to be
developed, have the potential to be at least as accu-
rate as deterministic transition-based dependency
parsing.

This paper intentionally limits the scope to pro-
jective parsing. The reason is that the literature on
non-projectivity (discontinuity) has not yet con-
verged, and new approaches are discovered with
some regularity. This makes it hard to offer formal
evidence that non-projective dependency parsing
can generally be realized via discontinuous con-
stituent parsing. At best, one can highlight one or
two typical implementations of dependency pars-
ing and constituent parsing and argue that the
mechanisms for dealing with non-projectivity are
comparable in nature, awaiting precise arguments
relating their formal power.

One well-established approach to dealing with
non-projective dependency structure is commonly
referred to as pseudo-projectivity (Kahane et al.,

1998; Nivre and Nilsson, 2005). The idea is that
a first phase of projective parsing is followed by
a lifting operation that rearranges edges to make
them cross one another. A related idea for discon-
tinuous constituent parsing is the reversible split-
ting conversion of Boyd (2007).

A related but different approach is due to Nivre
(2009). Here, the usual one-way input tape is re-
placed by a buffer. A non-topmost element from
the parsing stack, which holds a word previously
read from the input sentence, can be transferred
back to the buffer, and thereby input positions can
be effectively swapped, and non-projective struc-
tures result. We see no reason why the same idea
would not equally well apply to constituent pars-
ing.

This paper has the following structure. After
fixing notation in Section 2, we present a for-
mal model of deterministic parsing in Section 3,
in terms of oracle automata. These automata ap-
pear at first sight to be biased towards constituent
parsing, but Section 4 shows that they allow a
clean formalization of arc-standard and arc-eager
transition-based dependency parsing. It is shown
in Section 5 that oracle automata can, under rea-
sonable assumptions, be transformed into latent-
variable context-free grammars. Section 6 further
explores these assumptions as relating to common
implementations of transition-based dependency
parsing. As shown in Section 7, the results carry
over to probabilistic automata and grammars.

2 Preliminaries

In this paper, a tree refers to a term built of leaf
symbols, from the alphabet Σleaf , and internal
symbols, from the alphabet Σintern . A symbol
a ∈ Σleaf by itself is a tree, and if A ∈ Σintern
and t1, . . . , tk are trees, then A(t1 · · · tk) is a tree.
(In this paper, we assume the number k of chil-
dren of an internal node is non-zero.) The set of
all trees with given alphabets Σleaf and Σintern
is denoted by T (Σleaf ,Σintern). We will use the
symbol t for trees and symbol τ for sequences
of trees. The empty sequence is denoted by ε.
We define the root of a tree by root(a) = a and
root(A(t1 · · · tk)) = A. We define the yield of a
tree by yield(a) = a and yield(A(t1 · · · tk)) =
yield(t1) · · · yield(tk). We define first(aw) = a
and last(wa) = a, for a ∈ Σleaf and w ∈ Σ∗leaf ,
first(ε) and last(ε) are undefined, and first(t) =
first(yield(t)) and last(t) = last(yield(t)) for

22



t ∈ T (Σleaf ,Σintern).
As usual, a context-free grammar (CFG) is rep-

resented by a 4-tuple (Σ, N, S, R), where Σ and
N are two disjoint finite sets of terminals and non-
terminals, respectively, S ∈ N is the start symbol,
and R is a finite set of rules, each of the form
A → α, where A ∈ N and α ∈ (Σ ∪ N)∗.
By grammar symbol we mean a terminal or non-
terminal. We use symbols A,B,C, . . . for non-
terminals, a, b, c, . . . for terminals, v, w, x, . . . for
strings of terminals, and α, β, γ, . . . for strings of
grammar symbols. To simplify the discussion we
will assume that all rules are of the form A →
B1 · · ·Bk, where k ≥ 1, or of the form A → a.
We also assume that S does not occur in the right-
hand side of any rule.

A latent-variable CFG (L-CFG) differs from
a CFG in that each nonterminal, except the start
symbol S†, is of the composite form A(`), where
A is a surface symbol and ` is a latent symbol.
We denote the set of latent symbols by L, the set
of surface symbols by N and the set of composite
nonterminals by NL. A L-CFG has one or more
rules of the form S† → S(`), some ` ∈ L.

The intuition behind L-CFG is that the surface
symbols are those that occur in parse trees used to
represent syntactic structure, these being trees in
T (Σ, N), while the purpose of the latent symbols
is to restrict derivations and help define probability
distributions over parse trees, once we extend rules
with probabilities.

L-CFGs are intimately related to regular tree
grammars (Brainerd, 1969; Gécseg and Steinby,
1997), which is apparent from the definition of
their ‘derives’ relation. Fix a L-CFG G. For
t, t′ ∈ T (Σ ∪ NL, N), we let t ⇒G t′ if t′ re-
sults from t by replacing some occurrence of A(`)

by A(α), for some rule A(`) → α. A parse tree of
G is a tree t ∈ T (Σ, N) such that S(`) ⇒∗G t, for
some `.

A canonical L-CFG is formed from a CFG by
having a singleton set L = {`}, enhancing each
nonterminal occurrence with an additional super-
script (`), and adding rule S† → S(`). The parse
trees of this canonical L-CFG concur with the
standard definition of parse tree of a CFG. The set
of all parse trees is called the tree language of a
CFG or L-CFG.

It is often convenient to distinguish a subset
of the composite nonterminals as not producing
any surface symbols in parse trees. For exam-

ple, if we binarize a long rule A → B C D
from a CFG into two rules A(`A) → E(`E) D(`D)
and E(`E) → B(`B)C(`C) of a L-CFG, then we
may wish to mark E(`E) as not producing any
trace in the parse tree. In terms of the derives
relation, this means A(`A) ⇒G A(E(`E)D(`D))
⇒G A(B(`B)C(`C)D(`D)), etc. The same princi-
ple may be used to avoid spurious ambiguity in
the representation of dependency structures using
bilexical context-free grammars (Section 4).

3 Oracle automata

We define an oracle automaton as a variant of a
traditional shift-reduce parser, in which an oracle
uniquely determines the next parser action. The
oracle is a partial function Ω that maps a sequence
of trees (the current content of the stack, see be-
low) and a terminal (the lookahead) to a rule that
is to be applied next. It is constrained by:

1. if Ω(τ, a) = (A→ b), then a = b; and
2. if Ω(τ, a) = (A → B1 · · ·Bk), then τ can

be written as τ ′t1 · · · tk, where root(ti) = Bi
for each i (1 ≤ i ≤ k).

The first constraint says that reduction of terminal
b to nonterminalA should only be suggested if that
terminal is the lookahead. The second constraint
says that reduction by a rule with right-hand side
of length k should only be suggested if the roots
of the top-most k subtrees on the stack match the
right-hand side of that rule.

For CFG G and oracle Ω, the oracle automaton
Mmanipulates configurations of the form (τ, v$),
where τ is the stack, and v is the remaining in-
put. The symbol $ is the end-of-sentence marker,
which we will need for technical reasons. For
given input w, the initial configuration is (ε, w$).
The allowable steps are:

shift (τ, av$) `M (τA(a), v$), if Ω(τ, a) =
(A→ a); and

reduce (τt1 · · · tk, v$) `M (τA(t1 · · · tk), v$) if
Ω(τt1 · · · tk,first(v$)) = (A→ B1 · · ·Bk).

If a configuration is (τ, av$) and Ω(τ, a) is un-
defined, then parsing fails. Acceptance hap-
pens upon reaching a configuration (t, $) with
root(t) = S. By a computation we mean a se-
quence (τ, vw$) `∗M (τ ′, w$) of zero or more
steps.

23



It is easy to see that if (ε, w$) `∗M (t, $)
then yield(t) = w. The set of all t such that
(ε, w$) `∗M (t, $) and root(t) = S is the tree
language of M, and is a subset of the tree lan-
guage of G. This may be a strict subset. In par-
ticular, if t is a parse tree of G and w = yield(t),
then there is at most one computation of the form
(ε, w$) `∗M (t′, $), for some t′ with root(t′) = S,
but t′ may or may not be equal to t, depending on
the definition of Ω.

In practice, the value Ω(τ, a) is not an arbitrary
function of τ and a. It will typically depend on
only a bounded number of features that can be ex-
tracted from τ . As τ becomes longer and as trees
in τ become deeper, through application of reduc-
tions, more and more details of these trees will be
outside the reach of these features. This obser-
vation is formalized through the notion of a stack
congruence ≡st , which is an equivalence relation
on stacks, with additional constraints. These addi-
tional constraints are to capture the intuition that
once details of a stack have become irrelevant to
the features, they remain so. It was inspired by
Pereira and Wright (1997).

In order to define ≡st , we also need a tree con-
gruence ≡tr , which is an equivalence relation on
trees, again with an additional constraint. This
constraint on ≡tr says that if t1 ≡tr t′1, . . . ,
tk ≡tr t′k, then A(t1 · · · tk) ≡tr A(t′1 · · · t′k) for
eachA. The intuition is that once we have decided
that some aspects of trees t1, . . . tk are no longer
useful for the oracle, this remains so when these
trees become part of a deeper tree, by adding A as
root.

The constraint on ≡st now says that if τ ≡st τ ′
and t ≡tr t′ then also τt ≡st τ ′t′. We fur-
ther say that ≡st is consistent with oracle Ω if
τ ≡st τ ′ implies Ω(τ, a) = Ω(τ ′, a) for every
a. The equivalence class of tree t is denoted by
[t]≡tr = {t′ | t′ ≡tr t}, or simply [t]. Similarly, the
equivalence class of stack τ is denoted by [τ ]≡st
or [τ ].

Trivial tree and stack congruences result by
equivalence classes that each contain a single tree
or stack, respectively. This would entail an in-
finite number of equivalence classes. As argued
above however, we may reasonably assume that
the number of equivalence classes is finite, consid-
ering typical oracles would use a bounded number
of features. These features are likely to investigate
only a bounded number of top-most trees on the

Sandy served Pat tea

PN V PN N

subj iobj
dobj

root

Figure 1: Example dependency structure.

stack, and for any such tree, the focus of interest
is likely to be the root, or leaves at the extreme
ends of the yields. Features are further discussed
in Section 6.

For technical reasons, we will assume t ≡tr t′
implies first(t) = first(t′). This is without loss of
generality: in the worst case, one needs to split up
each existing equivalence class into several, one
for each terminal.

4 Oracle automata and transition-based
dependency parsing

As our oracle automata were defined in terms of
context-free grammars, it deserves an explanation
how we can use them to perform dependency pars-
ing. The most straightforward solution is to as-
sume a bilexical context-free grammar, with a sin-
gle delexicalized nonterminal A. Concretely, for
every pair of words a and b, we assume two rules
Aa → AaAb and Aa → AbAa. In the first rule,
the first member in the right-hand side is the head,
and in the second rule, the second member is the
head. (The critical reader may object this defini-
tion is inconsistent if a = b; this could be fixed by
having two versions of each nonterminal Aa.) For
each terminal, we also have the rule Aa → a and
the rule S → Aa.

With grammars of this form, we obtain what
is commonly known as spurious ambiguity.
That is, there may be several parse trees that
correspond to the same dependency struc-
ture. For example, the dependency structure
in Figure 1 can be obtained by a left-most
derivation: Aserved ⇒ ASandy Aserved ⇒
Sandy Aserved ⇒ Sandy Aserved Atea ⇒
Sandy Aserved APat Atea ⇒∗
Sandy served Pat tea. Two more left-
most derivations exist however that correspond to
the same dependency structure, both starting with
Aserved ⇒ Aserved Atea.

In practice, this spurious ambiguity is not a

24



problem. It is the oracle that ensures that only
one structure is produced. Spurious ambiguity of
transition-based dependency parsing is discussed
at length by Goldberg and Nivre (2012).

If we apply oracle automata on the above
bilexical context-free grammars, we obtain what
Nivre et al. (2007) call the arc-standard strat-
egy of transition-based dependency parsing. This
contrasts with the arc-eager strategy. The lat-
ter has a shift operation, which corresponds ex-
actly to our shift. The left-arc operation corre-
sponds to reduction with a rule Aa → AbAa,
or in other words, a step (τAb(τb)Aa(τa), v$)
` (τAa(Ab(τb)Aa(τa)), v$). The formulation of
e.g. Nivre et al. (2007) has the top of the stack as
part of the remaining input, which is largely an
inconsequential notational difference, although it
does affect the way features address elements in
the stack or in remaining input; we will return to
this issue in Section 6.

Contrary to what one may expect, the right-arc
operation is not the mirror image of the left-arc
operation but then for the rule Aa → AaAb. The
easiest way of looking at the right-arc operation is
as making an early commitment to do the actual
reduce operation with the rule Aa → AaAb, be-
fore all the dependents of b have been processed.

In terms of bilexical grammars, this ‘early com-
mitment’ made by the right-arc operation can be
expressed by marking a nonterminal occurrence,
to enforce that it (or its ancestors) will end up as
the second member (as opposed to the first) in the
right-hand side of a rule. We will use a bar-symbol
for this mark. Concretely, we may construct the
following rules:

• S → Aa, Aa → a and Aa → Aa, for each a,
and

• Aa → AbAa, Aa → AaAb and Aa → AaAb,
for each pair a and b.

A reduction with rule Aa → Aa now corre-
sponds to a right-arc operation, and a reduction
with Aa → AaAb or Aa → AaAb corresponds
to what is called a reduce in the arc-eager model.

Having a representation of ‘early commitment’
by bar-symbols does not change the information
available to an oracle, relative to the formulation
of the right-arc operation in the cited literature. In
the worst case, it will require a different way of
addressing elements in the stack. Thereby the con-
clusions we will draw in Section 6 are unaffected.

5 Construction of a L-CFG from an
oracle automaton

Let us assume an oracle automatonM for a CFG
G and an oracle Ω. We also assume a tree congru-
ence ≡tr and a stack congruence ≡st consistent
with Ω, both with a finite number of equivalence
classes. We will construct a L-CFG GM as fol-
lows. The terminals of GM are those of G. The
nonterminals of GM are S and composite non-
terminals of the form A(`), where A is a nonter-
minal from G and the latent symbol ` is a triple
([τ ], [t], a) consisting of an equivalence class of
stacks, an equivalence class of trees, and a looka-
head symbol. Intuitively, [τ ] represents context to
the left of the occurrence of A, [t] captures inter-
nal properties of a derivation of A, and a repre-
sents the first terminal of context immediately to
the right of the occurrence of A.

There are three types of rules in GM. The first
is:

S† → S([ε],[t],$)
for every class [t]. This is easily justified, as ini-
tially the stack is empty, and the first symbol after
an occurrence of S must be $. The second is:

A([τ ],[A(a)],b) → a
for every class [τ ], terminals a and b, and rule
(A→ a) = Ω(τ, a). The third is:

A([τ0],[t0],a0) → B([τ1],[t1],a1)1 · · ·B([τk],[tk],ak)k
for all classes [τ0], [τ1], . . . , [τk], classes [t0], [t1],
. . . , [tk], terminals a0, a1, . . . , ak, and rule (A →
B1 · · ·Bk) = Ω(τk, a0) such that:
• [τ1] = [τ0] and [τi] = [τi−1ti−1] for each i

(1 < i ≤ k),
• [t0] = [A(t1 · · · tk)],
• ai = first(ti+1) for each i (1 ≤ i < k) and
ak = a0.

Note that the definitions are all well-defined.
For example, [τi] = [τi−1ti−1] uniquely denotes
an equivalence class, regardless of the choice of
τi−1 from [τi−1] and the choice of ti−1 from [ti−1],
because of ≡st being a stack congruence. Sim-
ilarly, ai = first(ti+1) is well-defined by the
additional assumption on tree congruences. The
above construction is reminiscent of covering of
LR(k) grammars by LR(1) grammars (Sippu and
Soisalon-Soininen, 1990).

25



Theorem 1 The tree language of GM equals the
tree language ofM.
Proof. It is easy to see that if A([τ ],[t

′],b) ⇒∗GM t,
for some A, t′, b and t, then [t′] = [t]. We now
need to show that (ε, w$) `∗M (t, $) if and only if
S([ε],[t],$) ⇒∗GM t, for every t ∈ T (Σ, N), where
w = yield(t).

In the ‘only if’ direction, it suffices to prove
by induction on the length of computations that
(τ, vw$) `∗M (τt, w$) implies A([τ ],[t],b) ⇒∗GM t,
where A = root(t) and b = first(w$).

The base case applies if v = a and the computa-
tion consists of a shift (τ, aw$) `M (τA(a), w$),
where Ω(τ, a) = (A → a). Then GM must
include a rule A([τ ],[A(a)],b) → a, where b =
first(w$). Hence A([τ ],[A(a)],b) ⇒GM A(a).

Otherwise, we have a computation:

(τ0, v1 · · · vkw$) `∗M
(τ0t1, v2 · · · vkw$) `∗M · · · `∗M
(τ0t1 · · · tk−1, vkw$) `∗M
(τ0t1 · · · tk, w$) `M (τ0A(t1 · · · tk), w$)

where Ω(τ0t1 · · · tk, a0) = (A→ B1 · · ·Bk), with
a0 = first(w$) and Bi = root(ti) for each i (1 ≤
i ≤ k).

Let further τ1 = τ0 and τi = τi−1ti−1 for
each i (1 < i ≤ k), let t0 = A(t1 · · · tk), let
ai = first(ti+1) for each i (1 ≤ i < k) and let
ak = a0. Then GM must include a rule:

A([τ0],[t0],a0) → B([τ1],[t1],a1)1 · · ·B([τk],[tk],ak)k
We can now use the inductive hypothesis, which

tells us that B([τi],[ti],ai)i ⇒∗GM ti for each i (1 ≤
i ≤ k). Hence A([τ0],[t0],a0)⇒∗GM t0.

In the ‘if’ direction, it suffices to prove by in-
duction on the tree depth that A([τ ],[t],b) ⇒∗GM t
implies (τ, vw$) `∗M (τt, w$) for every w with
b = first(w$), where v = yield(t).

The base case applies if the derivation is
A([τ ],[A(a)],b) ⇒GM A(a). Due to existence of
A([τ ],[A(a)],b) → a, and because ≡st is consistent
with Ω, we must have Ω(τ, a) = (A→ a). Hence
(τ, aw$) `M (τA(a), w$) for every w, regardless
of whether b = first(w$).

Otherwise, we have a derivation:

A([τ0],[t0],a0) ⇒GM
A(B([τ1],[t1],a1)1 · · ·B([τk],[tk],ak)k )⇒∗GM
A(t1 · · · tk)

for some stack τ0, trees t1, . . ., tk, and terminal a0
such that Ω(τk, a0) = (A → B1 · · ·Bk), where
τ1 = τ0, τi = τi−1ti−1 for each i (1 < i ≤ k),
t0 = A(t1 · · · tk), ai = first(ti+1) for each i (1 ≤
i < k) and ak = a0.

Let vi = yield(ti) for each i (1 ≤ i ≤ k).
Choose w such that first(w$) = a0. This means
ai = first(vi+1 · · · vkw$) for each i (1 ≤ i ≤
k). We can now apply the inductive hypothesis on
B

([τi],[ti],ai)
i ⇒∗GM ti for each i (1 ≤ i ≤ k), and

assemble the desired computation:

(τ0, v1 · · · vkw$) `∗M
(τ0t1, v2 · · · vkw$) `∗M · · · `∗M
(τ0t1 · · · tk−1, vkw$) `∗M
(τ0t1 · · · tk, w$) `M (τ0A(t1 · · · tk), w$)

Note that we made implicit use of ≡st being con-
sistent with Ω, so that, for example, the choice of
τ0 from a class [τ0] is irrelevant.

Our construction may result in a L-CFG that is
not reduced, that is, it may contain unreachable or
unproductive rules. This can be solved by reduc-
tion algorithms for CFGs (Harrison, 1978).

If probabilistic L-CFGs are desired, one may as-
sign probabilities in an arbitrary way, for exam-
ple by assigning probability 1/n to each rule that
shares its left-hand side with n − 1 other rules.
This does not change the tree language however,
and the grammar remains unambiguous, that is,
for each string, there is at most one tree.

We make no claim that the construction of L-
CFGs as given here has practical benefits over
methods for obtaining L-PCFGs via EM training
or spectral learning. The main purpose of our con-
struction was to show that L-(P)CFGs are at least
as powerful as oracle automata.

6 Features

We now present a formalization of common fea-
tures. Recall root as defined in Section 2. We
introduce ⊥ to denote the undefined value. We
assume a function applied on the undefined value
evaluates to the undefined value; for example
root(⊥) = ⊥.

We define child and nth by
child(i, A(t1 · · · tk)) = child(−i, A(tk · · · t1))
= nth(i, t1 · · · tk) = nth(−i, tk · · · t1) = ti, for
1 ≤ i ≤ k. In words, the first argument is an
index, which counts from the left if it is positive
and from the right if it is negative. For arguments

26



not covered by the above, the function values are
⊥.

We now define a feature to be a function F from
sequences of trees (stacks) to Σleaf ∪ Σintern ∪
{⊥}. We will first consider a simple kind of fea-
ture of the form F= root(child(i`, child(i`−1, . . . ,
child(i1,nth(i0, ·) . . .), some ` ≥ 0. Here · is a
placeholder for the stack as argument. In words,
the feature value for a stack t1 · · · tk is found by
considering ti0 if i0 > 0 or tk+1+i0 if i0 < 0. The
subtree at index i1 is then taken (distinguishing be-
tween i1 > 0 and i1 < 0 as before), etc. Of the
subtree obtained by the final application of child
with argument i` the root label is returned.

For F as above we define initial(F ) = i0
and for 0 ≤ j ≤ `, we let prefix (F, j) de-
note the function root(child(i`, child(i`−1, . . . ,
child(ij+1, ·) . . .). In words, from F we re-
move the initial application of nth and the next
j applications of child . We let prefixes(F ) =
{prefix (F, j) | 0 ≤ j ≤ `}. For a function of
the form prefix (F, j), we let head(prefix (F, j))
= ij+1 and tail(prefix (F, j)) = prefix (F, j + 1)
for 0 ≤ j < `, and head(prefix (F, `)) =
tail(prefix (F, `)) = ⊥. In words, head returns
the index of the next application of child if there
is one, and tail removes the next application of
child .

We say oracle Ω is determined by the sequence
F1, . . . , Ff of features if for every τ1, τ2, a1, a2,
the equalities Fj(τ1) = Fj(τ2) for every j (1 ≤
j ≤ f ) and a1 = a2 together imply Ω(τ1, a1) =
Ω(τ2, a2). Here we have treated the lookahead (a1
or a2) as an implicit feature.

In order to obtain a tree congruence from a se-
quence F1, . . . , Ff of simple features as above,
we first define F = ∪1≤j≤fprefixes(Fj). Next
we define a function erase, which erases from a
tree t all subtrees that are outside the reach of the
functions in F , and that remain so if t becomes a
subtree of a bigger tree. Erasing is done by remov-
ing subtrees or replacing them by⊥. Formally, for
G ⊆ F , erase(G, t) = ⊥ if G = ∅, and for G 6= ∅
we define:

erase(G, A(t1 · · · tk)) = A(t′1 · · · t′k′t′′k′′ · · · t′′k)

where the t′i and t
′′
i are defined below. First, let

imax = max{i ∈ head(F ) | F ∈ G, 1 ≤ i ≤ k}
and imin = min{i ∈ head(F ) | F ∈ G, 1 ≤
−i ≤ k}. In words, in potential next applica-
tions of child in functions in G, we consider the

indices counting from the left and those counting
from the right and take the rightmost and leftmost,
respectively of those indices. If imax is defined
then k′ = imax and otherwise k′ = 0. If imin is
defined then k′′ = k + 1 + imin and otherwise
k′′ = k + 1. Note that k′ may be greater than
k′′ − 1.

For 1 ≤ i ≤ k′ we now define t′i =
erase(G′i, ti) where G′i = {tail(F ) | F ∈ G,
head(F ) = i}. For k′′ ≤ i ≤ k we define t′′i
= erase(G′′i , ti) where G′′i = {tail(F ) | F ∈ G,
k+ 1 + head(F ) = i}. Note that the total number
of nodes in (the tree representations of) the func-
tions in G′i and G′′i is strictly smaller than the total
number of nodes in the trees in G. It follows that,
for any t, the size of tree erase(F , t) is bounded,
that is, the set of such trees is finite.

Define ≡tr by t1 ≡tr t2 if and only if
erase(F , t1) = erase(F , t2). By the defini-
tion of erase , we have erase(F , A(t1 · · · tk))
= erase(F , A(erase(F , t1) · · · erase(F , tk))) for
every tree A(t1 · · · tk). It follows that ≡tr is a (fi-
nite) tree congruence.

As an example, consider f = 1 and:

F1 = root(child(3, child(2,nth(−1, ·))))
t = A(B1(b1)B2(C1(c1)C2(c2)C3(c3))B3(b3))

Then F = {root(·), root(child(3, ·)),
root(child(3, child(2, ·)))} and erase(F , t)
= A(⊥B2(⊥⊥C3())B3()).

In order to obtain our (finite) stack congru-
ence≡st , we erase elements from a stack t1 · · · tk.
We now determine imax = max{initial(Fj) |
1 ≤ j ≤ f, 1 ≤ initial(Fj) ≤ k} and
imin = min{initial(Fj) | 1 ≤ j ≤ f, 1 ≤
−initial(Fj) ≤ k}. Much as before we have
k′ = imax if imax is defined and k′ = 0 other-
wise and k′′ = k + 1 + imin if imin is defined and
k′′ = k + 1 otherwise. The stack after erasure is
erase(F , t1) · · · erase(F , tk′)erase(F , tk′′) · · ·
erase(F , tk). This allows definition of ≡st , in the
same way as of ≡tr .

We can extend the repertoire of functions in
our features. For example, we can include
first and last as defined in Section 2. We
can also add the function first intern , which
returns the internal symbol just above the left-
most leaf. Formally, first intern(A(a)) = A and
first intern(A(t1 · · · tk)) = first intern(t1) if
t1 /∈ Σleaf . The definition of last intern is sym-
metric. Allowing such functions requires appro-

27



priate refinements of erase , such that the depth of
the resulting trees remains bounded, by keeping
only the relevant nodes near selected leaves.

We will now discuss the features used by the
MaltParser, one of the most widely publicized
transition-based dependency parsers. The descrip-
tions will be based on Nivre et al. (2006) and Nivre
et al. (2007).

All features are defined in terms of word form,
part of speech or dependency relation. In our ora-
cle automata, this information can all be encoded
as parts of names of terminals and nonterminals.
In the MaltParser, the word forms, parts of speech
and dependency relations are attached to ‘tokens’
in the state of the parser. These tokens are found
in the stack or in the remaining input.

Tokens can be addressed by an index, which for
the stack counts from the top downward (cf. our
function nth with negative first argument), and for
the remaining input counts rightward from the first
unconsumed token. One source of confusion with
our automata is that in the MaltParser dependency
links can be attached to the first token in the re-
maining input, whereas our automata would first
have to transfer such a token to the stack before
linking it to other tokens by means of a reduction.
There can therefore be a slight mismatch in the
type of addressing of tokens, relative to our for-
mal framework above.

For presentational reasons, we have limited the
size of the lookahead of our oracle automata to 1.
Without causing any further complications how-
ever, this can be relaxed to lookahead of any fixed
size. In this way, we can model features of the
MaltParser that look a fixed distance ahead in the
remaining input. As for the construction of the
L-CFG, this would be modified accordingly, with
latent symbols in which the third component is a
string of the appropriate length.

Next to addressing tokens by index, features
of the MaltParser can also refer to leftmost and
rightmost dependents of indexed tokens. In our
framework, such features could be expressed us-
ing functions similar to child , first intern and
last intern , all allowing erase to return trees of
bounded size as before.

Features similar to those of the MaltParser are
used by Sagae and Lavie (2005), but in addition,
their features also include e.g. the number of de-
pendents of a token. This might suggest the num-
ber of equivalence classes is infinite after all. In

practice however, the oracle would only deal with
one from a bounded number of possible values,
that is, those that were encountered during train-
ing, which is necessarily finite. It is not clear to
us how their parser would behave if a value is
encountered during testing that is larger than the
maximum one encountered during training.

7 The probabilistic case

One may redefine Ω to be a probability distribu-
tion, constrained by:

• if Ω(A→ b | [τ ], a) > 0, then a = b; and
• if Ω(A→ B1 · · ·Bk | [τ ], a) > 0, then τ can

be written as τ ′t1 · · · tk, where root(ti) = Bi
for each i (1 ≤ i ≤ k).

This is in the same spirit as the non-deterministic
oracles of Goldberg and Nivre (2013).

With Ω now being a probability distribution, we
can refine the semantics of our automata to as-
sign a probability to each computation, which is
the product of the probabilities of all used steps.
The construction from Section 5 can be extended
to produce a L-PCFG, where:

• S† → S([ε],[t],$) is assigned probability 1,
• A([τ ],[A(a)],b) → a is assigned Ω(A → a |

[τ ], a),

• A([τ0],[t0],a0) → B([τ1],[t1],a1)1 · · ·B([τk],[tk],ak)k
is assigned Ω(A→ B1 · · ·Bk | [τk], a0).

If desired, the L-PCFG can be normalized to be-
come proper, i.e. so that the probabilities of all
rules with given left-hand side sum to 1; see e.g.
Chi (1999).

8 Conclusions

We have explored formal properties of transition-
based dependency parsing, in terms of traditional
automata theory. Through our formalization, an
explicit link has been established between pro-
jective transition-based dependency parsing and
constituent parsing, in particular latent-variable
context-free parsing. Extension to the non-
projective/discontinuous case will be the subject
of future investigations.

Acknowledgements

Thanks go to reviewers for helpful comments.

28



References
A. Boyd. 2007. Discontinuity revisited: An improved

conversion to context-free representations. In Pro-
ceedings of the Linguistic Annotation Workshop, at
ACL 2007, pages 41–44, Prague, Czech Republic,
June.

W.S. Brainerd. 1969. Tree generating regular systems.
Information and Control, 14:217–231.

M. Candito, J. Nivre, P. Denis, and E. Henestroza An-
guiano. 2010. Benchmarking of statistical de-
pendency parsers for French. In The 23rd Inter-
national Conference on Computational Linguistics,
pages 108–116, Beijing, China, August.

S.A. Caraballo and E. Charniak. 1998. New figures of
merit for best-first probabilistic chart parsing. Com-
putational Linguistics, 24(2):275–298.

G. Carroll and E. Charniak. 1992. Two experiments on
learning probabilistic dependency grammars from
corpora. In Statistically-Based NLP Techniques, Pa-
pers from the AAAI Workshop, pages 1–13, San Jose.

D. Cer, M.-C. de Marneffe, D. Jurafsky, and C. Man-
ning. 2010. Parsing to Stanford dependen-
cies: Trade-offs between speed and accuracy. In
LREC 2010: Seventh International Conference on
Language Resources and Evaluation, Proceedings,
pages 1628–1632, Valletta , Malta, May.

Z. Chi. 1999. Statistical properties of probabilistic
context-free grammars. Computational Linguistics,
25(1):131–160.

M. Collins. 2003. Head-driven statistical models for
natural language parsing. Computational Linguis-
tics, 29(4):589–637.

M.A. Covington. 2001. A fundamental algorithm for
dependency parsing. In Proceedings of the 39th An-
nual ACM Southeast Conference, pages 95–102.

J. Eisner and G. Satta. 1999. Efficient parsing for
bilexical context-free grammars and head automa-
ton grammars. In 37th Annual Meeting of the Asso-
ciation for Computational Linguistics, Proceedings
of the Conference, pages 457–464, Maryland, USA,
June.

H. Gaifman. 1965. Dependency systems and phrase-
structure systems. Information and Control, 8:304–
337.

F. Gécseg and M. Steinby. 1997. Tree languages. In
G. Rozenberg and A. Salomaa, editors, Handbook
of Formal Languages, Vol. 3, chapter 1, pages 1–68.
Springer, Berlin.

Y. Goldberg and J. Nivre. 2012. A dynamic oracle for
arc-eager dependency parsing. In The 24th Inter-
national Conference on Computational Linguistics,
pages 959–976, Mumbai, India, December.

Y. Goldberg and J. Nivre. 2013. Training determinis-
tic parsers with non-deterministic oracles. Transac-
tions of the Association for Computational Linguis-
tics, 1:403–414.

J. Goodman. 1997. Global thresholding and multiple-
pass parsing. In Proceedings of the Second Con-
ference on Empirical Methods in Natural Language
Processing, pages 11–25, Providence, Rhode Island,
USA, August.

K. Hall and V. Novák. 2005. Corrective modeling
for non-projective dependency parsing. In Proceed-
ings of the Ninth International Workshop on Pars-
ing Technologies, pages 42–52, Vancouver, British
Columbia, Canada, October.

M.A. Harrison. 1978. Introduction to Formal Lan-
guage Theory. Addison-Wesley.

D.G. Hays. 1964. Dependency theory: A formalism
and some observations. Language, 40(4):511–525.

L. Huang and K. Sagae. 2010. Dynamic programming
for linear-time incremental parsing. In Proceedings
of the 48th Annual Meeting of the Association for
Computational Linguistics, pages 1077–1086, Upp-
sala, Sweden, July.

M. Johnson. 2007. Transforming projective bilexi-
cal dependency grammars into efficiently-parsable
CFGs with Unfold-Fold. In 45th Annual Meeting of
the Association for Computational Linguistics, Pro-
ceedings of the Conference, pages 168–175, Prague,
Czech Republic, June.

S. Kahane, A. Nasr, and O. Rambow. 1998. Pseudo-
projectivity, a polynomially parsable non-projective
dependency grammar. In 36th Annual Meeting of
the Association for Computational Linguistics and
17th International Conference on Computational
Linguistics, volume 1, pages 646–652, Montreal,
Quebec, Canada, August.

K. Kallmeyer and M. Kuhlmann. 2012. A formal
model for plausible dependencies in lexicalized tree
adjoining grammar. In Eleventh International Work-
shop on Tree Adjoining Grammar and Related For-
malisms, pages 108–116.

L. Kallmeyer and W. Maier. 2010. Data-driven pars-
ing with probabilistic linear context-free rewriting
systems. In The 23rd International Conference on
Computational Linguistics, pages 537–545, Beijing,
China, August.

T. Kalt. 2004. Induction of greedy controllers for de-
terministic treebank parsers. In Conference on Em-
pirical Methods in Natural Language Processing,
pages 17–24, Barcelona, Spain, July.

D. Klein and C. Manning. 2004. Corpus-based induc-
tion of syntactic structure: Models of dependency
and constituency. In 42nd Annual Meeting of the As-
sociation for Computational Linguistics, Proceed-
ings of the Conference, pages 478–485, Barcelona,
Spain, July.

29



M. Kuhlmann, C. Gómez-Rodrı́guez, and G. Satta.
2011. Dynamic programming algorithms for
transition-based dependency parsers. In 49th An-
nual Meeting of the Association for Computational
Linguistics, Proceedings of the Conference, pages
673–682, Portland, Oregon, June.

M. Kuhlmann. 2013. Mildly non-projective de-
pendency grammar. Computational Linguistics,
39(2):355–387.

A. Lavie and M. Tomita. 1993. GLR∗ – an effi-
cient noise-skipping parsing algorithm for context
free grammars. In Third International Workshop on
Parsing Technologies, pages 123–134, Tilburg (The
Netherlands) and Durbuy (Belgium), August.

D. Lin. 1998. A dependency-based method for eval-
uating broad-coverage parsers. Natural Language
Engineering, 4(2):97–114.

X. Ma, X. Zhang, H. Zhao, and B.-L. Lu. 2010. De-
pendency parser for Chinese constituent parsing. In
CIPS-SIGHAN Joint Conference on Chinese Lan-
guage Processing.

T. Matsuzaki, Y. Miyao, and J. Tsujii. 2005. Proba-
bilistic CFG with latent annotations. In 43rd Annual
Meeting of the Association for Computational Lin-
guistics, Proceedings of the Conference, pages 75–
82, Ann Arbor, Michigan, June.

Y. Miyao, R. Sætre K. Sagae, T. Matsuzaki, and J. Tsu-
jii. 2008. Task-oriented evaluation of syntactic
parsers and their representations. In 46th Annual
Meeting of the Association for Computational Lin-
guistics: Human Language Technologies, pages 46–
54, Columbus, Ohio, June.

S. Narayan and S.B. Cohen. 2015. Diversity in spec-
tral learning for natural language parsing. In Con-
ference on Empirical Methods in Natural Language
Processing, Proceedings of the Conference, pages
1868–1878, Lisbon, Portugal, September.

M.-J. Nederhof and M. McCaffery. 2014. Determinis-
tic parsing using PCFGs. In Proceedings of the 14th
Conference of the European Chapter of the Associa-
tion for Computational Linguistics, pages 338–347,
Gothenburg, Sweden.

J. Nivre and J. Nilsson. 2005. Pseudo-projective
dependency parsing. In 43rd Annual Meeting of
the Association for Computational Linguistics, Pro-
ceedings of the Conference, pages 99–106, Ann Ar-
bor, Michigan, June.

J. Nivre and M. Scholz. 2004. Deterministic depen-
dency parsing of English text. In The 20th Inter-
national Conference on Computational Linguistics,
volume 1, pages 64–70, Geneva, Switzerland, Au-
gust.

J. Nivre, J. Hall, and J. Nilsson. 2004. Memory-
based dependency parsing. In Proceedings of
the Eighth Conference on Computational Natural

Language Learning, pages 49–56, Boston, Mas-
sachusetts, May.

J. Nivre, J. Hall, and J. Nilsson. 2006. MaltParser:
A data-driven parser-generator for dependency pars-
ing. In LREC 2006: Fifth International Conference
on Language Resources and Evaluation, Proceed-
ings, pages 2216–2219, Genoa, Italy, May.

J. Nivre, J. Hall, J. Nilsson, A. Chanev, G. Eryiǧit,
S. Kübler, S. Marinov, and E. Marsi. 2007. Malt-
Parser: A language-independent system for data-
driven dependency parsing. Natural Language En-
gineering, 13(2):95–135.

J. Nivre. 2003. An efficient algorithm for projective
dependency parsing. In 8th International Workshop
on Parsing Technologies, pages 149–160, LORIA,
Nancy, France, April.

J. Nivre. 2009. Non-projective dependency parsing
in expected linear time. In Proceedings of the Joint
Conference of the 47th Annual Meeting of the ACL
and the 4th International Joint Conference on Natu-
ral Language Processing of the AFNLP, pages 351–
359, Suntec, Singapore, August.

F.C.N. Pereira and R.N. Wright. 1997. Finite-state
approximation of phrase-structure grammars. In
E. Roche and Y. Schabes, editors, Finite-State Lan-
guage Processing, pages 149–173. MIT Press.

S. Petrov, L. Barrett, R. Thibaux, and D. Klein. 2006.
Learning accurate, compact, and interpretable tree
annotation. In Proceedings of the 21st Interna-
tional Conference on Computational Linguistics and
44th Annual Meeting of the Association for Compu-
tational Linguistics, pages 433–440, Sydney, Aus-
tralia, July.

O. Rambow. 2010. The simple truth about dependency
and phrase structure representations: An opinion
piece. In Human Language Technologies: The 2010
Annual Conference of the North American Chap-
ter of the Association for Computational Linguistics,
Proceedings of the Main Conference, pages 337–
340, Los Angeles, California, June.

A. Ratnaparkhi. 1997. A linear observed time statis-
tical parser based on maximum entropy models. In
Proceedings of the Second Conference on Empirical
Methods in Natural Language Processing, pages 1–
10, Providence, Rhode Island, USA, August.

K. Sagae and A. Lavie. 2005. A classifier-based
parser with linear run-time complexity. In Proceed-
ings of the Ninth International Workshop on Parsing
Technologies, pages 125–132, Vancouver, British
Columbia, Canada, October.

S. Seneff. 1989. TINA: A probabilistic syntac-
tic parser for speech understanding systems. In
ICASSP-89, volume 2, pages 711–714, Glasgow.

30



S. Sippu and E. Soisalon-Soininen. 1990. Parsing The-
ory, Vol. II: LR(k) and LL(k) Parsing, volume 20 of
EATCS Monographs on Theoretical Computer Sci-
ence. Springer-Verlag.

Y. Tsuruoka and J. Tsujii. 2005. Chunk parsing re-
visited. In Proceedings of the Ninth International
Workshop on Parsing Technologies, pages 133–140,
Vancouver, British Columbia, Canada, October.

A. van Cranenburgh, R. Scha, and F. Sangati. 2011.
Discontinuous data-oriented parsing: A mildly
context-sensitive all-fragments grammar. In Pro-
ceedings of the Second Workshop on Statistical Pars-
ing of Morphologically Rich Languages, pages 34–
44, Dublin, Ireland.

A. Wong and D. Wu. 1999. Learning a lightweight
robust deterministic parser. In Sixth European Con-
ference on Speech Communication and Technology,
pages 2047–2050.

H. Yamada and Y. Matsumoto. 2003. Statistical de-
pendency analysis with support vector machines. In
8th International Workshop on Parsing Technolo-
gies, pages 195–206, LORIA, Nancy, France, April.

31


