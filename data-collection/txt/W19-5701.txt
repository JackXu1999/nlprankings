

















































Parsing Weighted Order-Preserving Hyperedge Replacement Grammars

Henrik Björklund
Dept. of Computing Science
Umeå University (Sweden)
henrikb@cs.umu.se

Frank Drewes
Dept. of Computing Science
Umeå University (Sweden)
drewes@cs.umu.se

Petter Ericson
Dept. of Computing Science
Umeå University (Sweden)
pettter@cs.umu.se

Abstract

We introduce a weighted extension of the
recently proposed notion of order-preserving
hyperedge-replacement grammars and prove
that the weight of a graph according to such a
weighted graph grammar can be computed uni-
formly in quadratic time (under assumptions
made precise in the paper).

1 Introduction

The hyperedge-replacement grammar (HRG) is a
well-studied formalism for describing graph lan-
guages; see, e.g., (Bauderon and Courcelle, 1987;
Habel and Kreowski, 1987; Habel, 1992; Drewes
et al., 1997). As argued by Jones et al. (2012),
Koller (2015), and Groschwitz et al. (2015) it is
also a promising candidate for modelling seman-
tic representations of natural language such as
Abstract Meaning Representation (AMR, see Ba-
narescu et al. (2013)). However, HRGs overshoot
the mark in that parsing with respect to them is
computationally too expensive. Further, HRGs can
express intricate structural properties whose com-
plexity is far beyond what seems to be required to
describe practically relevant languages of seman-
tic graphs such as AMR. For example, as argued
by Chiang et al. (2018) it suffices if the path lan-
guages of such graph languages are regular lan-
guages. In contrast, HRGs easily give rise to even
non-context-free path languages. Thus, from both
perspectives less powerful special cases should be
sought if this helps to cut down on parsing complex-
ity. Recently, such a restriction, called order preser-
vation, was proposed and studied in (Björklund
et al., 2016; Björklund et al., 2017; Björklund et al.,
2018).

The present article builds upon the order-
preserving HRGs (OPHGs) of Björklund et al.
(2018), where it was shown that parsing for OPHGs
is efficient, requiring polynomial time even in the

uniform case i.e. when the grammar is consid-
ered to be part of the input. Here, we define a
weighted version of OPHGs, and extend the results
of Björklund et al. (2018) to show that when the
weights are taken from a commutative semiring, we
can efficiently compute the weight assigned by an
OPHG to any input graph. This is an important fea-
ture since applications such as semantic modelling
require ways to quantify the well-formedness of a
generated graph.

While providing a notion of grammars with
weights may appear to be a simple task as one
only has to assign weights to the rules, doing so in
a meaningful way for unrestricted HRGs is actually
not simple at all. The reason is that the weights of
different derivation trees generating the same graph
should be summed up to obtain the weight of the
graph. However, if a right-hand side of a rule has
nontrivial automorphisms that interchange two or
more nonterminal hyperedges, one gets spuriously
distinct derivation trees that should intuitively be
considered identical. At the very least, this compli-
cates uniform parsing as it requires to preprocess
the rules to detect the automorphisms of their right-
hand sides, a task for which no polynomial solution
is known.

In OPHGs, only the right-hand sides of so-called
duplication rules have nontrivial automorphisms,
and those do not require preprocessing. These rules
correspond to associative and commutative opera-
tions, which we propose to take special care of in
the computation of weights by using a type of re-
duced derivation trees introduced for the same pur-
pose by Courcelle (1991a); see also Courcelle and
Engelfriet (2012). In these derivation trees, some
nodes have a set of children, while others have
them ordered in a list. After this, we show how
weights can efficiently be computed, and prove the
correctness of the algorithm.



Related work. Another type of restricted HRGs
for semantic modelling was proposed by Chiang
et al. (2013), together with a parsing algorithm and
a detailed complexity analysis. The complexity
is, however, exponential even in the non-uniform
case. In particular, it is exponential in the maxi-
mum degree of nodes in the input graph. The same
holds for the parsing algorithm for regular graph
grammars presented by Gilroy et al. (2017). We
also mention that another technique for efficient
HRG parsing was resently developed by Drewes
et al. (2015, 2017).

2 Preliminaries

The set of non-negative integers is N, and [k] =
{1, . . . , k}. For a set S, S∗ is the set of strings over
S, while S~ is the set of strings in S∗ in which
no element of S occurs twice. The empty string
is �, and we have S+ = S∗ \ � and S⊕ = S~ \ �.
The length of a string w is denoted |w|. We use the
terms ‘string’ and ‘sequence’ interchangably. For a
sequence w = a1 · · · an, every sequence ai1 · · · aik
with 1 ≤ i1 < · · · < ik ≤ n is a subsequence of
w, and [w] is the set {a1, . . . , an}.

2.1 Hypergraphs

We fix a disjoint, countably infinite supply LAB
of labels, such that each σ ∈ LAB has a rank
rank(σ) ∈ N. A hypergraph is a structure g =
(V,E, lab, att, ext) where V and E are the (finite)
sets of nodes and hyperedges, lab : E → LAB
is the edge labelling, att : E → V ⊕ is the edge
attachment with |att(e)| = rank(lab(e))+1 for all
e ∈ E, and ext ∈ V ⊕ is the sequence of external
nodes.

From now on, we simply call hypergraphs
graphs, and hyperedges edges. We use the graph
as a subscript to identify its components. E.g.,
Eg refers to the set of edges of g. For an edge
e ∈ Eg with attg(e) = v0 · · · vk, we say that
srcg(e) = v0, targ(e) = v1 · · · vk, and name these
the source and sequence of targets, respectively.
Similarly, for extg = v0 · · · vl, we say that v0 = g
is the source of the graph, and v1 · · · vl = g its
sequence of targets. In this paper, we require all tar-
gets of a graph to be leaves, i.e. srcg(e) /∈ [g ] for
all e ∈ Eg. For a graph g, rank(g) = |g |, and for
an edge e, rank(e) = rank(labg(e)) = |targ(e)|.
Graphs g, h are isomorphic, denoted g ≡ h, if they
are equal up to a bijective renaming of nodes and
edges.

For a ∈ LAB with rank(a) = k, a• de-
notes the graph ({v0, . . . , vk}, {e}, (e→ a), (e→
v0 · · · vk), (v0 · · · vk)), i.e. the graph of one a-
labelled edge of the proper rank, with all its at-
tached nodes external.

An alternating sequence v1e1 . . . vkek of nodes
and edges is a path in g from v1 to ek if srcg(ei) =
vi and vi+1 ∈ [targ(ei)], for each i ∈ [k]. We may
optionally terminate the path at vk+1 instead of ek.
In either case, the path passes all nodes and edges
vi and ei for i ∈ [k]. If v1 = g, it is a source path.
A node v or edge e is reachable from s (in g) if
there is a path in g from s to v (e). A node or edge
is reachable in g if there is a source path to it.

2.2 Hyperedge replacement
Consider graphs h, f , and an edge e ∈ Eh such
that rank(e) = rank(f), Vh ∩ Vf = [atth(e)],
and atth(e) = extf . Then we can use hyperedge
replacement to obtain the graph g = h[[e : f ]], sub-
stituting f for e in h, where g = ((Vh∪Vf ), (Eh∪
Ef ) \ {e}, attg, labg, exth) with

attg(e
′) =

{
attf (e

′) if e′ ∈ Ef
atth(e

′) if e′ ∈ Eh \ {e}

and

labg(e
′) =

{
labf (e

′) if e′ ∈ Ef
labh(e

′) if e′ ∈ Eh \ {e}.

Clearly, if rank(e) = rank(f) then we can al-
ways choose isomorphic copies of h and f , renam-
ing nodes in such a way that h[[e : f ]] is defined.
We will generally not make note of this, to avoid
irrelevant technicalities.

For the case where g = h[[e : f ]] and i = g[[e′ :
j]] with e′ /∈ Ef , we write i = h[[e : f, e′ : j]], and
similarly for a larger number of replacements.

We divide LAB into two subsets TLAB and
NLAB of terminals and nonterminals, and accord-
ingly call edges terminal and nonterminal ones. We
sometimes shorten the expressions further to just
“terminals” and “nonterminals”.

2.3 Hyperedge replacement grammars
A hyperedge replacement grammar (HRG) G =
(Σ, N, S,R) consists of a terminal alphabet Σ ⊂
TLAB, a nonterminal alphabet N ⊂ NLAB, an
initial nonterminal S ∈ N , and a set R of (HR)
rules form A→ f , where A ∈ N and f is a graph
over Σ ∪ N with rank(A) = rank(f). If f has
` nonterminal edges, we name them {e1, . . . , e`}
and write arity (A→ f) for `.



Derivations in HRGs are context-free: Given a
graph h, an edge e ∈ Eh with labh(e) = A ∈ N ,
and a rule (A→ f) ∈ R, we can derive the graph
g = h[[e : f ]] from h. We call this a derivation
step, and denote it h→A→f g. We also write more
generally h →G g for a derivation step using any
rule in R. The reflexive and transitive closure of
→G is→∗G. The language of G is the set L(G) of
all graphs g over TLAB such that S• →∗G g.

3 Order-Preserving Hyperedge
Replacement Grammars

We now turn to order-preserving HRGs. The first
ingredient is a condition called reentrancy preser-
vation. Reentrancies are deeply entwined with the
way we identify places in a graph that match the
right-hand side of a given rule.

3.1 Reentrancies

Suppose we consider a subgraph h of a graph g as a
candidate of a subgraph that may have been derived
from a nonterminal e. If so, then g = g′[[e : h]]
where, intuitively, g′ is obtained from g by replac-
ing h by e. To perform this backwards replacement,
we have to determine which nodes of h are its ex-
ternal nodes, i.e., which ones are to be attached to
e. By the very definition of hyperedge replacement,
a node of h that is external in g or has an attached
edge not belonging to h, must be in [attg′(e)] (but
not generally vice versa). In particular, all nodes
in h that can be reached from g without passing a
node in h must be in [attg′(e)]. The notion of reen-
trant nodes to be defined now serves to turn this
inclusion into an equality (once we add [extg]∩Vh
to this set) in the case where h is rooted at some
node or edge x of g.

Intuitively, the reentrant nodes of a node or edge
x in a graph g are the first descendants of x that
can also be reached on a path that avoids x. As
the external nodes of a right-hand side of an HR
rule are the ones that, after the replacement, are
reachable from “outside” the subgraph, we also
consider them as reentrant. The graph delineated
by x and its reentrant nodes is the subgraph rooted
at x.

Let us have a look at a simple example before
defining the notion of reentrant nodes formally.
The graph in Figure 1 is single-rooted, with r the
root node. The reentrant nodes of r is the set of
external targets (i.e. x1, x2 and x3), and these are
also the reentrant nodes of the edge e sourced at r.

For the edge marked f , x2 is a reentrant node, and
so is v1 and v2, as v2 is reachable through the path
rei1gv2 that avoids f , and v1 likewise is reachable
by the path rei1gi2hv1, also avoiding f . For f ′,
the set of reentrant nodes is {v1, v3}, as v3 is also
a direct target of f , making it reachable on the path
rei3fv3 that avoids f ′.

e

g f

r

i1 i3

x3i2 i4
x2

h f ′

v1 v2 v3

x1

Figure 1: An example graph for reentrancies.

Definition 3.1 (Reentrant node). Given a graph g
and E ⊂ Eg, let TARg(E) be the union of all sets
of targets of edges in E, i.e.

⋃
e∈E [targ(e)].

Further, for x ∈ Vg ∪ Eg, let x̂ be x if x ∈ Vg,
and srcg(x) if x ∈ Eg. Now, let Exg be the set of
all edges e ∈ Eg such that all source paths to e
pass x.1 Then the set of reentrant nodes of x in g is

reentg(x) = (TARg(E
x
g ) \ {x̂}) ∩

(TARg(Eg \ Exg ) ∪ [extg]).

Definition 3.2 (Rooted subgraph). Given a graph
g with x ∈ Vg ∪ Eg, the subgraph g↓x rooted
at x is a graph h such that Eh = Exg , Vh =
{x̂} ∪ TARg(Eh), atth and labh are the appro-
priate restrictions of attg and labg, respectively,
and exth is x̂ followed by reenth(x) in some order.

Rooted subgraphs are strictly nested, which is
proved by Björklund et al. (2018) in the form of the
following lemma (where ∼ is isomorphy modulo
the order of g ):

1Note that if x is not reachable in g, Exg = ∅



Lemma 3.3 (Lemma 3.4 in (Björklund et al.,
2018)). Let g be a graph, h = g↓x for some
x ∈ Vg ∪ Eg. Then h↓y ∼ g↓y for all y ∈
(Vh ∪ Eh) \ [exth]

3.2 Reentrancy Preservation

Reentrancy preservation formalizes the property
that, given a graph h and some edge e ∈ Eh with
labh(e), we can replace e by some graph f accord-
ing to a rule A → f without affecting the sets
reentg(x) for x ∈ Vh ∪ Vf .

We achieve this by restricting our grammars to
two types of rules, namely duplication rules and
deep rules. Rules of these two kinds are called
reentrancy preserving. To define duplication rules,
consider a graph

f = ({v0, . . . , vn}, {e1, e2}, att, lab, ext),

where att(e1) = v0 · · · vn = att(e2), lab(e1) =
lab(e2) ∈ NLAB, and ext is a subsequence of
att(e1) starting with v0. If |ext| < n then f (and
every graph isomorphic to f ) is a twin, and if
|ext| = n then it is a clone. A rule A → f is
a twin rule if f is a twin and a clone rule if f is a
clone with lab(e1) = lab(e2) = A. A duplication
rule is either a clone or a twin rule.

A rule A → f is a deep rule if f fulfills the
following conditions:

• Vf 6= [extf ],

• all nodes in Vf are reachable from f and have
out-degree ≤ 1, and

• for every nonterminal edge e, reentf (e) =
[tarf (e)].

A HRG is reentrancy preserving if it has only
reentrancy-preserving rules. We note here that
Björklund et al. (2018) also permits chain rules,
i.e. rules that only change the label of an edge from
one nonterminal to another nonterminal, and thus
violate the first condition above. In the present
paper we exclude them because they can result in
an infinite number of derivations of a given graph,
thus making it in general unreasonable to associate
a weight with such a graph.2

Later on, we will also need the following gener-
alization of duplication rules to the case where `+1

2To allow for chain rules, one may require the semiring to
be complete, i.e., to have infinite sums. We do not pursue this
possibility here.

copies of a nonterminal edge are created: given any
duplication rule r = (A→ f) and some ` ≥ 1, we
denote by r` the rule A→ f ′, where f ′ is obtained
from f by replacing its two nonterminals by `+ 1
copies. Thus, r1 = r.
Lemma 3.4 (Björklund et al. (2018) adapted). Let
g ∈ L(G) for some reentrancy-preserving HRG G.
There is a quadratic algorithm that computes, for
every x ∈ Vg ∪Eg, the set reentg(x), and thus the
subgraph g↓x.

3.3 Ordering nodes
Reentrancy preservation allows us to pinpoint the
subgraphs that may have been generated by a spe-
cific nonterminal, but as shown by Björklund et al.
(2016), this is not sufficient to achieve efficient
parsing, as needing to guess the order of targets in
subgraphs g↓x may still cause NP-hardness. Thus,
we require a way to determine the order of nodes,
in particular reentrant nodes. This requires an or-
dering relation that can be efficiently computed,
and fulfils some basic requirements, and a set of
reentrancy-preserving rules that additionally pre-
serves that order. Formally:
Definition 3.5 (Suitable order). For a set G of
graphs, a suitable family of orders is a family
(�g)g∈G of binary relations �g ⊆ Vg × Vg such
that

• for allA ∈ LABN ,A• is ordered by�A• and

• if i : g → h is an isomorphism and u, v ∈ Vg,
then u �g v iff iV (u) �h iV (v).

Definition 3.6 (Order preservation). A reentrancy-
preserving set R of HR rules preserves a suitable
family of orders � = (�g)g∈G if, for all g = h[e :
f ] with g, h, f ∈ G, e ∈ Eh, and labh(e) → f ∈
R, we have �g|Vh = �h and �f |Vf = �f .

An order-preserving HRG (OPHG) is a reen-
trancy preserving HRG (Σ, N, S,R) together with
a suitable family � of orders preserved by R.

4 Weighted Order-Preserving HR
Grammars

We now add weights – taken from some semir-
ing – to order-preserving HR grammars. For this,
and throughout the rest of this paper, let S =
(S,+, ·, 0, 1) be a commutative semiring, meaning
that (S,+, 0) and (S, ·, 1) are two monoids over
the domain S such that · distributes over +. Thus,
spelled out in detail, + and · are binary operations
on S such that



• 1 is the identity element for ·

• 0 is the identity element for + and the absorb-
ing one for ·,

• + and · are commutative, and

• · distributes over +.

As usual, for every a ∈ S we let a0 = 1 and
an+1 = a · an for all n ∈ N.

Examples of well-known semirings are the
Boolean semiring, the real numbers with addition
and multiplication, the tropical semiring consisting
of the positive real numbers extended by∞ with
minimum and addition, and the Viterbi semiring
over [0, 1] in which multiplication is as usual and
addition is maximum. The latter is used in natu-
ral language processing to compute the likelihood
of the most probable derivation. See (Goodman,
1999) for more information on the use of semirings
in natural language parsing.

A weighted OPHG computes a graph series, i.e.
a mapping of graphs to S. As usual, this is achieved
by assigning weights to rules.

Definition 4.1 (weighted OPHG). A weighted
OPHG G = (Σ, N, S,R, ω) (over S) consists of
an OPHG (Σ, N, S,R) and a weight assignment
ω : R→ S.

Informally speaking, if several distinct deriva-
tions can produce the same graph, we sum up the
weights of the individual derivations to obtain the
weight of the graph. The weight for a single deriva-
tion is the product of the weights of all the rules
applied.

It is inconvenient to formalise this based on
the derivations themselves because, just as in the
case of ordinary context-free grammars, derivations
may differ only in the order in which nonterminals
are replaced, which yields distinct derivations that
should be considered equivalent. A standard tech-
nique to solve this problem is to consider derivation
trees instead of derivations. We can mostly use this
standard technique, but we propose to take into
account the fact, mentioned in the introduction,
that each duplication rules has a nontrivial auto-
morphism that interchanges the nonterminals in
its right-hand side. Hence, these nonterminals are
indistinguishable. Moreover, if the rule is a clone
rule, then applying it to any of the nonterminals
in its right-hand side yields three indistinguishable
nonterminals in two different ways.

In general, suppose that a nonterminal is cloned
` times, yielding ` + 1 copies which are then
further derived into graphs g0, . . . , g` of weights
w0, . . . , w`. Then the clones can be derived by
C` different derivation trees, where C` is the `-th
Catalan number (i.e., the number of binary trees
with ` + 1 leaves). The resulting nonterminals
e0, . . . , e` can be derived into the graphs g0, . . . , g`
in any order, all leading to the same result. This
yields `!C` distinct derivations, all generating the
same graph g which consists of g0, . . . , g` fused at
their external nodes. The weight of g would thus
be w`

∑`!C`
j=1

∏`
i=0wi, where w is the weight of the

cloning rule. While there is nothing wrong with
this in principle, the fact that we only allow for this
particular type of cloning rule implies that there
would be no way to avoid the sum by writing the
rules of the grammar in a different way. Further,
since the number of terms summed up depends on
`, it cannot in general be compensated for by re-
ducing the weights of rules. We expect this to be
a limiting factor in applications, and thus propose
to represent a `-fold cloning as an unordered node
of rank `+ 1 in the derivation tree, leading to the
weight w`

∏`
i=0wi.

Let us begin the process of making these notions
more precise by recalling the notions of shallow
graphs and siblinghoods from (Björklund et al.,
2018).

Definition 4.2. A graph g is shallow if g = srcg(e)
for all e ∈ Eg. A siblinghood in g is a set
Sib ⊆ Eg such that |Sib| ≥ 2 and targ(e) =
targ(e

′) for all e, e′ ∈ Sib. We denote targ(e),
e ∈ Sib, by targ(Sib), and let g(Sib) = ({g} ∪
[targ(Sib)], Sib, attg|Sib, labg|Sib, tar), where tar
is the subsequence of targ(Sib) of nodes that are
external in g or targets of edges outside of Sib,
i.e. that belong to the set

TARg(Sib) ∩ (TARg(Eg \ Sib) ∪ [g ]).

For siblinghoods Sib,Sib′, we let Sib ≤ Sib′ if
targ(Sib) is a subsequence of targ(Sib′). A sib-
linghood of g is prime if it is maximal with respect
to both ≤ and set inclusion.

From now on, we shall for technical simplicity
assume that the considered OPHG G contains ex-
actly one clone rule for every A ∈ N . This is not
a restriction because the definition of the weight
of derived graphs to be given below ensures that
any number of clone rules for the same nontermi-
nal can be replaced by a single clone rule whose



weight is the sum of the weights of the individ-
ual rules. In particular, if there is no clone rule
for A, this has the same effect as a single clone
rule of weight 0. The weight of the unique clone
rule for A ∈ N is denoted by ω(A), and we write
→cl for the derivation relation that exclusively uses
clone rules, i.e. g →∗cl g′ if g′ is obtained from g by
cloning nonterminal edges.

The following is essentially Lemma 5.3
of (Björklund et al., 2018):
Lemma 4.3. Let A ∈ N and let g be a shallow
graph over N with |Eg| ≥ 2.

• If A• →+ g, then for every prime sibling-
hood Sib of g we either have g = g(Sib) and
A• →+cl g, or A

• →∗ h→ h[[e : f ]]→∗cl h[[e :
f ′]] = g where labh(e) → f is a twin rule
and g(Sib) = f ′.

• Up to reordering of derivation steps, the
derivations of these forms are the only ones
deriving g from A•.

Hence, a derivation of a shallow graph can be
broken down into an initial series of clonings fol-
lowed by iterated sub-derivations each consisting
of an application of a twin rule A → f and any
number of clonings of the two nonterminal edges
e1, e2 of f . Note that the result of each such sub-
derivation depends only on A → f and the num-
ber of clonings since attf (e1) = attf (e2). There-
fore, the following definition of derivation trees
uses trees in which the nodes that correspond to
derivations of siblinghoods are unordered and un-
ranked. For a tree consisting of a root labelled a
and subtrees t1, . . . , t`, we write a[t1, . . . , t`] or
a〈t1, . . . , t`〉 depending on whether t1, . . . , t` is to
be interpreted as an ordered or unordered list (or
a multiset), respectively. We write a(t1, . . . , t`) to
denote a tree in which the first level of children can
be either ordered or unordered.
Definition 4.4 (derivation tree). For a weighted
OPHG G = (Σ, N, S,R, ω) and A ∈ N , the set
of all A-derivation trees is the smallest set of trees
t belonging to one of the following three types:

(1) t = r[t1, . . . , t`] for a deep rule r = (A →
f) ∈ R such that arity (A → f) = `, and ti
is a labf (ei)-derivation tree for every i ∈ [k].

(2) t = r`〈t1, . . . , t`+1〉 for a clone rule A → f ,
where ` ≥ 1 and, for every i ∈ [` + 1], the
subtree ti is an A-derivation tree that is not
of type (2).

(3) t = r`〈t1, . . . , t`+1〉 for a twin rule A → f ,
where ` ≥ 1 and, for every i ∈ [` + 1], the
subtree ti is a labf (e1)-derivation tree that is
not of type (2).

A more rigorous and complete treatment of var-
ious issues surrounding derivation trees of graph
algebras with associative and commutative opera-
tions can be found in (Courcelle, 1991b).

We can evaluate a derivation tree to yield a
graph g in the following way: Given a deriva-
tion tree t = r(t1, . . . , t`), eval (t) is defined
as the right-hand side f of r, with each succes-
sive nonterminal ei replaced with the evaluation
of the corresponding subtree of the derivation
tree, i.e. eval ((A → f)(t1, . . . , t`)) = f [[e1 :
eval (t1), . . . , e` : eval (t`)]]. Given a graph g, we
let DTG(g) denote the set of all S-derivation trees
such that eval (t) ≡ g.

We make the following observation, whose cor-
rectness follows from the context-freeness of hy-
peredge replacement.

Observation 4.5. Let G = (Σ, N, S,R, ω), be an
OPHG. Then it holds that

L(G) = {eval (t) | t is an S-derivation tree of G}.

Now, as mentioned, the weight of a graph is de-
fined to be the sum of the weights of all its deriva-
tion trees:

Definition 4.6 (generated graph series). Let G =
(Σ, N, S,R, ω) be a weighted OPHG and A ∈ N .

1. For every duplication rule r = (A → f) ∈
R and every ` ≥ 1, let ω(r`) = ω(r) ·
ω(labf (e1))

`−1. (Note that r` corresponds to
the application of r followed by `−1 clonings
of any of the two resulting nonterminal edges.)

2. The weight of an A-derivation tree t =
r(t1, . . . , t`) (` ∈ N) is defined inductively,
as

ω(t) = ω(r) ·
∏
i∈[k]

ω(ti).

3. The graph series ωG : GΣ → S generated by
G is given by

ωG(g) =
∑

t∈DTG(g)

ω(t).

(The sum is finite, and thus well defined due
to the commutativity of +.)



Note that given G, the language L(G) of G seen
as an unweighted grammar, is a superset of the
support of G, i.e. the set of all graphs g such that
ωG(g) 6= 0.

5 Computing Weights

Our algorithm builds upon the unweighted parsing
algorithm by Björklund et al. (2018). We store
in each node and edge nothing more than an |N |-
vector of weights, which is computed in very much
the same way as the sets of nonterminals computed
in (Björklund et al., 2018). We use the distributivity
of multiplication over addition to keep our compu-
tations efficient (assuming efficient multiplication
and addition).

The algorithm exploits Lemma 3.3, i.e. the prop-
erty that the subgraphs g↓x are strictly nested in
all graphs derivable by an OPHL. Using this, it is
possible to process the subgraphs of g in a tree-like
“bottom-up” manner, marking each node and edge
x with the set of all nonterminals that can generate
g↓x, after all g↓y properly contained in g↓x have
already been processed. Eventually, S belongs to
the set which the node g is marked with if and only
if g ∈ L(G).

Order preservation enters the picture as follows:
every subgraph h of g which was derived from
some nonterminal edge, is of the form h = g↓x for
some node or edge x of g. As shown by Björklund
et al. (2018), order preservation guarantees that
h is ordered by �g. Thus, in the algorithm only
those subgraphs g↓x are of interest for which the
ordering of targets is uniquely determined by �g.
From now on, we will thus assume that, whenever
a subgraph h = g↓x is constructed, the order of
nodes in h is chosen according to �g.

To show how ωG(g) can be computed, we de-
scribe two algorithms in one: the first computes
the derivation trees of g whereas the second com-
putes its weight by summing up over all the deriva-
tion trees. In the current paper, we mainly use the
first algorithm as a tool to facilitate the correctness
proof of the second. As a consequence, we do not
present that first algorithm in a way which immedi-
ately yields an efficient algorithm, i.e., we only care
for the efficiency of the second algorithm. The set
of derivation trees computed by the first algorithm
can, however, be represented in a compact fash-
ion as a “packed forest”, which is of independent
usefulness and makes the algorithm efficient.

The main procedure of the algorithm computes,

in the same bottom-up manner as in (Björklund
et al., 2018), a set Dx(A) of A-derivation trees for
each x ∈ Vg ∪ Eg and every A ∈ N . More pre-
cisely, Dx(A) is the set of all A-derivation trees of
the input HRGG such thatA• →∗G g↓x. As the cor-
rectness of this procedure was proved by Björklund
et al. (2018) (though not explicitly in terms of
derivation trees), all that remains to be shown is
that the second version of the algorithm computes∑

t∈D
g
(S) ω(t) under the assumption that the first

one is correct.
That second algorithm computes weightsWx(A)

instead of the sets Dx(A), where Wx(A) =∑
t∈Dx(A)) ω(t). In the pseudocode, we always in-

dicate the changes that must be made to obtain the
second version by lines marked by “alt:”. The line
marked in this manner replaces its immediate pre-
decessor. For sets of (derivation) trees D1, . . . , D`
(` ∈ N) and a rule r of arity `, we furthermore
write r(D1, . . . , D`) to denote the set

{r(t1, . . . , t`) | (t1, . . . , t`) ∈ D1 × · · · ×D`}

(i.e. we use that notation in both the ordered and
unordered case).

A subroutine used by the algorithm is Algo-
rithm 1, a modified version of the corresponding
procedure in (Björklund et al., 2018). It takes as
input a shallow graph h whose edges e are already
assumed to be annotated with the respective sets
De(A). The algorithm uses Lemma 4.3 in order to
assemble – in a bottom-up manner over the prime
siblinghoods of h – the set D

h
(A). In the algo-

rithm we say that a duplication rule A → f of
G fits a siblinghood Sib = {s1, . . . , s`} of h if
f ≡ h({s1, s2}) when disregarding edge labels,
and we denote f by B•• to indicate that the two
edges in f carry the label B.

The reader should note that the result of Al-
gorithm 1 does not depend on the choice of Sib
because the prime siblinghoods Sib1, . . . ,Sibk of
h are pairwise disjoint and the replacement of
Sib = Sibi by e does not affect the siblinghoods
Sibj , j ∈ [k] \ {i} (though it may of course create
an additional prime siblinghood).

The main procedure of the parsing algorithm is
shown in Algorithm 2. In its while loop, it repeat-
edly chooses an x ∈ Vg ∪ Eg for which the sets
Dx(A) shall be computed, and calls PARSEV (Al-
gorithm 3) or PARSEE (Algorithm 4) depending on
whether x ∈ Vg or x ∈ Eg.

The function MATCHING used in line 4 of Al-



Algorithm 1 Computing Derivation Trees with Duplication Rules
1: function SHALLOWPARSE(set R of duplication rules, shallow annotated graph h with irrelevant edge

labels)
2: while |Eg| > 1 do
3: if h does not contain a prime siblinghood then
4: return (A 7→ ∅)A∈N

alt: return (A 7→ 0)A∈N
5: choose a prime siblinghood Sib = {s1, . . . , s`+1} (` ≥ 1)
6: replace Sib in h by a new edge e with tarh(e) = h(Sib)
7: for each A ∈ N do
8: De(A)←

⋃
r = (A→ B••) fits Sib r

`〈Ds1(B), . . . ,Ds`+1(B)〉
alt: We(A)←

∑
r = (A→ B••) fits Sib ω(r

`) ·
∏
i∈[`+1]Wsi(B)

9: return (A 7→ De(A))A∈N where {e} = Eh
alt: return (A 7→ We(A))A∈N where {e} = Eh

Algorithm 2 Computing Derivation Trees for Order-Preserving HR Grammars
1: function PARSE(order-preserving HR grammar G = (Σ, N, S,R), graph g ∈ GR)
2: preProcess(g) . Compute ≺g as well as all g↓x for all x ∈ Vg ∪ Eg
3: for x ∈ Vg ∪ Eg do
4: if g↓x is defined then Dx ← ⊥
5: else
6: Dx ← (A 7→ ∅)A∈N

alt: Wv ← (A 7→ 0)A∈N
7: while Dg = ⊥ do
8: let x ∈ Vg ∪ Eg with Dx = ⊥ and Dy 6= ⊥ for all y ∈ (Vg↓x ∪ Eg↓x) \ ([extg↓x ] ∪ {x})
9: if x ∈ Vg then PARSEV(x)

10: else PARSEE(x)
11: return Dg(S)

alt: returnWg(S)

Algorithm 3 Computing Derivations Trees of g↓v for nodes v ∈ Vg
1: function PARSEV(node v such that De(A) 6= ⊥ for all e ∈ Eg with srcg(e) = v)
2: if v has out-degree 0 then
3: Dv ← (A 7→ ∅)A∈N

alt: Wv ← (A 7→ 0)A∈N
4: else
5: initialize h = (V,E, att, lab, ext) as the following shallow graph:
6: E = {e ∈ Eg | srcg(e) = v}
7: V = {v} ∪

⋃
e∈E reentg(e)

8: ext = extg↓v
9: att(e) = vw, where w is reentg(e) ordered by �g, for each e ∈ E

10: Dv ← SHALLOWPARSE({r ∈ R | r a duplication rule}, h)
alt: Wv ← SHALLOWPARSE({r ∈ R | r a duplication rule}, h)



Algorithm 4 Computing Derivations Trees of g↓e for edges e ∈ Eg
1: function PARSEE(edge e s.t. Dy 6= ⊥ for all y ∈ (Vg(x) ∪ Eg(x)) \ ([extg(x)] ∪ {x}))
2: De(A)← ∅ for all A ∈ N

alt: We(A)← 0 for all A ∈ N
3: for each deep rule r = (A→ f) of arity ` do
4: φ← MATCHING(f, e)
5: if φ 6= null then
6: De(A)← De(A) ∪ r[Dφ(srcf (e1))(labf (e1)), . . . ,Dφ(srcf (e`))(labf (e`))]

alt: We(A)←We(A) + ω(r) ·
∏
i∈[`]Wφ(srcf (ei))(labf (ei))}

gorithm 4 is described by Björklund et al. (2018)
(using slightly different notation). It is based on
the fact that, if g↓e can be derived from a deep
right-hand side f , then the mapping φ of the nodes
in f to their images in g↓e is uniquely determined
by f and the reentrancies in g↓e, due to reentrancy
and order preservation. As proved by Björklund
et al. (2018), this makes it furthermore possible to
compute φ = MATCHING(f, e) in linear time.

As mentioned above, the correctness of the com-
putation of the sets Dx(A) was essentially shown
by Björklund et al. (2018), and so we take it for
granted here and use that fact to show inductively
that the second version of the algorithm correctly
computes the weights. Below, we assume for
the sake of technical simplicity that the opera-
tions of the semiring S are computable in constant
time. Clearly, the efficiency of the algorithm de-
creases accordingly if the operations a more com-
plex. However, by the closedness of the class of
polynomials under composition, the computation
of weights stays polynomial whenever the opera-
tions of S are computable in polynomial time with
respect to the input graph and the HRG.

Theorem 5.1. Let ≺ be a suitable family of or-
ders, and let η be a function mapping graphs to
N such that both η(g) and ≺g can be computed
in time η(g).3 Then there is an algorithm which
takes as input a graph g and an OPHG grammar
G = (Σ, N, S,R, ω), and computes ωG(g) in time
O(η(g) + |g|2 + |G|2).

Proof. With straightforward reformulations, the
proof of the main theorem in (Björklund et al.,
2018) shows that Algorithm 2 computes DTG(g)
and runs in time O(η(g) + |g|2 + |G|2) if the time
required for the explicit construction of deriva-

3The function η describes the complexity of computing
≺g , and the condition that it can be executed in time η(g)
corresponds to the usual requirement of time constructibility.

tion trees is neglected.4 Together with the as-
sumption that the operations of S can be com-
puted in constant time, the latter means that the
weight-computing version of Algorithm 2 runs in
time O(η(g) + |g|2 + |G|2) as well. To complete
the proof, it thus suffices to prove by induction
that Algorithms 1–4 maintain the invariant that
Wx(A) =

∑
t∈Dx(A) ω(t) for those edges and

nodes x and those A ∈ N such that Dx(A) 6= ⊥.
In the proof, for a set D of derivation trees,

we abbreviate
∑

t∈D ω(t) by ω(D). We check
the algorithms one by one. Note that the induc-
tion hypothesis states that the equationWx(A) =
ω(Dx(A)) holds when the respective procedure is
entered, and we have to show that it still holds af-
terwards. We use the fact that, by distributivity,
for every rule r = (A→ f) of arity ` and all sets
D1, . . . , D` of derivation trees, it holds that

ω(r(D1, . . . , D`)) = ω(r) ·
∏
i∈[`]

ω(Di). (1)

Procedure SHALLOWPARSE: We have to show
that the two lines in the body of the loop starting
in line 7 maintain the invariant. These lines change
only De(A) andWe(A), and after those two lines
we have, for a rule r = (A→ B••) that fits Sib

We(A) =
∑

ω(r`) ·
∏

i∈[`+1]

Wsi(B)

=
∑

ω(r`) ·
∏

i∈[`+1]

ω(Dsi(B))

=
∑

ω(r`〈Ds1(B), . . . ,Ds`+1(B)〉)

= ω(De(A)).

Procedure PARSE: Only line 6 affects some
Dx(A) and Wx(A). These lines obviously pre-
serve the invariant.

4Instead of computing the sets Dx(A), the algorithm
in (Björklund et al., 2018) only computes, for every x ∈
Vg ∪ Eg , the set of all A ∈ N such that Dx(A) 6= ∅.



Procedure PARSEV: As before, line 3 respects
the invariant. Concerning line 10, note that the
two versions of SHALLOWPARSE return (A 7→
De(A))A∈N and (A 7→ We(A))A∈N , respec-
tively, for some edge e. By induction hypothesis,
We(A) = ω(De(A)) for all A ∈ N , which com-
pletes the argument.

Procedure PARSEE: Once more, line 2 respects
the invariant. Furthermore, if D = De(A) and
W =We(A) = ω(De(A)) before an execution of
line 6 then, after this line,

We(A) = W + ω(r) ·
∏
i∈[`]

Wφ(srcf (ei))(labf (ei))}

= ω(D) + ω(r) ·
∏
i∈[`]

ω(Dφ(srcf (ei))(labf (ei)))

= ω(D) + ω(r[Dφ(srcf (e1))(labf (e1)),
...

Dφ(srcf (e`))(labf (e`))]
= ω(De(A)).

This completes the correctness proof of the theo-
rem.

As indicated before, it is worthwhile noticing
that the first version of the parsing algorithm com-
putes the set DTG(g) in timeO(η(g)+|g|2 +|G|2)
if the sets Dx(A) are represented in a compact way
as packed forests. This may be useful for further
applications.

6 Conclusions

Semantic parsing is a necessary tool for the im-
provement of any number of natural language pro-
cessing tools and the use of graphs as semantic
models is becoming a standard approach. Abstract
Meaning Representation is one example. There is,
however no formal standard, and the algorithmic is-
sues involved are largely unexplored. In particular,
there are hardly any models for the formal descrip-
tion of weighted semantic graphs, despite the im-
portance of probabilities and other kinds of weights
in natural language processing for, e.g., resolving
ambituities. In this contribution, we have taken
a step towards resolving this situation by show-
ing that order-preserving hyperedge replacement
grammars can be extended with weights, without
signficantly affecting the complexity of analysing a
graph with respect to the grammar. We thus hope to
have provided a useful building block for making
semantic parsing practical.

To allow for efficient parsing, order-preserving
hyperedge replacement grammars allow only for
restricted forms of rules. In particular, the only way
to create nodes of unlimited out-degree is to use
so-called clone rules. Since clone rules are asso-
ciative and commutative, we have opted to view
the corresponding sections of the resulting deriva-
tion trees as unordered nodes of the appropriate de-
gree and define the weight of these substructures as
w`
∏`
i=0wi, where w is the weight of the cloning

rule (which is applied ` times) and w0, . . . , w` are
the weights of the subderivations. It may be worth-
while noting that, in cases where this is too restric-
tive, one may use a commutative product valuation
monoid (Droste and Meinecke, 2010) as a weight
structure. Such a valuation monoid comes with an
additional valuation function val which takes an ar-
bitrary multiset of weights to a generalized product.
Then the expression above may be generalized to
w` · val(w0, . . . , w`) without making parsing more
difficult.

References
Laura Banarescu, Claire Bonial, Shu Cai, Madalina

Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proc. 7th Linguistic Annotation
Workshop, ACL 2013 Workshop.

Michel Bauderon and Bruno Courcelle. 1987. Graph
expressions and graph rewriting. Mathematical Sys-
tems Theory, 20:83–127.

Henrik Björklund, Frank Drewes, and Petter Ericson.
2016. Between a rock and a hard place – uniform
parsing for hyperedge replacement DAG grammars.
In Proc. 10th Intl. Conf. on Language and Automata
Theory and Applications, volume 9618 of Lecture
Notes in Computer Science, pages 521–532.

Henrik Björklund, Frank Drewes, Petter Ericson,
and Florian Starke. 2018. Uniform parsing
for hyperedge replacement grammars. Tech-
nical Report UMINF 18.13, Umeå University,
http://www8.cs.umu.se/research/uminf/index.cgi.
Submitted for publication.

Henrik Björklund, Johanna Björklund, and Petter Eric-
son. 2017. On the regularity and learnability of or-
dered DAG languages. In Proc. 22nd International
Conference on the Implementation and Application
of Automata (CIAA’17), volume 10329 of Lecture
Notes in Computer Science, pages 27–39. Springer.

David Chiang, Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, Bevan Jones, and Kevin
Knight. 2013. Parsing graphs with hyperedge



replacement grammars. In Proc. 51st Annual
Meeting of the Association for Computational
Linguistics (ACL 2013), Volume 1: Long Papers,
pages 924–932. The Association for Computer
Linguistics.

David Chiang, Frank Drewes, Daniel Gildea, Adam
Lopez, and Giorgio Satta. 2018. Weighted DAG au-
tomata for semantic graphs. Computational Linguis-
tics, 44:119–186.

Bruno Courcelle. 1991a. The monadic second-order
logic of graphs V: on closing the gap between de-
finability and recognizability. Theoretical Computer
Science, 80:153–202.

Bruno Courcelle. 1991b. The monadic second-order
logic of graphs V: On closing the gap between de-
finability and recognizability. Theoretical Computer
Science, 80(2):153–202.

Bruno Courcelle and Joost Engelfriet. 2012. Graph
Structure and Monadic Second-Order Logic – A
Language-Theoretic Approach. Cambridge Univer-
sity Press.

Frank Drewes, Annegret Habel, and Hans-Jörg Kre-
owski. 1997. Hyperedge replacement graph gram-
mars. In G. Rozenberg, editor, Handbook of Graph
Grammars and Computing by Graph Transforma-
tion. Vol. 1: Foundations, chapter 2, pages 95–162.
World Scientific.

Frank Drewes, Berthold Hoffmann, and Mark Minas.
2015. Predictive top-down parsing for hyperedge
replacement grammars. In Proc. 8th Intl. Conf. on
Graph Transformation (ICGT’15), Lecture Notes in
Computer Science.

Frank Drewes, Berthold Hoffmann, and Mark Minas.
2017. Predictive shift-reduce parsing for hyperedge
replacement grammars. In Proc. 10th Intl. Conf. on
Graph Transformation (ICGT’17), volume 10373 of
Lecture Notes in Computer Science, pages 106–122.

Manfred Droste and Ingmar Meinecke. 2010. Describ-
ing average- and longtime-behavior by weighted
mso logics. In Proc. 35th Intl. Symp. on Mathemati-
cal Foundations of Computer Science (MFCS 2010),
volume 6281 of Lecture Notes in Computer Science,
pages 537–548.

Sorcha Gilroy, Adam Lopez, and Sebastian Maneth.
2017. Parsing graphs with regular graph grammars.
In Proc. 6th Joint Conf. on Lexical and Computa-
tional Semantics (*SEM 2017), pages 199–208.

Joshua Goodman. 1999. Semiring parsing. Computa-
tional Linguistics, 25:573–605.

Jonas Groschwitz, Alexander Koller, and Christoph Te-
ichmann. 2015. Graph parsing with s-graph gram-
mars. In Proc. 53rd Ann. Meeting of the Association
for Computational Linguistics and the 7th Intl. Joint
Conf. on Natural Language Processing (Volume 1:
Long Papers), pages 1481–1490.

Annegret Habel. 1992. Hyperedge Replacement:
Grammars and Languages, volume 643 of Lecture
Notes in Computer Science. Springer.

Annegret Habel and Hans-Jörg Kreowski. 1987. May
we introduce to you: Hyperedge replacement. In
Proceedings of the Third Intl. Workshop on Graph
Grammars and Their Application to Computer Sci-
ence, volume 291 of Lecture Notes in Computer Sci-
ence, pages 15–26. Springer.

Bevan Jones, Jacob Andreas, Daniel Bauer,
Karl Moritz Hermann, and Kevin Knight. 2012.
Semantics-based machine translation with hy-
peredge replacement grammars. In Proc. 24th
Intl. Conf. on Computational Linguistics (COL-
ING 2012): Technical Papers, pages 1359–1376.

Alexander Koller. 2015. Semantic construction with
graph grammars. In Proc. 11th Intl. Conf. on Com-
putational Semantics, pages 228–238.


