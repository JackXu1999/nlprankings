



















































Semantic Parsing for Single-Relation Question Answering


Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Short Papers), pages 643–648,
Baltimore, Maryland, USA, June 23-25 2014. c©2014 Association for Computational Linguistics

Semantic Parsing for Single-Relation Question Answering

Wen-tau Yih Xiaodong He Christopher Meek
Microsoft Research

Redmond, WA 98052, USA
{scottyih,xiaohe,meek}@microsoft.com

Abstract

We develop a semantic parsing framework
based on semantic similarity for open do-
main question answering (QA). We focus
on single-relation questions and decom-
pose each question into an entity men-
tion and a relation pattern. Using convo-
lutional neural network models, we mea-
sure the similarity of entity mentions with
entities in the knowledge base (KB) and
the similarity of relation patterns and re-
lations in the KB. We score relational
triples in the KB using these measures
and select the top scoring relational triple
to answer the question. When evaluated
on an open-domain QA task, our method
achieves higher precision across different
recall points compared to the previous ap-
proach, and can improve F1 by 7 points.

1 Introduction

Open-domain question answering (QA) is an im-
portant and yet challenging problem that remains
largely unsolved. In this paper, we focus on an-
swering single-relation factual questions, which
are the most common type of question observed in
various community QA sites (Fader et al., 2013),
as well as in search query logs. We assumed
such questions are answerable by issuing a single-
relation query that consists of the relation and an
argument entity, against a knowledge base (KB).
Example questions of this type include: “Who is
the CEO of Tesla?” and “Who founded Paypal?”

While single-relation questions are easier to
handle than questions with more complex and
multiple relations, such as “When was the child of
the former Secretary of State in Obama’s admin-
istration born?”, single-relation questions are still
far from completely solved. Even in this restricted
domain there are a large number of paraphrases of

the same question. That is to say that the problem
of mapping from a question to a particular relation
and entity in the KB is non-trivial.

In this paper, we propose a semantic parsing
framework tailored to single-relation questions.
At the core of our approach is a novel semantic
similarity model using convolutional neural net-
works. Leveraging the question paraphrase data
mined from the WikiAnswers corpus by Fader et
al. (2013), we train two semantic similarity mod-
els: one links a mention from the question to an
entity in the KB and the other maps a relation pat-
tern to a relation. The answer to the question can
thus be derived by finding the relation–entity triple
r(e1, e2) in the KB and returning the entity not
mentioned in the question. By using a general se-
mantic similarity model to match patterns and re-
lations, as well as mentions and entities, our sys-
tem outperforms the existing rule learning system,
PARALEX (Fader et al., 2013), with higher pre-
cision at all the recall points when answering the
questions in the same test set. The highest achiev-
able F1 score of our system is 0.61, versus 0.54 of
PARALEX.

The rest of the paper is structured as follows.
We first survey related work in Sec. 2, followed by
the problem definition and the high-level descrip-
tion of our approach in Sec. 3. Sec. 4 details our
semantic models and Sec. 5 shows the experimen-
tal results. Finally, Sec. 6 concludes the paper.

2 Related Work

Semantic parsing of questions, which maps nat-
ural language questions to database queries, is
a critical component for KB-supported QA. An
early example of this research is the semantic
parser for answering geography-related questions,
learned using inductive logic programming (Zelle
and Mooney, 1996). Research in this line origi-
nally used small, domain-specific databases, such
as GeoQuery (Tang and Mooney, 2001; Liang et

643



al., 2013). Very recently, researchers have started
developing semantic parsers for large, general-
domain knowledge bases like Freebase and DB-
pedia (Cai and Yates, 2013; Berant et al., 2013;
Kwiatkowski et al., 2013). Despite significant
progress, the problem remains challenging. Most
methods have not yet been scaled to large KBs
that can support general open-domain QA. In con-
trast, Fader et al. (2013) proposed the PARALEX
system, which targets answering single-relation
questions using an automatically created knowl-
edge base, ReVerb (Fader et al., 2011). By
applying simple seed templates to the KB and
by leveraging community-authored paraphrases of
questions from WikiAnswers, they successfully
demonstrated a high-quality lexicon of pattern-
matching rules can be learned for this restricted
form of semantic parsing.

The other line of work related to our approach
is continuous representations for semantic simi-
larity, which has a long history and is still an
active research topic. In information retrieval,
TF-IDF vectors (Salton and McGill, 1983), latent
semantic analysis (Deerwester et al., 1990) and
topic models (Blei et al., 2003) take the bag-of-
words approach, which captures well the contex-
tual information for documents, but is often too
coarse-grained to be effective for sentences. In
a separate line of research, deep learning based
techniques have been proposed for semantic un-
derstanding (Mesnil et al., 2013; Huang et al.,
2013; Shen et al., 2014b; Salakhutdinov and Hin-
ton, 2009; Tur et al., 2012). We adapt the work
of (Huang et al., 2013; Shen et al., 2014b) for mea-
suring the semantic distance between a question
and relational triples in the KB as the core compo-
nent of our semantic parsing approach.

3 Problem Definition & Approach

In this paper, we focus on using a knowledge
base to answer single-relation questions. A single-
relation question is defined as a question com-
posed of an entity mention and a binary rela-
tion description, where the answer to this ques-
tion would be an entity that has the relation with
the given entity. An example of a single-relation
question is “When were DVD players invented?”
The entity is dvd-player and the relation is
be-invent-in. The answer can thus be de-
scribed as the following lambda expression:

λx. be-invent-in(dvd-player, x)

Q→ RP ∧M (1)
RP → when were X invented (2)
M → dvd players (3)

when were X invented

→ be-invent-in (4)
dvd players

→ dvd-player (5)

Figure 1: A potential semantic parse of the ques-
tion “When were DVD players invented?”

A knowledge base in this work can be simply
viewed as a collection of binary relation instances
in the form of r(e1, e2), where r is the relation and
e1 and e2 are the first and second entity arguments.

Single-relation questions are perhaps the easiest
form of questions that can directly be answered
by a knowledge base. If the mapping of the re-
lation and entity in the question can be correctly
resolved, then the answer can be derived by a sim-
ple table lookup, assuming that the fact exists in
the KB. However, due to the large number of para-
phrases of the same question, identifying the map-
ping accurately remains a difficult problem.

Our approach in this work can be viewed as a
simple semantic parser tailored to single-relation
questions, powered by advanced semantic similar-
ity models to handle the paraphrase issue. Given a
question, we first separate it into two disjoint parts:
the entity mention and the relation pattern. The
entity mention is a subsequence of consecutive
words in the question, where the relation pattern
is the question where the mention is substituted
by a special symbol. The mapping between the
pattern and the relation in the KB, as well as the
mapping between the mention and the entity are
determined by corresponding semantic similarity
models. The high-level approach can be viewed
as a very simple context-free grammar, which is
shown in Figure 1.

The probability of the rule in (1) is 1 since
we assume the input is a single-relation ques-
tion. For the exact decomposition of the ques-
tion (e.g., (2), (3)), we simply enumerate all com-
binations and assign equal probabilities to them.
The performance of this approach depends mainly
on whether the relation pattern and entity mention
can be resolved correctly (e.g., (4), (5)). To deter-

644



15K 15K 15K 15K 15K

500 500 500

max max

...

...

... max

500

...

...

Word hashing layer: ft

Convolutional layer: ht

Max pooling layer: v

Semantic layer: y

     <s>             w1              w2                     wT             <s>Word sequence: xt

Word hashing matrix: Wf

Convolution matrix: Wc

Max pooling operation

Semantic projection matrix: Ws

... ...

500

Figure 2: The CNNSM maps a variable-length
word sequence to a low-dimensional vector in a
latent semantic space. A word contextual window
size (i.e., the receptive field) of three is used in the
illustration. Convolution over word sequence via
learned matrix Wc is performed implicitly via the
earlier word hashing layer’s mapping with a local
receptive field. The max operation across the se-
quence is applied for each of 500 feature dimen-
sions separately.

mine the probabilities of such mappings, we pro-
pose using a semantic similarity model based on
convolutional neural networks, which is the tech-
nical focus in this paper.

4 Convolutional Neural Network based
Semantic Model

Following (Collobert et al., 2011; Shen et al.,
2014b), we develop a new convolutional neural
network (CNN) based semantic model (CNNSM)
for semantic parsing. The CNNSM first uses a
convolutional layer to project each word within a
context window to a local contextual feature vec-
tor, so that semantically similar word-n-grams are
projected to vectors that are close to each other
in the contextual feature space. Further, since the
overall meaning of a sentence is often determined
by a few key words in the sentence, CNNSM uses
a max pooling layer to extract the most salient lo-
cal features to form a fixed-length global feature
vector. The global feature vector can be then fed
to feed-forward neural network layers to extract
non-linear semantic features. The architecture of
the CNNSM is illustrated in Figure 2. In what fol-
lows, we describe each layer of the CNNSM in
detail, using the annotation illustrated in Figure 2.

In our model, we leverage the word hash-
ing technique proposed in (Huang et al., 2013)
where we first represent a word by a letter-
trigram count vector. For example, given a
word (e.g., cat), after adding word boundary sym-
bols (e.g., #cat#), the word is segmented into a se-
quence of letter-n-grams (e.g., letter-trigrams: #-
c-a, c-a-t, a-t-#). Then, the word is represented
as a count vector of letter-trigrams. For exam-
ple, the letter-trigram representation of “cat” is:

In Figure 2, the word hashing matrix Wf de-
notes the transformation from a word to its letter-
trigram count vector, which requires no learning.
Word hashing not only makes the learning more
scalable by controlling the size of the vocabulary,
but also can effectively handle the OOV issues,
sometimes due to spelling mistakes. Given the
letter-trigram based word representation, we rep-
resent a word-n-gram by concatenating the letter-
trigram vectors of each word, e.g., for the t-th
word-n-gram at the word-n-gram layer, we have:

lt =
[
fTt−d, · · · , fTt , · · · , fTt+d

]T
, t = 1, · · · , T

where ft is the letter-trigram representation of the
t-th word, and n = 2d + 1 is the size of the con-
textual window. The convolution operation can
be viewed as sliding window based feature extrac-
tion. It captures the word-n-gram contextual fea-
tures. Consider the t-th word-n-gram, the convo-
lution matrix projects its letter-trigram representa-
tion vector lt to a contextual feature vector ht. As
shown in Figure 2, ht is computed by

ht = tanh(Wc · lt), t = 1, · · · , T
where Wc is the feature transformation matrix, as
known as the convolution matrix, which are shared
among all word n-grams. The output of the con-
volutional layer is a sequence of local contextual
feature vectors, one for each word (within a con-
textual window). Since many words do not have
significant influence on the semantics of the sen-
tence, we want to retain in the global feature vector
only the salient features from a few key words. For
this purpose, we use a max operation, also known
as max pooling, to force the network to retain only

645



the most useful local features produced by the con-
volutional layers. Referring to the max-pooling
layer of Figure 2, we have

v(i) = max
t=1,··· ,T

{ft(i)}, i = 1, · · · ,K

where v(i) is the i-th element of the max pool-
ing layer v, ht(i) is the i-th element of the t-th
local feature vector ht. K is the dimensionality
of the max pooling layer, which is the same as
the dimensionality of the local contextual feature
vectors {ht}. One more non-linear transformation
layer is further applied on top of the global feature
vector v to extract the high-level semantic repre-
sentation, denoted by y. As shown in Figure 2, we
have y = tanh(Ws · v), where v is the global fea-
ture vector after max pooling, Ws is the semantic
projection matrix, and y is the vector representa-
tion of the input query (or document) in latent se-
mantic space. Given a pattern and a relation, we
compute their relevance score by measuring the
cosine similarity between their semantic vectors.
The semantic relevance score between a pattern Q
and a relation R is defined as the cosine score of
their semantic vectors yQ and yR.

We train two CNN semantic models from sets of
pattern–relation and mention–entity pairs, respec-
tively. Following (Huang et al., 2013), for every
pattern, the corresponding relation is treated as a
positive example and 100 randomly selected other
relations are used as negative examples. The set-
ting for the mention–entity model is similar.

The posterior probability of the positive relation
given the pattern is computed based on the cosine
scores using softmax:

P (R+|Q) = exp(γ · cos(yR+ , yQ))∑
R′ exp(γ · cos(yR′ , yQ))

where γ is a scaling factor set to 5. Model train-
ing is done by maximizing the log-posteriori us-
ing stochastic gradient descent. More detail can
be found in (Shen et al., 2014a).

5 Experiments

In order to provide a fair comparison to previ-
ous work, we experimented with our approach
using the PARALAX dataset (Fader et al., 2013),
which consists of paraphrases of questions mined
from WikiAnswers and answer triples from Re-
Verb. In this section, we briefly introduce the
dataset, describe the system training and evalua-
tion processes and, finally, present our experimen-
tal results.

5.1 Data & Model Training

The PARALEX training data consists of ap-
proximately 1.8 million pairs of questions and
single-relation database queries, such as “When
were DVD players invented?”, paired with
be-invent-in(dvd-player,?). For eval-
uation, the authors further sampled 698 questions
that belong to 37 clusters and hand labeled the an-
swer triples returned by their systems.

To train our two CNN semantic models, we
derived two parallel corpora based on the PAR-
ALEX training data. For relation patterns, we first
scanned the original training corpus to see if there
was an exact surface form match of the entity (e.g.,
dvd-player would map to “DVD player” in the
question). If an exact match was found, then the
pattern would be derived by replacing the mention
in the question with the special symbol. The corre-
sponding relation of this pattern was thus the rela-
tion used in the original database query, along with
the variable argument position (i.e., 1 or 2, indicat-
ing whether the answer entity was the first or sec-
ond argument of the relation). In the end, we de-
rived about 1.2 million pairs of patterns and rela-
tions. We then applied these patterns to all the 1.8
million training questions, which helped discover
160 thousand new mentions that did not have the
exact surface form matches to the entities.

When training the CNNSM for the pattern–
relation similarity measure, we randomly split the
1.2 million pairs of patterns and relations into two
sets: the training set of 1.19 million pairs, and
the validation set of 12 thousand pairs for hyper-
parameter tuning. Data were tokenized by re-
placing hyphens with blank spaces. In the ex-
periment, we used a context window (i.e., the re-
ceptive field) of three words in the convolutional
neural networks. There were 15 thousand unique
letter-trigrams observed in the training set (used
for word hashing). Five hundred neurons were
used in the convolutional layer, the max-pooling
layer and the final semantic layer, respectively.
We used a learning rate of 0.002 and the train-
ing converged after 150 iterations. A similar set-
ting was used for the CNNSM for the mention–
entity model, which was trained on 160 thousand
mention-entity pairs.

5.2 Results

We used the same test questions in the PARALEX
dataset to evaluate whether our system could find

646



F1 Precision Recall MAP
CNNSMpm 0.57 0.58 0.57 0.28
CNNSMp 0.54 0.61 0.49 0.20
PARALEX 0.54 0.77 0.42 0.22

Table 1: Performance of two variations of our sys-
tems, compared with the PARALEX system.

the answers from the ReVerb database. Because
our systems might find triples that were not re-
turned by the PARALEX systems, we labeled these
new question–triple pairs ourselves.

Given a question, the system first enumerated
all possible decompositions of the mentions and
patterns, as described earlier. We then computed
the similarity scores between the pattern and all
relations in the KB and retained 150 top-scoring
relation candidates. For each selected relation, the
system then checked all triples in the KB that had
this relation and computed the similarity score be-
tween the mention and corresponding argument
entity. The product of the probabilities of these
two models, which are derived from the cosine
similarity scores using softmax as described in
Sec. 4, was used as the final score of the triple for
ranking the answers. The top answer triple was
used to compute the precision and recall of the sys-
tem when reporting the system performance. By
limiting the systems to output only answer triples
with scores higher than a predefined threshold, we
could control the trade-off between recall and pre-
cision and thus plot the precision–recall curve.

Table 1 shows the performance in F1, preci-
sion, recall and mean average precision of our sys-
tems and PARALEX. We provide two variations
here. CNNSMpm is the full system and consists
of two semantic similarity models for pattern–
relation and mention–entity. The other model,
CNNSMp, only measures the similarity between
the patterns and relations, and maps a mention to
an entity when they have the same surface form.

Since the trade-off between precision and re-
call can be adjusted by varying the threshold, it
is more informative to compare systems on the
precision–recall curves, which are shown in Fig-
ure 3. As we can observe from the figure, the
precision of our CNNSMpm system is consistently
higher than PARALEX across all recall regions.
The CNNSMm system also performs similarly to
CNNSMpm in the high precision regime, but is in-
ferior when recall is higher. This is understandable

 0.5

 0.6

 0.7

 0.8

 0.9

 1

 0  0.1  0.2  0.3  0.4  0.5  0.6

Pr
ec

is
io

n

Recall

  CNNSMpm
  CNNSMp
  Paralex

Figure 3: The precision–recall curves of the two
variations of our systems and PARALEX.

since the system does not match mentions with
entities of different surface forms (e.g., “Robert
Hooke” to “Hooke”). Notice that the highest F1
values of them are 0.61 and 0.56, compared to
0.54 of PARALEX. Tuning the thresholds using a
validation set would be needed if there is a metric
(e.g., F1) that specifically needs to be optimized.

6 Conclusions

In this work, we propose a semantic parsing
framework for single-relation questions. Com-
pared to the existing work, our key insight is to
match relation patterns and entity mentions using
a semantic similarity function rather than lexical
rules. Our similarity model is trained using convo-
lutional neural networks with letter-trigrams vec-
tors. This design helps the model go beyond bag-
of-words representations and handles the OOV is-
sue. Our method achieves higher precision on the
QA task than the previous work, PARALEX, con-
sistently at different recall points.

Despite the strong empirical performance, our
system has room for improvement. For in-
stance, due to the variety of entity mentions in
the real world, the parallel corpus derived from
the WikiAnswers data and ReVerb KB may not
contain enough data to train a robust entity link-
ing model. Replacing this component with a
dedicated entity linking system could improve
the performance and also reduce the number of
pattern/mention candidates when processing each
question. In the future, we would like to extend
our method to other more structured KBs, such as
Freebase, and to explore approaches to extend our
system to handle multi-relation questions.

647



References
Jonathan Berant, Andrew Chou, Roy Frostig, and Percy

Liang. 2013. Semantic parsing on Freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1533–1544, Seattle, Wash-
ington, USA, October. Association for Computa-
tional Linguistics.

David M Blei, Andrew Y Ng, and Michael I Jordan.
2003. Latent dirichlet allocation. the Journal of ma-
chine Learning research, 3:993–1022.

Qingqing Cai and Alexander Yates. 2013. Large-
scale semantic parsing via schema matching and lex-
icon extension. In Proceedings of the 51st Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers), pages 423–433,
Sofia, Bulgaria, August. Association for Computa-
tional Linguistics.

Ronan Collobert, Jason Weston, Leon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
scratch. Journal of Machine Learning Research.

Scott Deerwester, Susan Dumais, Thomas Landauer,
George Furnas, and Richard Harshman. 1990. In-
dexing by latent semantic analysis. Journal of the
American Society for Information Science, 41(6).

Anthony Fader, Stephen Soderland, and Oren Etzioni.
2011. Identifying relations for open information ex-
traction. In Proceedings of the Conference of Em-
pirical Methods in Natural Language Processing
(EMNLP ’11), Edinburgh, Scotland, UK, July 27-
31.

Anthony Fader, Luke Zettlemoyer, and Oren Etzioni.
2013. Paraphrase-driven learning for open question
answering. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguis-
tics (Volume 1: Long Papers), pages 1608–1618,
Sofia, Bulgaria, August. Association for Computa-
tional Linguistics.

Po-Sen Huang, Xiaodong He, Jianfeng Gao, Li Deng,
Alex Acero, and Larry Heck. 2013. Learning deep
structured semantic models for web search using
clickthrough data. In Proceedings of the 22nd ACM
international conference on Conference on informa-
tion & knowledge management, pages 2333–2338.
ACM.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and Luke
Zettlemoyer. 2013. Scaling semantic parsers with
on-the-fly ontology matching. In Proceedings of
the 2013 Conference on Empirical Methods in Natu-
ral Language Processing, pages 1545–1556, Seattle,
Washington, USA, October. Association for Compu-
tational Linguistics.

Percy Liang, Michael I Jordan, and Dan Klein. 2013.
Learning dependency-based compositional seman-
tics. Computational Linguistics, 39(2):389–446.

Grégoire Mesnil, Xiaodong He, Li Deng, and Yoshua
Bengio. 2013. Investigation of recurrent-neural-
network architectures and learning methods for spo-
ken language understanding. In Interspeech.

Ruslan Salakhutdinov and Geoffrey Hinton. 2009. Se-
mantic hashing. International Journal of Approxi-
mate Reasoning, 50(7):969–978.

Gerard Salton and Michael J. McGill. 1983. Intro-
duction to Modern Information Retrieval. McGraw
Hill.

Yelong Shen, Xiaodong He, Jianfeng Gao, Li Deng,
and Grégoire Mesnil. 2014a. A convolutional latent
semantic model for web search. Technical Report
MSR-TR-2014-55, Microsoft Research.

Yelong Shen, Xiaodong He, Jianfeng Gao, Li Deng,
and Grégoire Mesnil. 2014b. Learning semantic
representations using convolutional neural networks
for web search. In Proceedings of the Companion
Publication of the 23rd International Conference on
World Wide Web Companion, pages 373–374.

Lappoon Tang and Raymond Mooney. 2001. Using
multiple clause constructors in inductive logic pro-
gramming for semantic parsing. In Machine Learn-
ing: ECML 2001, pages 466–477. Springer.

Gokhan Tur, Li Deng, Dilek Hakkani-Tur, and Xi-
aodong He. 2012. Towards deeper understanding:
deep convex networks for semantic utterance classi-
fication. In Acoustics, Speech and Signal Processing
(ICASSP), 2012 IEEE International Conference on,
pages 5045–5048. IEEE.

John Zelle and Raymond Mooney. 1996. Learning
to parse database queries using inductive logic pro-
gramming. In Proceedings of the National Confer-
ence on Artificial Intelligence, pages 1050–1055.

648


