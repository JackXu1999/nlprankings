











































Constituent Parsing as Sequence Labeling


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 1314–1324
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

1314

Constituent Parsing as Sequence Labeling

Carlos Gómez-Rodrı́guez
Universidade da Coruña

FASTPARSE Lab, LyS Group
Departamento de Computación
Campus de Elviña s/n, 15071

A Coruña, Spain
carlos.gomez@udc.es

David Vilares
Universidade da Coruña

FASTPARSE Lab, LyS Group
Departamento de Computación
Campus de Elviña s/n, 15071

A Coruña, Spain
david.vilares@udc.es

Abstract

We introduce a method to reduce constituent
parsing to sequence labeling. For each word
wt, it generates a label that encodes: (1) the
number of ancestors in the tree that the words
wt andwt+1 have in common, and (2) the non-
terminal symbol at the lowest common ances-
tor. We first prove that the proposed encoding
function is injective for any tree without unary
branches. In practice, the approach is made
extensible to all constituency trees by collaps-
ing unary branches. We then use the PTB and
CTB treebanks as testbeds and propose a set of
fast baselines. We achieve 90% F-score on the
PTB test set, outperforming the Vinyals et al.
(2015) sequence-to-sequence parser. In addi-
tion, sacrificing some accuracy, our approach
achieves the fastest constituent parsing speeds
reported to date on PTB by a wide margin.

1 Introduction

Constituent parsing is a core problem in NLP
where the goal is to obtain the syntactic structure
of sentences expressed as a phrase structure tree.

Traditionally, constituent-based parsers have
been built relying on chart-based, statistical mod-
els (Collins, 1997; Charniak, 2000; Petrov et al.,
2006), which are accurate but slow, with typical
speeds well below 10 sentences per second on
modern CPUs (Kummerfeld et al., 2012).

Several authors have proposed more efficient
approaches which are helpful to gain speed while
preserving (or even improving) accuracy. Sagae
and Lavie (2005) present a classifier for con-
stituency parsing that runs in linear time by re-
lying on a shift-reduce stack-based algorithm, in-
stead of a grammar. It is essentially an ex-
tension of transition-based dependency parsing
(Nivre, 2003). This line of research has been
polished through the years (Wang et al., 2006;
Zhu et al., 2013; Dyer et al., 2016; Liu and

Zhang, 2017; Fernández-González and Gómez-
Rodrı́guez, 2018).

With an aim more related to our work, other au-
thors have reduced constituency parsing to tasks
that can be solved faster or in a more generic
way. Fernández-González and Martins (2015) re-
duce phrase structure parsing to dependency pars-
ing. They propose an intermediate representation
where dependency labels from a head to its de-
pendents encode the nonterminal symbol and an
attachment order that is used to arrange nodes
into constituents. Their approach makes it pos-
sible to use off-the-shelf dependency parsers for
constituency parsing. In a different line, Vinyals
et al. (2015) address the problem by relying on a
sequence-to-sequence model where trees are lin-
earized in a depth-first traversal order. Their so-
lution can be seen as a machine translation model
that maps a sequence of words into a parenthesized
version of the tree. Choe and Charniak (2016) re-
cast parsing as language modeling. They train a
generative parser that obtains the phrasal structure
of sentences by relying on the Vinyals et al. (2015)
intuition and on the Zaremba et al. (2014) model
to build the basic language modeling architecture.

More recently, Shen et al. (2018) propose an
architecture to speed up the current state-of-the-
art chart parsers trained with deep neural net-
works (Stern et al., 2017; Kitaev and Klein, 2018).
They introduce the concept of syntactic distances,
which specify the order in which the splitting
points of a sentence will be selected. The model
learns to predict such distances, to then recursively
partition the input in a top-down fashion.

Contribution We propose a method to trans-
form constituent parsing into sequence labeling.
This reduces it to the complexity of tasks such as
part-of-speech (PoS) tagging, chunking or named-
entity recognition. The contribution is two-fold.



1315

First, we describe a method to linearize a tree
into a sequence of labels (§2) of the same length
of the sentence minus one.1 The label generated
for each word encodes the number of common an-
cestors in the constituent tree between that word
and the next, and the nonterminal symbol associ-
ated with the lowest common ancestor. We prove
that the encoding function is injective for any tree
without unary branchings. After applying collaps-
ing techniques, the method can parse unary chains.

Second, we use such encoding to present differ-
ent baselines that can effectively predict the struc-
ture of sentences (§3). To do so, we rely on a
recurrent sequence labeling model based on BIL-
STM’s (Hochreiter and Schmidhuber, 1997; Yang
and Zhang, 2018). We also test other models in-
spired in classic approaches for other tagging tasks
(Schmid, 1994; Sha and Pereira, 2003). We use
the Penn Treebank (PTB) and the Penn Chinese
Treebank (CTB) as testbeds.

The comparison against Vinyals et al. (2015),
the closest work to ours, shows that our method is
able to train more accurate parsers. This is in spite
of the fact that our approach addresses constituent
parsing as a sequence labeling problem, which
is simpler than a sequence-to-sequence problem,
where the output sequence has variable/unknown
length. Despite being the first sequence label-
ing method for constituent parsing, our baselines
achieve decent accuracy results in comparison to
models coming from mature lines of research, and
their speeds are the fastest reported to our knowl-
edge.

2 Linearization of n-ary trees

Notation and Preliminaries In what follows,
we use bold style to refer to vectors and matrices
(e.g x and W). Let w=[w1, w2, ..., w|w|] be an in-
put sequence of words, where wi ∈ V . Let T|w|
be the set of constituent trees with |w| leaf nodes
that have no unary branches. For now, we will
assume that the constituent parsing problem con-
sists in mapping each sentence w to a tree in T|w|,
i.e., we assume that correct parses have no unary
branches. We will deal with unary branches later.

To reduce the problem to a sequence labeling
task, we define a set of labels L that allows us
to encode each tree in T|w| as a unique sequence
of labels in L(|w|−1), via an encoding function

1A last dummy label is generated to fulfill the properties
of sequence labeling tasks.

Φ|w| : T|w| → L(|w|−1). Then, we can reduce
the constituent parsing problem to a sequence la-
beling task where the goal is to predict a function
F|w|,θ : V

|w| → L|w|−1, where θ are the parame-
ters to be learned. To parse a sentence, we label it
and then decode the resulting label sequence into
a constituent tree, i.e., we apply F|w|,θ ◦ Φ−1|w|.

For the method to be correct, we need the en-
coding of trees to be complete (every tree in T|w|
must be expressible as a label sequence, i.e., Φ|w|
must be a function, so we have full coverage of
constituent trees) and injective (so that the in-
verse function Φ−1|w| is well-defined). Surjectivity
is also desirable, so that the inverse is a function
on L|w|−1, and the parser outputs a tree for any
sequence of labels that the classifier can generate.

We now define our Φ|w| and show that it is total
and injective. Our encoding is not surjective per
se. We handle ill-formed label sequences in §2.3.

2.1 The Encoding
Let wi be a word located at position i in the sen-
tence, for 1 ≤ i ≤ |w| − 1. We will assign it a
2-tuple label li = (ni, ci), where: ni is an inte-
ger that encodes the number of common ancestors
between wi and wi+1, and ci is the nonterminal
symbol at the lowest common ancestor.

Basic encodings The number of common ances-
tors may be encoded in several ways.

1. Absolute scale: The simplest encoding is to
make ni directly equal to the number of an-
cestors in common between wi and wi+1.

2. Relative scale: A second and better variant
consists in making ni represent the difference
with respect to the number of ancestors en-
coded in ni−1. Its main advantage is that the
size of the label set is reduced considerably.

Figure 1 shows an example of a tree linearized ac-
cording to both absolute and relative scales.

Encoding for trees with exactly k children For
trees where all branchings have exactly k children,
it is possible to obtain a even more efficient lin-
earization in terms of number of labels. To do so,
we take the relative scale encoding as our starting
point. If we build the tree incrementally in a left-
to-right manner from the labels, if we find a neg-
ative ni, we will need to attach the word wi+1 (or
a new subtree with that word as its leftmost leaf)
to the (−ni + 2)th node in the path going from



1316

PRP       NN      VBD   DET    JJ     NN    IN    DET      NN        .
My    daughter  broke  the    red    toy   with    a     hammer    .

S

NP

NP

NP

NP

PP

VP

 2NP      1S          2VP  4NP   4NP   3NP  4PP   5NP      1S

Linearized tree (absolute scale):

Linearized tree (relative scale):

2NP      -1S         1VP  2NP   0NP  -1NP  1PP  1NP     -4S

Figure 1: An example of a constituency tree linearized
applying both absolute and relative scales.

wi to the root. If every node must have exactly k
children, there is only one valid negative value of
ni: the one pointing to the first node in said path
that has not received its kth child yet. Any smaller
value would leave this node without enough chil-
dren (which cannot be fixed later due to the left-
to-right order in which we build the tree), and any
larger value would create a node with too many
children. Thus, we can map negative values to a
single label. Figure 2 shows an example for the
case of binarized trees (k = 2).

 3NP      2S'        3VP  5NP    6NP'   4NP  5PP   6NP      1S

Linearized tree (absolute scale):

Linearized tree (relative scale):

 3NP     -1S'        1VP  2NP    1NP'  -2NP  1PP   1NP     -5S

PRP       NN       VBD   DET    JJ     NN    IN    DET      NN        .
My    daughter  broke  the    red    toy   with    a     hammer    .

S'

NP

NP

NP

NP

PP

VP

NP'

S

Linearized tree (simplified relative scale):

3NP       -S'        1VP  2NP    1NP'    -NP  1PP   1NP       -S

Figure 2: An example of a binarized constituency tree,
linearized both applying absolute and relative scales.

Links to root Another variant emerged from the
empirical observation that some tokens that are
usually linked to the root node (such as the final
punctuation in Figure 1) were particularly difficult
to learn for the simpler baselines. To successfully
deal with these cases in practice, it makes sense to
consider a simplified annotation scheme where a

node is assigned a special tag (ROOT, ci) when it
is directly linked to the root of the tree.

From now on, unless otherwise specified, we
use the relative scale without the simplification for
exactly k children. This will be the encoding used
in the experiments (§4), because the size of the la-
bel set is significantly lower than the one obtained
by relying on the absolute one. Also, it works di-
rectly with non-binarized trees, in contrast to the
encoding that we introduce for trees with exactly k
children, which is described only for completeness
and possible interest for future work. For the ex-
periments (§4), we also use the special tag (ROOT,
ci) to further reduce the size of the label set and to
simplify the classification of tokens connected to
the root, where |ni| is expected to be large.

2.2 Theoretical correctness

We now prove that Φ|w| is a total function and in-
jective for any tree in T|w|. We remind that trees
in this set have no unary branches. Later (in §2.3)
we describe how we deal with unary branches. To
prove correctness, we use the relative scale. Cor-
rectness for the other scales follows trivially.

Completeness Every pair of nodes in a rooted
tree has at least one common ancestor, and a
unique lowest common ancestor. Hence, for any
tree in T|w|, the label li = (ni, ci) defined in Sec-
tion 2.1 is well-defined and unique for each word
wi, 1 ≤ i ≤ |w| − 1; and thus Φ|w| is a total func-
tion from T|w| to L(|w|−1).

Injectivity The encoding method must ensure
that any given sequence of labels corresponds to
exactly one tree. Otherwise, we have to deal with
ambiguity, which is not desirable.

For simplicity, we will prove injectivity in two
steps. First, we will show that the encoding is
injective if we ignore nonterminals (i.e., equiva-
lently, that the encoding is injective for the set of
trees resulting from replacing all the nonterminals
in trees in T|w| with a generic nonterminal X).
Then, we will show that it remains injective when
we take nonterminals into account.

For the first part, let τ ∈ T|w| be a tree where
nonterminals take a generic value X . We repre-
sent the label of the ith leaf node as •i. Con-
sider the representation of τ as a bracketed string,
where a single-node tree with a node labeled A
is represented by (A), and a tree rooted at R



1317

with child subtrees C1 . . . Cn is represented as
(R(C1 . . . Cn)).

Each leaf node will appear in this string as a
substring (•i). Thus, the parenthesized string has
the form α0(•1)α1(•2) . . . α|w|−1(•|w|)αw, where
the αis are strings that can only contain brackets
and nonterminals, as by construction there can be
no leaf nodes between (•i) and (•i+1).

We now observe some properties of this paren-
thesized string. First, note that each of the sub-
strings αi must necessarily be composed of zero
or more closing parentheses followed by zero or
more opening parentheses with their correspond-
ing nonterminal, i.e., it must be of the form
[)]∗[(X]∗. This is because an opening parenthesis
followed by a closing parenthesis would represent
a leaf node, and there are no leaf nodes between
(•i) and (•i+1) in the tree.

Thus, we can write αi as αi)αi(, where αi) is a
string matching the expression [)]∗ and αi( a string
matching the expression [(X]∗. With this, we can
write the parenthesized string for τ as

α0)α0((•1)α1)α1((•2)α2)α2( . . . (•|w|)α|w|)α|w|(.

Let us now denote by βi the string αi−1((•i)αi).
Then, and taking into account that α0) and αw(
are trivially empty in the previous expression due
to bracket balancing, the expression for the tree
becomes simply β1β2 . . . β|w|, where we know,
by construction, that each βi is of the form
[(X]∗(•i)[)]∗.

Since we have shown that each tree in T|w|
uniquely corresponds to a string β1β2 . . . β|w|, to
show injectivity of the encoding, it suffices to
show that different values for a βi generate dif-
ferent label sequences.

To show this, we can say more about the form
of βi: it must be either of the form [(X]∗(•i) or
of the form (•i)[)]∗, i.e., it is not possible that βi
contains both opening parenthesis before the leaf
node and closing parentheses after the leaf node.
This could only happen if the tree had a subtree of
the form (X(•i)), but this is not possible since we
are forbidding unary branches.

Hence, we can identify each βi with an in-
teger number δ(βi): 0 if βi has neither open-
ing nor closing parentheses outside the leaf node,
+k if it has k opening parentheses, and −k if it
has k closing parentheses. It is easy to see that
δ(β1)δ(β2) . . . δ(β|w|−1) corresponds to the val-
ues ni in the relative-scale label encoding of the

tree τ . To see this, note that the number of un-
closed parentheses at the point right after βi in the
string exactly corresponds to the number of com-
mon ancestors between the ith and (i + 1)th leaf
nodes. A positive δ(βi) = k corresponds to open-
ing k parentheses before βi, so the number of com-
mon ancestors of wi and wi+1 will be k more than
that of wi−1 and wi. A negative δ(βi) = −k cor-
responds to closing k parentheses after βi, so the
number of common ancestors will conversely de-
crease by k. A value of zero means no opening or
closing parentheses, and no change in the number
of common ancestors.

Thus, different parenthesized strings
β1β2 . . . β|w| generate different label sequences,
which proves injectivity ignoring nonterminals
(note that δ(β|w|) does not affect injectivity as
it is uniquely determined by the other values: it
corresponds to closing all the parentheses that
remain unclosed at that point).

It remains to show that injectivity still holds
when nonterminals are taken into account. Since
we have already proven that trees with differ-
ent structure produce different values of ni in
the labels, it suffices to show that trees with the
same structure, but different nonterminals, pro-
duce different values of ci. Essentially, this re-
duces to showing that every nonterminal in the tree
is mapped into a concrete ci. That said, consider
a tree τ ∈ T|w|, and some nonterminal X in τ .
Since trees in Tw do not have unary branches, X
has at least two children. Consider the rightmost
word in the first child subtree, and call it wi. Then,
wi+1 is the leftmost word in the second child sub-
tree, and X is the lowest common ancestor of wi
and wi+1. Thus, ci = X , and a tree with identical
structure but a different nonterminal at that posi-
tion will generate a label sequence with a different
value of ci. This concludes the proof of injectivity.

2.3 Limitations

We have shown that our proposed encoding is a
total, injective function from trees without unary
branches with yield of length |w| to sequences of
|w| − 1 labels. This will serve as the basis for our
reduction of constituent parsing to sequence label-
ing. However, to go from theory to practice, we
need to overcome two limitations of the theoreti-
cal encoding: non-surjectivity and the inability to
encode unary branches. Fortunately, both can be
overcome with simple techniques.



1318

Handling of unary branches The encoding
function Φ|w| cannot directly assign the nontermi-
nal symbols of unary branches, as there is not any
pair of words (wi, wi+1) that have those in com-
mon. Figure 3 illustrates it with an example.

It is worth remarking that this is not a limitation
of our encoding, but of any encoding that would
facilitate constituent parsing as sequence labeling,
as the number of nonterminal nodes in a tree with
unary branches is not bounded by any function of
|w|. The fact that our encoding works for trees
without unary branches owes to the fact that such a
tree cannot have more than |w|−1 non-leaf nodes,
and therefore it is always possible to encode all of
them in labels associated with |w| − 1 leaf nodes.

S

X

Y

Z

1_S   3_Y   1_S   1_S

S

Y

T:

 T1      T2     T3     T4      T5
w1     w2   w3    w4      w5

 T1      T2     T3     T4      T5
w1     w2    w3    w4      w5

Φ(T):

Φ-1(Φ(T)):

Figure 3: An example of a tree that cannot be di-
rectly linearized with our approach. wi and Ti abstract
over words and PoS tags. Dotted lines represent incor-
rect branches after applying and inverting our encoding
naively without any adaptation for unaries. The nonter-
minal symbol of the second ancestor of w2 (X) cannot
be decoded, as no pair of words have X as their lowest
common ancestor. A similar situation can be observed
for the closest ancestor of w5 (Z).

To overcome this issue, we follow a collapsing
approach, as is common in parsers that need spe-
cial treatment of unary chains (Finkel et al., 2008;
Narayan and Cohen, 2016; Shen et al., 2018). For
clarity, we use the name intermediate unary chains
to refer to unary chains that end up into a nonter-
minal symbol (e.g. X → Y in Figure 3) and leaf
unary chains to name those that yield a PoS tag
(e.g. Z → T5). Intermediate unary chains are col-
lapsed into a chained single symbol, which can be

encoded by Φ|w| as any other nonterminal symbol.
On the other hand, leaf unary chains are collapsed
together with the PoS tag, but these cannot be en-
coded and decoded by relying on Φ|w|, as our en-
coding assumes a fixed sequence of leaf nodes and
does not encode them explicitly. To overcome this,
we propose two methods:

1. To use an extra function to enrich the PoS
tags before applying our main sequence la-
beling function. This function is of the form
Ψ|w| : V

|w| → U |w|, where U is the set of la-
bels of the leaf unary chains (without includ-
ing the PoS tags) plus a dummy label ∅. Ψ|w|
maps wi to ∅ if there is no leaf unary chain
at wi, or to the collapsed label otherwise.

2. To extend our encoding function to predict
them as a part of our labels li, by transform-
ing them into 3-tuples (ni, ci, ui) where ui
encodes the leaf unary chain collapsed label
for wi, if there is any, or none otherwise. We
call this extended encoding function Φ ′|w|.

The former requires to run two passes of se-
quence labeling to deal with leaf unary chains.
The latter avoids this, but the number of labels is
larger and sparser. In §4 we discuss how these two
approaches behave in terms of accuracy and speed.

Non-surjectivity Our encoding, as defined for-
mally in Section 2.1, is injective but not surjec-
tive, i.e., not every sequence of |w| − 1 labels of
the form (ni, ci) corresponds to a tree in T|w|. In
particular, there are two situations where a label
sequence formally has no tree, and thus Φ−1|w| is not
formally defined and we have to use extra heuris-
tics or processing to define it:

• Sequences with conflicting nonterminals. A
nonterminal can be the lowest common an-
cestor of more than two pairs of contiguous
words when branches are non-binary. For ex-
ample, in the tree in Figure 1, the lowest com-
mon ancestor of both “the” and “red” and of
“red” and “toy” is the same NP node. This
translates into c4 = NP , c5 = NP in the la-
bel sequence. If we take that sequence and
set c5 = VP , we obtain a label sequence that
does not strictly correspond to the encoding
of any tree, as it contains a contradiction: two
elements referencing the same node indicate
different nonterminal labels. In practice, this



1319

problem is trivial to solve: when a label se-
quence encodes several conflicting nontermi-
nals at a given position in the tree, we com-
pute Φ−1|w| using the first such nonterminal and
ignoring the rest.

• Sequences that produce unary structures.
There are sequences of values ni that do not
correspond to a tree in T|w| because the only
tree structure satisfying the common ances-
tor conditions of their values (the one built
by generating the string of βis in the injec-
tivity proof) contains unary branchings, caus-
ing the problem described above where we
do not have a specification for every nonter-
minal. An example of this is the sequence
(1, S), (3, Y ), (1, S), (1, S) in absolute scal-
ing, that was introduced in Figure 3. In prac-
tice, as unary chains have been previously
collapsed, any generated unary node is con-
sidered as not valid and removed.

3 Sequence Labeling

Sequence labeling is an structured prediction task
that generates an output label for every token in an
input sequence (Rei and Søgaard, 2018). Exam-
ples of practical tasks that can be formulated un-
der this framework in natural language processing
are PoS tagging, chunking or named-entity recog-
nition, which are in general fast. However, to our
knowledge, there is no previous work on sequence
labeling methods for constituent parsing, as an en-
coding allowing it was lacking so far.

In this work, we consider a range of methods
ranging from traditional models to state-of-the-
art neural models for sequence labeling, to test
whether they are valid to train constituency-based
parsers following our approach. We give the es-
sential details needed to comprehend the core of
each approach, but will mainly treat them as black
boxes, referring the reader to the references for a
careful and detailed mathematical analysis of each
method. Appendix A specifies additional hyper-
parameters for the tested models.

Preprocessing We add to every sentence both
beginning and end tokens.

3.1 Traditional Sequence Labeling Methods

We consider two baselines to train our prediction
function F|w|,θ, based on popular sequence label-
ing methods used in NLP problems, such as PoS

tagging or shallow parsing (Schmid, 1994; Sha
and Pereira, 2003).

Conditional Random Fields (Lafferty et al.,
2001) Let CRF|w|,θ be its prediction function, a
CRF model computes conditional probability dis-
tributions of the form p(l,w) such that CRFθ(w)
= l = arg maxl′ p(l

′,w). In our work, the inputs
to the CRF are words and PoS tags. To repre-
sent a word wi, we are using information of the
word itself and also contextual information from
w[i−1:i+1].2 In particular:

• We extract the word form (lowercased), the
PoS tag and its prefix of length 2, from
w[i−1:i+1]. For these words we also include
binary features: whether it is the first word,
the last word, a number, whether the word is
capitalized or uppercased.

• Additionally, for wi we look at the suffixes of
both length 3 and 2 (i.e. wi[−3:] and wi[−2:]).

To build our CRF models, we relied on the
sklearn-crfsuite library3.

MultiLayer Perceptron (Rosenblatt, 1958) We
use one hidden layer. Let MLP|w|,θ be its predic-
tion function, it treats sequence labeling as a set of
independent predictions, one per word. The pre-
diction for a word is computed as softmax(W2 ·
relu(W1 · x + b1) + b2), where x is the input
vector and Wi and bi the weights and biases to
be learned at layer i. We consider both a discrete
(MLPd) and an embedded (MLPe) perceptron. For
the former, we use as inputs the same set of fea-
tures as for the CRF. For the latter, the vector x for
wi is defined as a concatenation of word and PoS
tag embeddings from w[i−2:i+2].4

To build our MLPs, we relied on keras.5

3.2 Sequence Labeling Neural Models

We are using NCRFPP++6, a sequence label-
ing framework based on recurrent neural net-
works (RNN) (Yang and Zhang, 2018), and more
specifically on bidirectional short-term memory
networks (Hochreiter and Schmidhuber, 1997),

2We tried contextual information beyond the immediate
previous and next word, but the performance was similar.

3https://sklearn-crfsuite.readthedocs.io/en/latest/
4In contrast to the discrete input, larger contextual infor-

mation was useful.
5https://keras.io/
6https://github.com/jiesutd/NCRFpp, with PyTorch.



1320

which have been successfully applied to problems
such as PoS tagging or dependency parsing (Plank
et al., 2016; Kiperwasser and Goldberg, 2016).
Let LSTM(x) be an abstraction of a standard long
short-term memory network that processes the se-
quence x = [x1, ...,x|x|], then a BILSTM encoding
of its ith element, BILSTM(x, i) is defined as:

BILSTM(x, i) = hi = hli ◦ hri =
LSTMl(x[1:i]) ◦ LSTMr(x[|x|:i])

In the case of multilayer BILSTM’S, the time-
step outputs of the BILSTMm are fed as input to
the BILSTMm+1. The output label for each wi is
finally predicted as softmax(W · hi + b).

Given a sentence [w1, w2, ..., w|w|], the input to
the sequence model is a sequence of embeddings
[w1,w2, ...,w|w|] where each wi = wi ◦ pi ◦
chi, such that wi and pi are a word and a PoS
tag embedding, and chi is a word embedding ob-
tained from an initial character embedding layer,
also based on a BILSTM. Figure 4 shows the ar-
chitecture of the network.

LSTM LSTM LSTM LSTM

LSTM LSTM LSTM LSTM

w1               w2                           w|w|-1          w|w|

...

...

h1 h2  h|w|

  

Linear Linear Linear Linear

Softmax

 h|w-1|

Softmax Softmax Softmax

l1 l2 l|w-1| l|w|

Figure 4: Architecture of the neural model

4 Experiments

We report results on models trained using the rela-
tive scale encoding and the special tag (ROOT,ci).
As a reminder, to deal also with leaf unary chains,
we proposed two methods in §2.3: to predict them
relying both on the encoding functions Φ|w| and
Ψ|w|, or to predict them as a part of an enriched
label predicted by the function Φ ′|w|. For clarity,
we are naming these models with the superscripts
Ψ,Φ and Φ

′
, respectively.

Datasets We use the Penn Treebank (Marcus
et al., 1994) and its official splits: Sections 2 to 21
for training, 22 for development and 23 for test-
ing. For the Chinese Penn Treebank (Xue et al.,
2005): articles 001- 270 and 440-1151 are used

for training, articles 301-325 for development, and
articles 271-300 for testing. We use the version
of the corpus with the predicted PoS tags of Dyer
et al. (2016). We train the Φ models based on the
predicted output by the corresponding Ψ model.

Metrics We use the F-score from the EVALB
script. Speed is measured in sentences per second.
As the problem is reduced to sequence labeling,
we briefly comment on the accuracy (percentage
of correctly predicted labels) of our baselines.

Source code It can be found at https://
github.com/aghie/tree2labels

Hardware The models are run on a single
thread of a CPU7 and on a consumer-grade GPU8.
In sequence-to-sequence work (Vinyals et al.,
2015) the authors use a multi-core CPU (the num-
ber of threads was not specified), while we pro-
vide results on a single core for easier comparabil-
ity. Parsing sentences on a CPU can be framed as
an “embarrassingly parallel” problem (Hall et al.,
2014), so speed can be made to scale linearly with
the number of cores. We use the same batch size
as Vinyals et al. (2015) for testing (128).9

4.1 Results
Table 1 shows the performance of our baselines
on the PTB development set. It is worth noting
that since we are using different libraries to train
the models, these might show some differences
in terms of performance/speed beyond those ex-
pected in theory. For the BILSTM model we test:

• BILSTMm=1: It does not use pretrained word
embeddings nor character embeddings. The
number of layers m is set to 1.

• BILSTMm=1,e: It adds pretrained word em-
beddings from GloVe (Pennington et al.,
2014) for English and from the Gigaword
corpus for Chinese (Liu and Zhang, 2017).

• BILSTMm=1,e,ch: It includes character em-
beddings processed through a BILSTM.

• BILSTMm=2,e: m is set to 2. No character
embeddings.

• BILSTMm=2,e,ch: m is set to 2.

7An Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz.
8A GeForce GTX 1080.
9A larger batch will likely result in faster parsing when

executing the model on a GPU, but not necessarily on a CPU.

https://github.com/aghie/tree2labels
https://github.com/aghie/tree2labels


1321

Model F-score Acc. Sent/s Sent/s(CPU) (GPU)
CRFΨ,Φ 60.4 63.9 83 -
MLPΨ,Φd 72.6 78.1 16 49
MLPΨ,Φe 74.8 79.3 503 666
CRFΦ

′
60.3 65.4 6 -

MLPΦ
′

d 71.9 78.0 31 95
MLPΦ

′
e 75.4 79.7 342 890

BILSTMΨ,Φm=1 87.2 88.9 144 541
BILSTMΨ,Φm=1,e 88.3 89.8 144 543
BILSTMΨ,Φm=1,e,ch 88.5 90.0 120 456
BILSTMΨ,Φm=2,e 89.7 90.7 72 476
BILSTMΨ,Φm=2,e,ch 89.9 90.9 65 405
BILSTMΦ

′
m=1 87.3 89.3 206 941

BILSTMΦ
′

m=1,e 88.5 90.1 209 957
BILSTMΦ

′
m=1,e,ch 88.0 90.0 180 808

BILSTMΦ
′

m=2,e 89.8 90.9 119 842
BILSTMΦ

′
m=2,e,ch 89.7 90.9 109 716

Table 1: Performance of the proposed sequence label-
ing methods on the development set of the PTB. For the
CRF models the complexity is quadratic with respect to
the number of labels, which causes CRFΦ

′
to be partic-

ularly slow.

The Ψ,Φ and the Φ ′ models obtain similar F-
scores. When it comes to speed, the BILSTMsΦ

′

are notably faster than the BILSTMsΨ,Φ. Φ ′ mod-
els are expected to be more efficient, as leaf unary
chains are handled implicitly. In practice, Φ ′ is a
more expensive function to compute than the orig-
inal Φ, since the number of output labels is sig-
nificantly larger, which reduces the expected gains
with respect to the Ψ,Φ models. It is worth not-
ing that our encoding is useful to train an MLPe
with a decent sense of phrase structure, while be-
ing very fast. Paying attention to the differences
between F-score and Accuracy for each baseline,
we notice the gap between them is larger for CRFs
and MLPs. This shows the difficulties that these
methods have, in comparison to the BILSTM ap-
proaches, to predict the correct label when a word
wi+1 has few common ancestors with wi. For ex-
ample, let -10X be the right (relative scale) label
between wi and wi+1, and let l1=-1X and l2=-9X
be two possible wrong labels. In terms of accu-
racy it is the same that a model predicts l1 or l2,
but in terms of constituent F-score, the first will
be much worse, as many closed parentheses will
remain unmatched.

Tables 2 and 3 compare our best models against
the state of the art on the PTB and CTB test sets.
The performance corresponds to models without
reranking strategies, unless otherwise specified.

5 Discussion

We are not aware of work that reduces con-
stituency parsing to sequence labeling. The work
that can be considered as the closest to ours is
that of Vinyals et al. (2015), who address it as
a sequence-to-sequence problem, where the out-
put sequence has variable/unknown length. In
this context, even a one hidden layer percep-
tron outperforms their 3-layer LSTM model with-
out attention, while parsing hundreds of sen-
tences per second. Our best models also out-
performed their 3-layer LSTM model with atten-
tion and even a simple BILSTM model with pre-
trained GloVe embeddings obtains a similar per-
formance. In terms of F-score, the proposed se-
quence labeling baselines still lag behind mature
shift-reduce and chart parsers. In terms of speed,
they are clearly faster than both CPU and GPU
chart parsers and are at least on par with the fastest
shift-reduce ones. Although with significant loss
of accuracy, if phrase-representation is needed in
large-scale tasks where the speed of current sys-
tems makes parsing infeasible (Gómez-Rodrı́guez,
2017; Gómez-Rodrı́guez et al., 2017), we can use
the simpler, less accurate models to get speeds
well above any parser reported to date.

It is also worth noting that in their recent work,
published while this manuscript was under review,
Shen et al. (2018) developed a mapping of binary
trees with n leaves to sequences of n− 1 integers
(Shen et al., 2018, Algorithm 1). This encoding
is different from the ones presented here, as it is
based on the height of lowest common ancestors in
the tree, rather than their depth. While their pur-
pose is also different from ours, as they use this
mapping to generate training data for a parsing al-
gorithm based on recursive partitioning using real-
valued distances, their encoding could also be ap-
plied with our sequence labeling approach. How-
ever, it has the drawback that it only supports bi-
narized trees, and some of its theoretical properties
are worse for our goal, as the way to define the in-
verse of an arbitrary label sequence can be highly
ambiguous: for example, a sequence of n−1 equal
labels in this encoding can represent any binary
tree with n leaves.

6 Conclusion

We presented a new parsing paradigm, based on a
reduction of constituency parsing to sequence la-
beling. We first described a linearization function



1322

Model Testbed CPU Run GPU Run F-score#Cores Sents/s #GPU Sents/s
Sequence labeling
MLPΨ,Φe WSJ23 1 501 1 669 74.1
MLPΦ

′
e WSJ23 1 349 1 929 74.8

BILSTMΨ,Φm=1,e WSJ23 1 148 1 581 88.1
BILSTMΦ

′
m=1,e WSJ23 1 221 1 1016 88.3

BILSTMΨ,Φm=2,e,ch WSJ23 1 66 1 434 89.9
BILSTMΦ

′
m=2,e,ch WSJ23 1 115 1 780 90.0

BILSTMΨ,Φm=2,e WSJ23 1 74 1 506 90.0
BILSTMΦ

′
m=2,e WSJ23 1 126 1 898 90.0

Sequence-to-sequence
3-layer LSTM WSJ 23 <70

3-layer LSTM + Attention� WSJ 23
Multi-core

120 88.3(number not
(Vinyals et al., 2015) specified)
Constituency parsing as dependency parsing
Fernández-González and Martins (2015)� WSJ23 1 41 90.2
Chart-based parsers
Charniak (2000)∗ WSJ23 1 6 89.5
Petrov and Klein (2007)∗ WSJ23 1 6 90.1
Stern et al. (2017)� WSJ23 16* 20 91.8
Kitaev and Klein (2018) WSJ23 2 70 95.1+ELMo (Peters et al., 2018)�

Chart-based parsers with GPU-specific implementation
Canny et al. (2013)� WSJ(<30) 1 250
Hall et al. (2014)� WSJ(<40) 1 404
Transition-based and other greedy constituent parsers
Zhu et al. (2013)� WSJ23 1 101 89.9
Zhu et al. (2013)+Padding� WSJ23 1 90 90.4
Dyer et al. (2016)� WSJ23 1 17 91.2
Fernández and Gómez-Rodrı́guez (2018)� WSJ23 1 18 91.7
Stern et al. (2017)� WSJ23 16* 76 91.8
Liu and Zhang (2017) WSJ23 91.8
Shen et al. (2018) WSJ23 1 111 91.8

Table 2: Comparison against the state of the art.*Stern et al. (2017) report that they use a 16-core machine, but
sentences are processed one-at-a-time. Hence, they do not exploit inter-sentence parallelism, but they may gain
some speed from intra-sentence parallelism. � indicates the that the speed was reported in the paper itself. ∗ and
� indicate that the speeds were extracted from Zhu et al. (2013) and Fernández and Gómez-Rodrı́guez (2018).

Model F-score
MLPΨ,Φe 63.1
MLPΦ

′
e 64.4

BILSTMΨ,Φm=2,e,ch 84.4
BILSTMΦ

′
m=2,e,ch 84.1

BILSTMΨ,Φm=2,e 84.4
BILSTMΦ

′
m=2,e 83.1

Zhu et al. (2013) 82.6
Zhu et al. (2013)+P 83.2
Dyer et al. (2016) 84.6
Liu and Zhang (2017) 86.1
Shen et al. (2018) 86.5
Fernández and Gómez-Rodrı́guez (2018) 86.8

Table 3: Performance on the CTB test set

to transform a constituent tree (with n leaves) into
a sequence of n − 1 labels that encodes it. We
proved that this encoding function is total and in-
jective for any tree without unary branches. We

also discussed its limitations: how to deal with
unary branches and non-surjectivity, and showed
how these can be solved. We finally proposed a
set of fast and strong baselines.

Acknowledgments

This work has received funding from the Eu-
ropean Research Council (ERC), under the Eu-
ropean Union’s Horizon 2020 research and in-
novation programme (FASTPARSE, grant agree-
ment No 714150), from the TELEPARES-
UDC project (FFI2014-51978-C2-2-R) and the
ANSWER-ASAP project (TIN2017-85160-C2-1-
R) from MINECO, and from Xunta de Galicia
(ED431B 2017/01). We gratefully acknowledge
NVIDIA Corporation for the donation of a GTX
Titan X GPU.



1323

References
John Canny, David Hall, and Dan Klein. 2013. A

multi-teraflop constituency parser using GPUs. In
Proceedings of the 2013 Conference on Empirical
Methods in Natural Language Processing, pages
1898–1907.

Eugene Charniak. 2000. A maximum-entropy-inspired
parser. In Proceedings of the 1st North American
chapter of the Association for Computational Lin-
guistics conference, pages 132–139. Association for
Computational Linguistics.

Do Kook Choe and Eugene Charniak. 2016. Parsing
as language modeling. In Proceedings of the 2016
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 2331–2336, Austin, Texas.
Association for Computational Linguistics.

Michael Collins. 1997. Three generative, lexicalised
models for statistical parsing. In Proceedings of the
eighth conference on European chapter of the Asso-
ciation for Computational Linguistics, pages 16–23.
Association for Computational Linguistics.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural net-
work grammars. In Proceedings of the 2016 Con-
ference of the North American Chapter of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, pages 199–209. Association for
Computational Linguistics.

Daniel Fernández-González and Carlos Gómez-
Rodrı́guez. 2018. Faster Shift-Reduce Constituent
Parsing with a Non-Binary, Bottom-Up Strategy.
ArXiv e-prints.

Daniel Fernández-González and André F. T. Martins.
2015. Parsing as reduction. In Proceedings of the
53rd Annual Meeting of the Association for Compu-
tational Linguistics and the 7th International Joint
Conference on Natural Language Processing (Vol-
ume 1: Long Papers), pages 1523–1533. Associa-
tion for Computational Linguistics.

Jenny Rose Finkel, Alex Kleeman, and Christopher D
Manning. 2008. Efficient, feature-based, condi-
tional random field parsing. Proceedings of ACL-
08: HLT, pages 959–967.

Carlos Gómez-Rodrı́guez. 2017. Towards fast natu-
ral language parsing: FASTPARSE ERC Starting
Grant. Procesamiento del Lenguaje Natural, 59.

Carlos Gómez-Rodrı́guez, Iago Alonso-Alonso, and
David Vilares. 2017. How important is syntactic
parsing accuracy? An empirical evaluation on rule-
based sentiment analysis. Artificial Intelligence Re-
view.

David Hall, Taylor Berg-Kirkpatrick, and Dan Klein.
2014. Sparser, better, faster GPU parsing. In Pro-
ceedings of the 52nd Annual Meeting of the Associa-
tion for Computational Linguistics (Volume 1: Long
Papers), volume 1, pages 208–217.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. Transactions
of the Association for Computational Linguistics,
4:313–327.

Nikita Kitaev and Dan Klein. 2018. Constituency
parsing with a self-attentive encoder. In Proceed-
ings of the 56th Annual Meeting of the Association
for Computational Linguistics (Volume 1: Long Pa-
pers), Melbourne, Australia. Association for Com-
putational Linguistics.

Jonathan K. Kummerfeld, David Hall, James R. Cur-
ran, and Dan Klein. 2012. Parser showdown at
the Wall Street corral: An empirical investigation
of error types in parser output. In Proceedings of
the 2012 Joint Conference on Empirical Methods
in Natural Language Processing and Computational
Natural Language Learning, pages 1048–1059, Jeju
Island, Korea. Association for Computational Lin-
guistics.

John D. Lafferty, Andrew McCallum, and Fernando
C. N. Pereira. 2001. Conditional random fields:
Probabilistic models for segmenting and labeling se-
quence data. In Proceedings of the Eighteenth Inter-
national Conference on Machine Learning, ICML
’01, pages 282–289, San Francisco, CA, USA. Mor-
gan Kaufmann Publishers Inc.

Jiangming Liu and Yue Zhang. 2017. In-order
transition-based constituent parsing. Transactions
of the Association for Computational Linguistics,
5:413–424.

Mitchell Marcus, Grace Kim, Mary Ann
Marcinkiewicz, Robert MacIntyre, Ann Bies,
Mark Ferguson, Karen Katz, and Britta Schas-
berger. 1994. The Penn Treebank: Annotating
predicate argument structure. In Proceedings of
the Workshop on Human Language Technology,
HLT ’94, pages 114–119, Stroudsburg, PA, USA.
Association for Computational Linguistics.

Shashi Narayan and Shay B. Cohen. 2016. Optimizing
spectral learning for parsing. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
1546–1556, Berlin, Germany. Association for Com-
putational Linguistics.

Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
8th International Workshop on Parsing Technologies
(IWPT), pages 149–160.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. Glove: Global vectors for word
representation. In Proceedings of the 2014 Con-
ference on Empirical Methods in Natural Language
Processing (EMNLP), pages 1532–1543.



1324

Matthew Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word repre-
sentations. In Proceedings of the 2018 Conference
of the North American Chapter of the Association
for Computational Linguistics: Human Language
Technologies, Volume 1 (Long Papers), pages 2227–
2237. Association for Computational Linguistics.

Slav Petrov, Leon Barrett, Romain Thibaux, and Dan
Klein. 2006. Learning accurate, compact, and inter-
pretable tree annotation. In Proceedings of the 21st
International Conference on Computational Lin-
guistics and the 44th annual meeting of the Associa-
tion for Computational Linguistics, pages 433–440.
Association for Computational Linguistics.

Slav Petrov and Dan Klein. 2007. Improved infer-
ence for unlexicalized parsing. In Human Language
Technologies 2007: The Conference of the North
American Chapter of the Association for Computa-
tional Linguistics; Proceedings of the Main Confer-
ence, pages 404–411.

Barbara Plank, Anders Søgaard, and Yoav Goldberg.
2016. Multilingual part-of-speech tagging with
bidirectional long short-term memory models and
auxiliary loss. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics (Volume 2: Short Papers), pages 412–
418, Berlin, Germany. Association for Computa-
tional Linguistics.

Marek Rei and Anders Søgaard. 2018. Zero-shot se-
quence labeling: Transferring knowledge from sen-
tences to tokens. In Proceedings of the 2018 Con-
ference of the North American Chapter of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, Volume 1 (Long Papers), pages
293–302. Association for Computational Linguis-
tics.

Frank Rosenblatt. 1958. The perceptron: a probabilis-
tic model for information storage and organization
in the brain. Psychological review, 65(6):386.

Kenji Sagae and Alon Lavie. 2005. A classifier-based
parser with linear run-time complexity. In Proceed-
ings of the Ninth International Workshop on Parsing
Technology, pages 125–132. Association for Com-
putational Linguistics.

Helmut Schmid. 1994. Part-of-speech tagging with
neural networks. In Proceedings of the 15th Con-
ference on Computational Linguistics - Volume 1,
COLING ’94, pages 172–176, Stroudsburg, PA,
USA. Association for Computational Linguistics.

Fei Sha and Fernando Pereira. 2003. Shallow parsing
with conditional random fields. In Proceedings of
the 2003 Conference of the North American Chapter
of the Association for Computational Linguistics on
Human Language Technology-Volume 1, pages 134–
141. Association for Computational Linguistics.

Yikang Shen, Zhouhan Lin, Athul Paul Jacob, Alessan-
dro Sordoni, Aaron Courville, and Yoshua Bengio.
2018. Straight to the tree: Constituency parsing
with neural syntactic distance. In Proceedings of the
56th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
1171–1180. Association for Computational Linguis-
tics.

Mitchell Stern, Jacob Andreas, and Dan Klein. 2017. A
minimal span-based neural constituency parser. In
Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 818–827, Vancouver, Canada.
Association for Computational Linguistics.

Oriol Vinyals, Łukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey Hinton. 2015. Gram-
mar as a foreign language. In Advances in Neural
Information Processing Systems, pages 2773–2781.

Mengqiu Wang, Kenji Sagae, and Teruko Mitamura.
2006. A fast, accurate deterministic parser for
chinese. In Proceedings of the 21st International
Conference on Computational Linguistics and the
44th Annual Meeting of the Association for Com-
putational Linguistics, ACL-44, pages 425–432,
Stroudsburg, PA, USA. Association for Computa-
tional Linguistics.

Naiwen Xue, Fei Xia, Fu-Dong Chiou, and Marta
Palmer. 2005. The Penn Chinese Treebank: Phrase
structure annotation of a large corpus. Natural lan-
guage engineering, 11(2):207–238.

Jie Yang and Yue Zhang. 2018. NCRF++: An open-
source neural sequence labeling toolkit. In Proceed-
ings of ACL 2018, System Demonstrations, pages
74–79, Melbourne, Australia. Association for Com-
putational Linguistics.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
2014. Recurrent neural network regularization.
arXiv preprint arXiv:1409.2329.

Muhua Zhu, Yue Zhang, Wenliang Chen, Min Zhang,
and Jingbo Zhu. 2013. Fast and accurate shift-
reduce constituent parsing. In Proceedings of the
51st Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), vol-
ume 1, pages 434–443.


