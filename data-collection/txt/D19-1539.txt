



















































Cloze-driven Pretraining of Self-attention Networks


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 5360–5369,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

5360

Cloze-driven Pretraining of Self-attention Networks

Alexei Baevski, Sergey Edunov∗, Yinhan Liu∗, Luke Zettlemoyer, Michael Auli
Facebook AI Research

Menlo Park, CA and Seattle, WA

Abstract

We present a new approach for pretraining a
bi-directional transformer model that provides
significant performance gains across a vari-
ety of language understanding problems. Our
model solves a cloze-style word reconstruction
task, where each word is ablated and must be
predicted given the rest of the text. Experi-
ments demonstrate large performance gains on
GLUE and new state of the art results on NER
as well as constituency parsing benchmarks,
consistent with BERT. We also present a de-
tailed analysis of a number of factors that con-
tribute to effective pretraining, including data
domain and size, model capacity, and varia-
tions on the cloze objective.

1 Introduction

Language model pretraining has recently been
shown to provide significant performance gains
for a range of challenging language understand-
ing problems (Dai and Le, 2015; Peters et al.,
2018; Radford et al., 2018). However, existing
work has either used unidirectional (left-to-right)
language models (LMs) (Radford et al., 2018) or
bi-directional (both left-to-right and right-to-left)
LMs (BiLMs) where each direction is trained with
an independent loss function (Peters et al., 2018).
In this paper, we show that even larger perfor-
mance gains are possible by jointly pretraining
both directions of a large language-model-inspired
self-attention cloze model.

Our bi-directional transformer architecture pre-
dicts every token in the training data (Figure 1).
We achieve this by introducing a cloze-style train-
ing objective where the model must predict the
center word given left-to-right and right-to-left
context representations. Our model separately
computes both forward and backward states with

∗Equal contribution.

<s> a b c <s>

Block1

BlockN

Block1

BlockN

Block1

BlockN

Block1

BlockN

comb

b

Figure 1: Illustration of the model. Blocki is a standard
transformer decoder block. Green blocks operate left to
right by masking future time-steps and blue blocks op-
erate right to left. At the top, states are combined with
a standard multi-head self-attention module whose out-
put is fed to a classifier that predicts the center token.

a masked self-attention architecture, that closely
resembles a language model. At the top of the net-
work, the forward and backward states are com-
bined to jointly predict the center word. This ap-
proach allows us to consider both contexts when
predicting words and to incur loss for every word
in the training set, if the model does not assign it
high likelihood.

Experiments on the GLUE (Wang et al., 2018)
benchmark show strong gains over the state of the
art for each task, including a 9.1 point gain on RTE
over Radford et al. (2018). These improvements
are consistent with, if slightly behind, BERT (De-
vlin et al., 2018), which we will discuss in more
detail in the next section. We also show that it
is possible to stack task-specific architectures for
NER and constituency parsing on top of our pre-
trained representations, and achieve new state-of-
the-art performance levels for both tasks. We also
present extensive experimental analysis to better



5361

understand these results, showing that (1) hav-
ing multiple sentences in each training example
is crucial for many tasks; (2) pre-training contin-
ues to improve performance with up to 18B tokens
and would likely continue to improve with more
data; and finally (3) our novel cloze-driven train-
ing regime is more effective than predicting left
and right tokens separately.

2 Related work

There has been much recent work on learning
sentence-specific representations for language un-
derstanding tasks. McCann et al. (2017) learn con-
textualized word representations from a sequence
to sequence translation task and uses the represen-
tations from the encoder network to improve a va-
riety of language understanding tasks. Subsequent
work focused on language modeling pretraining
which has been shown to be more effective and
which does not require bilingual data (Zhang and
Bowman, 2018).

Our work was inspired by ELMo (Peters et al.,
2018) and the generative pretraining (GPT) ap-
proach of Radford et al. (2018). ELMo introduces
language models to pretrain word representations
for downstream tasks including a novel mecha-
nism to learn a combination of different layers
in the language model that is most beneficial to
the current task. GPT relies on a left to right
language model and an added projection layer
for each downstream task without a task-specific
model. Our approach mostly follows GPT, though
we show that our model also works well with an
ELMo module on NER and constituency parsing.

The BERT model (Devlin et al., 2018) is a
transformer encoder model that captures left and
right context. There is significant overlap between
their work and ours but there are also significant
differences: our model is a bi-directional trans-
former language model that predicts every single
token in a sequence. Our model has two uni-
directional components encoding either the left or
right context and both are combined to predict cen-
ter words. BERT is also a transformer encoder that
has access to the entire input but this choice re-
quires a special training regime. In particular, they
multi-task between predicting a subset of masked
input tokens, similar to a denoising autoencoder,
and a next sentence prediction task. In compar-
ison, we optimize a single loss function that re-
quires the model to predict each token of an in-

put sentence given all surrounding tokens. We use
all tokens as training targets and therefore extract
learning signal from every single token in the sen-
tence and not just a subset. Melamud et al. (2016)
follow a similar approach to ours by predicting
the center word but their architecture is based on
LSTMs and we include the center word when we
actually fine-tune on downstream tasks.

BERT tailors pretraining to capture dependen-
cies between sentences via a next sentence predic-
tion task as well as by constructing training exam-
ples of sentence-pairs with input markers that dis-
tinguish between tokens of the two sentences. Our
model is trained similarly to a classical language
model since we do not adapt the training exam-
ples to resemble the end task data and we do not
solve a denoising task during training.

Finally, BERT as well as Radford et al. (2018)
consider only a single data source to pretrain
their models, either BooksCorpus (Radford et al.,
2018), or BooksCorpus and additional Wikipedia
data (Devlin et al., 2018), whereas our study ab-
lates the effect of various amounts of training data
as well as different data sources.

3 Two tower model

Our cloze model represents a probability distribu-
tion p(ti|t1, . . . , ti−1, ti+1, . . . , tn) for a sentence
with n tokens t1, . . . , tn. There are two self-
attentional towers each consisting of N stacked
blocks: the forward tower operates left-to-right
and the backward tower operates in the opposite
direction. To predict a token, we combine the
representations of the two towers, as described in
more detail below, taking care that neither repre-
sentation contains information about the current
target token.

The forward tower computes the representation
F li for token i at layer l based on the forward rep-
resentations of the previous layer F l−1≤i via self-
attention; the backward tower computes represen-
tation Bli based on information from the opposite
direction Bl−1≥i . When examples of uneven length
are batched, one of the towers may not have any
context at the beginning. We deal with this issue
by adding an extra zero state over which the self-
attention mechanism can attend.

We pretrain on individual examples as they oc-
cur in the training corpora (§5.1). For News Crawl
this is individual sentences while on Wikipedia,
Bookcorpus, and Common Crawl examples are



5362

paragraph length. Sentences are prepended and
appended with sample boundary markers < s >.

3.1 Block structure

The structure of the blocks follows most of the
architectural choices described in Vaswani et al.
(2017). Each block consists of two sub-blocks:
the first is a multi-head self-attention module with
H = 16 heads for which we mask out any sub-
sequent time-steps, depending on if we are deal-
ing with the forward or backward tower. The sec-
ond sub-block is a feed-forward module (FFN)
of the form ReLU(W1X + b1)W2 + b2 where
W1 ∈ Re×f , W1 ∈ Rf×e. Different to Vaswani
et al. (2017) we apply layer normalization before
the self-attention and FFN blocks instead of af-
ter, as we find it leads to more effective training.
Sub-blocks are surrounded by a residual connec-
tion (He et al., 2015). Position is encoded via
fixed sinusoidal position embeddings and we use
a character CNN encoding of the input tokens for
word-based models (Kim et al., 2016). Input em-
beddings are shared between the two towers.

3.2 Combination of representations

The forward and backward representations com-
puted by the two towers are combined to pre-
dict the ablated word. To combine them we use
a self-attention module which is followed by an
FFN block (§3.1). The output of the FFN block
f is projected by W into V classes represent-
ing the types in the vocabulary: WT f to which
a softmax is applied. When the model predicts
token i, the input to the attention module are
forward states FL1 . . . F

L
i−1 and backward states

BLi+1 . . . B
:
n where n is the length of the sequence

and L is the number of layers. We implement this
by masking BL≤i and F

L
≥i. The attention query

for token i is a combination of FLi−1 and B
L
i+1.

For the base model we sum the two representa-
tions and for the larger models they are concate-
nated. Keys and values are based on the forward
and backward states fed to the attention module.
In summary, this module has access to information
about the entire input surrounding the current tar-
get token. During training, we predict every token
in this way. The output of this module is fed to an
output classifier which predicts the center token.
We use an adaptive softmax for the output classi-
fier (Grave et al., 2017) for the word based models
and regular softmax for the BPE based models.

a b c

comb comb

comb

Embedding 
of c

Embedding 
of bEmbedding 

of a

Figure 2: Illustration of fine-tuning for a downstream
task. For classification problems, output of the first
and last token is fed to a task-specific classifier. Mask-
ing for the final combination layer (comb) is removed
which results in representations based on all forward
and backward states (cf. Figure 1). The red dot-dashed
arrows show connections that are masked during train-
ing, but unmasked for fine-tuning.

While all states that contain information about
the current target word are masked in the final self-
attention block during training, we found it bene-
ficial to disable this masking when fine tuning the
pretrained model for downstream tasks. This is es-
pecially true for tasks that label each token, such
as NER, as this allows the model to access the full
context including the token itself.

4 Fine-tuning

We use the following approach to fine-tune the
pretrained two tower model to specific down-
stream tasks (Figure 2).

Classification and regression tasks. For sin-
gle sentence classification tasks, we consider the
language model outputs for the boundary tokens
< s > which we add before the start and end
of each sentence. The language model outputs
are the representations f just before the final soft-
max layer (§3.2). The outputs are of dimension
d = 1024 and we concatenate them to project to
the number of classes C in the downstream task
with W1 ∈ RC×2d (Radford et al., 2018); we add a
bias term b ∈ RC and initialize all weights as well
as the bias to zero. The output of the projection
is softmax-normalized and the model is optimized
with cross-entropy for classification tasks. Re-



5363

gression tasks such as the Semantic Textual Sim-
ilarity benchmark (STS-B; Cer et al., 2017) use
C = 1 and are trained with mean squared error.
For tasks involving sentence-pairs, we concatenate
them and add a new separator token < sep > be-
tween them. We add the output of this token to the
final projection W2 ∈ RC×3d.

Structured prediction tasks. For named entity
recognition and parsing we use task-specific archi-
tectures which we fine-tune together with the lan-
guage model but with different learning rate. The
architectures are detailed in the respective results
sections. The input to the architectures are the
output representations of the pretrained language
model.

No Masking. For fine-tuning, we found it bene-
ficial to remove masking of the current token in
the final layer that pools the output of the two
towers. This is different than in the actual pre-
training. It is important to have access to informa-
tion about the token to be classified for token level
classification tasks such as NER but we also found
this to perform better for sentence classification
tasks. In practice, we completely disable masking
in the combination layer so that it operates over
all forward and backward states. However, dis-
abling masking below the combination layer does
not perform well.

Optimization. During fine-tuning we use larger
learning rates for the new parameters, that is W1,
W2, b or the task-specific architecture, compared
to the pretrained model. For GLUE tasks, we do
so by simply scaling the output of the language
model before the W1 and W2 projections by a
factor of 16. For structured prediction tasks, we
explicitly use different learning rates for the pre-
trained model and the task-specific parameters.

We fine tune with the Adam optimizer (Kingma
and Ba, 2015). For GLUE tasks, we disable
dropout in the language model and add 0.1 dropout
between language model output and the final out-
put projection; for structured prediction tasks, we
use 0.3 at all levels (within the pretrained model,
within the task-specific architecture, and on the
weights connecting them). In all settings, we use a
batch size of 16 examples. We use a cosine sched-
ule to linearly warm up the learning rate from 1e-
07 to the target value over the first 10% of train-
ing steps, and then anneal the learning rate to 1e-
06, following the cosine curve for the remaining

steps. For GLUE tasks, we tuned the learning rate
for each task and chose the best value over three
settings: 1e-04, 5e-05 and 3e-05. For structured
prediction tasks, we tuned on the pairs of learning
rate, see the results section for details. For GLUE
tasks, we train three seeds for each learning rate
value for three epochs and choose the model af-
ter each epoch that performs best on the validation
set. For structured prediction tasks, we train for up
to 25 epochs and stop if the validation loss does
not improve over the previous epoch.

5 Experimental setup

5.1 Datasets for pretraining

We train the two tower model on several datasets.

Common Crawl. We consider various subsets
of Common Crawl which is web data. We fol-
low the same pre-processing as Grave et al. (2018)
which is based on the May 2017 Common Crawl
dump. This setup add 20 copies of English
Wikipedia resulting in about 14% of the final
dataset to be Wikipedia. We subsample up to 18B
tokens. All experiments use Common Crawl sub-
sampled to 9B tokens, except §6.4.

News Crawl. We use up to 4.5B words of En-
glish news web data distributed as part of WMT
2018 (Bojar et al., 2018).

BooksCorpus + Wikipedia. This is similar to
the training data used by BERT which comprises
the BooksCorpus (Zhu et al., 2015) of about 800M
words plus English Wikipedia data of 2.5B words.

5.2 Pretraining hyper-parameters

We adapt the transformer implementation avail-
able in the fairseq toolkit to our two tower archi-
tecture (Ott et al., 2019). For hyper-parameter and
optimization choices we mostly follow Baevski
and Auli (2018). Our experiments consider three
model sizes shown in Table 1: There are two CNN
input models in a base and large configuration as
well as a Byte-Pair-Encoding based model (BPE;
Sennrich et al., 2016). The CNN models have un-
constrained input vocabulary, and an output vo-
cabulary limited to 1M most common types for
the large model, and 700K most common types
for the base model. CNN models use an adap-
tive softmax in the output: the head band contains
the 60K most frequent types with dimensionality



5364

Model Parameters Updates Blocks FFNDim
Attn Heads
(final layer)

Query formation
(final layer)

Train time
(days)

CNN Base 177M 600K 6 4096 12 Sum 6
CNN Large 330M 1M 12 4096 32 Concat 10
BPE Large 370M 1M 12 4096 32 Concat 4.5

Table 1: Hyper-parameters for our models. Parameter count excludes the (adaptive) softmax layer. Train time as
measured on 128 Volta GPUs for the CNN models and 64 Volta GPUs for the BPE model.

1024, followed by a 160K band with dimension-
ality 256. The remaining types have dimensional-
ity 64; there are 480K types for the small model
and 780K for the large model. The BPE model
uses a vocabulary of 55K types and we share input
and output embeddings in a flat softmax with di-
mension 1024 (Inan et al., 2016; Press and Wolf,
2017). The BPE vocabulary was constructed by
applying 30K merge operations over the training
data, then applying the BPE code to the training
data and retaining all types occurring at least three
times.

Every setup uses model dimensionaltiy d =
1024 with H = 16 attention heads for all but the
final attention layer. Model based on character in-
puts use character embedding size 128 and we ap-
ply six filters of size 1x128, 2x256, 3x384, 4x512,
5x512, 6x512 followed by a single highway layer.
The models are trained with model and attention
dropout rate of 0.1 and ReLU dropout rate of 0.05.

Different to Vaswani et al. (2017) we use Nes-
terov’s accelerated gradient method (Sutskever
et al., 2013) with a momentum of 0.99 and we
renormalize gradients if their norm exceeds 0.1
(Pascanu et al., 2013). The learning rate is lin-
early warmed up from 10−7 to 1 for 16K steps and
then annealed using a cosine learning rate sched-
ule with a single phase to 0.0001 (Loshchilov and
Hutter, 2016).

We run experiments on DGX-1 machines with
8 NVIDIA V100 GPUs and machines are inter-
connected by Infiniband. We also use the NCCL2
library and the torch.distributed package for inter-
GPU communication. We train models with 16-
bit floating point precision, following Ott et al.
(2018). The BPE model trains much faster than
the character CNN models (Table 1).

6 Results

6.1 GLUE

First, we conduct experiments on the general
language understanding evaluation benchmark
(GLUE; Wang et al., 2018) and present a short
overview of the tasks. More information can be
found in Wang et al. (2018). There are two single-
sentence classification tasks: First, the Corpus of
Linguistic Acceptability (CoLA; Warstadt et al.,
2018) is a binary task to judge sentence grammat-
icality; evaluation is in terms of the Matthews cor-
relation coefficient (mcc). Second, the Stanford
Sentiment Treebank (SST-2; Socher et al., 2013)
requires to judge if movie reviews have positive or
negative sentiment; evaluation is in terms of accu-
racy (acc).

There are three tasks assessing sentence sim-
ilarity: The Microsoft Research Paragraph Cor-
pus (MRPC; Dolan and Brockett, 2015) and the
Quora Question Pairs benchmark (QQP); we eval-
uate in terms of F1. The Semantic Textual Similar-
ity Benchmark (STS-B; Cer et al., 2017) requires
predicting a similarity score between 1 and 5 for a
sentence pair; we report the Spearman correlation
coefficient (scc).

Finally, there are four natural language infer-
ence tasks: the Multi-Genre Natural Language In-
ference (MNLI; Williams et al., 2018), the Stan-
ford Question Answering Dataset (QNLI; Ra-
jpurkar et al., 2016), the Recognizing Textual En-
tailment (RTE; Dagan et al., 2006, Bar Haim et al.,
2006, Ciampiccolo et al., 2007 Bentivogli et al.,
2009). We exclude the Winograd NLI task from
our results similar to Radford et al. (2018); De-
vlin et al. (2018) and report accuracy. For MNLI
we report both matched (m) and mismatched (mm)
accuracy on test.

We also report an average over the GLUE met-
rics. This figure is not comparable to the aver-
age on the official GLUE leaderboard since we ex-
clude Winograd and do not report MRPC accuracy



5365

CoLA
(mcc)

SST-2
(acc)

MRPC
(F1)

STS-B
(scc)

QQP
(F1)

MNLI-(m/mm)
(acc)

QNLI
(acc)

RTE
(acc) Avg

OpenAI GPT 45.4 91.3 82.3 80.0 70.3 82.1/81.4 88.1 56.0 75.2

CNN Base 53.1 93.6 81.3 82.2 70.5 82.5/82.2 89.5 64.6 77.7
CNN Large 52.8 94.6 83.7 83.4 71.7 84.3/83.8 89.8 63.7 78.6
BPE Large 51.8 94.0 83.0 84.2 70.6 82.9/82.2 89.3 65.1 78.1

GPT on STILTs 47.2 93.1 87.7 84.8 70.1 80.7/80.6 87.2 69.1 77.8
BERTBASE 52.1 93.5 88.9 85.8 71.2 84.6/83.4 90.1 66.4 79.6
BERTLARGE 60.5 94.9 89.3 86.5 72.1 86.7/85.9 91.1 70.1 81.9

Table 2: Test results as per the GLUE evaluation server. The average column does not include the WNLI test set.
mcc = Matthews correlation, acc = Accuracy, scc = Spearman correlation.

STS-B Pearson correlation as well as QQP accu-
racy.

Table 2 shows results for three configurations
of our approach (cf. Table 1). The BPE model
has more parameters than the CNN model but
does not perform better in aggregate, however, it is
faster to train. All our models outperform the uni-
directional transformer (OpenAI GPT) of Radford
et al. (2018), however, our model is about 50%
larger than their model. We also show results for
STILTs (Phang et al., 2018) and BERT (Devlin
et al., 2018). Our CNN base model performs as
well as STILTs in aggregate, however, on some
tasks involving sentence-pairs, STILTs performs
much better (MRPC, RTE); there is a similar trend
for BERT.

STILTs adds another fine-tuning step on an-
other downstream task which is similar to the fi-
nal task. The technique is equally applicable to
our approach. Training examples for our model
are Common Crawl paragraphs of arbitrary length.
We expect that tailoring training examples for lan-
guage model pretraining to the end tasks to signif-
icantly improve performance. For example, BERT
trains on exactly two sentences while as we train
on entire paragraphs.

6.2 Structured Prediction

We also evaluated performance on two structured
predictions tasks, NER and constituency parsing.
For both problems, we stacked task-specific archi-
tectures from recent work on top of our pretrained
two tower models. We evaluate two ways of stack-
ing: (1) ELMo-style, where the pretrained mod-
els are not fine-tuned but are linearly combined at
different depths, and (2) with fine-tuning, where
we set different learning rates for the task-specific

Model dev F1 test F1

ELMoBASE 95.7 92.2

CNN Large + ELMo 96.4 93.2
CNN Large + fine-tune 96.9 93.5

BERTBASE 96.4 92.4
BERTLARGE 96.6 92.8

Table 3: CoNLL-2003 Named Entity Recognition re-
sults. Test result was evaluated on parameter set with
the best dev F1.

Model dev F1 test F1

ELMoBASE 95.2 95.1

CNN Large + ELMo 95.1 95.2
CNN Large + fine-tune 95.5 95.6

Table 4: Penn Treebank Constituency Parsing results.
Test result was evaluated on parameter set with the best
dev F1.

layers but otherwise update all of the parameters
during the task-specific training.

6.2.1 Named Entity Recognition
We evaluated span-level F1 performance on the
CoNLL 2003 Named Entity Recognition (NER)
task, where spans of text must be segmented and
labeled as Person, Organization, Location, or Mis-
cellaneous. We adopted the NER architecture in
Peters et al. (2018), a biLSTM-CRF, with two mi-
nor modifications: (1) instead of two layers of biL-
STM, we only used one, and (2) a linear projection
layer was added between the token embedding and
biLSTM layer. We did grid search on the pairs of
learning rate, and found that projection-biLSTM-



5366

CoLA
(mcc)

SST-2
(acc)

MRPC
(F1)

STS-B
(scc)

QQP
(F1)

MNLI-m
(acc)

QNLI
(acc)

RTE
(acc) Avg

cloze 55.1 92.9 88.3 88.3 87.2 82.3 86.5 66.4 80.9
bilm 50.0 92.4 86.6 87.1 86.1 81.7 84.0 66.4 79.3
cloze + bilm 52.6 93.2 88.9 87.9 87.2 82.1 86.1 65.5 80.4

Table 5: Different loss functions on the development sets of GLUE (cf. Table 2). Results are based on the CNN
base model (Table 1)

CRF with 1E-03 and pretrained language model
with 1E-05 gave us the best result.

Table 3 shows the results, with comparison
to previous published ELMoBASE results (Peters
et al., 2018) and the BERT models. Both of our
stacking methods outperform the previous state of
the art, but fine tuning gives the biggest gain.

6.2.2 Constituency Parsing
We also report parseval F1 for Penn Treebank con-
stituency parsing. We adopted the current state-of-
the-art architecture (Kitaev and Klein, 2018). We
again used grid search for learning rates and num-
ber of layers in parsing encoder, and used 8E-04
for language model finetuning, 8E-03 for the pars-
ing model parameters, and two layers for encoder.

Table 4 shows the results. Here, fine tuning is
required to achieve gains over the previous state
of the art, which used ELMo embeddings.

6.3 Objective functions for pretraining

The two-tower model is trained to predict the cur-
rent token given representations of the entire left
and right context (cloze). Next we compare this
choice to two alternatives: First, Peters et al.
(2018) train two language models operating left-
to-right and right-to-left to predict the next word
for each respective direction. We change the two-
tower model to predict the next word using the in-
dividual towers only and remove the combination
module on top of the two towers (bilm); however,
we continue to jointly train the two towers.

Second, we combine the cloze loss with the
bilm loss to obtain a triplet loss which trains the
model to predict the current word given both left
and right context, as well as just right or left con-
text. The latter is much harder than the cloze loss
since less context is available and therefore gradi-
ents for the bilm loss are much larger: the cloze
model achieves perplexity of about 4 while as for
the bilm it is 27-30, depending on the direction.
This results in the bilm loss dominating the triplet

562M 1.1B 2.25B 4.5B 9B 18B

80

80.5

81

81.5

Train data tokens

A
vg

.G
L

U
E

sc
or

e

Average GLUE score

Figure 3: Average GLUE score with different amounts
of Common Crawl data for pretraining.

loss and we found that scaling the bilm term by a
factor of 0.15 results in better performance.

Table 5 shows that the cloze loss performs sig-
nificantly better than the bilm loss and that com-
bining the two loss types does not improve over
the cloze loss by itself. We conjecture that in-
dividual left and right context prediction tasks
are too different from center word prediction and
that their learning signals are not complementary
enough.

6.4 Domain and amount of training data

Next we investigate how much pretraining benefits
from larger training corpora and how the domain
of the data influences end-task performance.

Figure 3 shows that more training data can sig-
nificantly increase accuracy. We train all models
with the exact same hyper-parameter settings on
Common Crawl data using the CNN base archi-
tecture for 600K updates. We train on up to 18B
Common Crawl tokens and the results suggest that
more training data is likely to further increase per-
formance.

Table 6 shows a breakdown into individual



5367

train data
(M tok)

CoLA
(mcc)

SST-2
(acc)

MRPC
(F1)

STS-B
(scc)

QQP
(F1)

MNLI-m
(acc)

QNLI
(acc)

RTE
(acc) Avg

ccrawl

562 52.5 92.9 88.2 88.3 87.1 81.7 85.7 63.3 79.9
1125 55.5 93.1 86.1 88.4 87.1 81.9 85.7 65.2 80.4
2250 55.4 92.4 87.7 88.4 87.2 82.2 86.2 66.9 80.8
4500 56.6 93.0 87.3 88.6 87.0 82.0 86.2 65.7 80.8
9000 55.1 92.9 88.3 88.3 87.2 82.3 86.5 66.4 80.9

18000 56.3 93.1 88.0 88.8 87.2 82.3 86.3 68.4 81.3

news
crawl

562 50.9 92.8 81.4 78.2 84.9 79.1 82.0 55.7 75.6
1125 51.4 93.0 83.0 82.3 85.2 79.7 82.8 53.9 76.4
2250 54.8 92.9 83.5 82.8 85.4 80.4 82.4 54.8 77.1
4500 53.9 93.6 83.8 83.1 85.5 80.4 83.6 54.2 77.3

BWiki - sent 3300 53.5 91.6 86.4 86.2 86.9 82.3 86.9 63.8 79.7
BWiki - blck 3300 50.6 91.9 86.4 87.1 86.8 81.9 86.2 60.4 78.9

Table 6: Effect of different domains and amount of data for pretraining on the on the development sets of GLUE
(cf. Table 2). Results are based on the CNN base model (Table 1).

GLUE tasks. For pretraining on Common Crawl,
CoLA and RTE benefit most from additional train-
ing data. The same table also shows results for
News Crawl which contains newswire data. This
data generally performs less well than Common
Crawl, even on MRPC which is newswire. A
likely reason is that News Crawl examples are in-
dividual sentences of 23 words on average which
compares to several sentences or 50 words on av-
erage for Common Crawl. Mutli-sentence training
examples are more effective for end-tasks based
on sentence pairs, e.g., there is a 14 point accu-
racy gap on RTE between News Crawl and Com-
mon Crawl with 4.5B tokens. More News Crawl
data is most beneficial for CoLA and STS-B.

We also experiment with BooksCorpus (Zhu
et al., 2015) as well as English Wikipedia, similar
to Devlin et al. (2018). Examples in BooksCorpus
are a mix of individual sentences and paragraphs;
examples are on average 36 tokens. Wikipedia ex-
amples are longer paragraphs of 66 words on av-
erage. To reduce the effect of training on exam-
ples of different lengths, we adopted the following
strategy: we concatenate all training examples into
a single string and then crop blocks of 512 consec-
utive tokens from this string. We train on a batch
of these blocks (BWiki - blck). It turns out that this
strategy did not work better compared to our exist-
ing strategy of simply using the data as is (BWiki -
sent). BooksCorpus and Wikipedia performs very
well on QNLI and MNLI but less well on other
tasks.

In summary, more data for pretraining improves
performance, keeping everything else equal. Also
pretraining on corpora that retains paragraph
structure performs better than individual sen-
tences.

7 Conclusion

We presented a pretraining architecture based on a
bi-directional transformer model that predicts ev-
ery token in the training data. The model is trained
with a cloze-style objective and predicts the center
word given all left and right context.

Results on the GLUE benchmark show large
gains over Radford et al. (2018) for each task,
while experiments with model stacking set new
state of the art performance levels for parsing and
named entity recognition. We also did extensive
experimental analysis to better understand these
results, showing that (1) having multiple sentences
in each training example is crucial for many tasks;
(2) pre-training continues to improve performance
up to 18B tokens and would likely continue to im-
prove with more data; and finally (3) our novel
cloze-driven training regime is more effective than
predicting left and right tokens separately.

In future work, we will investigate variations
of our architecture. In particular, we had initial
success sharing the parameters of the two towers
which allows training much deeper models with-
out increasing the parameter count.



5368

References
Alexei Baevski and Michael Auli. 2018. Adaptive in-

put representations for neural language modeling.
arXiv, abs/1809.10853.

Luisa Bentivogli, Peter Clark, Ido Dagan, and Danilo
Giampiccolo. 2009. The fifth pascal recognizing
textual entailment challenge. In Proc. of TAC.

Ondřej Bojar, Christian Federmann, Mark Fishel,
Yvette Graham, Barry Haddow, Matthias Huck,
Philipp Koehn, and Christof Monz. 2018. Find-
ings of the 2018 conference on machine translation
(WMT18). In Proc. of WMT.

Daniel M. Cer, Mona T. Diab, Eneko Agirre, Iñigo
Lopez-Gazpio, and Lucia Specia. 2018. Semeval-
2017 task 1: Semantic textual similarity - multilin-
gual and cross-lingual focused evaluation. In Proc.
of SemEval.

Ido Dagan, Oren Glickman, and Bernardo Magnini.
2006. The pascal recognizing textual entailment
challenge. Machine learning challenges, evaluat-
ing predictive uncertainty, visual object classifica-
tion, and recognizing textual entailment, pages 177–
190.

Andrew M. Dai and Quoc V. Le. 2015.
Semi-supervised sequence learning. arXiv,
abs/1511.01432.

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and
Kristina Toutanova. 2018. Bert: Pre-training of deep
bidirectional transformers for language understand-
ing. CoRR, abs/1810.04805.

William B. Dolan and Chris Brockett. 2005. Automati-
cally constructing a corpus of sentential paraphrases.
In Proc. of IWP.

Danilo Giampiccolo, Bernardo Magnini, Ido Dagan,
and Bill Dolan. 2007. The pascal recognizing
textual entailment challenge. Proc. of the ACL-
PASCAL workshop on textual entailment and para-
phrasing.

Edouard Grave, Piotr Bojanowski, Prakhar Gupta, Ar-
mand Joulin, and Tomas Mikolov. 2018. Learning
word vectors for 157 languages. In Proc. of LREC.

Edouard Grave, Armand Joulin, Moustapha Cissé,
David Grangier, and Hervé Jégou. 2017. Efficient
softmax approximation for gpus. In Proc. of ICML.

Roy Bar Haim, Ido Dagan, Bill Dolan, Lisa Ferro,
Danilo Giampiccolo, Bernardo Magnini, and Idan
Szpektor. 2006. The pascal recognising textual en-
tailment challenge.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian
Sun. 2015. Deep Residual Learning for Image
Recognition. In Proc. of CVPR.

Hakan Inan, Khashayar Khosravi, and Richard Socher.
2016. Tying word vectors and word classifiers:
A loss framework for language modeling. arXiv,
abs/1611.01462.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2016. Character-aware neural language
models. In AAAI, pages 2741–2749.

Diederik P. Kingma and Jimmy Ba. 2015. Adam: A
Method for Stochastic Optimization. In Proc. of
ICLR.

Nikita Kitaev and Dan Klein. 2018. Constituency pars-
ing with a self-attentive encoder. In Proc. of ACL.

Ilya Loshchilov and Frank Hutter. 2016. SGDR:
stochastic gradient descent with restarts. arXiv,
abs/1608.03983.

Bryan McCann, James Bradbury, Caiming Xiong, and
Richard Socher. 2017. Learned in translation: Con-
textualized word vectors. In Proc. of NIPS.

Oren Melamud, Jacob Goldberger, and Ido Dagan.
2016. context2vec: Learning generic context em-
bedding with bidirectional lstm. In Proc. of CoNLL.

Myle Ott, Sergey Edunov, Alexei Baevski, Angela
Fan, Sam Gross, Nathan Ng, David Grangier, and
Michael Auli. 2019. fairseq: A fast, extensible
toolkit for sequence modeling. In Proc. of NAACL
System Demonstrations.

Myle Ott, Sergey Edunov, David Grangier, and
Michael Auli. 2018. Scaling neural machine trans-
lation. In Proc. of WMT.

Razvan Pascanu, Tomas Mikolov, and Yoshua Bengio.
2013. On the difficulty of training recurrent neural
networks. In Proc. of ICML.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. In Proc. of ACL.

Jason Phang, Thibault Fevry, and Samuel R. Bowman.
2018. Sentence encoders on stilts: Supplementary
training on intermediate labeled-data tasks. arXiv,
abs/1811.01088.

Ofir Press and Lior Wolf. 2017. Using the output em-
bedding to improve language models. In Proc. of
EACL.

Alec Radford, Karthik Narasimhan, Tim Sali-
mans, and Ilya Sutskever. 2018. Improving
language understanding by generative pre-training.
https://s3-us-west-2.amazonaws.
com/openai-assets/research-covers/
language-unsupervised/language_
understanding_paper.pdf.

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev,
and Percy Liang. 2016. Squad: 100, 000+ ques-
tions for machine comprehension of text. arXiv,
abs/1606.05250.

https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf


5369

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Neural machine translation of rare words with
subword units. In Proc. of ACL.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Ng, and
Christopher Potts. 2013. Recursive deep models
for semantic compositionality over a sentiment tree-
bank. In Proc. of EMNLP.

Ilya Sutskever, James Martens, George E. Dahl, and
Geoffrey E. Hinton. 2013. On the importance of ini-
tialization and momentum in deep learning. In Proc.
of ICML.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz
Kaiser, and Illia Polosukhin. 2017. Attention Is All
You Need. In Proc. of NIPS.

Alex Wang, Amanpreet Singh, Julian Michael, Felix
Hill, Omer Levy, and Samuel R. Bowman. 2018.
GLUE: A multi-task benchmark and analysis plat-
form for natural language understanding. arXiv,
abs/1804.07461.

Alex Warstadt, Amanpreet Singh, and Sam Bow-
man. 2018. Corpus of linguistic acceptability.
https://nyu-mll.github.io/CoLA.

Adina Williams, Nikita Nangia, and Samuel R Bow-
man. 2018. A broad-coverage challenge corpus for
sentence understanding through inference. In Proc.
of NAACL.

Kelly W. Zhang and Samuel R. Bowman. 2018. Lan-
guage modeling teaches you more syntax than trans-
lation does: Lessons learned through auxiliary task
analysis. arXiv, abs/1809.10040.

Yukun Zhu, Ryan Kiros, Richard S. Zemel, Ruslan
Salakhutdinov, Raquel Urtasun, Antonio Torralba,
and Sanja Fidler. 2015. Aligning books and movies:
Towards story-like visual explanations by watching
movies and reading books. arXiv, abs/1506.06724.


