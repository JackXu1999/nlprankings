



















































Zero-Shot Semantic Parsing for Instructions


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 4454–4464
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

4454

Zero-Shot Semantic Parsing for Instructions

Ofer Givoli1 and Roi Reichart2
1 Faculty of Computer Science, Technion, IIT

2 Faculty of Industrial Engineering and Management, Technion, IIT
ogivoli@cs.technion.ac.il, roiri@technion.ac.il

Abstract

We consider a zero-shot semantic parsing task:
parsing instructions into compositional logical
forms, in domains that were not seen during
training. We present a new dataset with 1,390
examples from 7 application domains (e.g. a
calendar or a file manager), each example con-
sisting of a triplet: (a) the application’s initial
state, (b) an instruction, to be carried out in
the context of that state, and (c) the state of
the application after carrying out the instruc-
tion. We introduce a new training algorithm
that aims to train a semantic parser on exam-
ples from a set of source domains, so that it
can effectively parse instructions from an un-
known target domain. We integrate our algo-
rithm into the floating parser of Pasupat and
Liang (2015), and further augment the parser
with features and a logical form candidate fil-
tering logic, to support zero-shot adaptation.
Our experiments with various zero-shot adap-
tation setups demonstrate substantial perfor-
mance gains over a non-adapted parser.1

1 Introduction

The idea of interacting with machines via natural
language instructions and queries has fascinated
researchers for decades (Winograd, 1971). Recent
years have seen an increasing number of applica-
tions that have a natural language interface, either
in the form of chatbots or via “intelligent personal
assistants” such as Alexa (Amazon), Google As-
sistant, Siri (Apple), and Cortana (Microsoft).

In the near future, we may find ourselves in
a world where even more functionality could be
accessed via a natural language user interface
(NLUI). If so, we better seek answers to the fol-
lowing questions: Will every developing team
need to hire NLP experts to develop a NLUI for

1Our code and data are available at:
https://github.com/givoli/TechnionNLI.

their specific application? Can we hope for a gen-
eral framework that once trained on annotated data
from a set of domains, does not require annotated
data from a newly presented domain? Previous
work on tasks related to NLUI for applications
mostly relied on in-domain data (e.g. Artzi and
Zettlemoyer (2013); Long et al. (2016)), and pa-
pers that did not rely on in-domain data did not at-
tempt to parse instructions into compositional log-
ical forms (Kim et al., 2016).

To fill this gap, we address the task of zero-
shot semantic parsing for instructions: training a
parser so that it can parse instructions into compo-
sitional logical forms, where the instructions are
from domains that were not seen during training.
Formally, our task assumes a set D = {d1, ..., dn}
of source domains, each corresponding to a sim-
ple application (e.g. a calendar or a file manager)
and an application program interface (API) con-
sisting of a set of interface methods. Each inter-
face method is augmented with a list of descrip-
tion phrases that are expected to be used by the
users of the application to ask for the invocation
of that method. These instructions are to be parsed
into logical forms that denote a method call with
specific arguments.

We collected a new dataset of 1,390 examples
from 7 domains. Each example in the dataset is
a triplet consisting of (a) the application’s initial
state, (b) an instruction, to be carried out in con-
text of that state, and (c) the state of the application
after carrying out the instruction, also referred to
as the desired state. The instructions were pro-
vided by MTurk workers, one for each pair of ini-
tial and desired states. Figure 1 demonstrates ex-
amples from two of the domains in our dataset.

We present a new training algorithm for zero-
shot semantic parsing, which involves learning the
weights in two steps, such that in each step differ-
ent source domains are used. Our training algo-

https://github.com/givoli/TechnionNLI


4455

Figure 1: Two examples from our dataset. Annotators
are presented with a visualization of initial and desired
states, and are asked to write an instruction that will
transfer the system from the former state to the latter.
(a) Shipping containers can be either empty (gray) or
full (blue), and have varying length. (b) Rooms can
have their lights on (orange) or off (gray).

rithm is motivated by the goal of optimizing the
weights for unseen domains rather than for the
source domains, and is integrated into the float-
ing parser (Pasupat and Liang, 2015): a parser that
was designed for question answering, but is easy
to adjust to instruction execution (see § 4.1).

To further assist the parser in dealing with the
zero-shot setup, we extract additional features,
mostly based on co-occurrence of primitive log-
ical forms and the description phrases that are
provided for the interface methods. We also use
the application logic to dismiss candidate logical
forms that represent a method call which does not
modify the application state or results in an excep-
tion being thrown from the application logic.

Our training algorithm yields an averaged accu-
racy of 44.5%, compared to 39.1% of the parser
when trained with its original AdaGrad training
algorithm (Duchi et al., 2011), but with our fea-
tures and filtering logic. Further exclusion of our
features and filtering logic decreases accuracy to
28.3%. We demonstrate that, relative to the base-
line, our training algorithm yields smaller weights
to some features in a way that can be expected to
benefit previously unseen domains.

2 Previous Work

Previous work on executable semantic parsing can
be classified as either work on question answer-
ing (e.g. Clarke et al. (2010); Pasupat and Liang
(2015); Krishnamurthy et al. (2017)) or instruc-
tion parsing (e.g. Artzi and Zettlemoyer (2013);
Long et al. (2016)). The result of executing a log-

ical form is either an answer or a change in some
state, respectively. Our work is the first to address
the novel semantic parsing task of mapping natu-
ral language instructions into compositional logi-
cal forms in zero-shot settings.

While in our task each example contains
a single sentence instruction, there are works
on semantic parsing for instruction sequences
(MacMahon et al., 2006; Long et al., 2016), but
not in a zero-shot setup. We keep zero-shot pars-
ing of instruction sequences for future research.

A lot of work has been done on slot tagging
and goal-oriented dialog (Kim et al., 2016; Gašić
et al., 2017; Zhao and Eskenazi, 2018) which, sim-
ilarly to our work, involves automatically enabling
an NLUI to a given system. Unlike in our task,
the tasks that are investigated in those papers do
not require the mapping of natural language to a
meaning representation over a space of composi-
tional logical forms. Other tasks related to ours
include program synthesis (Raza et al., 2015; De-
sai et al., 2016) and mapping natural language to
bash code (Lin et al., 2018), but these also did not
consider zero-shot setups and did not synthesize
code in the context of an application state.

Semantic Parsing with In-domain Data
Among the semantic parsing work that relied on
in-domain data, many relied on a domain-specific
lexicon (Kwiatkowski et al., 2010; Gerber and
Ngomo, 2011; Krishnamurthy and Mitchell, 2012;
Zettlemoyer and Collins, 2005; Cai and Yates,
2013) which maps natural language phrases to
primitive logical forms. Many of these works au-
tomatically constructed a domain-specific lexicon
using some additional domain-specific resources
that are associated with the entities and relations
of the given domain. Such a resource can be either
a very large corpus (Gerber and Ngomo, 2011;
Krishnamurthy and Mitchell, 2012), search results
from the Web (Cai and Yates, 2013) or pairs of a
sentence and an associated logical form (Zettle-
moyer and Collins, 2005; Kwiatkowski et al.,
2010). In our task none of the above resources
is assumed to be available but instead we use the
description phrases of the interface methods.

Cross-domain and Zero-shot Semantic Parsing
Previous semantic parsers use supervised train-
ing, either with (Zettlemoyer and Collins, 2005;
Kwiatkowski et al., 2010) or without (Clarke et al.,
2010; Berant et al., 2013) logical forms annota-



4456

tion, in addition to unsupervised training (Gold-
wasser et al., 2011). We take the supervised ap-
proach with no logical form annotations.

While most semantic parsing work trains on in-
domain data, there are some exceptions. Cai and
Yates (2013) and Kwiatkowski et al. (2013) in-
troduced semantic parsers for question answering
that can parse utterances from Free917 (Cai and
Yates, 2013) such that no Freebase entities or re-
lations appear in both training and test examples.
We also note the relevance of the dataset presented
in Pasupat and Liang (2015) which contains ques-
tions about Wikipedia tables, such that the con-
text of each question is a single table. They eval-
uate a parser on questions about tables that have
not been observed during training. Their work
does not fully constitute zero-shot semantic pars-
ing due to table columns across the train/test split
that share column headers (which correspond to
primitive logical forms that represent relations).
Our parser is based on the floating parser intro-
duced in that paper, and the space of logical forms
we use is very similar to theirs (see § 4.1).

Recently, Herzig and Berant (2017) and Su
and Yan (2017) experimented with the Overnight
dataset (Wang et al., 2015) in cross-domain set-
tings. These papers did not experiment with zero-
shot setups (i.e. training without any data from the
target domain), and they both observed that the
less in-domain training data was used, the more
training data from other domains was valuable.
Recently Herzig and Berant (2018) explored zero-
shot semantic parsing with the Overnight dataset.
Their framework, unlike ours, requires logical
form annotation, and is designed for question an-
swering rather than instruction parsing.

Another zero-shot semantic parsing task was
introduced in Yu et al. (2018a). The task re-
quires mapping natural language questions to
SQL queries, and includes a setting in which no
databases appear in both the training and test sets
(as attempted in Yu et al. (2018b)).

3 Task and Data

We now describe our task and dataset.

3.1 Task

Our task involves parsing a natural language in-
struction, in the context of a small application, into
a method call that corresponds to the application’s
API. For example, the LIGHTING domain corre-

sponds to a lighting control system application that
allows the user to turn the lights on and off in each
room in their house.

Formally, a domain has a set of interface meth-
ods (e.g. turnLightOn and turnLightOff) that
can be invoked with some arguments. Each
argument is a set of entities (e.g. a set of
Room entities). There are two kinds of entity
types: domain-specific (e.g. Room) and non
domain-specific (Integer, String). Each interface
method is augmented with 1-3 description phrases
that correspond to its functionality. For exam-
ple, the interface method removeEvents from the
CALENDAR domain has the description phrases
remove and cancel.

A state defines a knowledge base, consisting of
a set of (e1, r, e2) triplets, where e1 and e2 are en-
tities and r is a relation. For example, a knowl-
edge base in the LIGHTING domain might contain
the triplet (room3, floor, 2) which indicates that
room3 is on the second floor of the house. In fig-
ure 1 (b) we demonstrate two possible states in the
LIGHTING domain. In the first one, there is a bed-
room on the second floor with the lights turned on.
If that room is represented in the state s by the
entity room1, the following triplets will be in the
knowledge base of s: (room1,name,bedroom),
(room1,floor, 2) and (room1, lightMode,ON).

Our task is limited to mapping an utterance
into a single method call. A method call for-
mally consists of an [interface method, argument
list] pair. The invocation of the method call
changes the application state according to the
deterministic application logic.

Our dataset consists of examples from 7 ap-
plication domains. Each example is a triplet
(s, x, s′), where s is an initial application state, x
is a natural language instruction and s′ is a desired
application state, resulting from carrying out the
instruction x on the state s. The task is to train a
parser with examples from a given subset of do-
mains (the source domains), so that it can effec-
tively parse instructions from a different domain
(the target domain), which is unseen at training.

3.2 Data

Our task requires a dataset that consists of exam-
ples from multiple domains, such that each exam-
ple corresponds to an instruction in the context of
an application state. Following Long et al. (2016),
we constructed the dataset by presenting human



4457

annotators with visualizations of initial and de-
sired state pairs. The annotators were then asked
to write an English instruction that can be executed
in order to transfer the application from the initial
state to the desired state (see figure 1).

Given a domain and an interface method,
we randomly generate a state pair with the
following steps:

1. Randomly generating an initial state. For ex-
ample, in the LIGHTING domain (see figure
1 (b) of the main paper), we randomly se-
lect the number of floors, number of rooms in
each floor, and for each room we randomly
select a name (e.g. bedroom) from a list
of possible names, and a light mode (either
ON or OFF).

2. Randomly selecting arguments for the inter-
face methods. For example, in the LIGHTING
domain we randomly select a set of rooms
as an argument for the interface method
(turnLightOn or turnLightOff).

3. Invoking the interface method with the se-
lected arguments on the initial state. If the
result is a state that is identical to the initial
state, or if an error occurred during execution,
we go back to step 2. After 1,000 failed at-
tempts we deem the random initial state as
problematic and go back to step 1.

With this process, we collected 1,390 examples
from 7 domains (Table 1). We used the MTurk
platform and recruited annotators located in the
US with at least 1,000 approved tasks and a task
approval rate of at least 95%. Our dataset contains
utterances written by 53 unique annotators.

Throughout the dataset construction we blocked
16 annotators that generated utterances that did not
correspond to our instructions (mostly, referring
to irrelevant details of the provided figure which
are not part of the domain represented by the visu-
alized states). Annotators were paid 15-23 cents
per task (i.e. per utterance they write given a
state pair).

Each initial and desired state pair was given to
a single annotator. We filtered out examples with
utterances that consist of more than one sentence
(we instructed annotators to write only one sen-
tence). The average instruction length in the train-
ing set is 8.1 words.

We consider 7 domains: (a) CALENDAR: re-
moving calendar events and setting their color;

(b) CONTAINER: loading, unloading and re-
moving shipping containers; (c) FILE: remov-
ing files and moving them from one directory
to another; (d) LIGHTING: turning lights on
and off in rooms inside a house; (e) LIST: re-
moving elements and moving an element to the
beginning/end of a list; (f) MESSENGER: cre-
ating/deleting chat groups and muting/unmuting
them; and (g) WORKFORCE: assigning employees
to a new manager, firing employees, assigning an
employee to a new position and updating an em-
ployee’s salary.

Our choice of domains aims to include a vari-
ety of linguistic phenomena. These include su-
perlatives (e.g. remove the longest container in
CONTAINER, figure 1 (a)), spatial language (e.g.
turn off the light in the bedroom on floor 2 in
LIGHTING, figure 1 (b)), and temporal language
(e.g. delete my last two appointments on Thurs-
day, from CALENDAR). Also, the domains are
chosen to be rich enough to allow utterances with
highly compositional logical forms.

4 Zero-Shot Semantic Parsing For
Instructions

We modify the floating parser (henceforth denoted
with FParser), to address zero-shot learning in
three ways: (a) presenting a new training algo-
rithm; (b) filtering logical form candidates based
on the application logic; and (c) adding new fea-
tures. We begin with a brief description of the
FParser and then go on to describe our approach.

4.1 The Floating Parser

The FParser was designed to handle unseen predi-
cates, in the context of answering questions about
Wikipedia tables that did not appear during train-
ing.2 It is hence a natural starting point for our
zero-shot setup. We now describe the FParser
and its inference algorithm (with necessary model
modifications to support instruction parsing).

For each inference, the input of the parser is
an initial application state s, a set of interface
methods and their description phrases, and a nat-
ural language instruction x. The state s defines a
knowledge base Ks of (entity, relation, entity)
triples. The parser generates a set of logical
form candidates Zx that can be executed over the
knowledge base Ks to produce a method call c

2Their task diverged from zero-shot settings due to col-
umn headers that appear both in training and test tables.



4458

Domain Domain-specific entity types Interface method (parameters in parentheses) Examples # Train # Test #
CALENDAR Event (title, startTime, location, color, attendees) removeEvents(Collection<Event>)

setEventColor(Collection<Event>, Color)
199 100 99

CONTAINER
(container management system)

ShippingContainer (length,
contentState ∈ {LOADED,UNLOADED})

loadContainers(Collection<ShippingContainer>)
unloadContainers(Collection<ShippingContainer>)
removeContainers(Collection<ShippingContainer>)

201 104 97

FILE
(file manager)

Directory (name, childFiles, childDirectories)
File (name, type, sizeInBytes)

removeFiles(Collection<File>)
moveFiles(Collection<File>,Directory)

194 100 94

LIGHTING
(lighting control system)

Room (name, floor,
lightMode ∈ {ON,OFF})

turnLightOn(Collection<Room>)
turnLightOff(Collection<Room>)

209 104 105

LIST Element (value) remove(Collection<Element>)
moveToBeginning(Element)
moveToEnd(Element)

202 102 100

MESSENGER User (firstName)
ChatGroup (contacts, muted, participantsNumber)

createChatGroup(Collection<User>)
deleteChatGroups(Collection<ChatGroup>)
muteChatGroups(Collection<ChatGroup>)
unmuteChatGroups(Collection<ChatGroup>)

186 96 90

WORKFORCE
(workforce management system)

Employee (name, manager, salary,
position ∈ {DEVELOPER,QA,MANAGER})

assignEmployeesToNewManager(
Collection<Employee>, Employee)
fireEmployees(Collection<Employee>)
assignEmployeeToNewPosition(Employee, Position)
updateSalary(Employee, int)

199 101 98

Table 1: The domains in our dataset. The interface method parameters are presented in Java syntax. In the second
column, the properties of the non-primitive entities appear in parentheses.

formulated as an (interface method, argument list)
pair. The method call c can be invoked in the con-
text of s with the provided application logic, pro-
ducing the denotation y = JzKs, the resulting state.

For each logical form z ∈ Zx the parser ex-
tracts a feature vector φ(x, s, z). The probability
assigned to a logical form candidate z ∈ Zx is de-
fined by a log-linear model:

pθ(z|x, s) =
exp(θTφ(x, s, z))∑

z′∈Zx exp(θ
Tφ(x, s, z′))

where θ is the weight vector. The logical form
with maximal probability is chosen as the pre-
dicted logical form, and its denotation is the pre-
dicted desired state. Our logical form space is
based on λ-DCS (Liang, 2013), as in the original
FParser, but we use an additional derivation rule
that derives the logical form f(z1, ..., zn), denot-
ing a method call, given the primitive logical form
f (denoting an interface method) and the logical
forms z1, ..., zn (each denoting a set of entities that
correspond to an argument of f ).

The objective function is the L1 regularized log-
likelihood of the correct denotations across the
training data:

J(θ) =
1

N

N∑
i=1

log pθ(yi|xi, si)− λ‖θ‖1 (1)

where pθ(y|x, s) is the sum of the probabilities
assigned to all the candidate logical forms with
the denotation y.

4.2 Zero-Shot Parsing
We now present our modified FParser. We start
with our training algorithm, and proceed to the ap-
plication logic filtering and our new features.

4.2.1 Training: Gap Minimization via
Domain Partitioning (GMDP)

We start with some notations and definitions. Let
us denote the set of training domains with D =
d1, ..., dn. Let D = D1 ∪D2 be some partition of
the setD. The target domain is denoted with dn+1.
Let us now describe the training algorithm, formu-
lated in figure 2.

The GMDP algorithm consists of two steps. In
the first step, an initial estimate of the model pa-
rameters, denoted with θD1 , is learned on the train-
ing examples from the source domain subset D1.
θD1 is then used as an initialization for the second
step, in which the parser is re-trained, this time on
the training examples of the domains in D2.

In each of the two steps we update the weights
with AdaGrad (Duchi et al., 2011), the training al-
gorithm of the original FParser, using the objective
function in equation 1. Since this objective is non-
convex and hence sensitive to its starting point (pa-
rameter initialization), the weights learned at the
first step (θD1) have an impact on the final param-
eters of the parser (θD1,D2).

The motivation of GMDP training is simple. A
good zero-shot parser should perform well on ex-
amples from domains that have not been available
to it during training. To address this challenge,
this two step method first estimates its parameters



4459

Algorithm 1: Gap Minimization via Domain
Partitioning (GMDP)
Input: Domains partitioning: {D1, D2}
Output: Weight vector: θD1,D2

Initialize θ0
θD1 ← AdaGrad(D1, θ0)
θD1,D2 ← AdaGrad(D2, θD1)
return θD1,D2

Figure 2: The GMDP algorithm.

with respect to one set of domains (D1) and then
adjusts those parameters to fit a second set of do-
mains (D2) that have not been available at the first
training step. We refer to this adjustment process
as gap minimization.

The parser parameters learned by GMDP
strongly depend on the domains included in D1
and D2, and on the extent to which the adapta-
tion from D1 to D2 mimics the adaptation from
D = D1 ∪ D2 to the target domain dn+1. In
this paper we treat the division of domains to the
D1 and D2 subsets as a hyper-parameter and tune
it together with the other hyper-parameters of the
parser. Because this tuning process has to do with
the important division of the training domains to
D1 andD2, we detail it here as part of the descrip-
tion of the algorithm.

For every target domain dn+1 we iterate over
the training domains D = d1, ..., dn in a leave one
out manner, each time holding out one of the do-
mains di ∈ D, training on the other domains (D¬i)
with various hyper-parameter configurations and
testing on the training data of di. We consider
as a hyper-parameter the order of the domains in
D, assigning the first M domains to D1 and the
rest to D2 (di is excluded from the ordered list),
where M is another hyper-parameter. The hyper-
parameter configuration that works best in those n
iterations (achieves the highest average accuracy
on the held-out domains) is the one selected for
the training of the final parser for dn+1. When a
parser for dn+1 is then trained, we increase by one
the size of either D1 or D2, whichever is larger,
because this way the ratio between the size of D1
and D2 is kept as similar as possible to the ratio
during the hyper-parameter tuning.

4.2.2 Logical Form Filtering
The Fparser is a bottom-up beam-search parser, in
which a dynamic programming table is filled with

derivations. Each cell in the table corresponds to a
derivation size and a logical form category, where
the size is defined as the number of rules applied
when generating the logical form.

We add an additional stage to the inference step
of the parser. In this stage we filter logical form
candidates based on the application logic, which is
part of the domain definition. This filtering stage
dismisses incorrect candidate logical forms when
they represent a method call c that either does not
modify the application state or results in an excep-
tion being thrown. To do that, c is invoked on the
initial state s and if the result is a state identical to
s, or if an exception has been thrown by the ap-
plication logic, we dismiss the candidate logical
form. This added stage is especially important for
zero-shot settings, in which the application logic
of the target domain does not have any impact on
the learned weights.

As an example to application logic based filter-
ing, consider the LIGHTING domain in which the
lights in some rooms can be turned on and off. A
method call that turns off the lights in rooms where
the lights are already off does not change the ap-
plication state, and in such cases the correspond-
ing logical form will be dismissed. In the WORK-
FORCE domain, attempting to assign employees to
report to an employee who is not a manager results
in an exception being thrown.

4.2.3 Features
Given a state, an instruction and a logical form, we
extract the relevant features of the FParser (phrase-
predicate co-occurrence features3 and missing-
predicate features) and add our own features. We
extract features based on the description phrases:
the phrases that are provided for each inter-
face method as part of the domain definition.
The description phrases are used to extract addi-
tional phrase-predicate co-occurrence features and
missing-predicate features. For example, consider
the utterance Delete the largest file from the FILE
domain, with the logical form:

removeFiles(argmax(R[type].File,

R[sizeInBytes]))

The interface method removeFiles has the de-
scription phrase delete, which matches the phrase

3We use the term predicate here to be consistent with the
terminology used by Pasupat and Liang (2015), but in this
work it also includes primitive logical forms denoting inter-
face methods.



4460

Delete in the utterance, resulting in the extraction
of the corresponding co-occurrence features. Con-
versely, when the parser considers logical forms
that contain the method moveFiles instead of
removeFiles, it will extract features indicating
that a match between the unigram Delete and a
primitive logical form is possible but does not oc-
cur in the candidate logical form. We note the re-
sembles of this technique to the way Tafjord et al.
(2018) handled properties that were unseen during
training, using a list of provided words that are as-
sociated with the property.

We also extract features that correspond to the
size of a candidate logical form (the number of
derivation rules applied). The extracted features
indicate that the logical form size is larger than n,
for any n ≥ 2. These features captures a domain-
independent preference for simplicity.

5 Experimental Setup

Models and Baselines We compare eight com-
binations of parsers. Four models use our GMDP
training algorithm: (a) GMDP: the full model
(§ 4.2); (b) GMDP−A: where we do not ap-
ply the application logic filtering (§ 4.2.2); (c)
GMDP−F: where we do not use our features
(§ 4.2.3); and (d) GMDP−FA: where we omit
both our new features and the application logic fil-
tering. The other four models are identical, but
they use the original ADAGRAD training. Note
that ADAGRAD−FA corresponds to the original
FParser (with minimal modifications to support in-
struction parsing).

Notice that in some real-world settings our ap-
plication logic filtering, which requires invoking
interface methods hundreds of times per inference,
might be impractical (e.g. if executing the inter-
face methods is computationally intensive). This
motivates us to consider the results of the ablated
model that does not use the application logic.

Experiments In each experiment we train the
parsers on examples from 6 application domains
and test them on the remaining domain. Our evalu-
ation metric is accuracy: the fraction of the test ex-
amples where a correct denotation (desired state)
is predicted. For examples where multiple log-
ical forms achieve maximum score, we consider
the fraction that yields the desired state.

While in our main results we report the accu-
racy of the parsers on the target domain’s test set,
for the error and qualitative analyses we report the

accuracy on the target domain’s training set. We
do that in order to avoid multiple runs on the test
sets; we do not use the target domain’s training set
for other purposes (e.g. hyper-parameter tuning).
The average number of training and test examples
per domain is 101 and 97.6, respectively.

Hyper-parameter tuning We use a grid search
and leave-one-out cross-validation over the source
domains to tune the hyper-parameters. We tune
the following hyper-parameters: the L1 regular-
ization coefficient, the initial step-size, the num-
ber of training iterations (for the GMDP algo-
rithm: the number of training iterations in the sec-
ond step), and for the GMDP algorithm also: the
number and identity of training domains used in
the first (D1) and second (D2) steps, and the num-
ber of training iterations during the first step. We
use a beam size of 200 and limit the number of rule
applications per derivation to 15. We provide more
details about the values of the hyper-parameters
we consider in the appendix.

6 Results

Our results are summarized in Table 2. GMDP
outperforms ADAGRAD−FA, the original
FParser, in all the domains, and by 16.2%
on average accuracy. We next analyze the
importance of each of our zero-shot compo-
nents: the training algorithm, new features and
application logic filtering.

Training Algorithms GMDP (our full model)
yields an averaged accuracy of 44.5%, outper-
forming ADAGRAD, which is identical to our full
model except that training is performed with Ada-
Grad, by 5.4%. In four domains GMDP outper-
forms ADAGRAD by more than 4%. The gap is
most notable in the LIST and LIGHTING domains
where GMDP outperforms ADAGRAD by 14.3%
and 12.4%, respectively, but the improvements on
MESSENGER and WORKFORCE are also substan-
tial (8.4% and 4.1%, respectively). In the other
three domains, GMDP and ADAGRAD perform
identically (CONTAINER) or demonstrate differ-
ences of up to 2% (CALENDAR and FILE). Inter-
estingly, for the CALENDAR domain, performing
GMDP training without the features and filtering
(GMDP−FA) yields the best accuracy.

Features and Application Logic Removing our
new features (GMDP−F and ADAGRAD−F)
yields an averaged accuracy decrease of 17.6%



4461

Training Algorithm
and Model

CALENDAR CONTAINER FILE LIGHTING LIST MESSENGER WORKFORCE Avg.

GMDP 32.8 38.1 28.7 48.6 * 58.8 * 61.7 * 42.9 * 44.5
GMDP−F 36.4 25.8 21.3 11.4 33.5 37.2 22.8 26.9
GMDP−A 36.4 24.7 21.8 26.7 37.8 53.6 40.8 34.5

GMDP−FA 37.4 21.4 21.3 8.6 29.0 37.6 23.3 25.5

ADAGRAD
34.8

(39.9)
38.1

(36.1)
28.0

(39.4)
36.2

(83.8)
44.5

(88.0)
53.3

(73.3)
38.8

(57.7)
39.1

(59.7)
ADAGRAD−F 35.4 28.9 20.6 23.8 38.7 50.2 29.3 32.4
ADAGRAD−A 33.8 22.7 21.6 26.7 51.3 53.3 40.8 35.8

ADAGRAD−FA 29.8
(39.9)

21.6
(35.1)

19.5
(33.5)

10.5
(79.0)

39.6
(81.0)

49.6
(72.2)

27.4
(55.1)

28.3
(56.5)

Table 2: Test set accuracy. In parenthesis: result for the in-domain setup (training with the 96-104 training ex-
amples of the target domain). GMDP results marked with * represent a statistically significant difference from
ADAGRAD (α = 0.05, using the paired bootstrap test (Efron and Tibshirani, 1994), following Dror et al. (2018)),
we do not mark the cell in the Average column as statistically significant due to it being the average of accuracy
values from seven different distributions.

(from 44.5% to 26.9% for GMDP) or 6.7% (from
39.1% to 32.4% for ADAGRAD). Removing the
application logic filtering yields an averaged de-
crease of 10.0% (GMDP vs. GMDP−A) or 3.3%
(ADAGRAD vs. ADAGRAD−A). Finally, remov-
ing both the features and the application logic
yields an additional average degradation: a total
of 19% for GMDP and of 10.8% for ADAGRAD.

Combined Effect The impact of our features
and application logic filtering is much more sub-
stantial for GMDP models, both on average and
for the four domains where GMDP outperforms
ADAGRAD (four rightmost domain columns of the
table). Particularly, while in these four setups the
combination of GMDP training with the features
and filtering yields a substantial improvement over
AdaGrad training with these additions, excluding
either the features or the filtering often results in
an advantage for AdaGrad training. In the other
three setups, where GMDP and ADAGRAD per-
form similarly, excluding the features or the fil-
tering yields similar effects (with the exception of
GMDP−FA in the CALENDAR domain).

This observation provides an important insight
about our modeling decisions. At their best, our
three zero-shot components provide a complemen-
tary effect and these are the cases where our full
model, GMDP, is most useful. When this com-
plementary effect is not observed, AdaGrad and
GMDP training are equally effective.

Comparison with In-domain Training In or-
der to better quantify the impact of zero-shot train-
ing, we report results for AdaGrad training in the

in-domain setup, i.e. when the parser is trained
with the target domain’s training set. Note that
while the zero-shot models are trained with 603-
611 training examples (all the training examples
of the source domains), the in-domain models are
trained with 96-104 examples only.

As shown in Table 2, the accuracy of ADA-
GRAD with in-domain training is 15.2% higher
than that of GMDP with zero-shot training (59.7%
vs. 44.5%), despite the smaller number of train-
ing examples. A comparison between ADAGRAD
and ADAGRAD−FA reveals that in the in-domain
setup, our new features and filtering logic yields
only a modest performance gain that corresponds
to 3.2% on average (59.7% vs. 56.5%). This is an-
other induction for the relevance of our zero-shot
components to zero-shot adaptation.

Error analysis. For each domain we sample 10
training examples per interface method, and an-
alyze the performance of the parsers that are ap-
plied to this domain. This accumulates to 200 ex-
amples, that are used for the below error analysis.

For GMDP, 30.4% of the error is in examples
where the instruction is incorrect, which is the case
in 33 out of the 200 sampled examples (16.5%).
Another major source of errors is the lexical gap
between the domains. Consider the utterance re-
move the longest container from the CONTAINER
domain, with the correct logical form:

removeContainers(argmax(

R[type].ShippingContainer,R[length]))

The word longest did not appear in any example in
the source domains, and thus none of the relevant



4462

lexicalized features associated with argmax were
useful. In future work, we hence plan to extend
our parser to take word similarity into account.

Moreover, we found that 12.8% of the error
is due to incorrect parsing of utterances that ref-
erence an entity by its index. An example of
such an error is the mapping of the utterance un-
load the container in terminal four to the logical
form unloadContainers(R[length].4) instead of
unloadContainers(R[index].4).

Qualitative analysis. We observe that GMDP
yields smaller weights for features that can be ex-
pected to correlate with incorrect logical forms
due to the zero-shot setup. For example, in the
CONTAINER domain annotators often referred to
entities by their index (e.g. Remove the con-
tainer in the third terminal), while in the LIST
domain annotators mostly refer to entities (inte-
gers) by their numeric value. When LIST is the
target domain, we observe that in GMDP the lex-
icalized phrase-predicate features that indicate co-
occurrence between the logical form R[index] and
phrases that do not indicate an index based refer-
ence, receive smaller weights when compared to
ADAGRAD. For example, we find that the feature
that indicates a co-occurrence between R[index]
and the phrase in corresponds to the largest de-
crease in weight percentile rank: 88.7 points. At
the same time, the feature that indicates a co-
occurrence with the phrase the first (which should
correlate with R[index] being in the logical form)
corresponds to the largest increase in weight per-
centile rank: 86.1 points.

As a result of this change in feature weight-
ing, for LIST utterance such as: Remove the num-
ber 2 from the list, GMDP tends to yield cor-
rect logical forms (e.g. remove(R[value.2])),
unlike ADAGRAD that tends to query enti-
ties by their index instead of by their value
(e.g. remove(R[index.2])).

7 Conclusion

We presented a novel task of zero shot seman-
tic parsing for instructions, and introduced a new
dataset. We proposed a new training algorithm
as well as features and filtering logic that should
enhance zero-shot learning, and integrated them
into the FParser (Pasupat and Liang, 2015). Our
new parser substantially outperforms the original
parser and we further show that each of our zero-
shot components is vital for this improvement.

We hope this work will inspire readers to use
our framework for collecting a larger dataset and
experimenting with more approaches. Our frame-
work is designed to allow the definition of new do-
mains and collecting examples with minimal ef-
fort. Promising future directions include experi-
menting with our zero-shot adaptation methods in
the context of neural semantic parsing (after in-
creasing the number of examples per domain) and
extending the dataset to include more complicated
applications and multi-utterance instructions.

Acknowledgements

We would like to thank the members of the
IE@Technion NLP group for their valuable feed-
back and advice. This research has been funded
by an ISF personal grant on ”Domain Adaptation
in NLP: Combining Deep Learning with Domain
and Task Knowledge”.

References
Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-

pervised learning of semantic parsers for mapping
instructions to actions. Transactions of the Associa-
tion for Computational Linguistics, 1:49–62.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1533–1544. Association
for Computational Linguistics.

Qingqing Cai and Alexander Yates. 2013. Large-scale
semantic parsing via schema matching and lexicon
extension. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers), pages 423–433. Associa-
tion for Computational Linguistics.

James Clarke, Dan Goldwasser, Ming-Wei Chang, and
Dan Roth. 2010. Driving semantic parsing from
the world’s response. In Proceedings of the Four-
teenth Conference on Computational Natural Lan-
guage Learning, pages 18–27. Association for Com-
putational Linguistics.

Aditya Desai, Sumit Gulwani, Vineet Hingorani, Nidhi
Jain, Amey Karkare, Mark Marron, Sailesh R, and
Subhajit Roy. 2016. Program synthesis using nat-
ural language. In Proceedings of the 38th Interna-
tional Conference on Software Engineering, ICSE
’16, pages 345–356, New York, NY, USA. ACM.

Rotem Dror, Gili Baumer, Segev Shlomov, and Roi Re-
ichart. 2018. The hitchhiker’s guide to testing sta-
tistical significance in natural language processing.
In Proceedings of the 56th Annual Meeting of the

http://aclweb.org/anthology/Q13-1005
http://aclweb.org/anthology/Q13-1005
http://aclweb.org/anthology/Q13-1005
http://aclweb.org/anthology/D13-1160
http://aclweb.org/anthology/D13-1160
http://aclweb.org/anthology/P13-1042
http://aclweb.org/anthology/P13-1042
http://aclweb.org/anthology/P13-1042
http://aclweb.org/anthology/W10-2903
http://aclweb.org/anthology/W10-2903
https://doi.org/10.1145/2884781.2884786
https://doi.org/10.1145/2884781.2884786
http://aclweb.org/anthology/P18-1128
http://aclweb.org/anthology/P18-1128


4463

Association for Computational Linguistics (Volume
1: Long Papers), pages 1383–1392. Association for
Computational Linguistics.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
and stochastic optimization. J. Mach. Learn. Res.,
12:2121–2159.

Bradley Efron and Robert J Tibshirani. 1994. An intro-
duction to the bootstrap. CRC press.

Milica Gašić, Nikola Mrkšić, Lina M Rojas-Barahona,
Pei-Hao Su, Stefan Ultes, David Vandyke, Tsung-
Hsien Wen, and Steve Young. 2017. Dialogue man-
ager domain adaptation using gaussian process rein-
forcement learning. Computer Speech & Language,
45:552–569.

Daniel Gerber and A-C Ngonga Ngomo. 2011. Boot-
strapping the linked data web. In 1st Workshop on
Web Scale Knowledge Extraction at ISWC.

Dan Goldwasser, Roi Reichart, James Clarke, and Dan
Roth. 2011. Confidence driven unsupervised seman-
tic parsing. In Proceedings of the 49th Annual Meet-
ing of the Association for Computational Linguis-
tics: Human Language Technologies, pages 1486–
1495. Association for Computational Linguistics.

Jonathan Herzig and Jonathan Berant. 2017. Neu-
ral semantic parsing over multiple knowledge-bases.
In Proceedings of the 55th Annual Meeting of the
Association for Computational Linguistics (Volume
2: Short Papers), pages 623–628. Association for
Computational Linguistics.

Jonathan Herzig and Jonathan Berant. 2018. Decou-
pling structure and lexicon for zero-shot semantic
parsing. In Proceedings of the 2018 Conference on
Empirical Methods in Natural Language Process-
ing, pages 1619–1629. Association for Computa-
tional Linguistics.

Young-Bum Kim, Alexandre Rochette, and Ruhi
Sarikaya. 2016. Natural language model re-usability
for scaling to different domains. In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing, pages 2071–2076. Asso-
ciation for Computational Linguistics.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gard-
ner. 2017. Neural semantic parsing with type con-
straints for semi-structured tables. In Proceedings
of the 2017 Conference on Empirical Methods in
Natural Language Processing, pages 1516–1526,
Copenhagen, Denmark. Association for Computa-
tional Linguistics.

Jayant Krishnamurthy and Tom Mitchell. 2012.
Weakly supervised training of semantic parsers. In
Proceedings of the 2012 Joint Conference on Empir-
ical Methods in Natural Language Processing and
Computational Natural Language Learning, pages
754–765. Association for Computational Linguis-
tics.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and Luke
Zettlemoyer. 2013. Scaling semantic parsers with
on-the-fly ontology matching. In Proceedings of the
2013 Conference on Empirical Methods in Natural
Language Processing, pages 1545–1556. Associa-
tion for Computational Linguistics.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Gold-
water, and Mark Steedman. 2010. Inducing proba-
bilistic ccg grammars from logical form with higher-
order unification. In Proceedings of the 2010 Con-
ference on Empirical Methods in Natural Language
Processing, pages 1223–1233. Association for Com-
putational Linguistics.

Percy Liang. 2013. Lambda dependency-based com-
positional semantics. CoRR, abs/1309.4408.

Xi Victoria Lin, Chenglong Wang, Luke Zettlemoyer,
and Michael D. Ernst. 2018. Nl2bash: A corpus
and semantic parser for natural language interface
to the linux operating system. In Proceedings of
the Eleventh International Conference on Language
Resources and Evaluation LREC 2018, Miyazaki
(Japan), 7-12 May, 2018.

Reginald Long, Panupong Pasupat, and Percy Liang.
2016. Simpler context-dependent logical forms via
model projections. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 1456–
1465. Association for Computational Linguistics.

Matt MacMahon, Brian Stankiewicz, and Benjamin
Kuipers. 2006. Walk the talk: Connecting language,
knowledge, and action in route instructions. In Pro-
ceedings of the 21st National Conference on Artifi-
cial Intelligence - Volume 2, AAAI’06, pages 1475–
1482. AAAI Press.

Panupong Pasupat and Percy Liang. 2015. Compo-
sitional semantic parsing on semi-structured tables.
In Proceedings of the 53rd Annual Meeting of the
Association for Computational Linguistics and the
7th International Joint Conference on Natural Lan-
guage Processing (Volume 1: Long Papers), pages
1470–1480. Association for Computational Linguis-
tics.

Mohammad Raza, Sumit Gulwani, and Natasa Milic-
Frayling. 2015. Compositional program synthesis
from natural language and examples. In Proceed-
ings of the 24th International Conference on Artifi-
cial Intelligence, IJCAI’15, pages 792–800. AAAI
Press.

Yu Su and Xifeng Yan. 2017. Cross-domain seman-
tic parsing via paraphrasing. In Proceedings of the
2017 Conference on Empirical Methods in Natural
Language Processing, pages 1235–1246. Associa-
tion for Computational Linguistics.

Oyvind Tafjord, Peter Clark, Matt Gardner, Wen-tau
Yih, and Ashish Sabharwal. 2018. Quarel: A dataset
and models for answering questions about qualita-
tive relationships. CoRR, abs/1811.08048.

http://dl.acm.org/citation.cfm?id=1953048.2021068
http://dl.acm.org/citation.cfm?id=1953048.2021068
http://aclweb.org/anthology/P11-1149
http://aclweb.org/anthology/P11-1149
https://doi.org/10.18653/v1/P17-2098
https://doi.org/10.18653/v1/P17-2098
http://aclweb.org/anthology/D18-1190
http://aclweb.org/anthology/D18-1190
http://aclweb.org/anthology/D18-1190
https://doi.org/10.18653/v1/D16-1222
https://doi.org/10.18653/v1/D16-1222
https://doi.org/10.18653/v1/D17-1160
https://doi.org/10.18653/v1/D17-1160
http://aclweb.org/anthology/D12-1069
http://aclweb.org/anthology/D13-1161
http://aclweb.org/anthology/D13-1161
http://aclweb.org/anthology/D10-1119
http://aclweb.org/anthology/D10-1119
http://aclweb.org/anthology/D10-1119
http://dblp.uni-trier.de/db/journals/corr/corr1309.html#Liang13
http://dblp.uni-trier.de/db/journals/corr/corr1309.html#Liang13
https://doi.org/10.18653/v1/P16-1138
https://doi.org/10.18653/v1/P16-1138
http://dl.acm.org/citation.cfm?id=1597348.1597423
http://dl.acm.org/citation.cfm?id=1597348.1597423
https://doi.org/10.3115/v1/P15-1142
https://doi.org/10.3115/v1/P15-1142
http://dl.acm.org/citation.cfm?id=2832249.2832359
http://dl.acm.org/citation.cfm?id=2832249.2832359
https://doi.org/10.18653/v1/D17-1127
https://doi.org/10.18653/v1/D17-1127
http://arxiv.org/abs/1811.08048
http://arxiv.org/abs/1811.08048
http://arxiv.org/abs/1811.08048


4464

Yushi Wang, Jonathan Berant, and Percy Liang. 2015.
Building a semantic parser overnight. In Proceed-
ings of the 53rd Annual Meeting of the Association
for Computational Linguistics and the 7th Interna-
tional Joint Conference on Natural Language Pro-
cessing (Volume 1: Long Papers), pages 1332–1342.
Association for Computational Linguistics.

Terry Winograd. 1971. Procedures as a representation
for data in a computer program for understanding
natural language. Technical report, Massachusetts
Institute of Technology, Project MAC.

Tao Yu, Michihiro Yasunaga, Kai Yang, Rui Zhang,
Dongxu Wang, Zifan Li, and Dragomir Radev.
2018b. SyntaxSQLNet: Syntax tree networks
for complex and cross-domain text-to-SQL task.
In Proceedings of the 2018 Conference on Em-
pirical Methods in Natural Language Processing,
pages 1653–1663, Brussels, Belgium. Association
for Computational Linguistics.

Tao Yu, Rui Zhang, Kai Yang, Michihiro Yasunaga,
Dongxu Wang, Zifan Li, James Ma, Irene Li,
Qingning Yao, Shanelle Roman, Zilin Zhang,
and Dragomir Radev. 2018a. Spider: A large-
scale human-labeled dataset for complex and cross-
domain semantic parsing and text-to-SQL task.
In Proceedings of the 2018 Conference on Em-
pirical Methods in Natural Language Processing,
pages 3911–3921, Brussels, Belgium. Association
for Computational Linguistics.

Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In Proceedings of the Twenty-First Con-
ference on Uncertainty in Artificial Intelligence,
UAI’05, pages 658–666, Arlington, Virginia, United
States. AUAI Press.

Tiancheng Zhao and Maxine Eskenazi. 2018. Zero-
shot dialog generation with cross-domain latent ac-
tions. In Proceedings of the 19th Annual SIGdial
Meeting on Discourse and Dialogue, pages 1–10.
Association for Computational Linguistics.

A Hyper-parameter Tuning

The hyper-parameters we consider in the grid
search are as follows. L1 regularization coeffi-
cient: {0.001, 0.01}; initial step-size: {0.01, 0.1};
number of training iterations (for the GMDP algo-
rithm, the number of training iterations in the sec-
ond step): {1, 2, 3}. For the GMDP algorithm, the
grid search also included the number of training
domains used for the first step (D1): {3, 4} (the re-
maining domains are used in the second step, D2)
with three random domain orderings for determin-
ing the D1, D2 partition (see the last paragraph of
Section 4.2.1 for how these hyper-parameters are

used), and the number of training iterations during
the first step: {2, 4}.

https://doi.org/10.3115/v1/P15-1129
https://www.aclweb.org/anthology/D18-1193
https://www.aclweb.org/anthology/D18-1193
https://www.aclweb.org/anthology/D18-1425
https://www.aclweb.org/anthology/D18-1425
https://www.aclweb.org/anthology/D18-1425
http://dl.acm.org/citation.cfm?id=3020336.3020416
http://dl.acm.org/citation.cfm?id=3020336.3020416
http://dl.acm.org/citation.cfm?id=3020336.3020416
http://aclweb.org/anthology/W18-5001
http://aclweb.org/anthology/W18-5001
http://aclweb.org/anthology/W18-5001

