



















































CoNLL-2017 Shared Task


Proceedings of the CoNLL 2017 Shared Task: Multilingual Parsing from Raw Text to Universal Dependencies, pages 152–162,
Vancouver, Canada, August 3-4, 2017. c© 2017 Association for Computational Linguistics

A non-projective greedy dependency parser with bidirectional LSTMs

David Vilares
Universidade da Coruña

LyS Group
Departamento de Computación
Campus de Elviña s/n, 15071

A Coruña, Spain
david.vilares@udc.es

Carlos Gómez-Rodrı́guez
Universidade da Coruña

FASTPARSE Lab, LyS Group
Departamento de Computación
Campus de A Elviña s/n, 15071

A Coruña, Spain
carlos.gomez@udc.es

Abstract

The LyS-FASTPARSE team presents
BIST-COVINGTON, a neural implementa-
tion of the Covington (2001) algorithm
for non-projective dependency parsing.
The bidirectional LSTM approach by
Kiperwasser and Goldberg (2016) is used
to train a greedy parser with a dynamic
oracle to mitigate error propagation. The
model participated in the CoNLL 2017
UD Shared Task. In spite of not using
any ensemble methods and using the
baseline segmentation and PoS tagging,
the parser obtained good results on both
macro-average LAS and UAS in the
big treebanks category (55 languages),
ranking 7th out of 33 teams. In the all
treebanks category (LAS and UAS) we
ranked 16th and 12th. The gap between
the all and big categories is mainly due
to the poor performance on four parallel
PUD treebanks, suggesting that some ‘suf-
fixed’ treebanks (e.g. Spanish-AnCora)
perform poorly on cross-treebank settings,
which does not occur with the correspond-
ing ‘unsuffixed’ treebank (e.g. Spanish).
By changing that, we obtain the 11th
best LAS among all runs (official and
unofficial). The code is made available
at https://github.com/CoNLL-
UD-2017/LyS-FASTPARSE

1 Introduction

Dependency parsing is one of the core structured
prediction tasks researched by computational lin-
guists, due to the potential advantages that ob-
taining the syntactic structure of a text has in
many natural language processing applications,
such as machine translation (Miceli-Barone and

Attardi, 2015; Xiao et al., 2016), sentiment anal-
ysis (Socher et al., 2013; Vilares et al., 2017) or
information extraction (Yu et al., 2015).

The goal of a dependency parser is to analyze
the syntactic structure of sentences in one or sev-
eral human languages by obtaining their analy-
ses in the form of dependency trees. Let w =
[w1, w2, ..., w|w|] be an input sentence, a depen-
dency tree for w is an edge-labeled directed tree
T = (V,E) where V = {0, 1, 2, . . . , |w|} is the
set of nodes and E = V × D × V is the set of
labeled arcs. Each arc, of the form (i, d, j), cor-
responds to a syntactic dependency between the
words wi and wj ; where i is the index of the head
word, j is the index of the child word and d is the
dependency type representing the kind of syntac-
tic relation between them.1 We will write i d−→ j
as shorthand for (i, d, j) ∈ E and we will omit the
dependency types when they are not relevant.

A dependency tree is said to be non-projective
if it contains two arcs i −→ j and k −→ l
where min(i, j) < min(k, l) < max(i, j) <
max(k, l), i.e., if there is any pair of arcs that
cross when they are drawn over the sentence, as
shown in Figure 1. Unrestricted non-projective
parsing allows more accurate syntactic represen-
tations than projective parsing, but it comes at a
higher computational cost, as there is more flexi-
bility in how the tree can be arranged so that more
operations are usually needed to explore the much
larger search space.

Non-projective transition-based parsing has
been actively explored in the last decade
(Nivre and Nilsson, 2005; Attardi, 2006; Nivre,
2008, 2009; Gómez-Rodrı́guez and Nivre, 2010;
Gómez-Rodrı́guez et al., 2014). The success of
neural networks and word embeddings for pro-

1Following common practice, we are using node 0 as a
dummy root node that acts as the head of the syntactic root(s)
of the sentence.

152



He   gave   a   talk   yesterday   about   parsing 

Figure 1: A non-projective dependency tree

jective dependency parsing (Chen and Manning,
2014) also encouraged research on neural non-
projective models (Straka et al., 2016). How-
ever, to the best of our knowledge, no neural
implementation is available of unrestricted non-
projective transition-based parsing with a dynamic
oracle. Here, we present such an implementation
for the Covington (2001) algorithm using bidirec-
tional long short-term memory networks (LSTM)
(Hochreiter and Schmidhuber, 1997), which is the
main contribution of this paper.

The system is evaluated at the CoNLL 2017 UD
Shared Task: end-to-end multilingual parsing us-
ing Universal Dependencies (Zeman et al., 2017).
The goal is to obtain a Universal Dependencies
v2.0 representation (Nivre et al., 2016) of a col-
lection of raw texts in different languages.

2 End-to-end multilingual parsing

Given a raw text, we: (1) segment and tokenize
sentences and words, (2) apply part-of-speech
(PoS) tagging over them and (3) obtain the depen-
dency structure for each sentence.

2.1 Segmentation and PoS tagging
For these two steps we relied on the output pro-
vided by UDpipe v1.1 (Straka et al., 2016), which
was provided as a baseline model for the shared
task.

2.2 The BIST-COVINGTON parser
BIST-COVINGTON is built on the top of three core
ideas: a non-projective transition-based parsing al-
gorithm (Covington, 2001; Nivre, 2008), a neural
scoring model with bidirectional long short-term
memory networks as feature extractors that feed
a multilayer perceptron (Kiperwasser and Gold-
berg, 2016), and a dynamic oracle to mitigate error
propagation (Gómez-Rodrı́guez and Fernández-
González, 2015).

2.2.1 The Covington (2001) algorithm
The idea of Covington’s algorithm is quite intu-
itive: any pair of words wi, wj in w have a chance
to be connected, so we need to consider all such

pairs to determine the type of relation that exists
between them (i.e. i d−→ j, j d−→ i or none). One
pair (i, j) is compared at a time. We will be refer-
ring to the indexes i and j as the focus words. It
is straightforward to conclude that the theoretical
complexity of the algorithm is O(|w|2).

Covington’s algorithm can be easily imple-
mented as a transition system (Nivre, 2008). The
set of transitions used in BIST-COVINGTON and
their preconditions is specified in Table 1. Each
transition corresponds to a parsing configuration
represented as a 4-tuple c = (λ1, λ2, β, A), such
that:

• λ1, λ2 are two lists storing the words that
have been already processed in previous
steps. λ1 contains the already processed
words for which the parser still has not de-
cided, in the current state, the type of rela-
tion with respect to the focus word j, located
at the top of β. λ2 contains the already pro-
cessed words for which the parser has already
determined the type of relation with respect
to j in the current step.

• β contains the words to be processed.
• A contains the set of arcs already created.
Given a sentence w the parser starts at an initial

configuration cs = ([0], [], [1, ..., |w|], {}) and will
apply valid transitions until reaching a final con-
figuration cf such that cf = (λ1, λ2, [], A). Figure
2 illustrates an intermediate parsing configuration
for our introductory example.

He     gave     a     talk     yesterday     about     parsing
1          2          3       4                5                    6              7

A = [(0,2), (2,1), (4,3), (2,5), (2,4)]

i j

λ1 λ2 β

Figure 2: A parsing configuration for our in-
troductory example just before creating a non-
projective RIGHT ARC talk −→ about.

2.2.2 A dynamic oracle for Covington’s
algorithm (Gómez-Rodrı́guez and
Fernández-González, 2015)

Given a gold dependency tree, τg, and a parser
configuration c, we can define a loss function

153



Transitions
LEFT ARC (λ1|i, λ2, j|β,A) (λ1, i|λ2, j|β,A ∪ {(j, d, i)})
RIGHT ARC (λ1|i, λ2, j|β,A) (λ1, i|λ2, j|β,A ∪ {(i, d, j)})
SHIFT (λ1, λ2, i|β,A) (λ1 · λ2|i, [], β, A)
NO-ARC (λ1|i, λ2, β, A) (λ1 · i|λ2, β, A)

Preconditions
LEFT ARC i > 0 and 6 ∃(k −→ i) ∈ A and 6 ∃(i −→ ... −→ j)
RIGHT ARC 6 ∃(k −→ j) ∈ A and 6 ∃(j −→ ... −→ i)
NO-ARC i > 0

Table 1: Set of transitions for BIST-COVINGTON as described in Nivre (2008). a −→ ... −→ b indicates
there is a path in the dependency tree that allows to reach b from a

L(c, τg) that determines the minimum number of
missed arcs of τg across the possible outputs (A)
of final configurations that can be reached from c,
i.e., the least possible number of errors with re-
spect to τg that we can obtain from c. A static
(traditional) oracle is only defined on canonical
transition sequences that lead to the gold tree, so
that L(c, τg) = 0 at every step during the training
phase. However, during the test phase such train-
ing strategy might end up in serious error propaga-
tion, as it is difficult for the parser to recover from
wrong configurations that it has never seen, result-
ing from suboptimal transitions that increase loss.
A dynamic oracle (Goldberg and Nivre, 2012) ex-
plores such wrong configurations during the train-
ing phase to overcome this issue. Instead of al-
ways picking the optimal transition during train-
ing, the parser moves with probability x to an erro-
neous (loss-increasing) configuration, namely the
one with the highest score among those that in-
crease loss.

To compute L for non-projective trees we
used the approach proposed by Gómez-Rodrı́guez
and Fernández-González (2015, Algorithm 1).
This dynamic oracle can be computed in O(|w|)
although the current implementation in BIST-
COVINGTON is O(|w|3). To choose the depen-
dency type corresponding to the selected transition
(in case it is a LEFT or RIGHT ARC), we look at the
gold treebank.

2.2.3 The BIST-parsers (Kiperwasser and
Goldberg, 2016)

The original set of BIST-parsers is composed
of a projective transition-based model using the
arc-hybrid algorithm (Kuhlmann et al., 2011)
and a graph-based model inspired in Eisner

(1996). They both rely on bidirectional LSTM’s
(BILSTM’s). We kept the main architecture of the
arc-hybrid BIST-parser and changed the parsing
algorithm to that described in §2.2.1 and §2.2.2.
We encourage the reader to consult Kiperwasser
and Goldberg (2016) for a detailed explanation
of their architecture, but we now try to give a
quick overview of its use as the core part of BIST-
COVINGTON.2

In contrast to traditional parsers (Nivre et al.,
2006; Martins et al., 2010; Rasooli and Tetreault,
2015), BIST-parsers rely on embeddings as inputs
instead of on discrete events (co-occurrences of
words, tags, features, etc.). Embeddings are low-
dimensional vectors that provide a continuous rep-
resentation of a linguistic unit (word, PoS tag, etc.)
based on its context (Mikolov et al., 2013).

Let w=[w1, ...,w|w|] be a list of word embed-
dings for a sentence, let u=[u1, ...,u|w|] be the cor-
responding list of universal PoS tag embeddings,
t=[t1, ..., t|w|] the list of specific PoS tag embed-
dings, f=[f1, ..., f|w|] the list of morphological fea-
tures (“feats” column in the Universal Dependen-
cies data format) and e=[e1, ..., e|w|] a list of exter-
nal word embeddings; an input xi for a word wi to
BIST-COVINGTON is defined as:3

xi = wi ◦ ui ◦ ti ◦ fi ◦ ei
where ◦ is the concatenation operator.
Let LSTM(x) be an abstraction of a standard

long short-term memory network that processes
the sequence x = [x1, ...,x|x|], then a BILSTM
encoding of its ith element, BILSTM(x, i) can be

2Including some additional capabilities that we included
especially for BIST-COVINGTON.

3 It might turn out that for some treebank/language some
of this information is not available, in which case the unavail-
able elements are considered as empty lists.

154



defined as:

BILSTM(x, i) = LSTM(x1:i) ◦ LSTM(x|x|:i)
In the case of multilayer BILSTM’S (BIST-

parsers allow it), given n layers, the output of the
BILSTMm is fed as input to BILSTMm+1. From
the BILSTM network we take a hidden vector h,
which can contain the output hidden vectors for:
the x leftmost words in β, the rightmost y of λ1,
and the z leftmost and v rightmost words in λ2.

The hidden vector h is used to feed a multilayer
perceptron with one hidden layer and four output
neurons that predicts which transition to take. The
output is computed as W2 · tanh(W ·h + b) + b2,
where W,W2, b and b2 correspond to the weight
matrices and bias vectors of the hidden and output
layer of the perceptron. Similarly, BIST-parsers
(including BIST-COVINGTON) use a second per-
ceptron with one hidden layer to predict the de-
pendency type. In this case the output layer corre-
sponds to the number of dependency types in the
training set.

2.3 Postprocessing
BIST-COVINGTON as it is allows parses with mul-
tiple roots, i.e., with several nodes assigned as
children of the dummy root. This was not allowed
however by the task organizers, as it is enforced
by Universal Dependencies that only one word per
sentence must depend on the dummy root. To
overcome this, the output is postprocessed accord-
ing to Algorithm 1. Basically, we look for the first
verb rooted at 0, or for the first word whose head
is 0 if there is no verb, and reassign all other words
to the selected term:

3 Experiments

We here describe the official treebanks used in the
shared task (§3.1), the general setup used to train
the models (§3.2) and some exceptions to said gen-
eral setup that were applied to special cases (§3.3).
We also discuss the experimental results obtained
by our system in the shared task (§3.4).
3.1 CoNLL 2017 treebanks
3.1.1 Training/development splits
60 treebanks from 45 languages were released to
train the models, based on Universal Dependen-
cies 2.0 (Nivre et al., 2017a). Most of them al-
ready contained official training and development
splits. A few others lacked a development set.
For these, we applied a training/dev random split

Algorithm 1 Multiple to single node root
1: procedure TO SINGLE(V, E)

. Get the nodes rooted at zero (those whose head has to
be reassigned)

2: RO ← []
3: for i in V do
4: if head(i) = 0 then
5: append(RO, i)

. We select the first verb linked to the dummy root to
remove multiple roots

6: if len(RO) > 1 then
7: closest head← RO[0]
8: for r0 in RO do
9: if utag(r0) = VERB then

10: closest head← r0
11: break

. Reassign the head of the invalid nodes (rooted to the
dummy root) to closest head

12: for r0 in RO do
13: if r0 6= closest head then
14: head(r0)← closest head

(80/20) over the original training set. All devel-
opment sets were only used to evaluate and tune
the trained models. No development set was used
to train any of the runs, as specified in the task
guidelines.

Additionally, four surprise languages (truly low
resource languages), were considered by the orga-
nization for evaluation: Buryat, Kurmanji, North
Sami and Upper Sorbian. For these, the organiz-
ers only released a tiny sample set consisting of
very few sentences annotated according to the UD
guidelines.

3.1.2 Test splits
The organizers provided a test split for each of
the treebanks released in the training phase, in-
cluding the surprise languages. Additionally, they
provided test sets corresponding to 14 parallel
treebanks in different languages translated from a
unique source. All of these test sets (Nivre et al.,
2017b) were hidden from the participating teams
until the shared task had ended. Using the TIRA
environment (Potthast et al., 2014) provided for
the shared task, participants could execute runs on
them, but not see the outputs or the results.

3.2 General setup

We used the gold training treebanks to train the
parsing models. We trained one model per tree-
bank. No predicted training treebank (predicted
universal and/or specific tags and morphological
features) was used for training, except for the case
of Portuguese (see §3.3.1).

155



Embeddings: Word embeddings are set to
size 100 and universal tag embeddings to 25.
Language-specific tag and morphological feature
embeddings are used and set to size 25, if they
are available for the treebank at hand. Using
external word embeddings seems to be beneficial
to improve parsing performance (Kiperwasser and
Goldberg, 2016), but it also makes models take
more time and especially much more memory to
train. The external word embeddings used in this
work (the ones pretrained by the CoNLL 2017
UD Shared Task organizers4) are of size 100. Due
to lack of enough computational resources, we
only had time to train 38 models (mainly corre-
sponding to the smallest treebanks) including this
information. Models trained with external word
embeddings are marked in Table 3 with ?.

Parameters: Adam is used as optimizer (Kingma
and Ba, 2014). Models were trained for up to 30
epochs, except for the two smallest training sets
(Kazakh and Uyghur), where models were trained
for up to 100 epochs. The size of the output of the
stacked BILSTM was set to 512. For very large
treebanks (e.g. Czech or Russian-SyntagRus)
or treebanks where sentences are very long (e.g.
Arabic), we set it to 256, also to counteract the
lack of physical resources to finish the task on
time. These models are marked in Table 3 with
•. The number of BILSTM layers is set to 2.
To choose a transition, BIST-COVINGTON looks
at the embeddings of: the first word in β, the
rightmost three words in λ1, and the leftmost and
rightmost word in λ2 (i.e., following the notation
in Section 2.2.3, we set x = 1, y = 3, z = 1 and
v = 1).

Other relevant features of the setup: Aggressive
exploration is applied to the dynamic oracle, as in
the original arc-hybrid BIST-PARSER.

3.3 Special cases
For some treebanks, we followed a different strat-
egy due to various issues. We enumerate the
changes below:

3.3.1 The Portuguese model
Surprisingly, the model trained on the Portuguese
treebank suffered a significant loss with respect to
the UDpipe baseline when parsing the full pre-
dicted (segmentation and tagging) development

4http://hdl.handle.net/11234/1-1989

file. We first hypothesized this was due to a
low accuracy on predicting the “feats” column in
comparison to other languages, as they are pretty
sparse. To try to overcome this, we trained a model
without considering them, but it did not solve the
problem. Our second option was to train a Por-
tuguese model on its predicted training treebank.5

Additionally, despite being a relative large tree-
bank, we included external word embeddings to
boost performance. This helped us to obtain a per-
formance similar to that reported by UDpipe.

3.3.2 Surprise languages

As training an accurate parser with so little data
might be a hard task , especially in the case of
data-hungry deep learning models, we used other
training treebanks for this purpose. We built a set
of parsers inspired on the approach presented by
Vilares et al. (2016), who find that training a mul-
tilingual model on merged harmonized treebanks
might actually have a positive impact on parsing
the corresponding monolingual treebank. In this
particular case, we are assuming that a trained
model over multilingual treebanks might be able
to capture similar treebank structures for unseen
languages.

In particular, we: (1) ran every trained mono-
lingual model on the sample sets, (2) for each sur-
prise language, we chose the top three languages
where the corresponding models obtained the best
performance and (3) trained a parser taking the
first 2 000 sentences of the training sets corre-
sponding to such languages and merging them.

Thus, we did not use the provided sample data
for training, but only as a development set to
choose suitable source languages for our cross-
lingual approach.

3.3.3 Parallel (PUD) treebanks

The only information our models knew about the
parallel treebanks during the testing phase was the
language in which they were written. To parse
these languages we follow a simplistic approach,
using the models we had already trained on the
provided training corpora: (1) if there is only one
model trained on the same language we take that
model, (2) else if there is more than one model
trained on that language, we take the one trained
over the largest treebank (in number of sentences),

5We used the predicted tokenization and tagging provided
by UDpipe.

156



otherwise (3) we parse the PUD treebank using the
English model.6

3.4 Results

Official and unofficial results for our model
and for the rest of participants on the
test set can be found at the task website:
http://universaldependencies.
org/conll17/results.html, but in
this section we detail the results obtained by
BIST-COVINGTON.

3.4.1 Results on small and big treebanks
categories

Table 2 shows the performance on the test sets for
the treebanks where an official training set was re-
leased.

In Table 3 we summarize our results on the
development sets for those treebanks that pro-
vided an official one. Although not shown for
brevity and clarity reasons, it is easy to check for
the reader that BIST-COVINGTON outperformed
the baseline UDpipe7 for all these treebanks on
the gold configuration (gold segmentation, gold
tags). The same is true, except for Chinese (-
0.69 decrease in LAS) and Portuguese (-0.09), in
the fully predicted configuration (end-to-end pars-
ing). It is easy to conclude from the table that
including external word embeddings has a posi-
tive effect in most of the treebanks we had time to
try. This is especially true when performing end-
to-end parsing, where only for three languages
(English-LinES, Gothic and Old Church Slavonic)
a negative effect was observed.8

Table 4 shows the top three selected languages
for each surprise treebank, the performance of the
monolingual and multilingual (merged) models on
them on the sample set (used as dev set), and also
shows the performance of the multilingual models
in the official test sets.

Table 5 shows our performance on the PUD
treebanks (test sets). There are 4 PUD treebanks
for which we obtained a poor performance: Span-
ish, Finnish, Portuguese and Russian. Average
LAS loss with respect to the top system in the cor-

6This latter case should and did never happen, as the task
organizers specified in advance that the parallel treebanks
would correspond to languages with existing treebanks, but
we included it as a fallback mechanism.

7http://universaldependencies.org/
conll17/baseline.html

8Due to not so rich embeddings and/or the model finishing
earlier than expected during training. See §5.

Treebank LAS
Ancient Greek 67.858-PROIEL
Ancient Greek 59.836
Arabic 66.5410
Basque 73.275
Bulgarian 85.766
Catalan 85.3718
Chinese 56.762
Croatian 77.9111
Czech-CAC 82.7116
Czech-CLTT 68.9223
Czech 83.7711
Danish 75.2711
Dutch-LassySmall 82.496
Dutch 71.897
English-LinES 73.4713
English-ParTUT 74.5012
English 76.0014
Estonian 61.797
Finnish-FTB 76.807
Finnish 76.118
French-ParTUT 72.0925
French-Sequoia 77.7723
French 79.8620
Galician-TreeGal 65.4217
Galician 79.2412
German 68.3522
Gothic 62.077
Greek 81.436
Hebrew 59.289
Hindi 86.8815
Hungarian 66.009
Indonesian 72.9423
Irish 58.0522
Italian 85.6016
Japanese 72.6817
Kazakh 16.2026
Korean 63.8514
Latin-ITTB 79.587
Latin-PROIEL 61.457
Latin 48.927
Latvian 63.057
Norwegian-Bokmaal 84.498
Norwegian-Nynorsk 83.107
Old Church Slavonic 67.214
Persian 77.6817
Polish 82.097
Portuguese-BR 86.749
Portuguese 80.9119
Romanian 80.5811
Russian-SynTagRus 87.559
Russian 76.988
Slovak 76.476
Slovenian-SST 43.8021
Slovenian 82.927
Spanish-AnCora 86.837
Spanish 83.248
Swedish-LinES 75.0410
Swedish 77.3313
Turkish 57.225
Ukrainian 61.2115
Urdu 78.319
Uyghur 27.9223
Vietnamese 38.3312

Table 2: BIST-COVINGTON results on the test
sets, for those treebanks from which a training set
was provided (small and big treebanks categories)

157



Gold treebank LAS Predicted treebank LAS
Treebank no E E no E E
Ancient Greek 81.44 N/A 70.5 N/A-PROIEL
Ancient Greek? 71.01 71.31 60.41 61.25
Arabic?• 79.12 79.71 64.37 65.62
Basque? 81.53 82.06 72.00 73.42
Bulgarian? 89.88 90.46 84.33 85.30
Catalan• 90.63 N/A 87.21 N/A
Chinese 80.34 N/A 55.31 N/A
Croatian? 83.86 83.64 78.04 78.74
Czech-CAC• 88.64 N/A 84.93 N/A
Czech-CLTT• 82.28 N/A 68.03 N/A
Czech• 90.70 N/A 85.47 N/A
Danish? 83.85 85.78 74.92 76.94
Dutch-LassySmall? 86.59 86.65 76.78 77.50
Dutch 86.82 N/A 76.47 N/A
English-LinES? 83.74 83.05 76.48 76.44
English-ParTUT? 84.15 84.60 76.24 77.07
English 88.02 N/A 76.7 N/A
Estonian? 79.26 80.21 61.09 62.80
Finnish-FTB 89.00 N/A 76.43 N/A
Finnish 86.51 N/A 76.96 N/A
French-Sequoia 89.14 N/A 81.79 N/A
French• 89.86 N/A 85.8 N/A
Galician?• 84.22 82.58 80.17 79.03
German 87.63 N/A 73.61 N/A
Gothic? 80.82 81.17 60.84 60.82
Greek? 86.03 86.37 79.74 80.05
Hebrew?• 85.26 85.13 62.18 62.39
Hindi 93.42 N/A 87.41 N/A
Hungarian? 80.84 81.30 69.16 70.43
Indonesian 80.39 N/A 74.91 N/A
Italian-ParTUT? 86.20 86.83 78.90 79.56
Italian 90.30 N/A 86.05 N/A
Japanese? 96.48 96.46 73.99 74.20
Korean 68.66 N/A 60.18 N/A
Latin-ITTB 84.21 N/A 72.22 N/A
Latin-PROIEL 79.37 N/A 61.98 N/A
Latvian? 77.25 76.55 63.12 63.62
Norwegian-Bokmaal 91.45 N/A 85.13 N/A
Norwegian-Nynorsk 91.06 N/A 83.38 N/A
Old Church Slavonic? 84.59 84.52 66.93 66.66
Persian?• 86.85 N/A 80.44 81.45
Polish? 91.04 91.25 81.43 82.18
Portuguese-BR• 90.91 N/A 86.41 N/A
Portuguese?• 94.94 93.09 79.3 84.00
Romanian? 85.08 84.44 80.97 81.01
Russian-SynTagRus• 91.91 N/A 88.29 N/A
Russian? 85.12 86.07 78.02 79.09
Slovak? 87.61 88.39 75.59 77.35
Slovenian? 92.28 93.14 82.48 84.15
Spanish-AnCora• 90.50 N/A 86.21 N/A
Spanish• 87.90 N/A 84.25 N/A
Swedish-LinES? 84.23 84.44 76.39 76.86
Swedish? 84.88 85.03 76.41 76.64
Turkish? 61.66 64.46 55.05 57.60
Urdu? 87.63 87.50 77.43 77.49
Vietnamese? 72.21 72.58 42.27 42.94

Table 3: BIST-COVINGTON results on the
dev set, for those treebanks that have an offi-
cial dev set (all treebanks except French-ParTUT,
Irish, Galician-TreeGal, Kazakh, Slovenian-SST,
Kazakh, Uyghur and Ukrainian). ? indicates the
model was also trained with external word embed-
dings (E). • indicates the BILSTM output dimen-
sion was 256. The performance of some models is
likely to be improved, as its training finished ear-
lier than expected due to lack of time to finish it or
memory issues (see also §5)

responding treebank was 32.47, which implied a
LAS loss up to 1.60 points in the official global
ranking. We hypothesized that taking the model

Surprise Top 3 Sample set Sample set Test set
language treebanks Monolingual Multilingual Multi

Buryat
Hindi 36.60

43.14 28.655German 32.68
Korean 27.45

Kurmanji
Romanian 38.84

39.26 32.0816Czech 37.19
Slovenian 31.40

North Estonian 45.38 57.14 32.5814Finnish 40.82
Sami Finnish-FTB 40.14

Upper Slovenian 65.22 70.65 52.5015Slovak 64.78
Sorbian Bulgarian 61.09

Table 4: LAS on the surprise languages sample
sets for: (1) top 3 best performing monolingual
models for which there is an official training tree-
bank and (2) a multilingual model trained on the
first 2 000 sentences of each of such treebanks. For
the multilingual models, the last column shows its
performance on the test sets (subscripts indicate
our ranking in that language)

trained on the largest treebank of the same lan-
guage was the safest option to parse PUD texts,
but in retrospective this clearly was not the optimal
choice. Those four PUD treebanks were parsed
with models trained on Universal Dependencies
(UD) treebanks whose official name has a suffix
(i.e. Spanish-Ancora, Finnish-FTB, Portuguese-
BR and Russian-SyntagRus), which were larger
than the unsuffixed UD treebank. However, we
think such a poor performance surpasses what can
be reasonably expected from an universal treebank
written in the same language. From Table 5 it
is reasonable to conclude that such suffixed tree-
banks parse more than poorly on cross-treebank
settings, in comparison to the model trained on the
unsuffixed treebank (rightmost column). We won-
der if this can be an indicator of those treebanks
sharing universal dependency types, but diverging
in terms of syntactic structures, which caused the
low LAS scores in those cases.

A possible contributing factor to this could be
that the annotators of the parallel treebanks used
guidelines from the unsuffixed treebanks, or auto-
matic output trained on them, as a starting point
from the annotation process. At the point of writ-
ing we cannot confirm whether this is the case, as
documentation for the PUD treebanks is not yet
publicly available.

158



PUD Trained on
LAS

Trained on
LAStreebank largest treebank uns. treebank

(official) (unofficial)
Arabic Arabic 45.1211 =
Czech Czech 80.1310 =
German German 66.2919 =
English English 78.7916 =
Spanish Spanish-Ancora 53.7330↓ Spanish 78.90
Finnish Finnish-FTB 40.6628 ↓ Finnish 80.70
French French 73.1523 =
Hindi Hindi 51.1513 =
Italian Italian 83.8415 =
Japanese Japanese 76.0918 =
Portuguese Portuguese-BR 54.7527 ↓ Portuguese 72.84
Russian Russian-SyntagRus 44.6931 ↓ Russian 70.00
Swedish Swedish 69.6017 =
Turkish Turkish 34.964 =

Table 5: LAS/UAS performance on the PUD tree-
banks (test sets). The ↓ symbol indicates a dras-
tic gap in performance with respect the average
performance of BIST-COVINGTON. We show how
parsing the PUD treebank with a model trained on
the corresponding unsuffixed treebank clearly im-
proves the LAS accuracy.

4 Discussion

BIST-COVINGTON worked very well on languages
where official training/development sets were
available, what the organizers named big tree-
banks (55 treebanks), category where we ranked
7th out of 33 systems, both for LAS and UAS met-
rics, in spite of not using any ensemble method
and not performing custom tokenization, segmen-
tation or tagging.

More in detail, we ranked in the top
ten LAS for 35 languages, where 32 be-
long to the category of big treebanks: Ara-
bic (10th), Bulgarian (6th), Buryat (5th), Czech-
PUD (10th), Old Church Slavonic (4th), Greek
(6th), Spanish (8th), Spanish-Ancora (7th),
Estonian (7th), Basque (5th), Finnish (8th),
Finnish-ftb (7th), Gothic (7th), Ancient Greek
(6th), Ancient Greek-PROIEL (8th), Hebrew
(9th), Hungarian (9th), Latin (7th), Latin-
ITB (7th), Latin-PROIEL (7th), Latvian (7th),
Dutch (7th), Dutch-lassysmall (6th), Norwegian-
Bokmaal (8th), Norwegian-Nynorsk (7th), Pol-
ish (7th), Portuguese-BR (9th), Russian (8th),
Russian-Syntagrus(9th), Slovak (6th), Slovenian
(7th), Swedish-LinES (10th), Turkish (5th),
Turkish-PUD (4th) and Ukrainian (9th).

We failed on a subset of the PUD treebanks. As
previously explained, the main gap came from the
Spanish, Russian, Portuguese and Finnish PUD
treebanks. We analyzed those treebanks based on
existing UD CoNLL treebanks. We parsed them

with the model trained on the largest treebank that
shared the language. It turned out that those PUD
treebanks that were parsed with suffixed treebanks
(e.g. Spanish-Ancora or Russian-SynTagRus) ob-
tained a very low performance, something that did
not happen when parsing them with the model
trained on the corresponding unsuffixed treebank
(e.g. Spanish or Russian). In cases where there
was only one UD treebank sharing the language,
our approach worked reasonably well, in spite
of the simplistic strategy followed (e.g. Turkish-
PUD or Czech-PUD).

We did not perform too well either on the set of
small treebanks (French-ParTUT, Irish, Galician-
TreeGal, Kazakh, Slovenian-SST, Uyghur and
Ukrainian). This was somewhat expected for two
reasons: (1) neural models that are fed with con-
tinuous vector representations are usually data-
hungry and (2) the submitted model was only
trained on our training split; we did not include
the ad-hoc dev sets for those languages as a part
of the final training data.

We believe that the cases where the parser did
not work well were due to external causes (e.g.
the chosen cross-treebank strategy), as shown in
the case of the PUD treebanks. Unofficial results
such as the ones in Table 5 show that this can be
easily addressed to push BIST-COVINGTON to ob-
tain competitive results in those treebanks too.

5 Hardware requirements and issues

Our models required DyNet (Neubig et al., 2017),
which allocates memory when it is launched. We
ran them on CPU. To train the models we used two
servers with 128GB of RAM memory each. Es-
timating the required memory to allocate to train
each model was a hard task for us. Dynet does
not currently have a garbage collector,9 so many
models ran out of memory even before finishing
their training, probably due to wrong memory es-
timations to complete this phase, and our lack of
resources to allocate memory for many treebanks
at a time. We observed that models such as Arabic
with external word embeddings could take up to
64GB during the training phase.

The performance on the dev set of our trained
models was close, but not equal, in our train-
ing machine and in TIRA. This might be caused
by a serialization versioning issue: https://

9https://github.com/clab/dynet/issues/
418

159



github.com/clab/dynet/issues/84.
To safely run a large trained model with exter-

nal embeddings we recommend at least 32GB of
RAM memory. We think a safe estimate to run
any model without external embeddings would be
something between 15 and 20GB.

The current version of BIST-COVINGTON is not
very fast. Average speed (tokens/second) over
all test treebanks was 18.27. The fastest mod-
els were Kazakh (66.36), Uyghur (54.11) and
Czech-PUD (45.79) and the slowest ones Czech-
CLTT (5.37), Latin-PROIEL (7.69) and Galician-
TreeGal (8.19). To complete the testing phase of
the shared task, BIST-COVINGTON took around 28
hours. These times correspond to those of the offi-
cial evaluation on the TIRA virtual machine. Sev-
eral factors influence these speeds. Firstly, RNN
approaches tend to be slower than feedforward
approaches (e.g., reported speeds for the original
transition-based BIST-parser by Kiperwasser and
Goldberg (2016) are an order of magnitude be-
hind those of Chen and Manning (2014), although
the latter is also much less accurate). Secondly,
parsing UD data for different languages accurately
requires using more linguistic information (e.g.
feature embeddings), increasing the model size
with respect to models evaluated on simpler set-
tings like the English Penn Treebank. Finally,
we are aware that Covington’s algorithm may be-
come slower when sentences are too long due to its
quadratic worst-case complexity, an issue that is
likely to happen due to the predicted segmentation
(the organizers actually informed that some tree-
banks contained sentences of about 300 words).

6 Conclusion

This paper presented BIST-COVINGTON, a bidi-
rectional LSTM implementation of the Coving-
ton (2001) algorithm for non-projective transition-
based dependency parsing. Our model was evalu-
ated on the end-to-end multilingual parsing with
universal dependencies shared task proposed at
CoNLL 2017. For segmentation and part-of-
speech tagging our model relied on the official
UDpipe baseline. The official results located us
7th out of 33 teams in the big treebanks category,
in spite of not using any ensemble method.

As future work, there is room for improvement.
Due to lack of resources to train the models and
complete the task on time, we could not train all
models using external word embeddings, which

has been shown to produce a significant over-
all improvement. Jackniffing (Agić and Schluter,
2017) might be a simple way to improve the LAS
scores. Finally, it would be interesting to im-
plement the non-monotonic version of the Cov-
ington transition system, together with approxi-
mate dynamic oracles (Fernández-González and
Gómez-Rodrı́guez, 2017), shown to improve ac-
curacy over the regular Covington parser.

Acknowledgments

David Vilares is funded by an FPU Grant
13/01180. Carlos Gómez-Rodrı́guez has re-
ceived funding from the European Research Coun-
cil (ERC), under the European Union’s Hori-
zon 2020 research and innovation programme
(FASTPARSE, grant agreement No 714150).
Both authors have received funding from the
TELEPARES-UDC project from MINECO.

References
Željko Agić and Natalie Schluter. 2017. How (not) to

train a dependency parser: The curious case of jack-
knifing part-of-speech taggers. In The 54th Annual
Meeting of the Association for Computational Lin-
guistics (ACL 2017).

Giuseppe Attardi. 2006. Experiments with a mul-
tilanguage non-projective dependency parser. In
Proceedings of the Tenth Conference on Compu-
tational Natural Language Learning. Association
for Computational Linguistics, pages 166–170.
http://dl.acm.org/citation.cfm?id=1596276.1596307.

Danqi Chen and Christopher Manning. 2014. A fast
and accurate dependency parser using neural net-
works. In Proceedings of the 2014 Conference
on Empirical Methods in Natural Language Pro-
cessing (EMNLP). Doha, Qatar, pages 740–750.
http://www.aclweb.org/anthology/D14-1082.

Michael A Covington. 2001. A fundamental algorithm
for dependency parsing. In Proceedings of the 39th
annual ACM southeast conference. Citeseer, pages
95–102.

Jason M Eisner. 1996. Three new probabilis-
tic models for dependency parsing: An explo-
ration. In Proceedings of the 16th conference
on Computational linguistics-Volume 1. Associa-
tion for Computational Linguistics, pages 340–345.
https://arxiv.org/pdf/cmp-lg/9706003.pdf.

Daniel Fernández-González and Carlos Gómez-
Rodrı́guez. 2017. A full non-monotonic transition
system for unrestricted non-projective parsing.
In Proceedings of the 55th Annual Meeting of
the Association for Computational Linguistics (in
press). Association for Computational Linguistics.

160



Yoav Goldberg and Joakim Nivre. 2012. A
dynamic oracle for arc-eager dependency
parsing. In COLING. pages 959–976.
http://www.aclweb.org/anthology/C12-1059.

Carlos Gómez-Rodrı́guez and Daniel Fernández-
González. 2015. An efficient dynamic or-
acle for unrestricted non-projective pars-
ing. Volume 2: Short Papers page 256.
http://aclweb.org/anthology/P/P15/P15-2042.pdf.

Carlos Gómez-Rodrı́guez and Joakim Nivre.
2010. A transition-based parser for 2-planar
dependency structures. In Proceedings of the
48th Annual Meeting of the Association for
Computational Linguistics. Association for
Computational Linguistics, pages 1492–1501.
http://aclweb.org/anthology/P/P10/P10-1151.pdf.

Carlos Gómez-Rodrı́guez, Francesco Sartorio, and
Giorgio Satta. 2014. A polynomial-time dy-
namic oracle for non-projective dependency
parsing. In Proceedings of the 2014 Confer-
ence on Empirical Methods in Natural Lan-
guage Processing (EMNLP). pages 917–927.
http://aclweb.org/anthology/D/D14/D14-1099.pdf.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation
9(8):1735–1780.

Diederik Kingma and Jimmy Ba. 2014.
Adam: A method for stochastic opti-
mization. arXiv preprint arXiv:1412.6980
https://arxiv.org/pdf/1412.6980.pdf.

Eliyahu Kiperwasser and Yoav Goldberg. 2016.
Simple and accurate dependency parsing
using bidirectional lstm feature represen-
tations. Transactions of the Association
for Computational Linguistics 4:313–327.
http://transacl.org/ojs/index.php/tacl/article/view/885.

Marco Kuhlmann, Carlos Gómez-Rodrı́guez, and Gior-
gio Satta. 2011. Dynamic programming algo-
rithms for transition-based dependency parsers. In
Proceedings of the 49th Annual Meeting of the
Association for Computational Linguistics: Hu-
man Language Technologies-Volume 1. Associa-
tion for Computational Linguistics, pages 673–682.
http://aclweb.org/anthology/P/P11/P11-1068.pdf.

André FT Martins, Noah A Smith, Eric P Xing,
Pedro MQ Aguiar, and Mário AT Figueiredo.
2010. Turbo parsers: Dependency parsing by
approximate variational inference. In Proceed-
ings of the 2010 Conference on Empirical Meth-
ods in Natural Language Processing. Associa-
tion for Computational Linguistics, pages 34–44.
http://aclweb.org/anthology/D/D10/D10-1004.pdf.

Antonio Valerio Miceli-Barone and Giuseppe At-
tardi. 2015. Non-projective dependency-based pre-
reordering with recurrent neural network for ma-
chine translation. In The 53rd Annual Meeting of

the Association for Computational Linguistics and
The 7th International Joint Conference of the Asian
Federation of Natural Language Processing.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S
Corrado, and Jeff Dean. 2013. Distributed
representations of words and phrases and their
compositionality. In Advances in neural infor-
mation processing systems. pages 3111–3119.
https://papers.nips.cc/paper/5021-distributed-
representations-of-words-and-phrases-and-their-
compositionality.pdf.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, Kevin Duh, Manaal
Faruqui, Cynthia Gan, Dan Garrette, Yangfeng Ji,
Lingpeng Kong, Adhiguna Kuncoro, Gaurav Ku-
mar, Chaitanya Malaviya, Paul Michel, Yusuke
Oda, Matthew Richardson, Naomi Saphra, Swabha
Swayamdipta, and Pengcheng Yin. 2017. Dynet:
The dynamic neural network toolkit. arXiv preprint
arXiv:1701.03980 https://arxiv.org/abs/1701.03980.

Joakim Nivre. 2008. Algorithms for deter-
ministic incremental dependency parsing.
Computational Linguistics 34(4):513–553.
http://dl.acm.org/citation.cfm?id=1479205.

Joakim Nivre. 2009. Non-projective dependency
parsing in expected linear time. In Proceed-
ings of the Joint Conference of the 47th Annual
Meeting of the ACL and the 4th International
Joint Conference on Natural Language Process-
ing of the AFNLP: Volume 1-Volume 1. Associa-
tion for Computational Linguistics, pages 351–359.
http://aclweb.org/anthology/P/P09/P09-1040.pdf.

Joakim Nivre, Željko Agić, Lars Ahrenberg, et al.
2017a. Universal Dependencies 2.0. LIN-
DAT/CLARIN digital library at the Institute of
Formal and Applied Linguistics, Charles Uni-
versity, Prague, http://hdl.handle.net/
11234/1-1983. http://hdl.handle.net/11234/1-
1983.

Joakim Nivre, Željko Agić, Lars Ahrenberg, et al.
2017b. Universal dependencies 2.0 CoNLL 2017
shared task development and test data. LIN-
DAT/CLARIN digital library at the Institute of For-
mal and Applied Linguistics, Charles University.
http://hdl.handle.net/11234/1-2184.

Joakim Nivre, Marie-Catherine de Marneffe, Filip
Ginter, Yoav Goldberg, Jan Hajič, Christopher
Manning, Ryan McDonald, Slav Petrov, Sampo
Pyysalo, Natalia Silveira, Reut Tsarfaty, and Daniel
Zeman. 2016. Universal Dependencies v1: A
multilingual treebank collection. In Proceed-
ings of the 10th International Conference on Lan-
guage Resources and Evaluation (LREC 2016).
European Language Resources Association, Por-
toro, Slovenia, pages 1659–1666. http://www.lrec-
conf.org/proceedings/lrec2016/pdf/348 Paper.pdf.

161



Joakim Nivre, Johan Hall, and Jens Nilsson. 2006.
Maltparser: A data-driven parser-generator for de-
pendency parsing. In Proceedings of LREC.
volume 6, pages 2216–2219. http://www.lrec-
conf.org/proceedings/lrec2006/pdf/162 pdf.pdf.

Joakim Nivre and Jens Nilsson. 2005. Pseudo-
projective dependency parsing. In Proceed-
ings of the 43rd Annual Meeting on Asso-
ciation for Computational Linguistics. Associa-
tion for Computational Linguistics, pages 99–106.
http://aclweb.org/anthology/P/P05/P05-1013.pdf.

Martin Potthast, Tim Gollub, Francisco Rangel, Paolo
Rosso, Efstathios Stamatatos, and Benno Stein.
2014. Improving the reproducibility of PAN’s
shared tasks: Plagiarism detection, author iden-
tification, and author profiling. In Evangelos
Kanoulas, Mihai Lupu, Paul Clough, Mark Sander-
son, Mark Hall, Allan Hanbury, and Elaine Toms,
editors, Information Access Evaluation meets Mul-
tilinguality, Multimodality, and Visualization. 5th
International Conference of the CLEF Initiative
(CLEF 14). Springer, Berlin Heidelberg New York,
pages 268–299. https://doi.org/10.1007/978-3-319-
11382-1 22.

Mohammad Sadegh Rasooli and Joel Tetreault.
2015. Yara parser: A fast and accurate depen-
dency parser. arXiv preprint arXiv:1503.06733
https://arxiv.org/pdf/1503.06733.pdf.

Richard Socher, Alex Perelygin, Jean Y Wu, Jason
Chuang, Christopher D Manning, Andrew Y Ng,
Christopher Potts, et al. 2013. Recursive deep
models for semantic compositionality over a senti-
ment treebank. In Proceedings of the conference on
empirical methods in natural language processing
(EMNLP). volume 1631, page 1642.

Milan Straka, Jan Hajic, and Jana Straková. 2016. Ud-
pipe: Trainable pipeline for processing conll-u files
performing tokenization, morphological analysis,
pos tagging and parsing. In Proceedings of the Tenth
International Conference on Language Resources
and Evaluation (LREC 2016). http://www.lrec-
conf.org/proceedings/lrec2016/pdf/873 Paper.pdf.

David Vilares, Carlos Gómez-Rodrıguez, and
Miguel A. Alonso. 2016. One model, two lan-
guages: training bilingual parsers with harmonized
treebanks. In The 54th Annual Meeting of the
Association for Computational Linguistics. pages
425–431. http://aclweb.org/anthology/P/P16/P16-
2069.pdf.

David Vilares, Carlos Gómez-Rodrı́guez, and
Miguel A Alonso. 2017. Universal, unsuper-
vised (rule-based), uncovered sentiment analysis.
Knowledge-Based Systems 118:45–55.

Tong Xiao, Jingbo Zhu, Chunliang Zhang, and Tongran
Liu. 2016. Syntactic skeleton-based translation.
In Proceedings of the Thirtieth AAAI Confer-
ence on Artificial Intelligence, February 12-17,

2016, Phoenix, Arizona, USA.. pages 2856–2862.
http://www.aaai.org/ocs/index.php/AAAI/AAAI16/paper/view/11933.

Mo Yu, Matthew R Gormley, and Mark Dredze. 2015.
Combining word embeddings and feature embed-
dings for fine-grained relation extraction. In HLT-
NAACL. pages 1374–1379.

Daniel Zeman, Martin Popel, Milan Straka, Jan
Hajič, Joakim Nivre, Filip Ginter, Juhani Luotolahti,
Sampo Pyysalo, Slav Petrov, Martin Potthast, Fran-
cis Tyers, Elena Badmaeva, Memduh Gökırmak,
Anna Nedoluzhko, Silvie Cinková, Jan Hajič jr.,
Jaroslava Hlaváčová, Václava Kettnerová, Zdeňka
Urešová, Jenna Kanerva, Stina Ojala, Anna Mis-
silä, Christopher Manning, Sebastian Schuster, Siva
Reddy, Dima Taji, Nizar Habash, Herman Leung,
Marie-Catherine de Marneffe, Manuela Sanguinetti,
Maria Simi, Hiroshi Kanayama, Valeria de Paiva,
Kira Droganova, Héctor Martı́nez Alonso, Hans
Uszkoreit, Vivien Macketanz, Aljoscha Burchardt,
Kim Harris, Katrin Marheinecke, Georg Rehm,
Tolga Kayadelen, Mohammed Attia, Ali Elkahky,
Zhuoran Yu, Emily Pitler, Saran Lertpradit, Michael
Mandl, Jesse Kirchner, Hector Fernandez Alcalde,
Jana Strnadova, Esha Banerjee, Ruli Manurung, An-
tonio Stella, Atsuko Shimada, Sookyoung Kwak,
Gustavo Mendonça, Tatiana Lando, Rattima Nitis-
aroj, and Josie Li. 2017. CoNLL 2017 Shared Task:
Multilingual Parsing from Raw Text to Universal
Dependencies. In Proceedings of the CoNLL 2017
Shared Task: Multilingual Parsing from Raw Text to
Universal Dependencies. Association for Computa-
tional Linguistics.

162


