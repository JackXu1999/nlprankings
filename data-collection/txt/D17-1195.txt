



















































Dynamic Entity Representations in Neural Language Models


Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 1830–1839
Copenhagen, Denmark, September 7–11, 2017. c©2017 Association for Computational Linguistics

Dynamic Entity Representations in Neural Language Models

Yangfeng Ji∗ Chenhao Tan∗ Sebastian Martschat† Yejin Choi∗ Noah A. Smith∗
∗Paul G. Allen School of Computer Science & Engineering, University of Washington

†Department of Computational Linguistics, Heidelberg University
{yangfeng,chenhao,yejin,nasmith}@cs.washington.edu

martschat@cl.uni-heidelberg.de

Abstract

Understanding a long document requires
tracking how entities are introduced and
evolve over time. We present a new type of
language model, ENTITYNLM, that can
explicitly model entities, dynamically up-
date their representations, and contextu-
ally generate their mentions. Our model is
generative and flexible; it can model an ar-
bitrary number of entities in context while
generating each entity mention at an arbi-
trary length. In addition, it can be used
for several different tasks such as language
modeling, coreference resolution, and en-
tity prediction. Experimental results with
all these tasks demonstrate that our model
consistently outperforms strong baselines
and prior work.

1 Introduction

Understanding a narrative requires keeping track
of its participants over a long-term context. As a
story unfolds, the information a reader associates
with each character in a story increases, and ex-
pectations about what will happen next change ac-
cordingly. At present, models of natural language
do not explicitly track entities; indeed, in today’s
language models, entities are no more than the
words used to mention them.

In this paper, we endow a generative language
model with the ability to build up a dynamic rep-
resentation of each entity mentioned in the text.
Our language model defines a probability distribu-
tion over the whole text, with a distinct generative
story for entity mentions. It explicitly groups those
mentions that corefer and associates with each en-
tity a continuous representation that is updated by
every contextualized mention of the entity, and
that in turn affects the text that follows.

[John]1 wanted to go to [the coffee shop]2 in
[downtown Copenhagen]3. [He]1 was told that
[it]2 sold [the best beans]4.

Figure 1: ENTITYNLM explicitly tracks entities
in a text, including coreferring relationships be-
tween entities like [John]1 and [He]1. As a lan-
guage model, it is designed to predict that a coref-
erent of [the coffee shop]2 is likely to follow “told
that,” that the referring expression will be “it”, and
that “sold the best beans” is likely to come next, by
using entity information encoded in the dynamic
distributed representation.

Our method builds on recent advances in repre-
sentation learning, creating local probability dis-
tributions from neural networks. It can be un-
derstood as a recurrent neural network language
model, augmented with random variables for en-
tity mentions that capture coreference, and with
dynamic representations of entities. We estimate
the model’s parameters from data that is annotated
with entity mentions and coreference.

Because our model is generative, it can be
queried in different ways. Marginalizing every-
thing except the words, it can play the role of a lan-
guage model. In §5.1, we find that it outperforms
both a strong n-gram language model and a strong
recurrent neural network language model on the
English test set of the CoNLL 2012 shared task
on coreference evaluation (Pradhan et al., 2012).
The model can also identify entity mentions and
coreference relationships among them. In §5.2,
we show that it can easily be used to add a per-
formance boost to a strong coreference resolution
system, by reranking a list of k-best candidate out-
puts. On the CoNLL 2012 shared task test set, the
reranked outputs are significantly better than the
original top choices from the same system. Fi-

1830



nally, the model can perform entity cloze tasks.
As presented in §5.3, it achieves state-of-the-art
performance on the InScript corpus (Modi et al.,
2017).

2 Model

A language model defines a distribution over se-
quences of word tokens; let Xt denote the random
variable for the tth word in the sequence, xt de-
note the value of Xt and xt the distributed repre-
sentation (embedding) of this word. Our starting
point for language modeling is a recurrent neural
network (Mikolov et al., 2010), which defines

p(Xt | history) = softmax (Whht−1 + b) (1)
ht−1 = LSTM(ht−2,xt−1) (2)

where Wh and b are parameters of the model
(along with word embeddings xt), LSTM is the
widely used recurrent function known as “long
short-term memory” (Hochreiter and Schmidhu-
ber, 1997), and ht is a LSTM hidden state encoding
the history of the sequence up to the tth word.

Great success has been reported for this model
(Zaremba et al., 2015), which posits nothing ex-
plicitly about the words appearing in the text se-
quence. Its generative story is simple: the value
of each Xt is randomly chosen conditioned on the
vector ht−1 encoding its history.

2.1 Additional random variables and
representations for entities

To introduce our model, we associate with each
word an additional set of random variables. At po-
sition t,

• Rt is a binary random variable that indi-
cates whether xt belongs to an entity men-
tion (Rt = 1) or not (Rt = 0). Though not
explored here, this is easily generalized to a
categorial variable for the type of the entity
(e.g., person, organization, etc.).

• Lt ∈ {1, . . . , `max} is a categorical random
variable if Rt = 1, which indicates the num-
ber of remaining words in this mention, in-
cluding the current word (i.e., Lt = 1 for
the last word in any mention). `max is a
predefined maximum length fixed to be 25,
which is an empirical value derived from the
training corpora used in the experiments. If
Rt = 0, then Lt = 1. We denote the value of
Lt by `t.

• Et ∈ Et is the index of the entity referred to,
if Rt = 1. The set Et consists of {1, . . . , 1 +
maxt′<t et′}, i.e., the indices of all previously
mentioned entities plus an additional value
for a new entity. Thus Et starts as {1} and
grows monotonically with t, allowing for an
arbitrary number of entities to be mentioned.
We denote the value of Et by et. If Rt = 0,
then Et is fixed to a special value ø.

The values of these random variables for our run-
ning example are shown in Figure 2.

In addition to using symbolic variables to en-
code mentions and coreference relationships, we
maintain a vector representation of each entity that
evolves over time. For the ith entity, let ei,t be
its representation at time t. These vectors are
different from word vectors (xt), in that they are
not parameters of the model. They are similar to
history representations (ht), in that they are de-
rived through parameterized functions of the ran-
dom variables’ values, which we will describe in
the next subsections.

2.2 Generative story
The generative story for the word (and other
variables) at timestep t is as follows; forward-
referenced equations are in the detailed discussion
that follows.

1. If `t−1 = 1 (i.e., xt is not continuing an
already-started entity mention):

• Choose rt (Equation 3).
• If rt = 0, set `t = 1 and et = ø; then go

to step 3. Otherwise:
– If there is no embedding for the

new candidate entity with index
1 + maxt′<t et′ , create one follow-
ing §2.4.

– Select the entity et from {1, . . . , 1 +
maxt′<t et′} (Equation 4).

– Set ecurrent = eet,t−1, which is
the entity embedding of et before
timestep t.

– Select the length of the mention, `t
(Equation 5).

2. Otherwise,

• Set `t = `t−1 − 1, rt = rt−1, et = et−1.
3. Sample xt from the word distribution given

the LSTM hidden state ht−1 and the current

1831



X1:12: John wanted to go to the coffee shop in downtown Copenhagen .
R1:12: 1 0 0 0 0 1 1 1 0 1 1 0
E1:12: 1 ø ø ø ø 2 2 2 ø 3 3 ø
L1:12: 1 1 1 1 1 3 2 1 1 2 1 1

X13:22: He was told that it sold the best beans .
R13:22: 1 0 0 0 1 0 1 1 1 .
E13:22: 1 ø ø ø 2 ø 4 4 4 ø
L13:22: 1 1 1 1 1 1 3 2 1 0

Figure 2: The random variable values in ENTITYNLM for the running example in Figure 1.

(or most recent) entity embedding ecurrent
(Equation 6). (If rt = 0, then ecurrent still
represents the most recently mentioned en-
tity.)

4. Advance the RNN, i.e., feed it the word vec-
tor xt to compute ht (Equation 2).

5. If rt = 1, update eet,t using eet,t−1 and ht,
then set ecurrent = eet,t. Details of the entity
updating are given in §2.4.

6. For every entity eι ∈ Et \ {et}, set eι,t =
eι,t−1 (i.e., no changes to other entities’ rep-
resentations).

Note that at any given time step t, ecurrent will al-
ways contain the most recent vector representation
of the most recently mentioned entity.

A generative model with a similar hierarchi-
cal structure was used by Haghighi and Klein
(2010) for coreference resolution. Our approach
differs in two important ways. First, our model
defines a joint distribution over all of the text, not
just the entity mentions. Second, we use repre-
sentation learning rather than Bayesian nonpara-
metrics, allowing natural integration with the lan-
guage model.

2.3 Probability distributions

The generative story above referenced several
parametric distributions defined based on vector
representations of histories and entities. These are
defined as follows.

For r ∈ {0, 1},

p(Rt = r | ht−1) ∝ exp(h>t−1Wrr), (3)

where r is the parameterized embedding associ-
ated with r, which paves the way for exploring en-
tity type representations in future work; Wr is a
parameter matrix for the bilinear score for ht−1
and r.

To give the possibility of predicting a new en-
tity, we need an entity embedding beforehand with
index (1 + maxt′<t et′), which is randomly sam-
pled from Equation 7. Then, for every e ∈
{1, . . . , 1 + maxt′<t et′}:
p(Et = e | Rt = 1,ht−1)
∝ exp(h>t−1Wentityee,t−1 + w>dist f(e)),

(4)

where ee,t−1 is the embedding of entity e at time
step t−1 and Wentity is the weight matrix for pre-
dicting entities using their continuous representa-
tions. The score above is normalized over values
{1, . . . , 1 + maxt′<t et′}. f(e) represents a vec-
tor of distance features associated with e and the
mentions of the existing entities. Hence two in-
formation sources are used to predict the next en-
tity: (i) contextual information ht−1, and (ii) dis-
tance features f(e) from the current mention to the
closest mention from each previously mentioned
entity. f(e) = 0 if e is a new entity. This term
can also be extended to include other surface-form
features for coreference resolution (Martschat and
Strube, 2015; Clark and Manning, 2016b).

For the chosen entity et from Equation 4, the
distribution over its mention length is drawn ac-
cording to

p(Lt = ` | ht−1, eet,t−1)
∝ exp(W>length,`[ht−1; eet,t−1]),

(5)

where eet,t−1 is the most recent embedding of the
entity et, not updated with ht. The intuition is that
eet,t−1 will help contextual information ht−1 to
select the residual length of entity et. Wlength
is the weight matrix for length prediction, with
`max = 25 rows.

Finally, the probability of a word x as the next
token is jointly modeled by ht−1 and the vector
representation of the most recently mentioned en-
tity ecurrent :

p(Xt = x | ht−1, ecurrent)
∝ CFSM(ht−1 + Weecurrent),

(6)

1832



where We is a transformation matrix to adjust the
dimensionality of ecurrent . CFSM is a class factor-
ized softmax function (Goodman, 2001; Baltescu
and Blunsom, 2015). It uses a two-step prediction
with predefined word classes instead of direct pre-
diction on the whole vocabulary, and reduces the
time complexity to the log of vocabulary size.

2.4 Dynamic entity representations
Before predicting the entity at step t, we need an
embedding for the new candidate entity with index
e′ = 1 + maxt′<t et′ if it does not exist. The new
embedding is generated randomly, according to a
normal distribution, then projected onto the unit
ball:

u ∼ N (r1, σ2I);
ee′,t−1 =

u
‖u‖2 ,

(7)

where σ = 0.01. The time step t − 1 in ee′,t−1
means the current embedding contains no infor-
mation from step t, although it will be updated
once we have ht and if Et = e′. r1 is the pa-
rameterized embedding for Rt = 1, which will be
jointly optimized with other parameters and is ex-
pected to encode some generic information about
entities. All the initial entity embeddings are cen-
tered on the mean r1, which is used in Equation 3
to determine whether the next token belongs to an
entity mention. Another choice would be to ini-
tialize with a zero vector, although our preliminary
experiments showed this did not work as well as
random initialization in Equation 7.

Assume Rt = 1 and Et = et, which means xt
is part of a mention of entity et. Then, we need
to update eet,t−1 based on the new information we
have from ht. The new embedding eet,t is a con-
vex combination of the old embedding (eet,t−1)
and current LSTM hidden state (ht) with the in-
terpolation (δt) determined dynamically based on
a bilinear function:

δt = σ(h>t Wδeet,t−1);
u = δteet,t−1 + (1− δt)ht;

eet,t =
u
‖u‖2 , (8)

This updating scheme will be used to update et in
each of all the following `t steps. The projection
in the last step keeps the magnitude of the entity
embedding fixed, avoiding numeric overflow. A
similar updating scheme has been used by Henaff

et al. (2016) for the “memory blocks” in their re-
current entity network models. The difference is
that their model updates all memory blocks in each
time step. Instead, our updating scheme in Equa-
tion 8 only applies to the selected entity et at time
step t.

2.5 Training objective
The model is trained to maximize the log of the
joint probability of R,E,L, and X:

`(θ) = logP (R,E,L,X; θ)

=
∑
t

logP (Rt, Et, Lt, Xt; θ), (9)

where θ is the collection of all the parameters
in this model. Based on the formulation in §2.3,
Equation 9 can be decomposed as the sum of con-
ditional log-probabilities of each random variable
at each time step.

This objective requires the training data anno-
tated as in Figure 2. We do not assume that these
variables are observed at test time.

3 Implementation Details

Our model is implemented with DyNet (Neu-
big et al., 2017) and available at https://
github.com/jiyfeng/entitynlm. We
use AdaGrad (Duchi et al., 2011) with learning
rate λ = 0.1 and ADAM (Kingma and Ba, 2014)
with default learning rate λ = 0.001 as the candi-
date optimizers of our model. For all the parame-
ters, we use the initialization tricks recommended
by Glorot and Bengio (2010). To avoid overfitting,
we also employ dropout (Srivastava et al., 2014)
with the candidate rates as {0.2, 0.5}.

In addition, there are two tunable hyperpa-
rameters of ENTITYNLM: the size of word em-
beddings and the dimension of LSTM hidden
states. For both of them, we consider the values
{32, 48, 64, 128, 256}. We also experiment with
the option to either use the pretrained GloVe word
embeddings (Pennington et al., 2014) or randomly
initialized word embeddings (then updated during
training). For all experiments, the best configura-
tion of hyperparameters and optimizers is selected
based on the objective value on the development
data.

4 Evaluation Tasks and Datasets

We evaluate our model in diverse use scenarios:
(i) language modeling, (ii) coreference resolution,

1833



and (iii) entity prediction. The evaluation on lan-
guage modeling shows how the internal entity rep-
resentation, when marginalized out, can improve
the perplexity of language models. The evaluation
on coreference resolution experiment shows how
our new language model can improve a compet-
itive coreference resolution system. Finally, we
employ an entity cloze task to demonstrate the
generative performance of our model in predicting
the next entity given the previous context.

We use two datasets for the three evaluation
tasks. For language modeling and coreference
resolution, we use the English benchmark data
from the CoNLL 2012 shared task on corefer-
ence resolution (Pradhan et al., 2012). We employ
the standard training/development/test split, which
includes 2,802/343/348 documents with roughly
1M/150K/150K tokens, respectively. We follow
the coreference annotation in the CoNLL dataset
to extract entities and ignore the singleton men-
tions in texts.

For entity prediction, we employ the InScript
corpus created by Modi et al. (2017). It consists of
10 scenarios, including grocery shopping, taking
a flight, etc. It includes 910 crowdsourced simple
narrative texts in total and 18 stories were ignored
due to labeling problems (Modi et al., 2017). On
average, each story has 12.4 sentences, 24.9 en-
tities and 217.2 tokens. Each entity mention is
labeled with its entity index. We use the same
training/development/test split as in (Modi et al.,
2017), which includes 619, 91, 182 texts, respec-
tively.

Data preprocessing

For the CoNLL dataset, we lowercase all tokens
and remove any token that only contains a punctu-
ation symbol unless it is in an entity mention. We
also replace numbers in the documents with the
special token NUM and low-frequency word types
with UNK. The vocabulary size of the CoNLL data
after preprocessing is 10K. For entity mention ex-
traction, in the CoNLL dataset, one entity men-
tion could be embedded in another. For embed-
ded mentions, only the enclosing entity mention
is kept. We use the same preprocessed data for
both language modeling and coreference resolu-
tion evaluation.

For the InScript corpus, we apply similar data
preprocessing to lowercase all tokens, and we re-
place low-frequency word types with UNK. The

vocabulary size after preprocessing is 1K.

5 Experiments

In this section, we present the experimental results
on the three evaluation tasks.

5.1 Language modeling
Task description. The goal of language model-
ing is to compute the marginal probability:

P (X) =
∑

R,E,L

P (X,R,E,L). (10)

However, due to the long-range dependency in
recurrent neural networks, the search space of
R,E,L during inference grows exponentially.
We thus use importance sampling to approxi-
mate the marginal distribution of X. Specifi-
cally, with the samples from a proposal distri-
bution Q(R,E,L|X), the approximated marginal
probability is defined as

P (X) =
∑

R,E,L

P (X,R,E,L)

=
∑

R,E,L

Q(R,E,L | X) P (X,R,E,L)
Q(R,E,L | X)

≈ 1
N

∑
{r(i),e(i),`(i)}∼Q

P (r(i), e(i), `(i),x)
Q(r(i), e(i), `(i) | x)

(11)

A similar idea of using importance sampling for
language modeling evaluation has been used by
Dyer et al. (2016).

For language modeling evaluation, we train our
model on the training set from the CoNLL 2012
dataset with coreference annotation. On the test
data, we treat coreference structure as latent vari-
ables and use importance sampling to approximate
the marginal distribution of X. For each docu-
ment, the model randomly draws N = 100 sam-
ples from the proposal distribution, discussed next.

Proposal distribution. For implementation of
Q, we use a discriminative variant of ENTI-
TYNLM by taking the current word xt for predict-
ing the entity-related variables in the same time
step. Specifically, in the generative story described
in §2.2, we delete step 3 (words are not gener-
ated, but rather conditioned upon), move step 4
before step 1, and replace ht−1 with ht in the
steps for predicting entity type Rt, entity Et and
mention length Lt. This model variant provides a

1834



Model Perplexity

1. 5-gram LM 138.37
2. RNNLM 134.79
3. ENTITYNLM 131.64

Table 1: Language modeling evaluation on the test
sets of the English section in the CoNLL 2012
shared task. As mentioned in §4, the vocabulary
size is 10K. ENTITYNLM does not require any
coreference annotation on the test data.

conditional probability Q(Rt, Et, Lt | Xt) at each
timestep.

Baselines. We compare the language modeling
performance with two competitive baselines: 5-
gram language model implemented in KenLM
(Heafield et al., 2013) and RNNLM with LSTM
units implemented in DyNet (Neubig et al., 2017).
For RNNLM, we use the same hyperparameters
described in §3 and grid search on the develop-
ment data to find the best configuration.

Results. The results of ENTITYNLM and the
baselines on both development and test data are
reported in Table 1. For ENTITYNLM, we use the
value of 2−

1
T

∑T
t=1 logP (Xt,Rt,Et,Lt) on the devel-

opment set with coreference annotation to select
the best model configuration and report the best
number. On the test data, we are able to calcu-
late perplexity by marginalizing all other random
variables using Equation 11. To compute the per-
plexity numbers on the test data, our model only
takes account of log probabilities on word predic-
tion. The difference is that coreference informa-
tion is only used for training ENTITYNLM and
not for test. All three models reported in Table 1
share the same vocabulary, therefore the numbers
on the test data are directly comparable. As shown
in Table 1, ENTITYNLM outperforms both the 5-
gram language model and the RNNLM on the test
data. Better performance of ENTITYNLM on lan-
guage modeling can be expected, if we also use the
marginalization method defined in Equation 11 on
the development data to select the best configura-
tion. However, we plan to use the same experi-
mental setup for all experiments, instead of cus-
tomizing our model for each individual task.

5.2 Coreference reranking
Task description. We show how ENTITYLM,
which allows an efficient computation of the

probability P (R,E,L,X), can be used as a
coreference reranker to improve a competitive
coreference resolution system due to Martschat
and Strube (2015). This task is analogous to
the reranking approach used in machine transla-
tion (Shen et al., 2004). The specific formulation
is as follows:

arg max
{r(i),e(i),l(i)}∈K

P (r(i), e(i), l(i),x) (12)

where K is the k-best list for a given document.
In our experiments, k = 100. To the best of our
knowledge, the problem of obtaining k-best out-
puts of a coreference resolution system has not
been studied before.

Approximate k-best decoding. We rerank the
output of a system that predicts an antecedent for
each mention by relying on pairwise scores for
mention pairs. This is the dominant approach
for coreference resolution (Martschat and Strube,
2015; Clark and Manning, 2016a). The predic-
tions induce an antecedent tree, which represents
antecedent decisions for all mentions in the doc-
ument. Coreference chains are obtained by tran-
sitive closure over the antecedent decisions en-
coded in the tree. A mention also can have an
empty mention as antecedent, which denotes that
the mention is non-anaphoric.

For extending Martschat and Strube’s greedy
decoding approach to k-best inference, we can-
not simply take the k highest scoring trees ac-
cording to the sum of edge scores, because dif-
ferent trees may represent the same coreference
chain. Instead, we use an heuristic that creates
an approximate k-best list on candidate antecedent
trees. The idea is to generate trees from the orig-
inal system output by considering suboptimal an-
tecedent choices that lead to different coreference
chains. For each mention pair (mj ,mi), we com-
pute the difference of its score to the score of the
optimal antecedent choice for mj . We then sort
pairs in ascending order according to this differ-
ence and iterate through the list of pairs. For each
pair (mj ,mi), we create a tree tj,i by replacing
the antecedent of mj in the original system output
with mi. If this yields a tree that encodes differ-
ent coreference chains from all chains encoded by
trees in the k-best list, we add ti,j to the k-best list.
In the case that we cannot generate a given num-
ber of trees (particularly for a short document with
a large k), we pad the list with the last item added
to the list.

1835



Evaluation measures. For coreference resolu-
tion evaluation, we employ the CoNLL scorer
(Pradhan et al., 2014). It computes three com-
monly used evaluation measures MUC (Vilain
et al., 1995), B3 (Bagga and Baldwin, 1998), and
CEAFe (Luo, 2005). We report the F1 score of
each evaluation measure and their average as the
CoNLL score.

Competing systems. We employed CORT1
(Martschat and Strube, 2015) as our baseline
coreference resolution system. Here, we com-
pare with the original (one best) outputs of
CORT’s latent ranking model, which is the best-
performing model implemented in CORT. We
consider two rerankers based on ENTITYNLM.
The first reranking method only uses the log
probability for ENTITYNLM to sort the candidate
list (Equation 12). The second method uses a
linear combination of both log probabilities from
ENTITYNLM and the scores from CORT, where
the coefficients were found via grid search with
the CoNLL score on the development set.

Results. The reranked results on the CoNLL
2012 test set are reported in Table 2. The numbers
of the baseline are higher than the results reported
in Martschat and Strube (2015) since the feature
set of CORT was subsequently extended. Lines 2
and 3 in Table 2 present the reranked best results.
As shown in this table, both reranked results give
more than 1% of CoNLL score improvement on
the test set over CORT, which are significant based
on an approximate randomization test2.

Additional experiments also found that increas-
ing k from 100 to 500 had a minor effect. That is
because the diversity of each k-best list is limited
by (i) the number of entity mentions in the docu-
ment, (ii) the performance of the baseline corefer-
ence resolution system, and possibly (iii) the ap-
proximate nature of our k-best inference proce-
dure. We suspect that a stronger baseline system
(such as that of Clark and Manning, 2016a) could
give greater improvements, if it can be adapted to
provide k-best lists. Future work might incorpo-
rate the techniques embedded in such systems into
ENTITYNLM.

[I]1 was about to ride [my]1 [bicycle]2 to the
[park]3 one day when [I]1 noticed that the front
[tire]4 was flat . [I]1 realized that [I]1 would
have to repair [it]4 . [I]1 went into [my]1
[garage]5 to get some [tools]5 . The first thing
[I]1 did was remove the xxxx

Figure 3: A short story on bicycles from the
InScript corpus (Modi et al., 2017). The entity
prediction task requires predicting xxxx given
the preceding text either by choosing a previously
mentioned entity or deciding that this is a “new en-
tity”. In this example, the ground-truth prediction
is [tire]4. For training, ENTITYNLM attempts to
predict every entity. While, for testing, it predicts
a maximum of 30 entities after the first three sen-
tences, which is consistent with the experimental
setup suggested by Modi et al. (2017).

5.3 Entity prediction

Task description. Based on Modi et al. (2017),
we introduce a novel entity prediction task that
tries to predict the next entity given the preced-
ing text. For a given text as in Figure 3, this task
makes a forward prediction based on only the left
context. This is different from coreference reso-
lution, where both left and right contexts from a
given entity mention are used in decoding. It is
also different from language modeling, since this
task only requires predicting entities. Since EN-
TITYNLM is generative, it can be directly applied
to this task. To predict entities in test data, Rt is
always given and ENTITYNLM only needs to pre-
dict Et when Rt = 1.

Baselines and human prediction. We intro-
duce two baselines in this task: (i) the always-new
baseline that always predicts “new entity”; (ii) a
linear classification model using shallow features
from Modi et al. (2017), including the recency of
an entity’s last mention and the frequency. We also
compare with the model proposed by Modi et al.
(2017). Their work assumes that the model has
prior knowledge of all the participant types, which
are specific to each scenario and fine-grained, e.g.,
rider in the bicycle narrative, and predicts partic-
ipant types for new entities. This assumption is
unrealistic for pure generative models like ours.

1https://github.com/smartschat/cort, we
used version 0.2.4.5.

2https://github.com/smartschat/art

1836



MUC B3 CEAFe
Model CoNLL P R F1 P R F1 P R F1

1. Baseline: CORT’s one best 62.93 77.15 68.67 72.66 66.00 54.92 59.95 60.07 52.76 56.18
2. Rerank: ENTITYNLM 64.00 77.90 69.45 73.44 66.84 56.12 61.01 61.73 53.90 57.55
3. Rerank: ENTITYNLM + CORT 64.04 77.93 69.49 73.47 67.08 55.99 61.04 61.76 53.98 57.61

Table 2: Coreference resolution scores on the CoNLL 2012 test set. CORT is the best-performing model
of Martschat and Strube (2015) with greedy decoding.

Accuracy (%)

1. Baseline: always-new 31.08
2. Baseline: shallow features 45.34
3. Modi et al. (2017) 62.65
4. ENTITYNLM 74.23
5. Human prediction 77.35

Table 3: Entity prediction accuracy on the test set
of the InScript corpus.

Therefore, we remove this assumption and adapt
their prediction results to our formulation by map-
ping all the predicted entities that have not been
mentioned to “new entity”. We also compare to
the adapted human prediction used in the In-
Script corpus. For each entity slot, Modi et al.
(2017) acquired 20 human predictions, and the
majority vote was selected. More details about
human predictions are discussed in (Modi et al.,
2017).

Results. Table 3 shows the prediction accura-
cies. ENTITYNLM (line 4) significantly outper-
forms both baselines (line 1 and 2) and prior work
(line 3) (p � 0.01, paired t-test). The compari-
son between line 4 and 5 shows our model is even
close to the human prediction performance.

6 Related Work

Rich-context language models. The originally
proposed recurrent neural network language mod-
els only capture information within sentences.
To extend the capacity of RNNLMs, various re-
searchers have incorporated information beyond
sentence boundaries. Previous work focuses
on contextual information from previous sen-
tences (Ji et al., 2016a) or discourse relations be-
tween adjacent sentences (Ji et al., 2016b), show-
ing improvements to language modeling and re-
lated tasks like coherence evaluation and discourse
relation prediction. In this work, ENTITYNLM
adds explicit entity information to the language
model, which is another way of adding a memory

network for language modeling. Unlike the work
by Tran et al. (2016), where memory blocks are
used to store general contextual information for
language modeling, ENTITYNLM assigns each
memory block specifically to only one entity.

Entity-related models. Two recent approaches
to modeling entities in text are closely related to
our model. The first is the “reference-aware” lan-
guage models proposed by Yang et al. (2016),
where the referred entities are from either a pre-
defined item list, an external database, or the con-
text from the same document. Yang et al. (2016)
present three models, one for each case. For mod-
eling a document with entities, they use corefer-
ence links to recover entity clusters, though they
only model entity mentions as containing a single
word (an inappropriate assumption, in our view).
Their entity updating method takes the latest hid-
den state (similar to ht whenRt = 1 in our model)
as the new representation of the current entity; no
long-term history of the entity is maintained, just
the current local context. In addition, their lan-
guage model evaluation assumes that entity infor-
mation is provided at test time (Yang, personal
communication), which makes a direct compari-
son with our model impossible. Our entity updat-
ing scheme is similar to the “dynamic memory”
method used by Henaff et al. (2016). Our entity
representations are dynamically allocated and up-
dated only when an entity appears up, while the
EntNet from Henaff et al. (2016) does not model
entities and their relationships explicitly. In their
model, entity memory blocks are pre-allocated
and updated simultaneously in each timestep. So
there is no dedicated memory block for every en-
tity and no distinction between entity mentions
and non-mention words. As a consequence, it is
not clear how to use their model for coreference
reranking and entity prediction.

Coreference resolution. The hierarchical struc-
ture of our entity generation model is inspired by

1837



Haghighi and Klein (2010). They implemented
this idea as a probabillistic graphical model with
the distance-dependent Chinese Restaurant Pro-
cess (Pitman, 1995) for entity assignment, while
our model is built on a recurrent neural network
architecture. The reranking method considered in
our coreference resolution evaluation could also
be extended with samples from additional coref-
erence resolution systems, to produce more va-
riety (Ng, 2005). The benefit of such a system
comes, we believe, from the explicit tracking of
each entity throughout the text, providing entity-
specific representations. In previous work, such
information has been added as features (Luo et al.,
2004; Björkelund and Kuhn, 2014) or by com-
puting distributed entity representations (Wiseman
et al., 2016; Clark and Manning, 2016b). Our ap-
proach complements these previous methods.

Entity prediction. The entity prediction task
discussed in §5.3 is based on work by Modi et al.
(2017). The main difference is that we do not as-
sume that all entities belong to a previously known
set of entity types specified for each narrative sce-
nario. This task is also closely related to the
“narrative cloze” task of Chambers and Jurafsky
(2008) and the “story cloze test” of Mostafazadeh
et al. (2016). Those studies aim to understand re-
lationships between events, while our task focuses
on predicting upcoming entity mentions.

7 Conclusion

We have presented a neural language model, EN-
TITYNLM, that defines a distribution over texts
and the mentioned entities. It provides vector rep-
resentations for the entities and updates them dy-
namically in context. The dynamic representations
are further used to help generate specific entity
mentions and the following text. This model out-
performs strong baselines and prior work on three
tasks: language modeling, coreference resolution,
and entity prediction.

Acknowledgments

We thank anonymous reviewers for the helpful
feedback on this work. We also thank the members
of Noah’s ARK and XLab at University of Wash-
ington for their valuable comments, particularly
Eunsol Choi for pointing out the InScript corpus.
This research was supported in part by a Univer-
sity of Washington Innovation Award, Samsung

GRO, NSF grant IIS-1524371, the DARPA CwC
program through ARO (W911NF-15-1-0543), and
gifts by Google and Facebook.

References
Amit Bagga and Breck Baldwin. 1998. Algorithms for

scoring coreference chains. In LREC Workshop on
Linguistic Coreference.

Paul Baltescu and Phil Blunsom. 2015. Pragmatic neu-
ral language modelling in machine translation. In
NAACL.

Anders Björkelund and Jonas Kuhn. 2014. Learn-
ing structured perceptrons for coreference resolution
with latent antecedents and non-local features. In
ACL.

Nathanael Chambers and Daniel Jurafsky. 2008. Un-
supervised Learning of Narrative Event Chains. In
ACL.

Kevin Clark and Christopher D. Manning. 2016a.
Deep reinforcement learning for mention-ranking
coreference models. In EMNLP.

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In ACL.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning
and stochastic optimization. Journal of Machine
Learning Research, 12:2121–2159.

Chris Dyer, Adhiguna Kuncoro, Miguel Ballesteros,
and Noah A. Smith. 2016. Recurrent neural network
grammars. In EMNLP.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difficulty of training deep feedforward neural
networks. In AISTATS, pages 249–256.

Joshua Goodman. 2001. Classes for fast maximum en-
tropy training. In ICASSP.

Aria Haghighi and Dan Klein. 2010. Coreference res-
olution in a modular, entity-centered model. In
NAACL.

Kenneth Heafield, Ivan Pouzyrevsky, Jonathan H.
Clark, and Philipp Koehn. 2013. Scalable modified
Kneser-Ney language model estimation. In ACL.

Mikael Henaff, Jason Weston, Arthur Szlam, An-
toine Bordes, and Yann LeCun. 2016. Track-
ing the world state with recurrent entity networks.
arXiv:1612.03969.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780.

1838



Yangfeng Ji, Trevor Cohn, Lingpeng Kong, Chris Dyer,
and Jacob Eisenstein. 2016a. Document context lan-
guage models. In ICLR (workshop track).

Yangfeng Ji, Gholamreza Haffari, and Jacob Eisen-
stein. 2016b. A latent variable recurrent neural
network for discourse-driven language models. In
NAACL-HLT.

Diederik Kingma and Jimmy Ba. 2014. Adam:
A method for stochastic optimization.
arXiv:1412.6980.

Xiaoqiang Luo. 2005. On coreference resolution per-
formance metrics. In HLT-EMNLP.

Xiaoqiang Luo, Abe Ittycheriah, Hongyan Jing, Nanda
Kambhatla, and Salim Roukos. 2004. A mention-
synchronous coreference resolution algorithm based
on the Bell tree. In ACL.

Sebastian Martschat and Michael Strube. 2015. La-
tent structures for coreference resolution. Transac-
tions of the Association for Computational Linguis-
tics, 3:405–418.

Tomas Mikolov, Martin Karafiát, Lukas Burget, Jan
Cernockỳ, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH.

Ashutosh Modi, Ivan Titov, Vera Demberg, Asad Say-
eed, and Manfred Pinkal. 2017. Modeling seman-
tic expectation: Using script knowledge for referent
prediction. Transactions of the Association of Com-
putational Linguistics, 5:31–44.

Nasrin Mostafazadeh, Nathanael Chambers, Xiaodong
He, Devi Parikh, Dhruv Batra, Lucy Vanderwende,
Pushmeet Kohli, and James Allen. 2016. A corpus
and evaluation framework for deeper understanding
of commonsense stories. In NAACL.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv:1701.03980.

Vincent Ng. 2005. Machine learning for coreference
resolution: From local classification to global rank-
ing. In ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. Glove: Global vectors for
word representation. In EMNLP.

Jim Pitman. 1995. Exchangeable and partially ex-
changeable random partitions. Probability Theory
and Related Fields, 102(2):145–158.

Sameer Pradhan, Xiaoqiang Luo, Marta Recasens, Ed-
uard Hovy, Vincent Ng, and Michael Strube. 2014.
Scoring coreference partitions of predicted men-
tions: A reference implementation. In ACL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
stricted coreference in OntoNotes. In EMNLP-
CoNLL.

Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004.
Discriminative reranking for machine translation. In
NAACL.

Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky,
Ilya Sutskever, and Ruslan Salakhutdinov. 2014.
Dropout: A simple way to prevent neural networks
from overfitting. Journal of Machine Learning Re-
search, 15(1):1929–1958.

Ke Tran, Arianna Bisazza, and Christof Monz. 2016.
Recurrent memory networks for language modeling.
In NAACL-HLT.

Marc Vilain, John Burger, John Aberdeen, Dennis Con-
nolly, and Lynette Hirschman. 1995. A model-
theoretic coreference scoring scheme. In MUC.

Sam Wiseman, Alexander M. Rush, and Stuart M.
Shieber. 2016. Learning global features for coref-
erence resolution. In NAACL.

Zichao Yang, Phil Blunsom, Chris Dyer, and Wang
Ling. 2016. Reference-aware language models.
arXiv:1611.01628.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
2015. Recurrent neural network regularization.
ICLR.

1839


