



















































Universal Semantic Parsing


Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 89–101
Copenhagen, Denmark, September 7–11, 2017. c©2017 Association for Computational Linguistics

Universal Semantic Parsing

Siva Reddy†∗ Oscar Täckström‡ Slav Petrov‡ Mark Steedman†† Mirella Lapata††
†Stanford University

‡ Google Inc.
††University of Edinburgh

sivar@stanford.edu, {oscart, slav}@google.com, {steedman, mlap}@inf.ed.ac.uk

Abstract

Universal Dependencies (UD) offer a uni-
form cross-lingual syntactic representation,
with the aim of advancing multilingual ap-
plications. Recent work shows that se-
mantic parsing can be accomplished by
transforming syntactic dependencies to log-
ical forms. However, this work is lim-
ited to English, and cannot process de-
pendency graphs, which allow handling
complex phenomena such as control. In
this work, we introduce UDEPLAMBDA,
a semantic interface for UD, which maps
natural language to logical forms in an
almost language-independent fashion and
can process dependency graphs. We per-
form experiments on question answering
against Freebase and provide German and
Spanish translations of the WebQuestions
and GraphQuestions datasets to facilitate
multilingual evaluation. Results show that
UDEPLAMBDA outperforms strong base-
lines across languages and datasets. For
English, it achieves a 4.9 F1 point improve-
ment over the state-of-the-art on Graph-
Questions.

1 Introduction

The Universal Dependencies (UD) initiative seeks
to develop cross-linguistically consistent annota-
tion guidelines as well as a large number of uni-
formly annotated treebanks for many languages
(Nivre et al., 2016). Such resources could advance
multilingual applications of parsing, improve com-
parability of evaluation results, enable cross-lingual
learning, and more generally support natural lan-
guage understanding.

∗Work done at the University of Edinburgh

Seeking to exploit the benefits of UD for natu-
ral language understanding, we introduce UDEP-
LAMBDA, a semantic interface for UD that maps
natural language to logical forms, representing un-
derlying predicate-argument structures, in an al-
most language-independent manner. Our frame-
work is based on DEPLAMBDA (Reddy et al.,
2016) a recently developed method that converts
English Stanford Dependencies (SD) to logical
forms. The conversion process is illustrated in
Figure 1 and discussed in more detail in Section 2.
Whereas DEPLAMBDA works only for English, U-
DEPLAMBDA applies to any language for which
UD annotations are available.1 Moreover, DEP-
LAMBDA can only process tree-structured inputs
whereas UDEPLAMBDA can also process depen-
dency graphs, which allow to handle complex con-
structions such as control. The different treatments
of various linguistic constructions in UD compared
to SD also require different handling in UDEP-
LAMBDA (Section 3.3).

Our experiments focus on Freebase semantic
parsing as a testbed for evaluating the framework’s
multilingual appeal. We convert natural language
to logical forms which in turn are converted to ma-
chine interpretable formal meaning representations
for retrieving answers to questions from Freebase.
To facilitate multilingual evaluation, we provide
translations of the English WebQuestions (Berant
et al., 2013) and GraphQuestions (Su et al., 2016)
datasets to German and Spanish. We demonstrate
that UDEPLAMBDA can be used to derive logical
forms for these languages using a minimal amount
of language-specific knowledge. Aside from devel-
oping the first multilingual semantic parsing tool
for Freebase, we also experimentally show that U-
DEPLAMBDA outperforms strong baselines across

1As of v1.3, UD annotations are available for 47 languages
at http://universaldependencies.org.

89



languages and datasets. For English, it achieves the
strongest result to date on GraphQuestions, with
competitive results on WebQuestions. Our imple-
mentation and translated datasets are publicly avail-
able at https://github.com/sivareddyg/udeplambda.

2 DEPLAMBDA

Before describing UDEPLAMBDA, we provide an
overview of DEPLAMBDA (Reddy et al., 2016)
on which our approach is based. DEPLAMBDA
converts a dependency tree to its logical form in
three steps: binarization, substitution, and com-
position, each of which is briefly outlined below.
Algorithm 1 describes the steps of DEPLAMBDA
in lines 4-6, whereas lines 2 and 3 are specific to
UDEPLAMBDA.

Binarization A dependency tree is first mapped
to a Lisp-style s-expression indicating the order
of semantic composition. Figure 1(b) shows the
s-expression for the sentence Disney won an Os-
car for the movie Frozen, derived from the depen-
dency tree in Figure 1(a). Here, the sub-expression
(dobj won (det Oscar an)) indicates that the logi-
cal form of the phrase won an Oscar is derived by
composing the logical form of the label dobj with
the logical form of the word won and the logical
form of the phrase an Oscar, derived analogously.
The s-expression can also be interpreted as a bi-
narized tree with the dependency label as the root
node, and the left and right expressions as subtrees.

A composition hierarchy is employed to impose
a strict traversal ordering on the modifiers to each
head in the dependency tree. As an example, won
has three modifiers in Figure 1(a), which according
to the composition hierarchy are composed in the
order dobj > nmod > nsubj. In constructions like
coordination, this ordering is crucial to arrive at
the correct semantics. Lines 7-17 in Algorithm 1
describe the binarization step.

Substitution Each symbol in the s-expressions
is substituted for a lambda expression encoding
its semantics. Words and dependency labels are
assigned different types of expressions. In general,
words have expressions of the following kind:
ENTITY ⇒ λx.word(xa); e.g. Oscar⇒ λx.Oscar(xa)
EVENT ⇒ λx.word(xe); e.g. won⇒ λx.won(xe)
FUNCTIONAL⇒ λx. TRUE; e.g. an⇒ λx. TRUE

Here, the subscripts ·a and ·e denote the types
of individuals (Ind) and events (Event), respec-
tively, whereas x denotes a paired variable (xa,xe)

Disney won an Oscar for the movie Frozen
propn verb det propn adp det noun propn

nsubj

dobj

nmod

det

case

det

compound

root

(a) The dependency tree for Disney won an Oscar for the
movie Frozen in the Universal Dependencies formalism.

(nsubj (nmod (dobj won (det Oscar an))
(case (det (comp. Frozen movie) the) for)) Disney)

(b) The binarized s-expression for the dependency tree.

λx.∃yzw.won(xe)∧Disney(ya)∧Oscar(za)
∧Frozen(wa)∧ movie(wa)
∧arg1(xe,ya)∧ arg2(xe,za)∧ nmod.for(xe,wa)

(c) The composed lambda-calculus expression.

Figure 1: The mapping of a dependency tree to its
logical form with the intermediate s-expression.

of type Ind×Event. Roughly speaking, proper
nouns and adjectives invoke ENTITY expressions,
verbs and adverbs invoke EVENT expressions, and
common nouns invoke both ENTITY and EVENT ex-
pressions (see Section 3.3), while remaining words
invoke FUNCTIONAL expressions. DEPLAMBDA
enforces the constraint that every s-expression is of
the type η = Ind×Event→ Bool, which simpli-
fies the type system considerably.

Expressions for dependency labels glue the
semantics of heads and modifiers to articulate
predicate-argument structure. These expressions in
general take one of the following forms:

COPY ⇒ λ f gx.∃y. f (x)∧g(y)∧ rel(x,y)
e.g. nsubj, dobj, nmod, advmod
INVERT ⇒ λ f gx.∃y. f (x)∧g(y)∧ reli(y,x)
e.g. amod, acl
MERGE ⇒ λ f gx. f (x)∧g(x)
e.g. compound, appos, amod, acl
HEAD ⇒ λ f gx. f (x)
e.g. case, punct, aux, mark .

As an example of COPY, consider the lambda
expression for dobj in (dobj won (det Oscar an)):
λ f gx.∃y. f (x)∧ g(y)∧ arg2(xe,ya). This expres-
sion takes two functions f and g as input, where
f represents the logical form of won and g repre-
sents the logical form of an Oscar. The predicate-
argument structure arg2(xe,ya) indicates that the
arg2 of the event xe, i.e. won, is the individual ya,
i.e. the entity Oscar. Since arg2(xe,ya) mimics the
dependency structure dobj(won, Oscar), we refer
to the expression kind evoked by dobj as COPY.

90



Expressions that invert the dependency direc-
tion are referred to as INVERT (e.g. amod in run-
ning horse); expressions that merge two subexpres-
sions without introducing any relation predicates
are referred to as MERGE (e.g. compound in movie
Frozen); and expressions that simply return the par-
ent expression semantics are referred to as HEAD
(e.g. case in for Frozen). While this generalization
applies to most dependency labels, several labels
take a different logical form not listed here, some
of which are discussed in Section 3.3. Sometimes
the mapping of dependency label to lambda expres-
sion may depend on surrounding part-of-speech
tags or dependency labels. For example, amod acts
as INVERT when the modifier is a verb (e.g. in run-
ning horse), and as MERGE when the modifier is
an adjective (e.g. in beautiful horse).2 Lines 26-32
in Algorithm 1 describe the substitution procedure.

Composition The final logical form is computed
by beta-reduction, treating expressions of the form
(f x y) as the function f applied to the arguments
x and y. For example, (dobj won (det Oscar an))
results in λx.∃z.won(xe)∧Oscar(za)∧ arg2(xe,za)
when the expression for dobj is applied to those
for won and (det Oscar an). Figure 1(c) shows the
logical form for the s-expression in Figure 1(b).
The binarized s-expression is recursively converted
to a logical form as described in lines 18-25 in
Algorithm 1.

3 UDEPLAMBDA

We now introduce UDEPLAMBDA, a semantic in-
terface for Universal Dependencies.3 Whereas
DEPLAMBDA only applies to English Stanford De-
pendencies, UDEPLAMBDA takes advantage of the
cross-lingual nature of UD to facilitate an (almost)
language independent semantic interface. This is
accomplished by restricting the binarization, sub-
stitution, and composition steps described above
to rely solely on information encoded in the UD
representation. As shown in Algorithm 1, lines
4-6 are common to both DEPLAMBDA and UDEP-
LAMBDA, whereas lines 2 and 3 applies only to
UDEPLAMBDA. Importantly, UDEPLAMBDA is
designed to not rely on lexical forms in a language

2We use Tregex (Levy and Andrew, 2006) for substitu-
tion mappings and Cornell SPF (Artzi, 2013) as the lambda-
calculus implementation. For example, in running horse, the
tregex /label:amod/=target < /postag:verb/ matches amod to
its INVERT expression λ f gx.∃y. f (x)∧g(y)∧ amodi(ye,xa).

3In what follows, all references to UD are to UD v1.3.

Algorithm 1: UDEPLAMBDA Steps
1 Function UDepLambda(depTree):
2 depGraph = Enhancement (depTree)

#See Figure 2(a) for a depGraph.
3 bindedTree = SplitLongDistance (depGraph)

#See Figure 2(b) for a bindedTree.
4 binarizedTree = Binarization (bindedTree)

#See Figure 1(b) for a binarizedTree.
5 logicalForm = Composition (binarizedTree)
6 return logicalForm

7 Function Binarization (tree):
8 parent = GetRootNode (tree);
9 {(label1,child1),(label2,child2) . . .}

= GetChildNodes (parent)
10 sortedChildren = SortUsingLabelHierarchy

({(label1,child1),(label2,child2) . . .})
11 binarziedTree.root = parent
12 for label, child ∈ sortedChildren:
13 temp.root = label
14 temp.le f t = binarziedTree
15 temp.right = Binarization(child)
16 binarziedTree = temp
17 return binarizedTree

18 Function Composition (binarizedTree):
19 mainLF = Substitution (binarizedTree.root)
20 if binarziedTree has left and right children:
21 le f tLF = Composition (binarziedTree.le f t)
22 rightLF = Composition(binarziedTree.right)
23 mainLF = BetaReduce (mainLF, le f tLF)
24 mainLF = BetaReduce (mainLF,rightLF)
25 return mainLF

26 Function Substitution (node):
27 logicalForms = [ ]
28 for tregexRule, template ∈ substitutionRules:
29 if tregexRule.match(node):
30 l f = GenLambdaExp (node, template)
31 logicalForms.add(l f )
32 return logicalForms

to assign lambda expressions, but only on informa-
tion contained in dependency labels and postags.

However, some linguistic phenomena are lan-
guage specific (e.g. pronoun-dropping) or lexical-
ized (e.g. every and the in English have different
semantics, despite being both determiners) and are
not encoded in the UD schema. Furthermore, some
cross-linguistic phenomena, such as long-distance
dependencies, are not part of the core UD represen-
tation. To circumvent this limitation, a simple en-
hancement step enriches the original UD represen-
tation before binarization takes place (Section 3.1).
This step adds to the dependency tree missing syn-
tactic information and long-distance dependencies,
thereby creating a graph. Whereas DEPLAMBDA
is not able to handle graph-structured input, UDEP-

91



LAMBDA is designed to work with dependency
graphs as well (Section 3.2). Finally, several con-
structions differ in structure between UD and SD,
which requires different handling in the semantic
interface (Section 3.3).

3.1 Enhancement

Both Schuster and Manning (2016) and Nivre et al.
(2016) note the necessity of an enhanced UD rep-
resentation to enable semantic applications. How-
ever, such enhancements are currently only avail-
able for a subset of languages in UD. Instead, we
rely on a small number of enhancements for our
main application—semantic parsing for question-
answering—with the hope that this step can be re-
placed by an enhanced UD representation in the fu-
ture. Specifically, we define three kinds of enhance-
ments: (1) long-distance dependencies; (2) types
of coordination; and (3) refined question word tags.
These correspond to line 2 in Algorithm 1.

First, we identify long-distance dependencies in
relative clauses and control constructions. We fol-
low Schuster and Manning (2016) and find these
using the labels acl (relative) and xcomp (control).
Figure 2(a) shows the long-distance dependency in
the sentence Anna wants to marry Kristoff. Here,
marry is provided with its missing nsubj (dashed
arc). Second, UD conflates all coordinating con-
structions to a single dependency label, conj. To
obtain the correct coordination scope, we refine
conj to conj:verb, conj:vp, conj:sentence,
conj:np, and conj:adj, similar to Reddy et al.
(2016). Finally, unlike the PTB tags (Marcus et al.,
1993) used by SD, the UD part-of-speech tags do
not distinguish question words. Since these are cru-
cial to question-answering, we use a small lexicon
to refine the tags for determiners (DET), adverbs
(ADV) and pronouns (PRON) to DET:WH, ADV:WH
and PRON:WH, respectively. Specifically, we use
a list of 12 (English), 14 (Spanish) and 35 (Ger-
man) words, respectively. This is the only part
of UDEPLAMBDA that relies on language-specific
information. We hope that, as the coverage of mor-
phological features in UD improves, this refine-
ment can be replaced by relying on morphological
features, such as the interrogative feature (INT).

3.2 Graph Structures and BIND

To handle graph structures that may result from the
enhancement step, such as those in Figure 2(a), we
propose a variable-binding mechanism that differs

Anna wants to marry Kristoff

nsubj

xcomp

mark dobj

nsubj

(a) With long-distance dependency.

Anna wants to marry Kristoff

Ω Ω

nsubj

xcomp

mark dobj

bind nsubj

(b) With variable binding.

Figure 2: The original and enhanced dependency
trees for Anna wants to marry Kristoff.

from that of DEPLAMBDA. This is indicated in
line 3 of Algorithm 1. First, each long-distance
dependency is split into independent arcs as shown
in Figure 2(b). Here, Ω is a placeholder for the sub-
ject of marry, which in turn corresponds to Anna as
indicated by the binding of Ω via the pseudo-label
BIND. We treat BIND like an ordinary dependency
label with semantics MERGE and process the result-
ing tree as usual, via the s-expression:

(nsubj (xcomp wants (nsubj (mark
(dobj marry Kristoff) to) Ω) (BIND Anna Ω)) ,

with the lambda-expression substitutions:

wants, marry ∈ EVENT; to ∈ FUNCTIONAL;
Anna, Kristoff ∈ ENTITY;
mark ∈ HEAD; BIND ∈ MERGE;
xcomp = λ f gx.∃y. f (x)∧g(y)∧xcomp(xe,ye) .

These substitutions are based solely on unlexi-
calized context. For example, the part-of-speech
tag PROPN of Anna invokes an ENTITY expression.

The placeholder Ω has semantics λx.EQ(x,ω),
where EQ(u,ω) is true iff u and ω are equal (have
the same denotation), which unifies the subject vari-
able of wants with the subject variable of marry.

After substitution and composition, we get:

λz.∃xywv.wants(ze)∧Anna(xa)∧ arg1(ze,xa)∧ EQ(x,ω)
∧marry(ye)∧xcomp(ze,ye)∧ arg1(ye,va)∧ EQ(v,ω)
∧ Kristoff(wa)∧ arg2(ye,wa) ,

This expression may be simplified further by
replacing all occurrences of v with x and removing
the unification predicates EQ, which results in:

λz.∃xyw.wants(ze)∧Anna(xa)∧ arg1(ze,xa)
∧marry(ye)∧xcomp(ze,ye)∧ arg1(ye,xa)
∧ Kristoff(wa)∧ arg2(ye,wa) .

92



This expression encodes the fact that Anna is the
arg1 of the marry event, as desired. DEPLAMBDA,
in contrast, cannot handle graph-structured input,
since it lacks a principled way of generating s-
expressions from graphs. Even given the above
s-expression, BIND in DEPLAMBDA is defined in
a way such that the composition fails to unify v
and x, which is crucial for the correct semantics.
Moreover, the definition of BIND in DEPLAMBDA
does not have a formal interpretation within the
lambda calculus, unlike ours.

3.3 Linguistic Constructions

Below, we highlight the most pertinent differences
between UDEPLAMBDA and DEPLAMBDA, stem-
ming from the different treatment of various lin-
guistic constructions in UD versus SD.

Prepositional Phrases UD uses a content-head
analysis, in contrast to SD, which treats function
words as heads of prepositional phrases, Accord-
ingly, the s-expression for the phrase president
in 2009 is (nmod president (case 2009 in)) in U-
DEPLAMBDA and (prep president (pobj in 2009))
in DEPLAMBDA. To achieve the desired semantics,

λx.∃y.president(xa)∧president event(xe)∧
arg1(xe,xa)∧2009(ya)∧prep.in(xe,ya) ,

DEPLAMBDA relies on an intermediate logical
form that requires some post-processing, whereas
UDEPLAMBDA obtains the desired logical form
directly through the following entries:

in ∈ FUNCTIONAL; 2009 ∈ ENTITY; case ∈ HEAD;
president = λx.president(xa)∧president event(xe)

∧arg1(xe,xa) ;
nmod = λ f gx.∃y. f (x)∧g(y)∧nmod.in(xe,ya) .

Other nmod constructions, such as possessives
(nmod:poss), temporal modifiers (nmod:tmod)
and adverbial modifiers (nmod:npmod), are han-
dled similarly. Note how the common noun presi-
dent, evokes both entity and event predicates above.

Passives DEPLAMBDA gives special treatment
to passive verbs, identified by the fine-grained part-
of-speech tags in the PTB tag together with de-
pendency context. For example, An Oscar was
won is analyzed as λx.won.pass(xe)∧Oscar(ya)∧
arg1(xe,ya), where won.pass represents a passive
event. However, UD does not distinguish be-
tween active and passive forms.4 While the labels

4UD encodes voice as a morphological feature, but most
syntactic analyzers do not produce this information yet.

nsubjpass or auxpass indicate passive construc-
tions, such clues are sometimes missing, such as in
reduced relatives. We therefore opt to not have sep-
arate entries for passives, but aim to produce identi-
cal logical forms for active and passive forms when
possible (for example, by treating nsubjpass as
direct object). With the following entries,
won ∈ EVENT; an, was ∈ FUNCTIONAL; auxpass ∈ HEAD;
nsubjpass = λ f gx.∃y. f (x)∧g(y)∧ arg2(xe,ya) ,
the lambda expression for An Oscar was won be-
comes λx.won(xe)∧Oscar(ya)∧arg2(xe,ya), iden-
tical to that of its active form. However, not having
a special entry for passive verbs may have unde-
sirable side-effects. For example, in the reduced-
relative construction Pixar claimed the Oscar won
for Frozen, the phrase the Oscar won ... will
receive the semantics λx.Oscar(ya)∧won(xe)∧
arg1(xe,ya), which differs from that of an Oscar
was won. We leave it to the target application to
disambiguate the interpretation in such cases.

Long-Distance Dependencies As discussed in
Section 3.2, we handle long-distance dependen-
cies evoked by clausal modifiers (acl) and con-
trol verbs (xcomp) with the BIND mechanism,
whereas DEPLAMBDA cannot handle control con-
structions. For xcomp, as seen earlier, we use the
mapping λ f gx.∃y. f (x)∧g(y)∧xcomp(xe,ye). For
acl we use λ f gx.∃y. f (x)∧ g(y), to conjoin the
main clause and the modifier clause. However, not
all acl clauses evoke long-distance dependencies,
e.g. in the news that Disney won an Oscar, the
clause that Disney won an Oscar is a subordinating
conjunction of news. In such cases, we instead
assign acl the INVERT semantics.

Questions Question words are marked with the
enhanced part-of-speech tags DET:WH, ADV:WH
and PRON:WH, which are all assigned the seman-
tics λx.${word}(xa)∧ TARGET(xa). The predicate
TARGET indicates that xa represents the variable of
interest, that is the answer to the question.

3.4 Limitations

In order to achieve language independence, UDEP-
LAMBDA has to sacrifice semantic specificity, since
in many cases the semantics is carried by lexical
information. Consider the sentences John broke
the window and The window broke. Although it is
the window that broke in both cases, our inferred
logical forms do not canonicalize the relation be-
tween broke and window. To achieve this, we

93



language target people

x e1 y e2 Ghana
speak
.arg2

speak
.arg1

people
.arg1

people
.nmod.in

typ
e

typ
e

(a) English

sprache target

x e1 Ghana
gesprochen

.arg2
gesprochen
.nmod.in

typ
e

(b) German

lengua target

x e1 Ghana
lengua
.arg1

lengua
.nmod.de

typ
e

(c) Spanish

language
.human language

target

x m Ghana
location.country

.official language.2
location.country

.official language.1

typ
e

(d) Freebase

Figure 3: The ungrounded graphs for What language do the people in Ghana speak?, Welche Sprache
wird in Ghana gesprochen? and Cuál es la lengua de Ghana?, and the corresponding grounded graph.

would have to make the substitution of nsubj de-
pend on lexical context, such that when window
occurs as nsubj with broke, the predicate arg2 is
invoked rather than arg1. UDEPLAMBDA does
not address this problem, and leave it to the tar-
get application to infer context-sensitive semantics
of arg1 and arg2. To measure the impact of this
limitation, we present UDEPLAMBDASRL in Sec-
tion 4.4 which addresses this problem by relying on
semantic roles from semantic role labeling (Palmer
et al., 2010).

Other constructions that require lexical informa-
tion are quantifiers like every, some and most, nega-
tion markers like no and not, and intentional verbs
like believe and said. UD does not have special
labels to indicate these. We discuss how to handle
quantifiers in this framework in the supplementary
material.

Although in the current setup UDEPLAMBDA
rules are hand-coded, the number of rules are only
proportional to the number of UD labels, mak-
ing rule-writing manageable.5 Moreover, we view
UDEPLAMBDA as a first step towards learning
rules for converting UD to richer semantic repre-
sentations such as PropBank, AMR, or the Paral-
lel Meaning Bank (Palmer et al., 2005; Banarescu
et al., 2013; Abzianidze et al., 2017)..

4 Cross-lingual Semantic Parsing

To study the multilingual nature of UDEPLAMBDA,
we conduct an empirical evaluation on question
answering against Freebase in three different lan-
guages: English, Spanish, and German. Before
discussing the details of this experiment, we briefly
outline the semantic parsing framework employed.

5UD v1.3 has 40 dependency labels, and the number of
substitution rules in UDEPLAMBDA are 61, with some labels
having multiple rules, and some representing lexical seman-
tics.

4.1 Semantic Parsing as Graph Matching

UDEPLAMBDA generates ungrounded logical
forms that are independent of any knowledge base,
such as Freebase. We use GRAPHPARSER (Reddy
et al., 2016) to map these logical forms to their
grounded Freebase graphs, via corresponding un-
grounded graphs. Figures 3(a) to 3(c) show the
ungrounded graphs corresponding to logical forms
from UDEPLAMBDA, each grounded to the same
Freebase graph in Figure 3(d). Here, rectangles de-
note entities, circles denote events, rounded rectan-
gles denote entity types, and edges between events
and entities denote predicates or Freebase relations.
Finally, the TARGET node represents the set of val-
ues of x that are consistent with the Freebase graph,
that is the answer to the question.

GRAPHPARSER treats semantic parsing as a
graph-matching problem with the goal of finding
the Freebase graphs that are structurally isomorphic
to an ungrounded graph and rank them according
to a model. To account for structural mismatches,
GRAPHPARSER uses two graph transformations:
CONTRACT and EXPAND. In Figure 3(a) there are
two edges between x and Ghana. CONTRACT col-
lapses one of these edges to create a graph isomor-
phic to Freebase. EXPAND, in contrast, adds edges
to connect the graph in the case of disconnected
components. The search space is explored by beam
search and model parameters are estimated with
the averaged structured perceptron (Collins, 2002)
from training data consisting of question-answer
pairs, using answer F1-score as the objective.

4.2 Datasets

We evaluate our approach on two public bench-
marks of question answering against Freebase:
WebQuestions (Berant et al., 2013), a widely used
benchmark consisting of English questions and
their answers, and GraphQuestions (Su et al., 2016),
a recently released dataset of English questions
with both their answers and grounded logical forms.

94



While WebQuestions is dominated by simple entity-
attribute questions, GraphQuestions contains a
large number of compositional questions involving
aggregation (e.g. How many children of Eddard
Stark were born in Winterfell? ) and comparison
(e.g. In which month does the average rainfall of
New York City exceed 86 mm? ). The number of
training, development and test questions is 2644,
1134, and 2032, respectively, for WebQuestions
and 1794, 764, and 2608 for GraphQuestions.

To support multilingual evaluation, we created
translations of WebQuestions and GraphQuestions
to German and Spanish. For WebQuestions two
professional annotators were hired per language,
while for GraphQuestions we used a trusted pool of
20 annotators per language (with a single annotator
per question). Examples of the original questions
and their translations are provided in Table 1.

4.3 Implementation Details

Here we provide details on the syntactic analyzers
employed, our entity resolution algorithm, and the
features used by the grounding model.

Dependency Parsing The English, Spanish, and
German Universal Dependencies (UD) treebanks
(v1.3; Nivre et al 2016) were used to train part of
speech taggers and dependency parsers. We used a
bidirectional LSTM tagger (Plank et al., 2016) and
a bidirectional LSTM shift-reduce parser (Kiper-
wasser and Goldberg, 2016). Both the tagger and
parser require word embeddings. For English, we
used GloVe embeddings (Pennington et al., 2014)
trained on Wikipedia and the Gigaword corpus.
For German and Spanish, we used SENNA em-
beddings (Collobert et al., 2011; Al-Rfou et al.,
2013) trained on Wikipedia corpora (589M words
German; 397M words Spanish).6 Measured on the
UD test sets, the tagger accuracies are 94.5 (En-
glish), 92.2 (German), and 95.7 (Spanish), with
corresponding labeled attachment parser scores of
81.8, 74.7, and 82.2.

Entity Resolution We follow Reddy et al. (2016)
and resolve entities in three steps: (1) potential en-
tity spans are identified using seven handcrafted
part-of-speech patterns; (2) each span is associated
with potential Freebase entities according to the
Freebase/KG API; and (3) the 10-best entity link-
ing lattices, scored by a structured perceptron, are

6https://sites.google.com/site/rmyeid/projects/polyglot.

WebQuestions

en What language do the people in Ghana speak?
de Welche Sprache wird in Ghana gesprochen?
es ¿Cuál es la lengua de Ghana?

en Who was Vincent van Gogh inspired by?
de Von wem wurde Vincent van Gogh inspiriert?
es ¿Qué inspiró a Van Gogh?

GraphQuestions

en NASA has how many launch sites?
de Wie viele Abschussbasen besitzt NASA?
es ¿Cuántos sitios de despegue tiene NASA?

en Which loudspeakers are heavier than 82.0 kg?
de Welche Lautsprecher sind schwerer als 82.0 kg?
es ¿Qué altavoces pesan más de 82.0 kg?

Table 1: Example questions and their translations.

k WebQuestions GraphQuestions
en de es en de es

1 89.6 82.8 86.7 47.2 39.9 39.5
10 95.7 91.2 94.0 56.9 48.4 51.6

Table 2: Structured perceptron k-best entity linking
accuracies on the development sets.

input to GRAPHPARSER, leaving the final disam-
biguation to the semantic parsing problem. Table 2
shows the 1-best and 10-best entity disambiguation
F1-scores for each language and dataset.

Features We use features similar to Reddy et al.
(2016): basic features of words and Freebase re-
lations, and graph features crossing ungrounded
events with grounded relations, ungrounded types
with grounded relations, and ungrounded answer
type crossed with a binary feature indicating if the
answer is a number. In addition, we add features
encoding the semantic similarity of ungrounded
events and Freebase relations. Specifically, we used
the cosine similarity of the translation-invariant em-
beddings of Huang et al. (2015).7

4.4 Comparison Systems

We compared UDEPLAMBDA to four versions of
GRAPHPARSER that operate on different represen-
tations, in addition to prior work.

SINGLEEVENT This model resembles the
learning-to-rank model of Bast and Haussmann
(2015). An ungrounded graph is generated by con-
necting all entities in the question with the TARGET
node, representing a single event. Note that this

7http://128.2.220.95/multilingual/data/.

95



WebQuestions GraphQuestions
Method en de es en de es

SINGLEEVENT 48.5 45.6 46.3 15.9 8.8 11.4
DEPTREE 48.8 45.9 46.4 16.0 8.3 11.3
CCGGRAPH 49.5 – – 15.9 – –
UDEPLAMBDA 49.5 46.1 47.5 17.7 9.5 12.8
UDEPLAMBDASRL 49.8 46.2 47.0 17.7 9.1 12.7

Table 3: F1-scores on the test data.

baseline cannot handle compositional questions, or
those with aggregation or comparison.

DEPTREE An ungrounded graph is obtained di-
rectly from the original dependency tree. An event
is created for each parent and its dependents in the
tree. Each dependent is linked to this event with an
edge labeled with its dependency relation, while the
parent is linked to the event with an edge labeled
arg0. If a word is a question word, an additional
TARGET predicate is attached to its entity node.

CCGGRAPH This is the CCG-based semantic
representation of Reddy et al. (2014). Note that
this baseline exists only for English.

UDEPLAMBDASRL This is similar to UDEP-
LAMBDA except that instead of assuming nsubj,
dobj and nsubjpass correspond to arg1, arg2 and
arg2, we employ semantic role labeling to identify
the correct interpretation. We used the systems of
Roth and Woodsend (2014) for English and Ger-
man and Bjrkelund et al. (2009) for Spanish trained
on the CoNLL-2009 dataset (Haji et al., 2009).8

4.5 Results

Table 3 shows the performance of GRAPHPARSER
with these different representations. Here and in
what follows, we use average F1-score of predicted
answers (Berant et al., 2013) as the evaluation met-
ric. We first observe that UDEPLAMBDA consis-
tently outperforms the SINGLEEVENT and DEP-
TREE representations in all languages.

For English, performance is on par with CCG-
GRAPH, which suggests that UDEPLAMBDA does
not sacrifice too much specificity for universal-
ity. With both datasets, results are lower for Ger-
man compared to Spanish. This agrees with the
lower performance of the syntactic parser on the
German portion of the UD treebank. While U-
DEPLAMBDASRL performs better than UDEP-

8The parser accuracies (%) are 87.33, 81.38 and 79.91for
English, German and Spanish respectively.

Method GraphQ. WebQ.

SEMPRE (Berant et al., 2013) 10.8 35.7
JACANA (Yao and Van Durme, 2014) 5.1 33.0
PARASEMPRE (Berant and Liang, 2014) 12.8 39.9
QA (Yao, 2015) – 44.3
AQQU (Bast and Haussmann, 2015) – 49.4
AGENDAIL (Berant and Liang, 2015) – 49.7
DEPLAMBDA (Reddy et al., 2016) – 50.3

STAGG (Yih et al., 2015) – 48.4 (52.5)
BILSTM (Türe and Jojic, 2016) – 24.9 (52.2)
MCNN (Xu et al., 2016) – 47.0 (53.3)
AGENDAIL-RANK (Yavuz et al., 2016) – 51.6 (52.6)

UDEPLAMBDA 17.7 49.5

Table 4: F1-scores on the English GraphQuestions
and WebQuestions test sets (results with additional
task-specific resources in parentheses).

LAMBDA on WebQuestions for English, we do not
see large performance gaps in other settings, sug-
gesting that GRAPHPARSER is either able to learn
context-sensitive semantics of ungrounded predi-
cates or that the datasets do not contain ambiguous
nsubj, dobj and nsubjpass mappings. Finally,
while these results confirm that GraphQuestions is
much harder compared to WebQuestions, we note
that both datasets predominantly contain single-hop
questions, as indicated by the competitive perfor-
mance of SINGLEEVENT on both datasets.

Table 4 compares UDEPLAMBDA with previ-
ously published models which exist only for En-
glish and have been mainly evaluated on Web-
Questions. These are either symbolic like ours (first
block) or employ neural networks (second block).
Results for models using additional task-specific
training resources, such as ClueWeb09, Wikipedia,
or SimpleQuestions (Bordes et al., 2015) are shown
in parentheses. On GraphQuestions, we achieve
a new state-of-the-art result with a gain of 4.8 F1-
points over the previously reported best result. On
WebQuestions we are 2.1 points below the best
model using comparable resources, and 3.8 points
below the state of the art. Most related to our
work is the English-specific system of Reddy et al.
(2016). We attribute the 0.8 point difference in F1-
score to their use of the more fine-grained PTB tag
set and Stanford Dependencies.

5 Related Work

Our work continues the long tradition of building
logical forms from syntactic representations initi-
ated by Montague (1973). The literature is rife with

96



attempts to develop semantic interfaces for HPSG
(Copestake et al., 2005), LFG (Kaplan and Bresnan,
1982; Dalrymple et al., 1995; Crouch and King,
2006), TAG (Kallmeyer and Joshi, 2003; Gardent
and Kallmeyer, 2003; Nesson and Shieber, 2006),
and CCG (Baldridge and Kruijff, 2002; Bos et al.,
2004; Artzi et al., 2015). Unlike existing semantic
interfaces, UDEPLAMBDA uses dependency syn-
tax, a widely available syntactic resource.

A common trend in previous work on seman-
tic interfaces is the reliance on rich typed feature
structures or semantic types coupled with strong
type constraints, which can be very informative
but unavoidably language specific. Instead, UDEP-
LAMBDA relies on generic unlexicalized informa-
tion present in dependency treebanks and uses a
simple type system (one type for dependency labels,
and one for words) along with a combinatory mech-
anism, which avoids type collisions. Earlier at-
tempts at extracting semantic representations from
dependencies have mainly focused on language-
specific dependency representations (Spreyer and
Frank, 2005; Simov and Osenova, 2011; Hahn and
Meurers, 2011; Reddy et al., 2016; Falke et al.,
2016; Beltagy, 2016), and multi-layered depen-
dency annotations (Jakob et al., 2010; Bédaride
and Gardent, 2011). In contrast, UDEPLAMBDA
derives semantic representations for multiple lan-
guages in a common schema directly from Univer-
sal Dependencies. This work parallels a growing
interest in creating other forms of multilingual se-
mantic representations (Akbik et al., 2015; Vander-
wende et al., 2015; White et al., 2016; Evang and
Bos, 2016).

We evaluate UDEPLAMBDA on semantic pars-
ing for question answering against a knowledge
base. Here, the literature offers two main modeling
paradigms: (1) learning of task-specific grammars
that directly parse language to a grounded repre-
sentation (Zelle and Mooney, 1996; Zettlemoyer
and Collins, 2005; Berant et al., 2013; Flanigan
et al., 2014; Pasupat and Liang, 2015; Groschwitz
et al., 2015); and (2) converting language to a lin-
guistically motivated task-independent representa-
tion that is then mapped to a grounded representa-
tion (Kwiatkowski et al., 2013; Reddy et al., 2014;
Krishnamurthy and Mitchell, 2015; Gardner and
Krishnamurthy, 2017). Our work belongs to the
latter paradigm, as we map natural language to
Freebase indirectly via logical forms. Capitalizing
on natural-language syntax affords interpretability,

scalability, and reduced duplication of effort across
applications (Bender et al., 2015). Our work also re-
lates to literature on parsing multiple languages to a
common executable representation (Cimiano et al.,
2013; Haas and Riezler, 2016). However, existing
approaches still map to the target meaning represen-
tations (more or less) directly (Kwiatkowksi et al.,
2010; Jones et al., 2012; Jie and Lu, 2014).

6 Conclusions

We introduced UDEPLAMBDA, a semantic inter-
face for Universal Dependencies, and showed that
the resulting semantic representation can be used
for question-answering against a knowledge base
in multiple languages. We provided translations of
benchmark datasets in German and Spanish, in the
hope to stimulate further multilingual research on
semantic parsing and question answering in gen-
eral. We have only scratched the surface when it
comes to applying UDEPLAMBDA to natural lan-
guage understanding tasks. In the future, we would
like to explore how this framework can benefit ap-
plications such as summarization (Liu et al., 2015)
and machine reading (Sachan and Xing, 2016).

Acknowledgements

This work greatly benefited from discussions with
Michael Collins, Dipanjan Das, Federico Fancellu,
Julia Hockenmaier, Tom Kwiatkowski, Adam
Lopez, Valeria de Paiva, Martha Palmer, Fernando
Pereira, Emily Pitler, Vijay Saraswat, Nathan
Schneider, Bonnie Webber, Luke Zettlemoyer, and
the members of ILCC Edinburgh University, the
Microsoft Research Redmond NLP group, the Stan-
ford NLP group, and the UW NLP and Linguistics
group. We thank Reviewer 2 for useful feedback.
The authors would also like to thank the Univer-
sal Dependencies community for the treebanks and
documentation. This research is supported by a
Google PhD Fellowship to the first author. We ac-
knowledge the financial support of the European
Research Council (Lapata; award number 681760).

References
Lasha Abzianidze, Johannes Bjerva, Kilian Evang,

Hessel Haagsma, Rik van Noord, Pierre Ludmann,
Duc-Duy Nguyen, and Johan Bos. 2017. The Par-
allel Meaning Bank: Towards a Multilingual Cor-
pus of Translations Annotated with Compositional
Meaning Representations. In Proceedings of the

97



European Chapter of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics, Valencia, Spain, pages 242–247.

Alan Akbik, laura chiticariu, Marina Danilevsky, Yun-
yao Li, Shivakumar Vaithyanathan, and Huaiyu Zhu.
2015. Generating High Quality Proposition Banks
for Multilingual Semantic Role Labeling. In Pro-
ceedings of the Association for Computational Lin-
guistics and the International Joint Conference on
Natural Language Processing. Association for Com-
putational Linguistics, Beijing, China, pages 397–
407.

Rami Al-Rfou, Bryan Perozzi, and Steven Skiena.
2013. Polyglot: Distributed Word Representations
for Multilingual NLP. In Proceedings of the Com-
putational Natural Language Learning. Sofia, Bul-
garia, pages 183–192.

Yoav Artzi. 2013. Cornell SPF: Cornell Semantic Pars-
ing Framework. arXiv:1311.3011 [cs.CL] .

Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.
Broad-coverage CCG Semantic Parsing with AMR.
In Proceedings of the Empirical Methods on Natural
Language Processing. pages 1699–1710.

Jason Baldridge and Geert-Jan Kruijff. 2002. Coupling
CCG and Hybrid Logic Dependency Semantics. In
Proceedings of the Association for Computational
Linguistics. pages 319–326.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract Meaning Representation
for Sembanking. In Linguistic Annotation Workshop
and Interoperability with Discourse. Sofia, Bulgaria,
pages 178–186.

Hannah Bast and Elmar Haussmann. 2015. More Ac-
curate Question Answering on Freebase. In Pro-
ceedings of ACM International Conference on Infor-
mation and Knowledge Management. pages 1431–
1440.

Paul Bédaride and Claire Gardent. 2011. Deep Seman-
tics for Dependency Structures. In Proceedings of
Conference on Intelligent Text Processing and Com-
putational Linguistics. pages 277–288.

Islam Beltagy. 2016. Natural Language Semantics Us-
ing Probabilistic Logic. Ph.D. thesis, Department
of Computer Science, The University of Texas at
Austin.

Emily M. Bender, Dan Flickinger, Stephan Oepen,
Woodley Packard, and Ann Copestake. 2015. Lay-
ers of Interpretation: On Grammar and Composition-
ality. In Proceedings of the International Confer-
ence on Computational Semantics. Association for
Computational Linguistics, London, UK, pages 239–
249.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic Parsing on Freebase from
Question-Answer Pairs. In Proceedings of the Em-
pirical Methods on Natural Language Processing.
pages 1533–1544.

Jonathan Berant and Percy Liang. 2014. Semantic Pars-
ing via Paraphrasing. In Proceedings of the Asso-
ciation for Computational Linguistics. pages 1415–
1425.

Jonathan Berant and Percy Liang. 2015. Imitation
Learning of Agenda-Based Semantic Parsers. Trans-
actions of the Association for Computational Lin-
guistics 3:545–558.

Anders Bjrkelund, Love Hafdell, and Pierre Nugues.
2009. Multilingual Semantic Role Labeling. In
Proceedings of Computational Natural Language
Learning (CoNLL 2009): Shared Task. Association
for Computational Linguistics, Boulder, Colorado,
pages 43–48.

Antoine Bordes, Nicolas Usunier, Sumit Chopra, and
Jason Weston. 2015. Large-scale simple ques-
tion answering with memory networks. CoRR
abs/1506.02075.

Johan Bos, Stephen Clark, Mark Steedman, James R.
Curran, and Julia Hockenmaier. 2004. Wide-
Coverage Semantic Representations from a CCG
Parser. In Proceedings of the Conference on Com-
putational Linguistics. pages 1240–1246.

Philipp Cimiano, Vanessa Lopez, Christina Unger,
Elena Cabrio, Axel-Cyrille Ngonga Ngomo, and
Sebastian Walter. 2013. Multilingual question an-
swering over linked data (QALD-3): Lab overview.
In Information Access Evaluation. Multilinguality,
Multimodality, and Visualization. Springer, Valencia,
Spain, volume 8138.

Michael Collins. 2002. Discriminative Training Meth-
ods for Hidden Markov Models: Theory and Exper-
iments with Perceptron Algorithms. In Proceedings
of the Empirical Methods on Natural Language Pro-
cessing. pages 1–8.

Ronan Collobert, Jason Weston, Leon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuks. 2011.
Natural language processing (almost) from scratch.
Journal of Machine Learning Research 12:2493–
2537.

Ann Copestake, Dan Flickinger, Carl Pollard, and
Ivan A. Sag. 2005. Minimal Recursion Semantics:
An Introduction. Research on Language and Com-
putation 3(2-3):281–332.

Dick Crouch and Tracy Holloway King. 2006. Seman-
tics via f-structure rewriting. In Proceedings of the
LFG’06 Conference. CSLI Publications, page 145.

Mary Dalrymple, John Lamping, Fernando C. N.
Pereira, and Vijay A. Saraswat. 1995. Linear Logic
for Meaning Assembly. In Proceedings of Computa-
tional Logic for Natural Language Processing.

98



Kilian Evang and Johan Bos. 2016. Cross-lingual
Learning of an Open-domain Semantic Parser. In
Proceedings of the Conference on Computational
Linguistics. The COLING 2016 Organizing Com-
mittee, Osaka, Japan, pages 579–588.

Tobias Falke, Gabriel Stanovsky, Iryna Gurevych, and
Ido Dagan. 2016. Porting an Open Information Ex-
traction System from English to German. In Pro-
ceedings of the Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, Austin, Texas, pages 892–898.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A Discrimi-
native Graph-Based Parser for the Abstract Meaning
Representation. In Proceedings of the Association
for Computational Linguistics. pages 1426–1436.

Claire Gardent and Laura Kallmeyer. 2003. Semantic
Construction in Feature-based TAG. In Proceedings
of European Chapter of the Association for Compu-
tational Linguistics. pages 123–130.

Matt Gardner and Jayant Krishnamurthy. 2017. Open-
Vocabulary Semantic Parsing with both Distribu-
tional Statistics and Formal Knowledge. In Proceed-
ings of Association for the Advancement of Artificial
Intelligence.

Jonas Groschwitz, Alexander Koller, and Christoph Te-
ichmann. 2015. Graph parsing with s-graph gram-
mars. In Proceedings of the Association for Compu-
tational Linguistics. pages 1481–1490.

Carolin Haas and Stefan Riezler. 2016. A Corpus and
Semantic Parser for Multilingual Natural Language
Querying of OpenStreetMap. In Proceedings of
the North American Chapter of the Association for
Computational Linguistics: Human Language Tech-
nologies. Association for Computational Linguistics,
San Diego, California, pages 740–750.

Michael Hahn and Detmar Meurers. 2011. On deriv-
ing semantic representations from dependencies: A
practical approach for evaluating meaning in learner
corpora. In Proceedings of the Int. Conference on
Dependency Linguistics (Depling 2011). Barcelona,
pages 94–103.

Jan Haji, Massimiliano Ciaramita, Richard Johans-
son, Daisuke Kawahara, Maria Antnia Mart, Llus
Mrquez, Adam Meyers, Joakim Nivre, Sebastian
Pad, Jan tpnek, and others. 2009. The CoNLL-2009
shared task: Syntactic and semantic dependencies in
multiple languages. In Proceedings of the Compu-
tational Natural Language Learning: Shared Task.
Association for Computational Linguistics, pages 1–
18.

Kejun Huang, Matt Gardner, Evangelos Papalex-
akis, Christos Faloutsos, Nikos Sidiropoulos, Tom
Mitchell, Partha P. Talukdar, and Xiao Fu. 2015.

Translation Invariant Word Embeddings. In Pro-
ceedings of the Empirical Methods in Natural Lan-
guage Processing. Lisbon, Portugal, pages 1084–
1088.

Max Jakob, Markéta Lopatková, and Valia Kordoni.
2010. Mapping between Dependency Structures and
Compositional Semantic Representations. In Pro-
ceedings of the Fifth International Conference on
Language Resources and Evaluation.

Zhanming Jie and Wei Lu. 2014. Multilingual Seman-
tic Parsing : Parsing Multiple Languages into Se-
mantic Representations. In Proceedings of the Con-
ference on Computational Linguistics. Dublin City
University and Association for Computational Lin-
guistics, Dublin, Ireland, pages 1291–1301.

Bevan Keeley Jones, Mark Johnson, and Sharon Gold-
water. 2012. Semantic Parsing with Bayesian Tree
Transducers. In Proceedings of the Association for
Computational Linguistics. Association for Compu-
tational Linguistics, Stroudsburg, PA, USA, pages
488–496.

Laura Kallmeyer and Aravind Joshi. 2003. Factor-
ing predicate argument and scope semantics: Under-
specified semantics with LTAG. Research on Lan-
guage and Computation 1(1-2):3–58.

Ronald M Kaplan and Joan Bresnan. 1982. Lexical-
functional grammar: A formal system for gram-
matical representation. Formal Issues in Lexical-
Functional Grammar pages 29–130.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and Accurate Dependency Parsing Using Bidi-
rectional LSTM Feature Representations. Transac-
tions of the Association for Computational Linguis-
tics 4:313–327.

Jayant Krishnamurthy and Tom M. Mitchell. 2015.
Learning a Compositional Semantics for Freebase
with an Open Predicate Vocabulary. Transactions
of the Association for Computational Linguistics
3:257–270.

Tom Kwiatkowksi, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing Probabilis-
tic CCG Grammars from Logical Form with Higher-
Order Unification. In Proceedings of the Empiri-
cal Methods on Natural Language Processing. pages
1223–1233.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and Luke
Zettlemoyer. 2013. Scaling Semantic Parsers with
On-the-Fly Ontology Matching. In Proceedings of
the Empirical Methods on Natural Language Pro-
cessing. pages 1545–1556.

Roger Levy and Galen Andrew. 2006. Tregex and tsur-
geon: tools for querying and manipulating tree data
structures. In Proceedings of LREC. pages 2231–
2234.

99



Fei Liu, Jeffrey Flanigan, Sam Thomson, Norman
Sadeh, and Noah A. Smith. 2015. Toward Ab-
stractive Summarization Using Semantic Represen-
tations. In Proceedings of North American Chap-
ter of the Association for Computational Linguistics.
pages 1077–1086.

Mitchell P. Marcus, Mary Ann Marcinkiewicz, and
Beatrice Santorini. 1993. Building a large annotated
corpus of English: The Penn Treebank. Computa-
tional linguistics 19(2):313–330.

Richard Montague. 1973. The Proper Treatment of
Quantification in Ordinary English. In K.J.J. Hin-
tikka, J.M.E. Moravcsik, and P. Suppes, editors,
Approaches to Natural Language, Springer Nether-
lands, volume 49 of Synthese Library, pages 221–
242.

Rebecca Nesson and Stuart M. Shieber. 2006. Simpler
TAG Semantics Through Synchronization. In Pro-
ceedings of the 11th Conference on Formal Gram-
mar. Center for the Study of Language and Informa-
tion, Malaga, Spain, pages 129–142.

Joakim Nivre, Marie-Catherine de Marneffe, Filip Gin-
ter, Yoav Goldberg, Jan Hajic, Christopher D. Man-
ning, Ryan McDonald, Slav Petrov, Sampo Pyysalo,
Natalia Silveira, Reut Tsarfaty, and Daniel Zeman.
2016. Universal Dependencies v1: A Multilingual
Treebank Collection. In Proceedings of the Tenth In-
ternational Conference on Language Resources and
Evaluation. European Language Resources Associa-
tion (ELRA), Paris, France.

Joakim Nivre et al. 2016. Universal dependencies 1.3.
LINDAT/CLARIN digital library at the Institute of
Formal and Applied Linguistics, Charles University
in Prague.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated corpus of
semantic roles. Computational linguistics 31(1):71–
106.

Martha Palmer, Daniel Gildea, and Nianwen Xue. 2010.
Semantic role labeling. Synthesis Lectures on Hu-
man Language Technologies 3(1):1–103.

Panupong Pasupat and Percy Liang. 2015. Composi-
tional Semantic Parsing on Semi-Structured Tables.
In Proceedings of the Association for Computational
Linguistics. pages 1470–1480.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. Glove: Global Vectors for Word
Representation. In Proceedings of the Empirical
Methods in Natural Language Processing. Associ-
ation for Computational Linguistics, Doha, Qatar,
pages 1532–1543.

Barbara Plank, Anders Søgaard, and Yoav Goldberg.
2016. Multilingual Part-of-Speech Tagging with
Bidirectional Long Short-Term Memory Models and
Auxiliary Loss. In Proceedings of the Annual Meet-
ing of the Association for Computational Linguistics.
Berlin, Germany, pages 412–418.

Siva Reddy, Mirella Lapata, and Mark Steedman. 2014.
Large-scale Semantic Parsing without Question-
Answer Pairs. Transactions of the Association for
Computational Linguistics 2:377–392.

Siva Reddy, Oscar Täckström, Michael Collins, Tom
Kwiatkowski, Dipanjan Das, Mark Steedman, and
Mirella Lapata. 2016. Transforming Dependency
Structures to Logical Forms for Semantic Parsing.
Transactions of the Association for Computational
Linguistics 4:127–140.

Michael Roth and Kristian Woodsend. 2014. Compo-
sition of Word Representations Improves Semantic
Role Labelling. In Proceedings of the Empirical
Methods in Natural Language Processing (EMNLP).
Association for Computational Linguistics, Doha,
Qatar, pages 407–413.

Mrinmaya Sachan and Eric Xing. 2016. Machine Com-
prehension using Rich Semantic Representations. In
Proceedings of the Association for Computational
Linguistics. Association for Computational Linguis-
tics, Berlin, Germany, pages 486–492.

Sebastian Schuster and Christopher D. Manning. 2016.
Enhanced English Universal Dependencies: An Im-
proved Representation for Natural Language Under-
standing Tasks. In Proceedings of the Tenth Interna-
tional Conference on Language Resources and Eval-
uation. European Language Resources Association
(ELRA), Paris, France.

Kiril Simov and Petya Osenova. 2011. Towards Min-
imal Recursion Semantics over Bulgarian Depen-
dency Parsing. In Proceedings of the International
Conference Recent Advances in Natural Language
Processing 2011. RANLP 2011 Organising Commit-
tee, Hissar, Bulgaria, pages 471–478.

Kathrin Spreyer and Anette Frank. 2005. Projecting
RMRS from TIGER Dependencies. In Proceedings
of the HPSG 2005 Conference. CSLI Publications.

Yu Su, Huan Sun, Brian Sadler, Mudhakar Srivatsa,
Izzeddin Gur, Zenghui Yan, and Xifeng Yan. 2016.
On Generating Characteristic-rich Question Sets for
QA Evaluation. In Proceedings of the Empirical
Methods in Natural Language Processing. Austin,
Texas, pages 562–572.

Ferhan Türe and Oliver Jojic. 2016. Simple and Ef-
fective Question Answering with Recurrent Neural
Networks. CoRR abs/1606.05029.

Lucy Vanderwende, Arul Menezes, and Chris Quirk.
2015. An AMR parser for English, French, German,
Spanish and Japanese and a new AMR-annotated
corpus. In Proceedings of the North American Chap-
ter of the Association for Computational Linguistics:
Demonstrations. Association for Computational Lin-
guistics, Denver, Colorado, pages 26–30.

100



Aaron Steven White, Drew Reisinger, Keisuke Sak-
aguchi, Tim Vieira, Sheng Zhang, Rachel Rudinger,
Kyle Rawlins, and Benjamin Van Durme. 2016. Uni-
versal Decompositional Semantics on Universal De-
pendencies. In Proceedings of the Empirical Meth-
ods in Natural Language Processing. Association
for Computational Linguistics, Austin, Texas, pages
1713–1723.

Kun Xu, Siva Reddy, Yansong Feng, Songfang Huang,
and Dongyan Zhao. 2016. Question Answering on
Freebase via Relation Extraction and Textual Evi-
dence. In Proceedings of the Association for Compu-
tational Linguistics. Association for Computational
Linguistics, Berlin, Germany, pages 2326–2336.

Xuchen Yao. 2015. Lean Question Answering over
Freebase from Scratch. In Proceedings of North
American Chapter of the Association for Computa-
tional Linguistics. pages 66–70.

Xuchen Yao and Benjamin Van Durme. 2014. Infor-
mation Extraction over Structured Data: Question
Answering with Freebase. In Proceedings of the As-
sociation for Computational Linguistics. pages 956–
966.

Semih Yavuz, Izzeddin Gur, Yu Su, Mudhakar Srivatsa,
and Xifeng Yan. 2016. Improving Semantic Parsing
via Answer Type Inference. In Proceedings of the
Empirical Methods in Natural Language Processing.
Association for Computational Linguistics, Austin,
Texas, pages 149–159.

Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and
Jianfeng Gao. 2015. Semantic Parsing via Staged
Query Graph Generation: Question Answering with
Knowledge Base. In Proceedings of the Association
for Computational Linguistics. pages 1321–1331.

John M. Zelle and Raymond J. Mooney. 1996. Learn-
ing to Parse Database Queries Using Inductive Logic
Programming. In Proceedings of Association for the
Advancement of Artificial Intelligence. pages 1050–
1055.

Luke S. Zettlemoyer and Michael Collins. 2005. Learn-
ing to Map Sentences to Logical Form: Structured
Classification with Probabilistic Categorial Gram-
mars. In Proceedings of Uncertainty in Artificial In-
telligence. pages 658–666.

101


