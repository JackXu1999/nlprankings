



















































Hierarchical Pointer Net Parsing


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 1007–1017,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

1007

Hierarchical Pointer Net Parsing

Linlin Liu12∗†, Xiang Lin1†, Shafiq Joty13, Simeng Han1, Lidong Bing2
1Nanyang Technological University, Singapore

2R&D Center Singapore, Machine Intelligence Technology, Alibaba DAMO Academy
3Salesforce Research Asia, Singapore
{linx0057, srjoty, hans0035}@ntu.edu.sg
{linlin.liu, l.bing}@alibaba-inc.com

Abstract

Transition-based top-down parsing with
pointer networks has achieved state-of-the-art
results in multiple parsing tasks, while having
a linear time complexity. However, the
decoder of these parsers has a sequential
structure, which does not yield the most
appropriate inductive bias for deriving tree
structures. In this paper, we propose hierarchi-
cal pointer network parsers, and apply them
to dependency and sentence-level discourse
parsing tasks. Our results on standard bench-
mark datasets demonstrate the effectiveness of
our approach, outperforming existing methods
and setting a new state-of-the-art.

1 Introduction

Parsing of sentences is a core natural language un-
derstanding task, where the goal is to construct
a tree structure that best describes the relation-
ships between the tree constituents (e.g., words,
phrases). For example, Figure 1 shows examples
of a dependency tree and a sentence-level dis-
course tree that respectively represent how the
words and clauses are related in a sentence. Such
parse trees are directly useful in numerous NLP
applications, and also serve as intermediate rep-
resentations for further language processing tasks
such as semantic and discourse processing.

Existing approaches to parsing can be distin-
guished based on whether they employ a greedy
transition-based algorithm (Marcu, 1999; Zhang
and Nivre, 2011; Wang et al., 2017) or a glob-
ally optimized algorithm such as graph-based
methods for dependency parsing (Eisner, 1996) or
chart parsing for discourse (Soricut and Marcu,
2003; Joty et al., 2015). Transition-based parsers
build the tree incrementally by making a series
∗ Linlin Liu is under the Joint PhD Program between Alibaba

and Nanyang Technological University.
† Equal contribution.

Figure 1: (a) A dependency tree for a sentence; (b)
a discourse tree for the sentence “[Now that’s name-
dropping,]e1 [if you know]e2 [what I mean.]e3”, where
‘S’ denotes Satellite and ‘N’ denotes Nucleus.

of shift-reduce decisions. The advantage of this
method is that the parsing time is linear with re-
spect to the sequence length. The limitation, how-
ever, is that the decisions made at each step are
based on local information, disallowing the model
to capture long distance dependencies and also
causing error propagation to subsequent steps. Re-
cent methods attempt to address this issue us-
ing neural networks capable of remembering long
range relationships such as Stacked LSTMs (Dyer
et al., 2015; Ballesteros et al., 2015) or using glob-
ally normalized models (Andor et al., 2016).

The globally optimized methods, on the other
hand, learn scoring functions for subtrees and per-
form search over all possible trees to find the most
probable tree for a text. Recent graph-based meth-
ods use neural models as scoring functions (Kiper-
wasser and Goldberg, 2016; Dozat and Manning,
2017). Despite being more accurate than greedy
parsers, these methods are generally slow having
a polynomial time complexity (O(n3) or higher).

Recently, transition-based top-down parsing
with Pointer Networks (Vinyals et al., 2015) has
attained state-of-the-art results in both dependency
and discourse parsing tasks with the same com-
putational efficiency (Ma et al., 2018; Lin et al.,
2019); thanks to the encoder-decoder architecture
that makes it possible to capture information from
the whole text and the previously derived subtrees,



1008

while limiting the number of parsing steps to lin-
ear. However, the decoder of these parsers has
a sequential structure, which may not yield the
most appropriate inductive bias for deriving a hi-
erarchical structure. For example, when decod-
ing “pens” in Figure 1 in a top-down depth-first
manner, the decoder state is directly conditioned
on “and” as opposed to the states representing its
parent “sell”. This on one hand may induce irrel-
evant information in the current state, on the other,
as the text length gets longer, the decoder state at
later steps tends to forget more relevant informa-
tion due to long distance. Having an explicit hier-
archical inductive bias should allow the model to
receive more relevant information and help with
the long-term dependency problem by providing
shortcuts for gradient back-propagation.

In this paper, we propose a Hierarchical
Pointer Network (H-PtrNet) parser to address
the above mentioned limitations. In addition to the
sequential dependencies, our parser also directly
models the parent-child and sibling relationships
in the decoding process. We apply our proposed
method to both dependency and discourse parsing
tasks. To verify the effectiveness of our approach,
we conduct extensive experiments and analysis on
both tasks. Our results demonstrate that in depen-
dency parsing, our model outperforms in most of
the languages. In discourse parsing, we push for-
ward the state-of-the-art in all evaluation metrics.
Furthermore, our results on the hardest task of
relation labeling have touched human agreement
scores on this task. We have released our code
at https://ntunlpsg.github.io/project/parser/ptrnet-
depparser/ for research purposes.

2 Background

2.1 Dependency Parsing

Dependency parsing is the task of predicting the
existence and type of linguistic dependency re-
lations between words in a sentence (Figure 1a).
Given an input sentence, the output is a tree
that shows relationships (e.g., NOMINAL SUB-
JECT (NSUBJ), DETERMINER (DET)) between
head words and words that modify those heads,
called dependents or modifiers.

Approaches to dependency parsing can be di-
vided into two main categories: greedy transition-
based parsing and graph-based parsing. In both
paradigms, neural models have proven to be more
effective than feature-based models where select-

ing the composition of features is a major chal-
lenge. Kiperwasser and Goldberg (2016) pro-
posed graph-based and transition-based depen-
dency parsers with a Bi-LSTM feature represen-
tation. Since then much work has been done to
improve these two parsers. Dozat and Manning
(2017) proposed a bi-affine classifier for the pre-
diction of arcs and labels based on graph-based
model, and achieved state-of-the-art performance.
Nguyen and Verspoor (2018) adopted a joint mod-
eling approach by adding a Bi-LSTM POS tag-
ger to generate POS tags for the graph-based de-
pendency parser. Though transition-based meth-
ods are superior in terms of time complexity, they
fail in capturing the global dependency informa-
tion when making decisions. To address this is-
sue, Andor et al. (2016) proposed a globally op-
timized transition-based model. Recently, by in-
corporating a stack within a pointer network, Ma
et al. (2018) proposed a transition-based model
and achieved state-of-the-art performance across
many languages .

2.2 Discourse Parsing

Rhetorical Structure Theory or RST (Mann and
Thompson, 1988) is one of the most influential
theories of discourse, which posits a tree structure
(called discourse tree) to represent a text (Fig. 1b).
The leaves of a discourse tree represent contigu-
ous text spans called Elementary Discourse Units
(EDUs). The adjacent EDUs and larger units are
recursively connected by coherence relations (e.g.,
CONDITION, ATTRIBUTION). Furthermore, the
discourse units connected by a relation are dis-
tinguished based on their relative importance —
NUCLEUS refers to the core part(s) while SATEL-
LITE refers to the peripheral one. Coherence anal-
ysis in RST consists of two subtasks: (a) identi-
fying the EDUs in a text, referred to as Discourse
Segmentation, and (b) building a discourse tree
by linking the EDUs hierarchically, referred to as
Discourse Parsing. This work focuses on the
more challenging task of discourse parsing assum-
ing that EDUs have already been identified. In
fact, state-of-the-art segmenter (Lin et al., 2019)
has already achieved 95.6 F1 on RST discourse
treebank, where the human agreement is 98.3 F1.

Earlier methods have mostly utilized hand-
crafted lexical and syntactic features (Soricut and
Marcu, 2003; Feng and Hirst, 2014; Joty et al.,
2015; Wang et al., 2017). Recent approaches have

https://ntunlpsg.github.io/project/parser/ptrnet-depparser/
https://ntunlpsg.github.io/project/parser/ptrnet-depparser/


1009

shown competitive results with neural models that
are able to automatically learn the feature repre-
sentations in an end-to-end fashion (Ji and Eisen-
stein, 2014; Li et al., 2014). Very recently, Lin
et al. (2019) propose a parser based on pointer net-
works and achieve state-of-the-art performance.

Remark. Although related, the dependency and
RST tree structures (hence the parsing tasks) are
different. RST structure is similar to constituency
structure. Therefore, the differences between
constituency and dependency structures also hold
here.1 First, while dependency relations can only
be between words, discourse relations can be be-
tween elementary units, between larger units or
both. Second, in dependency parsing, any two
words can be linked, whereas RST allows connec-
tions only between two adjacent units. Third, in
dependency parsing, a head word can have mul-
tiple modifier words, whereas in discourse pars-
ing, a discourse unit can be associated with only
one connection. The parsing algorithm needs to
be adapted to account for these differences.

2.3 Pointer Networks.

Pointer networks (Vinyals et al., 2015) are a class
of encoder-decoder models that can tackle prob-
lems where the output vocabulary depends on the
input sequence. They use attentions as pointers to
the input elements. An encoder network first con-
verts the input sequence X = (x1, . . . ,xn) into
a sequence of hidden states H = (h1, . . . ,hn).
At each time step t, the decoder takes the input
from previous step, generates a decoder state dt,
and uses it to attend over the input elements. The
attention gives a softmax distribution over the in-
put elements.

st,i = σ(dt,hi); at = softmax(st) (1)

where σ(., .) is a scoring function for atten-
tion, which can be a neural network or an ex-
plicit formula like dot product. The model uses
at to infer the output: ŷt = arg max(at) =
arg max p(yt|y<t,X, θ) where θ is the set of pa-
rameters. To condition on yt−1, the corresponding
input xyt−1 is copied as the input to the decoder.

1 There are also studies that use dependency structure to
directly represent the relations between the EDUs; see
(Muller et al., 2012; Li et al., 2014; Morey et al., 2018).

3 Hierarchical Pointer Networks

Before presenting our proposed hierarchical
pointer networks, we first revisit how pointer net-
works have been used for parsing tasks.

3.1 Pointer Networks for Parsing.

Ma et al. (2018) and Lin et al. (2019) both use
a pointer network as the backbone of their pars-
ing models and achieve state-of-the-art perfor-
mance in dependency and discourse parsing tasks,
respectively. As shown in Figures 2(a) and 3,
in both cases, the parsing algorithm is imple-
mented in a top-down depth-first order. They
share the same encoder-decoder structure. A
bi-directional Recurrent Neural Network (RNN)
encodes a sequence of word embeddings X =
(x1, . . . ,xn) into a sequence of hidden states H
= (h1, . . . ,hn). The decoder implements a uni-
directional RNN to greedily generate the corre-
sponding tree. It maintains a stack to keep track
of the units that yet need to be parsed, i.e., head
words for dependency parsing and larger units for
discourse parsing. At each step t, the decoder
takes out an element from the stack and gener-
ates a decoder state dt, which is in turn used in
the pointer layer to compute the attention over the
relevant input elements. In the case of depen-
dency parsing, the representation of the head word
is used to find its dependent. For discourse pars-
ing, it uses the representation of the span to iden-
tify the break position that splits the text span into
two subspans.

In addition to the tree structure, the parser
also deals with the corresponding labelling tasks.
Whenever the pointer network yields a newly
created pair (i.e., head-dependent in dependency
parsing, two sub-spans in discourse parsing), a
separate classifier is applied to predict the corre-
sponding relation between them.

3.2 Limitations of Existing Methods

One crucial limitation of the existing models is
that the decoder has a linear structure, although the
task is to construct a hierarchical structure. This
can be noticed in the Figures 2 and 3, where the
current decoder state dt is conditioned on the pre-
vious state dt−1 (see horizontal blue lines), but not
on its parent’s decoder state or siblings’ decoder
state, when it was pointed from its head. This can
induce irrelevant information if the previous de-
coding state corresponds to an element that is not



1010

relevant to the current element. For example, in
Figure 2, the decoder state for pointing to “pens” is
conditioned on the state used for pointing to “and”,
but not the one used for pointing to “sell”, which is
more relevant according to the dependency struc-
ture. Also, the decoder state for “sell” is far apart
from the one for “pens”. Therefore, more relevant
information could be diminished in a sequential
decoder, especially for long range dependencies.

3.3 Hierarchical Decoder

To address the above issues, we propose hierarchi-
cal pointer network (H-PtrNet), which poses a hi-
erarchical decoder that reflects the underlying tree
structure. H-PtrNet has the same encoder-decoder
architecture as the original pointer network except
that each decoding state dt is conditioned directly
on its parent’s decoder state dp(t) and its immedi-
ate sibling’s decoder state ds(t) in addition to the
previous decoder state dt−1 and parent’s encoder
state hp(t) (from input). Formally, the pointing
mechanism in H-PtrNet can be defined as:

dt = f(dp(t),ds(t),dt−1,hp(t)) (2)

st,i = σ(dt,hi) (3)

p(yt|y<t,X, θ)= softmax(st)=
exp(st,i)∑
i exp(st,i)

(4)

where f(.) is a fusion function to combine the four
components into a decoder state, and other terms
are similarly defined as before for Eq. 1. Figure
2(b) shows an example of H-PtrNet decoder con-
nections for dependency parsing.

The fusion function f(.) can be implemented
in multiple ways and may depend on the specific
parsing task. More variants of the fusion function
will be discussed in Section 4.

Decoder Time Complexity. Given a sentence of
length n, the number of decoding steps to build a
parse tree is linear. The attention mechanism at
each decoding step computes an attention vector
of length n. The overall decoding complexity is
O(n2), which is same as the StackPointer Parser
(Ma et al., 2018).

Remark. If we look at the decoding steps of the
StackPointer Parser (Ma et al., 2018) more closely,
we notice that it also takes the decoder state of the
immediate sibling (when it points to itself). This

decoder state represents the state after all its chil-
dren are generated. Thus it contains information
about its children. In contrast, in our model we
consider the decoder state when the sibling was
first generated from its parent. Therefore this state
contains the sibling’s parent information, which
helps with capturing long term dependencies.

3.4 Model Specifics for Dependency Parsing
Figure 2(a) shows the encoding and decoding
steps of H-PtrNet for dependency parsing. We
use the same encoder as Ma et al. (2018) (red
color).2 Given a sentence, a convolutional neural
network (CNN) is used to encode character-level
representation of each word, which is then con-
catenated with word embedding and POS embed-
ding vectors to generate the input sequence X =
(x1, . . . ,xn). Then a three-layer bi-directional
LSTM encodes X into a sequence of hidden states
H = (h1, . . . ,hn). The decoder (blue color) is a
single layer uni-directional LSTM, and also main-
tains a stack to track of the decoding status. At
each decoding step t, the decoder receives the en-
coder state of the parent from the stack. In ad-
dition, it gets decoder states from three different
sources: previous decoding step dt−1, parent dp(t)
and immediate sibling ds(t).

Instead of simply feeding these three compo-
nents to the decoder, we incorporate a gating
mechanism to generalize the ability of our model
to extract the most useful information. Eventually,
the fusion function f(dp(t),ds(t),dt−1,hp(t)) in
Eq. 2 is defined with a gating mechanism. We
experimented with two different gating functions:

gt = sigmoid(Wgddt−1 + Wgpdp(t)
+ Wgsds(t) + bg) (5)

gt = sigmoid(Wgp(dt−1 � dp(t))
+ Wgs(dt−1 � ds(t)) + bg) (6)

where Wgp, Wgs, Wgd and bg are the gating
weights. The fusion function is then defined as

h′t = tanh(Wddt−1 + Wpdp(t) + Wsds(t))(7)

h′′t = gt � h′t (8)
dt = LSTM(h′′t ,hp(t)) (9)

2 https://github.com/XuezheMax/NeuroNLP2



1011

(a) Model Structure (b) Decoder Connections

Figure 2: (a) H-PtrNet for dependency parsing. To reduce visual clutter, we do not show the attention scores over
all the input elements at each pointing step, rather show only the pointed element. Figure (b) shows the decoder
connections in our H-PtrNet model. The StackPointer network of Ma et al. (2018) has a sequential decoder (shown
as blue straight lines). The Green dash lines indicate parent connections and purple solid lines denote the immediate
sibling connections in our model.

where Wd, Wp, Ws are the weights to get the in-
termediate hidden state h′t, and gt is a gate to con-
trol the information flow from the three decoder
states LSTM is the LSTM layer that accepts h′′t
as the the hidden state and hp(t) as its input. The
LSTM decoder state dt is then used to compute
the attention distribution over the encoder states in
pointer layer.

Pointer and Classifier. Same as Ma et al.
(2018), the pointer and the label classifier are im-
plemented as bi-affine layers. Formally, the scor-
ing function σ(dt,hi) in Eq. 3 is defined as:

st,i = g1(dt)
TW g2(hi) + Ug1(dt)+

V g2(hi) + b (10)

where W , U and V are the weights, and g1(.)
and g2(.) are two single layer MLPs with ELU ac-
tivations. The dependency label classifier has the
same structure as the pointer. More specifically,

p(yl|X) = softmax(g′1(dt)TWcg′2(hk)+
Ucg

′
1(dt) + Vcg

′
2(hk) + bc) (11)

where hk is the encoder state of the dependent
word, dt is the decoder state of the head word, Wc,
Uc and Vc are the weights, and g′1(.) and g

′
2(.) are

two single layer MLPs with ELU activations.

Partial Tree Information. Similar to Ma et al.
(2018), we provide the decoder at each step with
higher order information about the parent and the
sibling of the current node.

3.5 Model Specifics for Discourse Parsing.

For discourse parsing, our model uses the same
structure as Lin et al. (2019).3 The encoder is
a 5-layer bidirectional RNN based on Gated Re-
current Units (BiGRU) (Cho et al., 2014). As
shown in Figure 3, after obtaining a sequence of
encoder hidden states representing the words, the
last hidden states of the EDUs (e.g., h2, h3, h5,
h6, h8 and h10) are taken as the EDU represen-
tations, generating a sequence of EDU representa-
tions E = (e1, . . . , em) for the input sentence.

Our hierarchical decoder is based on a 5-layer
unidirectional GRU. The decoder maintains a
stack to keep track of the spans that need to be
parsed further. At time step t, the decoder takes
the text span (e.g., ei:j) representation from the
top of the stack and receives the corresponding
parent decoder state dp(t), sibling decoder state
ds(t) and previous decoder state dt−1 as the input
to generate a current decoder state dt. For dis-
course parsing, we apply Eq. 7 and 9 (with GRU)
to implement the fusion function f(.) and to get
the decoder state dt.4 The decoder state is then
used in the pointer layer to compute the attention
score over the current text span (e.g., ei:j) in or-
der to find the position k to generate a new split
(ei:k, ek+1:j). The parser then applies a relation
classifier Φ(ei:k, ek+1:j) to predict the relation and
the nuclearity labels for the the new split.

3 https://ntunlpsg.github.io/project/
parser/pointer-net-parser

4 Adding gating mechanism did not give any gain, rather in-
creased the number of parameters.

https://ntunlpsg.github.io/project/parser/pointer-net-parser
https://ntunlpsg.github.io/project/parser/pointer-net-parser


1012

Figure 3: H-PtrNet for discourse parsing. The input
symbols in red (x2,x3,x5,x6,x8,x9) represent last
words of the respective EDUs. To avoid visual clut-
ter, we do not show the attention distributions over the
EDUs, rather only show the decisions. Green dash lines
indicate parent connections and purple solid lines de-
note the immediate sibling connections.

For pointing, the parser uses a simple dot prod-
uct attention. For labeling, it uses a bi-affine clas-
sifier similar to the one in Eq. 11. It takes the
representations of two spans (i.e., ek for ei:k, ej
for ek+1:j) as input and predicts the correspond-
ing relation between them. Whenever the length
of any of the newly created span (ei:k and ek+1:j)
is larger than two, the parser pushes it onto the
stack for further processing. Similar to depen-
dency parsing, the decoder is also provided with
partial tree information – the representations of
the parent and the immediate sibling.

3.6 Objective Function

Same as Ma et al. (2018) and Lin et al. (2019), our
parsers are trained to minimize the total log loss
(cross entropy) for building the right tree struc-
ture for a given sentence X . The structure loss L
is the pointing loss for the pointer network:

L(θ) = −
T∑
t=1

logPθ(yt|y<t,X) (12)

where θ denotes the model parameters, y<t rep-
resents the subtrees that have been generated by
our parser at previous steps, and T is the number
needed for parsing the whole sentence (i.e., num-
ber of words in dependency parsing and spans con-
taining more than two EDUs in discourse parsing).
The label classifiers are trained simultaneously, so
the final loss function is the sum of structure loss
(Eq. 12) and the loss for label classifier.

4 Experiments

In this section, we describe the experimental de-
tails about dependency parsing and discourse pars-
ing, as well as the analysis on both tasks.

Apart from the two gating-based fusion func-
tions described in Section 3 (Eq. 5-6), we experi-
mented with three different versions of our model
depending on which connections are considered in
the decoder. We append suffixes P for parent, S
for sibling and T for temporal to the model name
(H-PtrNet) to denote different versions.

• H-PtrNet-P: The H-PtrNet model with fusion
function dt = f(dp(t),hp(t)), where the de-
coder receives hidden (decoder) state only from
the parent (dp(t)) in each decoding step. Note
that hp(t) is the encoder state of the parent.

• H-PtrNet-PS: The H-PtrNet model with fusion
function dt = f(dp(t),ds(t),hp(t)), where the
decoder receives the hidden states from both the
parent and sibling in each decoding step.

• H-PtrNet-PST: This is the full model with fu-
sion function dt = f(dp(t),ds(t),dt−1,hp(t))
(Eq. 2). In this model, the decoder receives the
hidden states from its parent, sibling and previ-
ous step in each decoding step.

4.1 Dependency Parsing

Dataset. We evaluate our model on the English
Penn Treebank (PTB v3.0) (Marcus et al., 1994),
which is converted to Stanford Dependencies for-
mat with Stanford Dependency Converter 3.3.0
(Schuster and Manning, 2016). To make a thor-
ough empirical comparison with previous stud-
ies, we also evaluate our system on seven (7)
languages from the Universal Dependency (UD)
Treebanks5 (version 2.3).

Metrics. We evaluate the performance of our
models with unlabeled attachment score (UAS)
and labeled attachment score (LAS). We ignore
punctuations in the evaluation for English.

Experimental Settings. We use the same setup
as Ma et al. (2018) in the experiments for English
Penn Treebank and UD Treebanks. For a fair com-
parison, we rerun their model with the hyperpa-
rameters provided by the authors on the same ma-
chine as our experiments. For all the languages,

5 http://universaldependencies.org/



1013

StackPtr (code) H-PtrNet-PST (Gate) H-PtrNet-PST (SGate)

UAS LAS UAS LAS UAS LAS

bg 94.17±0.11 90.63±0.06 94.20±0.16 90.70±0.14 94.50±0.16 91.01±0.20

ca 93.82±0.06 91.99±0.07 93.78±0.03 91.92±0.03 93.67±0.06 91.82±0.07

en 90.97±0.07 89.06±0.08 91.03±0.19 89.07±0.16 90.94±0.12 89.01±0.12

de 87.97±0.20 83.75±0.21 88.14±0.22 83.89±0.26 88.06±0.17 83.83±0.13

fr 91.57±0.23 88.76±0.21 91.63±0.15 88.70±0.14 91.69±0.07 88.80±0.11

it 93.76±0.13 92.00±0.08 93.73±0.08 91.90±0.10 93.88±0.05 92.09±0.02

ro 91.15±0.12 85.54±0.13 91.34±0.18 85.73±0.22 91.09±0.09 85.36±0.10

Table 1: Dependency parsing results on 7 UD Treebanks. StackPtr (code) denotes the experiments we rerun on
our machine. H-PtrNet-PST (Gate) and H-PtrNet-PST (SGate) are H-PtrNet models with gating mechanism.

we follow the standard split for training, valida-
tion and testing. It should be noted that Ma et al.
(2018) used UD Treebanks 2.1, which is not the
most up-to-date version. Therefore, during exper-
iments, we rerun their codes with UD Treebanks
2.3 to match our experiments. To be specific, we
use structured-skipgram (Ling et al., 2015) for En-
glish and German, while Polyglot embedding (Al-
Rfou et al., 2013) for the other languages. Adam
optimizer (Kingma and Ba, 2015) is used as the
optimization algorithm. We apply 0.33 dropout
rate between layers of encoder and to word em-
beddings as well as Eq. 8. We use beam size of
10 for English Penn Treebank, and beam size of 1
for UD Treebanks. The gold-standard POS tags is
used for English Penn Treebank. We also use the
universal POS tags (Petrov et al., 2011) provided
in the dataset for UD Treebanks. See Appendix
for a complete list of hyperparameters.

Results on UD Treebanks. We evaluate on 7
different languages from the UD Treebanks: 4 ma-
jor ones: English (en), German (de), French (fr),
and Italian (it), and 3 relatively minor ones: Bul-
garian (bg), Catalan (ca), and Romanian (ro). Ta-
ble 1 shows the results. We refer to the results of
our run of the code released by Ma et al. (2018)
as StackPtr (code).6 StackPtr (code) and our mod-
els are trained in identical settings making them
comparable. H-PtrNet-PST (Gate) (Eq. 5) and H-
PtrNet-PST (SGate) (Eq. 6) are H-PtrNet models
with gating mechanism. Element wise product in
Eq. 6 has the effect of similarity comparison, so
we denote it as SGATE. With gating mechanism,
6 We do not directly report the results from their paper be-

cause we use a different version of the UD Treebanks.

Approach UAS LAS

Baselines
StackPtr (paper) 96.12±0.03 95.06±0.05
StackPtr (code) 95.94±0.03 94.91±0.05

Proposed Model
H-PtrNet-PST (Gate) 96.03±0.02 94.99±0.02
H-PtrNet-PST (SGate) 96.04±0.05 95.00±0.06
H-PtrNet-PS (Gate) 96.09±0.05 95.03±0.03

Table 2: Dependency parsing results on English Penn
Treebank v3.0.

our model shows consistent improvements against
the baseline on bg, en, de, fr, it and ro. We also
tested H-PtrNet-PS on these 7 languages, but the
performances are worse than StackPtr.

Results on English Penn Treebank. Table 2
presents the results on English Penn Treebank.
StackPtr (paper) refer to the results reported by
Ma et al. (2018), and StackPtr (code) is our run of
their code in identical settings as ours. Our model
H-PtrNet-PST (Gate) outperforms the baseline by
0.09 and 0.08 in terms of UAS and LAS, respec-
tively. Performance of H-PtrNet-PST (SGate) is
close to that of H-PtrNet-PST (Gate), though we
see slight improvement. We also test H-PtrNet-
PS (Gate), the model with parent and sibling con-
nections only, which further improves the perfor-
mance to 96.09 and 95.03 in UAS and LAS.

Performance Analysis. To make a thorough
analysis of our model, we breakdown UAS in
terms of sentence lengths to compare the perfor-
mance of our model and StackPtr. We first take
the performance on UD German as an example,



1014

(a) H-PtrNet-PST (no gating) (b) H-PtrNet-PST (SGate)

Figure 4: UD German parsing performance in terms of
sentence length.

(a) UD French (b) UD Italian

Figure 5: Performance analysis on French and Italian
based on H-PtrNet-PST (SGate).

which is shown in Figure 4. The blue line shows
the performance of StackPtr, and the orange line
shows the performance of our model. From Fig-
ure 4(a) we can see that our model without gate
performs better on relatively short sentences (10 to
29 words), however, the accuracy drops on longer
sentences. The reason could be that adding parent
and sibling hidden states to decoder may amplify
error accumulation from early parsing mistakes.

Figure 4(b) shows the performance of our
model with SGATE (Eq. 6), where we can see
that the performance on long sentences has been
improved significantly. In the meanwhile, it still
maintains higher accuracy than StackPtr on the
short sentences (10 to 29 words). Figure 5 shows
two more examples, again, from which we can see
that our model with SGATE tends to outperform
StackPtr on longer sentences.

4.2 Discourse Parsing

Dataset. We use the standard RST Discourse
Treebank (RST-DT) (Carlson et al., 2002), which
contains discourse annotations for 385 news ar-
ticles from Penn Treebank (Marcus et al., 1994).
We evaluate our model in sentence-level parsing,
for which we extract all the well-formed sentence-
level discourse trees from document-level trees.

Approach Span Nuclearity Relation

Human Agreement 95.7 90.4 83.0

Baselines
Joty et al. (2012) 94.6 86.9 77.1

Ji and Eisenstein (2014) 93.5 81.3 70.5

Wang et al. (2017) 95.6 87.8 77.6

Pointer Net† (Lin et al., 2019) 97.39±0.1 91.01±0.4 81.08±0.4
Pointer Net§ (Lin et al., 2019) 97.14±0.1 91.00±0.3 81.29±0.2

Proposed Model
H-PtrNet-P† 97.68±0.03 91.86±0.2 81.82±0.2
H-PtrNet-P§ 97.51±0.08 91.98±0.1 82.11±0.2
H-PtrNet-PS† 97.56±0.1 91.52±0.3 82.05±0.5
H-PtrNet-PS§ 97.35±0.1 91.78±0.1 82.35±0.2
H-PtrNet-PST† 97.56±0.06 91.97±0.3 82.37±0.4
H-PtrNet-PST§ 97.48±0.2 92.01±0.2 82.77±0.2

Table 3: Discourse parsing results with gold segmen-
tation. † denotes the models selected based on Span.
§ denotes the models selected based on Relation. We
run all the experiments for three times and report the
averages and the standard deviations.

In all, the training data contains 7321 sentences,
and the testing data contains 951 sentences. These
numbers match the statistics reported by Lin et al.
(2019). We follow the same settings as in their ex-
periments and randomly choose 10% of the train-
ing data for hyperparameter tuning.

Metric and Relation Labels. Following the
standard in RST parsing, we use the unlabeled
(Span) and labeled (Nuclearity, Relation) metrics
proposed by Marcu (2000). We only present F1-
score for space limitations. Following the previ-
ous work, we attach the nuclearity labels (NS, SN,
NN) to 18 discourse relations, together giving 39
distinctive relation labels.

Experimental Settings. Since our goal is to
evaluate our parsing method, we conduct the ex-
periments based on gold EDU segmentations. We
compare our results with the recently proposed
pointer network based parser of Lin et al. (2019)
(Pointer Net). However, unlike their paper, we re-
port results for both cases: (i) when the model was
selected based on the best performance on Span
identification; and (ii) when it was selected based
on the relation labeling performance on the devel-
opment set. We retrain their model for both set-
tings. We also apply Adam optimizer as optimiza-
tion algorithm and ELMo (Peters et al., 2018) with
0.5 dropout rate as word embeddings.



1015

Results. We present the results in Table 3. In
discourse parsing, the number of EDUs in a sen-
tence is relatively small compared to the sentence
lengths (in words) in dependency parsing. Based
on the observation in dependency parsing that the
performance of H-PtrNet may drop for longer sen-
tences due to parent error accumulation, we expect
that in discourse parsing, this should not be the
case since the the number of parsing steps is much
smaller compared to that of dependency parsing.

We first consider the models that were selected
based on Span performance (models with † su-
perscript). H-PtrNet-P, with only parent connec-
tion, outperforms the baseline in all three tasks. It
achieves an absolute improvement of 0.29 F1 in
span identification compared to the baseline. Con-
sidering the performance has already exceeded the
human agreement of 95.7 F1, this gain is remark-
able. Thanks to the higher accuracy on finding the
right spans, we also achieve 0.85 and 0.74 absolute
improvements in Nuclearity and Relation tasks,
respectively. By adding the sibing and temporal
connections, we test the performance of our full
model, H-PtrNet-PST. The performance on Span
is 0.17 F1 higher than the baseline. However, it is
not on par with our H-PtrNet-P. But, it is not sur-
prising since we adopt binary tree structures in dis-
course parsing, which means the sibling informa-
tion could be redundant in most cases. This also
accords with our previous assumption that parent
connections may bring enough information to de-
code RST trees.

Now we consider the models that were selected
based on Relation labeling performance (models
with § superscript). We achieve significant im-
provement in Relation compared to the baseline.
Eventually the parser yields an F1 of 82.77, which
is very close to the human agreement (83.0 F1).
We observe that the performance in H-PtrNet-PS
and H-PtrNet-PST is better than the H-PtrNet-P.
As the relation classifier and the pointer network
share the same encoder information (Sec. 3), we
believe that richer decoder information leads the
model to learn better representations of the text
spans (encoder states) and further leads to a bet-
ter performance in relation labeling.

We further analyze the performance of our pro-
posed model in terms of number of EDUs. We
present the F1 score in Span of H-PtrNet-P and
H-PtrNet-PST as well as the baseline in Figure 6.
It can be observed that both H-PtrNet-P and H-

Figure 6: F1 score in Span for different EDU numbers.

PtrNet-PST outperform the baseline with respect
to almost every number of EDUs. Moreover, we
can see that the H-PtrNet-P performs better in
most of the cases, which once again conforms to
our assumption that parent information is enough
to decode RST trees. However, as discussed in
our dependency parsing experiments, when the
number of words (EDUs for discourse parsing) in-
creases, the model may suffer from error accumu-
lation from early parsing. Hence, H-PtrNet-PST
tends to perform better when EDU number be-
comes large.

5 Conclusions

In this paper, we propose hierarchical pointer net-
work parsers and apply them to dependency and
discourse parsing tasks. Our parsers address the
limitation of previous methods, where the decoder
has a sequential structure while it is decoding a
hierarchical tree structure, by allowing more flex-
ible information flow to help the decoder receive
the most relevant information. For both tasks, our
parsers outperform existing methods and set new
state-of-the-arts of the two tasks. The broken-
down analysis clearly illustrates that our parsers
perform better for long sequences, complying with
the motivation of our model.

Acknowledgements

This research is partly supported by the Alibaba-
NTU Singapore Joint Research Institute, Nanyang
Technological University (NTU), Singapore.
Shafiq Joty would like to thank the funding
support from his Start-up Grant (M4082038.020).

References
Rami Al-Rfou, Bryan Perozzi, and Steven Skiena.

2013. Polyglot: Distributed word represen-



1016

tations for multilingual nlp. arXiv preprint
arXiv:1307.1662.

Daniel Andor, Chris Alberti, David Weiss, Aliaksei
Severyn, Alessandro Presta, Kuzman Ganchev, Slav
Petrov, and Michael Collins. 2016. Globally nor-
malized transition-based neural networks. In Pro-
ceedings of the 54th Annual Meeting of the Associa-
tion for Computational Linguistics (Volume 1: Long
Papers), pages 2442–2452, Berlin, Germany. Asso-
ciation for Computational Linguistics.

Miguel Ballesteros, Chris Dyer, and Noah A. Smith.
2015. Improved transition-based parsing by mod-
eling characters instead of words with LSTMs. In
Proceedings of the 2015 Conference on Empirical
Methods in Natural Language Processing, pages
349–359, Lisbon, Portugal. Association for Compu-
tational Linguistics.

Lynn Carlson, Daniel Marcu, and Mary Ellen
Okurowski. 2002. RST Discourse Treebank (RST–
DT) LDC2002T07. Linguistic Data Consortium,
Philadelphia.

Kyunghyun Cho, Bart van Merrienboer, Çaglar
Gülçehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using RNN encoder-decoder
for statistical machine translation. In Proceedings of
the 2014 Conference on Empirical Methods in Nat-
ural Language Processing, EMNLP 2014, October
25-29, 2014, Doha, Qatar, A meeting of SIGDAT,
a Special Interest Group of the ACL, pages 1724–
1734.

Timothy Dozat and Christopher D. Manning. 2017.
Deep biaffine attention for neural dependency pars-
ing. In ICLR.

Chris Dyer, Miguel Ballesteros, Wang Ling, Austin
Matthews, and Noah A. Smith. 2015. Transition-
based dependency parsing with stack long short-
term memory. In Proceedings of the 53rd Annual
Meeting of the Association for Computational Lin-
guistics and the 7th International Joint Conference
on Natural Language Processing (Volume 1: Long
Papers), pages 334–343, Beijing, China. Associa-
tion for Computational Linguistics.

Jason Eisner. 1996. Three new probabilistic models for
dependency parsing: An exploration. In Proceed-
ings of the 16th Conference on Computational Lin-
guistics - Volume 1, COLING ’96, pages 340–345,
Copenhagen, Denmark. ACL.

Vanessa Wei Feng and Graeme Hirst. 2014. A linear-
time bottom-up discourse parser with constraints
and post-editing. In Proceedings of the 52nd Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers), pages 511–521.
Association for Computational Linguistics.

Yangfeng Ji and Jacob Eisenstein. 2014. Represen-
tation learning for text-level discourse parsing. In

Proceedings of the 52nd Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 13–24, Baltimore, Maryland.
ACL.

Shafiq Joty, Giuseppe Carenini, and Raymond Ng.
2012. A novel discriminative framework for
sentence-level discourse analysis. In Proceedings
of the 2012 Joint Conference on Empirical Methods
in Natural Language Processing and Computational
Natural Language Learning, pages 904–915. Asso-
ciation for Computational Linguistics.

Shafiq Joty, Giuseppe Carenini, and Raymond T Ng.
2015. Codra: A novel discriminative framework
for rhetorical analysis. Computational Linguistics,
41:3:385–435.

Diederik P. Kingma and Jimmy Ba. 2015. Adam:
A method for stochastic optimization. CoRR,
abs/1412.6980.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. Transactions
of the Association for Computational Linguistics,
4:313–327.

Sujian Li, Liang Wang, Ziqiang Cao, and Wenjie Li.
2014. Text-level discourse dependency parsing. In
Proceedings of the 52nd Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 25–35. ACL.

Xiang Lin, Shafiq Joty, Prathyusha Jwalapuram, and
M Saiful Bari. 2019. A Unified Linear-Time Frame-
work for Sentence-Level Discourse Parsing. In Pro-
ceedings of the 57th Annual Meeting of the Associa-
tion for Computational Linguistics, ACL ’19, pages
xx–xx, Florence, Italy. ACL.

Wang Ling, Chris Dyer, Alan W Black, and Isabel
Trancoso. 2015. Two/too simple adaptations of
word2vec for syntax problems. In Proceedings of
the 2015 Conference of the North American Chap-
ter of the Association for Computational Linguistics:
Human Language Technologies, pages 1299–1304.

Xuezhe Ma, Zecong Hu, Jingzhou Liu, Nanyun Peng,
Graham Neubig, and Eduard Hovy. 2018. Stack-
pointer networks for dependency parsing. In Pro-
ceedings of the 56th Annual Meeting of the Associa-
tion for Computational Linguistics (Volume 1: Long
Papers), pages 1403–1414. Association for Compu-
tational Linguistics.

William Mann and Sandra Thompson. 1988. Rhetor-
ical Structure Theory: Toward a Functional Theory
of Text Organization. Text, 8(3):243–281.

Daniel Marcu. 1999. The automatic construction of
large-scale corpora for summarization research. In
Proceedings of SIGIR, pages 137–144.

Daniel Marcu. 2000. The Rhetorical Parsing of Unre-
stricted Texts: A Surface-based Approach. Compu-
tational Linguistics, 26:395–448.

https://doi.org/10.18653/v1/P16-1231
https://doi.org/10.18653/v1/P16-1231
https://doi.org/10.18653/v1/D15-1041
https://doi.org/10.18653/v1/D15-1041
http://aclweb.org/anthology/D/D14/D14-1179.pdf
http://aclweb.org/anthology/D/D14/D14-1179.pdf
http://aclweb.org/anthology/D/D14/D14-1179.pdf
http://arxiv.org/abs/1611.01734
http://arxiv.org/abs/1611.01734
https://doi.org/10.3115/v1/P15-1033
https://doi.org/10.3115/v1/P15-1033
https://doi.org/10.3115/v1/P15-1033
https://doi.org/10.3115/v1/P14-1048
https://doi.org/10.3115/v1/P14-1048
https://doi.org/10.3115/v1/P14-1048
http://www.aclweb.org/anthology/P/P14/P14-1002
http://www.aclweb.org/anthology/P/P14/P14-1002
http://aclweb.org/anthology/D12-1083
http://aclweb.org/anthology/D12-1083
https://doi.org/10.1162/tacl_a_00101
https://doi.org/10.1162/tacl_a_00101
https://doi.org/10.1162/tacl_a_00101
http://aclweb.org/anthology/P14-1003
https://arxiv.org/abs/1905.05682
https://arxiv.org/abs/1905.05682
http://aclweb.org/anthology/P18-1130
http://aclweb.org/anthology/P18-1130


1017

Mitchell Marcus, Mary Marcinkiewicz, and Beatrice
Santorini. 1994. Building a Large Annotated Cor-
pus of English: The Penn Treebank. Computational
Linguistics, 19(2):313–330.

Mathieu Morey, Philippe Muller, and Nicholas Asher.
2018. A dependency perspective on RST discourse
parsing and evaluation. American Journal of Com-
putational Linguistics, 44(2):197–235.

Philippe Muller, Stergos Afantenos, Pascal Denis, and
Nicholas Asher. 2012. Constrained decoding for
text-level discourse parsing. In Proceedings of
COLING 2012, pages 1883–1900, Mumbai, India.
The COLING 2012 Organizing Committee.

Dat Quoc Nguyen and Karin Verspoor. 2018. An im-
proved neural network model for joint POS tagging
and dependency parsing. CoRR, abs/1807.03955.

Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. In Proc. of NAACL.

Slav Petrov, Dipanjan Das, and Ryan T. McDonald.
2011. A universal part-of-speech tagset. CoRR,
abs/1104.2086.

Sebastian Schuster and Christopher D. Manning. 2016.
Enhanced english universal dependencies: An im-
proved representation for natural language under-
standing tasks. In LREC.

Radu Soricut and Daniel Marcu. 2003. Sentence Level
Discourse Parsing Using Syntactic and Lexical In-
formation. In Proceedings of the 2003 Conference
of the North American Chapter of the Association
for Computational Linguistics on Human Language
Technology - Volume 1, NAACL’03, pages 149–156,
Edmonton, Canada. ACL.

Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly.
2015. Pointer networks. In C. Cortes, N. D.
Lawrence, D. D. Lee, M. Sugiyama, and R. Garnett,
editors, Advances in Neural Information Processing
Systems 28, pages 2692–2700. Curran Associates,
Inc.

Yizhong Wang, Sujian Li, and Houfeng Wang. 2017.
A two-stage parsing method for text-level discourse
analysis. In Proceedings of the 55th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers), pages 184–188. Associa-
tion for Computational Linguistics.

Yue Zhang and Joakim Nivre. 2011. Transition-based
dependency parsing with rich non-local features. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies, pages 188–193, Portland, Ore-
gon, USA. Association for Computational Linguis-
tics.

https://doi.org/10.1162/COLI_a_00314
https://doi.org/10.1162/COLI_a_00314
https://www.aclweb.org/anthology/C12-1115
https://www.aclweb.org/anthology/C12-1115
http://arxiv.org/abs/1807.03955
http://arxiv.org/abs/1807.03955
http://arxiv.org/abs/1807.03955
http://arxiv.org/abs/1104.2086
http://papers.nips.cc/paper/5866-pointer-networks.pdf
https://doi.org/10.18653/v1/P17-2029
https://doi.org/10.18653/v1/P17-2029
https://www.aclweb.org/anthology/P11-2033
https://www.aclweb.org/anthology/P11-2033

