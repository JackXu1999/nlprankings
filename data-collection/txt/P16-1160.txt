



















































A Character-level Decoder without Explicit Segmentation for Neural Machine Translation


Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 1693–1703,
Berlin, Germany, August 7-12, 2016. c©2016 Association for Computational Linguistics

A Character-Level Decoder without Explicit Segmentation
for Neural Machine Translation

Junyoung Chung
Université de Montréal

junyoung.chung@umontreal.ca

Kyunghyun Cho
New York University

Yoshua Bengio
Université de Montréal
CIFAR Senior Fellow

Abstract

The existing machine translation systems,
whether phrase-based or neural, have
relied almost exclusively on word-level
modelling with explicit segmentation. In
this paper, we ask a fundamental question:
can neural machine translation generate
a character sequence without any explicit
segmentation? To answer this question,
we evaluate an attention-based encoder–
decoder with a subword-level encoder and
a character-level decoder on four language
pairs–En-Cs, En-De, En-Ru and En-Fi–
using the parallel corpora from WMT’15.
Our experiments show that the models
with a character-level decoder outperform
the ones with a subword-level decoder on
all of the four language pairs. Further-
more, the ensembles of neural models with
a character-level decoder outperform the
state-of-the-art non-neural machine trans-
lation systems on En-Cs, En-De and En-Fi
and perform comparably on En-Ru.

1 Introduction
The existing machine translation systems have re-
lied almost exclusively on word-level modelling
with explicit segmentation. This is mainly due
to the issue of data sparsity which becomes much
more severe, especially for n-grams, when a sen-
tence is represented as a sequence of characters
rather than words, as the length of the sequence
grows significantly. In addition to data sparsity,
we often have a priori belief that a word, or its
segmented-out lexeme, is a basic unit of meaning,
making it natural to approach translation as map-
ping from a sequence of source-language words to
a sequence of target-language words.

This has continued with the more recently
proposed paradigm of neural machine transla-

tion, although neural networks do not suffer from
character-level modelling and rather suffer from
the issues specific to word-level modelling, such
as the increased computational complexity from a
very large target vocabulary (Jean et al., 2015; Lu-
ong et al., 2015b). Therefore, in this paper, we ad-
dress a question of whether neural machine trans-
lation can be done directly on a sequence of char-
acters without any explicit word segmentation.

To answer this question, we focus on represent-
ing the target side as a character sequence. We
evaluate neural machine translation models with
a character-level decoder on four language pairs
from WMT’15 to make our evaluation as convinc-
ing as possible. We represent the source side as
a sequence of subwords extracted using byte-pair
encoding from Sennrich et al. (2015), and vary the
target side to be either a sequence of subwords or
characters. On the target side, we further design a
novel recurrent neural network (RNN), called bi-
scale recurrent network, that better handles multi-
ple timescales in a sequence, and test it in addition
to a naive, stacked recurrent neural network.

On all of the four language pairs–En-Cs, En-De,
En-Ru and En-Fi–, the models with a character-
level decoder outperformed the ones with a
subword-level decoder. We observed a similar
trend with the ensemble of each of these con-
figurations, outperforming both the previous best
neural and non-neural translation systems on En-
Cs, En-De and En-Fi, while achieving a compara-
ble result on En-Ru. We find these results to be
a strong evidence that neural machine translation
can indeed learn to translate at the character-level
and that in fact, it benefits from doing so.

2 Neural Machine Translation

Neural machine translation refers to a recently
proposed approach to machine translation (Cho et

1693



al., 2014; Sutskever et al., 2014; Bahdanau et al.,
2015). This approach aims at building an end-to-
end neural network that takes as input a source
sentence X = (x1, . . . , xTx) and outputs its trans-
lation Y = (y1, . . . , yTy), where xt and yt′ are re-
spectively source and target symbols. This neural
network is constructed as a composite of an en-
coder network and a decoder network.

The encoder network encodes the input sen-
tence X into its continuous representation. In
this paper, we closely follow the neural transla-
tion model proposed in Bahdanau et al. (2015)
and use a bidirectional recurrent neural network,
which consists of two recurrent neural networks.
The forward network reads the input sentence
in a forward direction: −→z t = −→φ (ex(xt),−→z t−1),
where ex(xt) is a continuous embedding of the
t-th input symbol, and φ is a recurrent activa-
tion function. Similarly, the reverse network
reads the sentence in a reverse direction (right
to left): ←−z t =←−φ (ex(xt),←−z t+1). At each loca-
tion in the input sentence, we concatenate the hid-
den states from the forward and reverse RNNs
to form a context set C = {z1, . . . , zTx} , where
zt =

[−→z t;←−z t].
Then the decoder computes the conditional dis-

tribution over all possible translations based on
this context set. This is done by first rewrit-
ing the conditional probability of a translation:
log p(Y |X) = ∑Tyt′=1 log p(yt′ |y<t′ , X). For each
conditional term in the summation, the decoder
RNN updates its hidden state by

ht′ = φ(ey(yt′−1),ht′−1, ct′), (1)

where ey is the continuous embedding of a target
symbol. ct′ is a context vector computed by a soft-
alignment mechanism:

ct′ = falign(ey(yt′−1),ht′−1, C)). (2)

The soft-alignment mechanism falign weights
each vector in the context set C according to its
relevance given what has been translated. The
weight of each vector zt is computed by

αt,t′ =
1
Z
efscore(ey(yt′−1),ht′−1,zt), (3)

where fscore is a parametric function returning an
unnormalized score for zt given ht′−1 and yt′−1.
We use a feedforward network with a single hid-
den layer in this paper.1 Z is a normalization con-
stant: Z =

∑Tx
k=1 e

fscore(ey(yt′−1),ht′−1,zk). This
1For other possible implementations, see (Luong et al., 2015a).

procedure can be understood as computing the
alignment probability between the t′-th target
symbol and t-th source symbol.

The hidden state ht′ , together with the previous
target symbol yt′−1 and the context vector ct′ , is
fed into a feedforward neural network to result in
the conditional distribution:

p(yt′ | y<t′ , X) ∝ ef
yt′
out(ey(yt′−1),ht′ ,ct′ ). (4)

The whole model, consisting of the encoder,
decoder and soft-alignment mechanism, is then
tuned end-to-end to minimize the negative log-
likelihood using stochastic gradient descent.

3 Towards Character-Level Translation

3.1 Motivation
Let us revisit how the source and target sen-
tences (X and Y ) are represented in neural ma-
chine translation. For the source side of any given
training corpus, we scan through the whole cor-
pus to build a vocabulary Vx of unique tokens to
which we assign integer indices. A source sen-
tence X is then built as a sequence of the indices
of such tokens belonging to the sentence, i.e.,
X = (x1, . . . , xTx), where xt ∈ {1, 2, . . . , |Vx|}.
The target sentence is similarly transformed into a
target sequence of integer indices.

Each token, or its index, is then transformed
into a so-called one-hot vector of dimensionality
|Vx|. All but one elements of this vector are set to
0. The only element whose index corresponds to
the token’s index is set to 1. This one-hot vector
is the one which any neural machine translation
model sees. The embedding function, ex or ey, is
simply the result of applying a linear transforma-
tion (the embedding matrix) to this one-hot vector.

The important property of this approach based
on one-hot vectors is that the neural network is
oblivious to the underlying semantics of the to-
kens. To the neural network, each and every token
in the vocabulary is equal distance away from ev-
ery other token. The semantics of those tokens are
simply learned (into the embeddings) to maximize
the translation quality, or the log-likelihood of the
model.

This property allows us great freedom in the
choice of tokens’ unit. Neural networks have been
shown to work well with word tokens (Bengio et
al., 2001; Schwenk, 2007; Mikolov et al., 2010)
but also with finer units, such as subwords (Sen-
nrich et al., 2015; Botha and Blunsom, 2014; Lu-

1694



ong et al., 2013) as well as symbols resulting
from compression/encoding (Chitnis and DeNero,
2015). Although there have been a number of
previous research reporting the use of neural net-
works with characters (see, e.g., Mikolov et al.
(2012) and Santos and Zadrozny (2014)), the dom-
inant approach has been to preprocess the text into
a sequence of symbols, each associated with a se-
quence of characters, after which the neural net-
work is presented with those symbols rather than
with characters.

More recently in the context of neural machine
translation, two research groups have proposed to
directly use characters. Kim et al. (2015) proposed
to represent each word not as a single integer index
as before, but as a sequence of characters, and use
a convolutional network followed by a highway
network (Srivastava et al., 2015) to extract a con-
tinuous representation of the word. This approach,
which effectively replaces the embedding func-
tion ex, was adopted by Costa-Jussà and Fonollosa
(2016) for neural machine translation. Similarly,
Ling et al. (2015b) use a bidirectional recurrent
neural network to replace the embedding functions
ex and ey to respectively encode a character se-
quence to and from the corresponding continuous
word representation. A similar, but slightly differ-
ent approach was proposed by Lee et al. (2015),
where they explicitly mark each character with its
relative location in a word (e.g., “B”eginning and
“I”ntermediate).

Despite the fact that these recent approaches
work at the level of characters, it is less satisfying
that they all rely on knowing how to segment char-
acters into words. Although it is generally easy
for languages like English, this is not always the
case. This word segmentation procedure can be
as simple as tokenization followed by some punc-
tuation normalization, but also can be as compli-
cated as morpheme segmentation requiring a sep-
arate model to be trained in advance (Creutz and
Lagus, 2005; Huang and Zhao, 2007). Further-
more, these segmentation2 steps are often tuned
or designed separately from the ultimate objective
of translation quality, potentially contributing to a
suboptimal quality.

Based on this observation and analysis, in this
paper, we ask ourselves and the readers a question
which should have been asked much earlier: Is it

2From here on, the term segmentation broadly refers to
any method that splits a given character sequence into a se-
quence of subword symbols.

possible to do character-level translation without
any explicit segmentation?

3.2 Why Word-Level Translation?

(1) Word as a Basic Unit of Meaning A word
can be understood in two different senses. In the
abstract sense, a word is a basic unit of mean-
ing (lexeme), and in the other sense, can be un-
derstood as a “concrete word as used in a sen-
tence.” (Booij, 2012). A word in the former sense
turns into that in the latter sense via a process
of morphology, including inflection, compound-
ing and derivation. These three processes do al-
ter the meaning of the lexeme, but often it stays
close to the original meaning. Because of this
view of words as basic units of meaning (either
in the form of lexemes or derived form) from lin-
guistics, much of previous work in natural lan-
guage processing has focused on using words as
basic units of which a sentence is encoded as a
sequence. Also, the potential difficulty in finding
a mapping between a word’s character sequence
and meaning3 has likely contributed to this trend
toward word-level modelling.

(2) Data Sparsity There is a further technical
reason why much of previous research on ma-
chine translation has considered words as a ba-
sic unit. This is mainly due to the fact that ma-
jor components in the existing translation systems,
such as language models and phrase tables, are a
count-based estimator of probabilities. In other
words, a probability of a subsequence of sym-
bols, or pairs of symbols, is estimated by count-
ing the number of its occurrences in a training
corpus. This approach severely suffers from the
issue of data sparsity, which is due to a large
state space which grows exponentially w.r.t. the
length of subsequences while growing only lin-
early w.r.t. the corpus size. This poses a great chal-
lenge to character-level modelling, as any subse-
quence will be on average 4–5 times longer when
characters, instead of words, are used. Indeed,
Vilar et al. (2007) reported worse performance
when the character sequence was directly used by
a phrase-based machine translation system. More
recently, Neubig et al. (2013) proposed a method
to improve character-level translation with phrase-
based translation systems, however, with only a
limited success.

3For instance, “quit”, “quite” and “quiet” are one edit-
distance away from each other but have distinct meanings.

1695



(3) Vanishing Gradient Specifically to neural
machine translation, a major reason behind the
wide adoption of word-level modelling is due to
the difficulty in modelling long-term dependen-
cies with recurrent neural networks (Bengio et al.,
1994; Hochreiter, 1998). As the lengths of the
sentences on both sides grow when they are repre-
sented in characters, it is easy to believe that there
will be more long-term dependencies that must be
captured by the recurrent neural network for suc-
cessful translation.

3.3 Why Character-Level Translation?

Why not Word-Level Translation? The most
pressing issue with word-level processing is that
we do not have a perfect word segmentation al-
gorithm for any one language. A perfect segmen-
tation algorithm needs to be able to segment any
given sentence into a sequence of lexemes and
morphemes. This problem is however a difficult
problem on its own and often requires decades of
research (see, e.g., Creutz and Lagus (2005) for
Finnish and other morphologically rich languages
and Huang and Zhao (2007) for Chinese). There-
fore, many opt to using either a rule-based tok-
enization approach or a suboptimal, but still avail-
able, learning based segmentation algorithm.

The outcome of this naive, sub-optimal segmen-
tation is that the vocabulary is often filled with
many similar words that share a lexeme but have
different morphology. For instance, if we apply
a simple tokenization script to an English corpus,
“run”, “runs”, “ran” and “running” are all separate
entries in the vocabulary, while they clearly share
the same lexeme “run”. This prevents any ma-
chine translation system, in particular neural ma-
chine translation, from modelling these morpho-
logical variants efficiently.

More specifically in the case of neural machine
translation, each of these morphological variants–
“run”, “runs”, “ran” and “running”– will be as-
signed a d-dimensional word vector, leading to
four independent vectors, while it is clear that if
we can segment those variants into a lexeme and
other morphemes, we can model them more effi-
ciently. For instance, we can have a d-dimensional
vector for the lexeme “run” and much smaller
vectors for “s” and“ing”. Each of those variants
will be then a composite of the lexeme vector
(shared across these variants) and morpheme vec-
tors (shared across words sharing the same suffix,

for example) (Botha and Blunsom, 2014). This
makes use of distributed representation, which
generally yields better generalization, but seems
to require an optimal segmentation, which is un-
fortunately almost never available.

In addition to inefficiency in modelling, there
are two additional negative consequences from us-
ing (unsegmented) words. First, the translation
system cannot generalize well to novel words,
which are often mapped to a token reserved for
an unknown word. This effectively ignores any
meaning or structure of the word to be incorpo-
rated when translating. Second, even when a lex-
eme is common and frequently observed in the
training corpus, its morphological variant may not
be. This implies that the model sees this specific,
rare morphological variant much less and will not
be able to translate it well. However, if this rare
morphological variant shares a large part of its
spelling with other more common words, it is de-
sirable for a machine translation system to exploit
those common words when translating those rare
variants.

Why Character-Level Translation? All of
these issues can be addressed to certain extent by
directly modelling characters. Although the issue
of data sparsity arises in character-level transla-
tion, it is elegantly addressed by using a paramet-
ric approach based on recurrent neural networks
instead of a non-parametric count-based approach.
Furthermore, in recent years, we have learned how
to build and train a recurrent neural network that
can well capture long-term dependencies by using
more sophisticated activation functions, such as
long short-term memory (LSTM) units (Hochre-
iter and Schmidhuber, 1997) and gated recurrent
units (Cho et al., 2014).

Kim et al. (2015) and Ling et al. (2015a) re-
cently showed that by having a neural network that
converts a character sequence into a word vector,
we avoid the issues from having many morpho-
logical variants appearing as separate entities in
a vocabulary. This is made possible by sharing
the character-to-word neural network across all the
unique tokens. A similar approach was applied to
machine translation by Ling et al. (2015b).

These recent approaches, however, still rely on
the availability of a good, if not optimal, segmen-
tation algorithm. Ling et al. (2015b) indeed states
that “[m]uch of the prior information regarding
morphology, cognates and rare word translation

1696



among others, should be incorporated”.
It however becomes unnecessary to consider

these prior information, if we use a neural net-
work, be it recurrent, convolution or their combi-
nation, directly on the unsegmented character se-
quence. The possibility of using a sequence of un-
segmented characters has been studied over many
years in the field of deep learning. For instance,
Mikolov et al. (2012) and Sutskever et al. (2011)
trained a recurrent neural network language model
(RNN-LM) on character sequences. The latter
showed that it is possible to generate sensible text
sequences by simply sampling a character at a
time from this model. More recently, Zhang et
al. (2015) and Xiao and Cho (2016) successfully
applied a convolutional net and a convolutional-
recurrent net respectively to character-level docu-
ment classification without any explicit segmenta-
tion. Gillick et al. (2015) further showed that it
is possible to train a recurrent neural network on
unicode bytes, instead of characters or words, to
perform part-of-speech tagging and named entity
recognition.

These previous works suggest the possibility of
applying neural networks for the task of machine
translation, which is often considered a substan-
tially more difficult problem compared to docu-
ment classification and language modelling.

3.4 Challenges and Questions

There are two overlapping sets of challenges for
the source and target sides. On the source side, it
is unclear how to build a neural network that learns
a highly nonlinear mapping from a spelling to the
meaning of a sentence.

On the target side, there are two challenges. The
first challenge is the same one from the source
side, as the decoder neural network needs to sum-
marize what has been translated. In addition to
this, the character-level modelling on the target
side is more challenging, as the decoder network
must be able to generate a long, coherent sequence
of characters. This is a great challenge, as the size
of the state space grows exponentially w.r.t. the
number of symbols, and in the case of characters,
it is often 300-1000 symbols long.

All these challenges should first be framed as
questions; whether the current recurrent neural
networks, which are already widely used in neu-
ral machine translation, are able to address these
challenges as they are. In this paper, we aim at an-

(a) Gating units (b) One-step processing

Figure 1: Bi-scale recurrent neural network

swering these questions empirically and focus on
the challenges on the target side (as the target side
shows both of the challenges).

4 Character-Level Translation

In this paper, we try to answer the questions posed
earlier by testing two different types of recurrent
neural networks on the target side (decoder).

First, we test an existing recurrent neural net-
work with gated recurrent units (GRUs). We call
this decoder a base decoder.

Second, we build a novel two-layer recurrent
neural network, inspired by the gated-feedback
network from Chung et al. (2015), called a bi-
scale recurrent neural network. We design this
network to facilitate capturing two timescales, mo-
tivated by the fact that characters and words may
work at two separate timescales.

We choose to test these two alternatives for the
following purposes. Experiments with the base
decoder will clearly answer whether the existing
neural network is enough to handle character-level
decoding, which has not been properly answered
in the context of machine translation. The alterna-
tive, the bi-scale decoder, is tested in order to see
whether it is possible to design a better decoder, if
the answer to the first question is positive.

4.1 Bi-Scale Recurrent Neural Network

In this proposed bi-scale recurrent neural network,
there are two sets of hidden units, h1 and h2. They
contain the same number of units, i.e., dim(h1) =
dim(h2). The first set h1 models a fast-changing
timescale (thereby, a faster layer), and h2 a slower
timescale (thereby, a slower layer). For each hid-
den unit, there is an associated gating unit, to
which we refer by g1 and g2. For the descrip-
tion below, we use yt′−1 and ct′ for the previous
target symbol and the context vector (see Eq. (2)),
respectively.

1697



Let us start with the faster layer. The faster layer
outputs two sets of activations, a normal output h1t′
and its gated version ȟ1t′ . The activation of the
faster layer is computed by

h1t′ = tanh
(
Wh

1
[
ey(yt′−1); ȟ1t′−1; ĥ

2
t′−1; ct′

])
,

where ȟ1t′−1 and ĥ
2
t′−1 are the gated activations of

the faster and slower layers respectively. These
gated activations are computed by

ȟ1t′ = (1− g1t′)� h1t′ , ĥ2t′ = g1t′ � h2t′ .
In other words, the faster layer’s activation is

based on the adaptive combination of the faster
and slower layers’ activations from the previous
time step. Whenever the faster layer determines
that it needs to reset, i.e., g1t′−1 ≈ 1, the next
activation will be determined based more on the
slower layer’s activation.

The faster layer’s gating unit is computed by

g1t′ = σ
(
Wg

1
[
ey(yt′−1); ȟ1t′−1; ĥ

2
t′−1; ct′

])
,

where σ is a sigmoid function.
The slower layer also outputs two sets of acti-

vations, a normal output h2t′ and its gated version
ȟ2t′ . These activations are computed as follows:

h2t′ = (1− g1t′)� h2t′−1 + g1t′ � h̃2t′ ,
ȟ2t′ = (1− g2t′)� h2t′ ,

where h̃2t′ is a candidate activation. The slower
layer’s gating unit g2t′ is computed by

g2t′ =σ
(
Wg

2 [
(g1t′ � h1t′); ȟ2t′−1; ct′

])
.

This adaptive leaky integration based on the gat-
ing unit from the faster layer has a consequence
that the slower layer updates its activation only
when the faster layer resets. This puts a soft con-
straint that the faster layer runs at a faster rate by
preventing the slower layer from updating while
the faster layer is processing a current chunk.

The candidate activation is then computed by

h̃2t′ = tanh
(
Wh

2 [
(g1t′ � h1t′); ȟ2t′−1; ct′

])
. (5)

ȟ2t′−1 indicates the reset activation from the pre-
vious time step, similarly to what happened in the
faster layer, and ct′ is the input from the context.

According to g1t′�h1t′ in Eq. (5), the faster layer
influences the slower layer, only when the faster

Figure 2: (left) The BLEU scores on En-Cs
w.r.t. the length of source sentences. (right) The
difference of word negative log-probabilities be-
tween the subword-level decoder and either of the
character-level base or bi-scale decoder.

layer has finished processing the current chunk
and is about to reset itself (g1t′ ≈ 1). In other
words, the slower layer does not receive any in-
put from the faster layer, until the faster layer has
quickly processed the current chunk, thereby run-
ning at a slower rate than the faster layer does.

At each time step, the final output of the pro-
posed bi-scale recurrent neural network is the con-
catenation of the output vectors of the faster and
slower layers, i.e.,

[
h1; h2

]
. This concatenated

vector is used to compute the probability distribu-
tion over all the symbols in the vocabulary, as in
Eq. (4). See Fig. 1 for graphical illustration.

5 Experiment Settings

For evaluation, we represent a source sentence as
a sequence of subword symbols extracted by byte-
pair encoding (BPE, Sennrich et al. (2015)) and a
target sentence either as a sequence of BPE-based
symbols or as a sequence of characters.

Corpora and Preprocessing We use all avail-
able parallel corpora for four language pairs from
WMT’15: En-Cs, En-De, En-Ru and En-Fi. They
consist of 12.1M, 4.5M, 2.3M and 2M sentence
pairs, respectively. We tokenize each corpus using
a tokenization script included in Moses.4 We only
use the sentence pairs, when the source side is up
to 50 subword symbols long and the target side is
either up to 100 subword symbols or 500 charac-
ters. We do not use any monolingual corpus.

For all the pairs other than En-Fi, we use
newstest-2013 as a development set, and newstest-
2014 (Test1) and newstest-2015 (Test2) as test sets.
For En-Fi, we use newsdev-2015 and newstest-
2015 as development and test sets, respectively.

4Although tokenization is not necessary for character-
level modelling, we tokenize the all target side corpora to
make comparison against word-level modelling easier.

1698



Sr
c

De
pt

h Attention

M
od

el Development Test1 Test2
Trgt h1 h2 Single Ens Single Ens Single Ens

E
n-

D
e

(a)

B
PE

BPE 1 D Base 20.78 – 19.98 – 21.72 –
(b) 2 D D 21.2621.4520.62 23.49 20.4720.8819.30 23.10 22.0222.2121.35 24.83
(c)

Char

2 D Base 21.57
21.88
20.88 23.14 21.3321.5619.82 23.11 23.4523.9121.72 25.24

(d) 2 D D 20.31 – 19.70 – 21.30 –
(e) 2 D

Bi-S
21.2921.4321.13 23.05 21.2521.4720.62 23.04 23.0623.4722.85 25.44

(f) 2 D D 20.78 – 20.19 – 22.26 –
(g) 2 D 20.08 – 19.39 – 20.94 –

State-of-the-art Non-Neural Approach∗ – 20.60(1) 24.00(2)

E
n-

C
s (h)

B
PE

BPE 2 D D Base 16.1216.9615.96 19.21 17.1617.6816.38 20.79 14.6315.0914.26 17.61
(i) Char 2 D Base 17.68

17.78
17.39 19.52 19.2519.5518.89 21.95 16.9817.1716.81 18.92

(j) 2 D Bi-S 17.6217.9317.43 19.83 19.2719.5319.15 22.15 16.8617.1016.68 18.93
State-of-the-art Non-Neural Approach∗ – 21.00(3) 18.20(4)

E
n-

R
u

(k)

B
PE

BPE 2 D D Base 18.5618.7018.26 21.17 25.3025.4024.95 29.26 19.7220.2919.02 22.96
(l) Char 2 D Base 18.56

18.87
18.39 20.53 26.0026.0725.04 29.37 21.1021.2420.14 23.51

(m) 2 D Bi-S 18.3018.5417.88 20.53 25.5925.7624.57 29.26 20.7321.0219.97 23.75
State-of-the-art Non-Neural Approach∗ – 28.70(5) 24.30(6)

E
n-

Fi

(n)

B
PE

BPE 2 D D Base 9.6110.029.24 11.92 – – 8.979.178.88 11.73
(o) Char 2 D Base 11.19

11.55
11.09 13.72 – – 10.9311.5610.11 13.48

(p) 2 D Bi-S 10.7311.0410.40 13.39 – – 10.2410.639.71 13.32
State-of-the-art Non-Neural Approach∗ – – 12.70(7)

Table 1: BLEU scores of the subword-level, character-level base and character-level bi-scale decoders
for both single models and ensembles. The best scores among the single models per language pair
are bold-faced, and those among the ensembles are underlined. When available, we report the median
value, and the minimum and maximum values as a subscript and a superscript, respectively. (∗) http:
//matrix.statmt.org/ as of 11 March 2016 (constrained only). (1) Freitag et al. (2014). (2, 6) Williams et al. (2015).

(3, 5) Durrani et al. (2014). (4) Haddow et al. (2015). (7) Rubino et al. (2015).

Models and Training We test three models set-
tings: (1) BPE→BPE, (2) BPE→Char (base) and
(3) BPE→Char (bi-scale). The latter two differ by
the type of recurrent neural network we use. We
use GRUs for the encoder in all the settings. We
used GRUs for the decoders in the first two set-
tings, (1) and (2), while the proposed bi-scale re-
current network was used in the last setting, (3).
The encoder has 512 hidden units for each direc-
tion (forward and reverse), and the decoder has
1024 hidden units per layer.

We train each model using stochastic gradient
descent with Adam (Kingma and Ba, 2014). Each
update is computed using a minibatch of 128 sen-
tence pairs. The norm of the gradient is clipped
with a threshold 1 (Pascanu et al., 2013).

Decoding and Evaluation We use beamsearch
to approximately find the most likely translation
given a source sentence. The beam widths are
5 and 15 respectively for the subword-level and
character-level decoders. They were chosen based
on the translation quality on the development set.

The translations are evaluated using BLEU.5

Multilayer Decoder and Soft-Alignment Mech-
anism When the decoder is a multilayer re-
current neural network (including a stacked net-
work as well as the proposed bi-scale network),
the decoder outputs multiple hidden vectors–{
h1, . . . ,hL

}
for L layers, at a time. This allows

an extra degree of freedom in the soft-alignment
mechanism (fscore in Eq. (3)). We evaluate using
alternatives, including (1) using only hL (slower
layer) and (2) using all of them (concatenated).

Ensembles We also evaluate an ensemble of
neural machine translation models and compare
its performance against the state-of-the-art phrase-
based translation systems on all four language
pairs. We decode from an ensemble by taking the
average of the output probabilities at each step.

6 Quantitative Analysis

Slower Layer for Alignment On En-De, we
test which layer of the decoder should be used

5We used the multi-bleu.perl script from Moses.

1699



Figure 3: Alignment matrix of a test example from En-De using the BPE→Char (bi-scale) model.

for computing soft-alignments. In the case of
subword-level decoder, we observed no difference
between choosing any of the two layers of the de-
coder against using the concatenation of all the
layers (Table 1 (a–b)) On the other hand, with the
character-level decoder, we noticed an improve-
ment when only the slower layer (h2) was used
for the soft-alignment mechanism (Table 1 (c–g)).
This suggests that the soft-alignment mechanism
benefits by aligning a larger chunk in the target
with a subword unit in the source, and we use only
the slower layer for all the other language pairs.

Single Models In Table 1, we present a com-
prehensive report of the translation qualities of
(1) subword-level decoder, (2) character-level base
decoder and (3) character-level bi-scale decoder,
for all the language pairs. We see that the both
types of character-level decoder outperform the
subword-level decoder for En-Cs and En-Fi quite
significantly. On En-De, the character-level base
decoder outperforms both the subword-level de-
coder and the character-level bi-scale decoder,
validating the effectiveness of the character-level
modelling. On En-Ru, among the single mod-
els, the character-level decoders outperform the
subword-level decoder, but in general, we observe
that all the three alternatives work comparable to
each other.

These results clearly suggest that it is indeed
possible to do character-level translation without
explicit segmentation. In fact, what we observed is
that character-level translation often surpasses the
translation quality of word-level translation. Of
course, we note once again that our experiment is
restricted to using an unsegmented character se-
quence at the decoder only, and a further explo-
ration toward replacing the source sentence with
an unsegmented character sequence is needed.

Ensembles Each ensemble was built using eight
independent models. The first observation we
make is that in all the language pairs, neural ma-

chine translation performs comparably to, or often
better than, the state-of-the-art non-neural transla-
tion system. Furthermore, the character-level de-
coders outperform the subword-level decoder in
all the cases.

7 Qualitative Analysis

(1) Can the character-level decoder generate
a long, coherent sentence? The translation in
characters is dramatically longer than that in
words, likely making it more difficult for a recur-
rent neural network to generate a coherent sen-
tence in characters. This belief turned out to be
false. As shown in Fig. 2 (left), there is no sig-
nificant difference between the subword-level and
character-level decoders, even though the lengths
of the generated translations are generally 5–10
times longer in characters.

(2) Does the character-level decoder help with
rare words? One advantage of character-level
modelling is that it can model the composition of
any character sequence, thereby better modelling
rare morphological variants. We empirically con-
firm this by observing the growing gap in the aver-
age negative log-probability of words between the
subword-level and character-level decoders as the
frequency of the words decreases. This is shown
in Fig. 2 (right) and explains one potential cause
behind the success of character-level decoding in
our experiments (we define diff(x, y) = x− y).
(3) Can the character-level decoder soft-align
between a source word and a target charac-
ter? In Fig. 3 (left), we show an example soft-
alignment of a source sentence, “Two sets of light
so close to one another”. It is clear that the
character-level translation model well captured the
alignment between the source subwords and tar-
get characters. We observe that the character-
level decoder correctly aligns to “lights” and “sets
of” when generating a German compound word

1700



“Lichtersets” (see Fig. 3 (right) for the zoomed-
in version). This type of behaviour happens simi-
larly between “one another” and “einander”. Of
course, this does not mean that there exists an
alignment between a source word and a target
character. Rather, this suggests that the internal
state of the character-level decoder, the base or bi-
scale, well captures the meaningful chunk of char-
acters, allowing the model to map it to a larger
chunk (subword) in the source.

(4) How fast is the decoding speed of the
character-level decoder? We evaluate the de-
coding speed of subword-level base, character-
level base and character-level bi-scale decoders on
newstest2013 corpus (En-De) with a single Titan
X GPU. The subword-level base decoder gener-
ates 31.9 words per second, and the character-level
base decoder and character-level bi-scale decoder
generate 27.5 words per second and 25.6 words
per second, respectively. Note that this is evalu-
ated in an online setting, performing consecutive
translation, where only one sentence is translated
at a time. Translating in a batch setting could dif-
fer from these results.

8 Conclusion

In this paper, we addressed a fundamental ques-
tion on whether a recently proposed neural ma-
chine translation system can directly handle trans-
lation at the level of characters without any word
segmentation. We focused on the target side, in
which a decoder was asked to generate one char-
acter at a time, while soft-aligning between a tar-
get character and a source subword. Our extensive
experiments, on four language pairs–En-Cs, En-
De, En-Ru and En-Fi– strongly suggest that it is
indeed possible for neural machine translation to
translate at the level of characters, and that it actu-
ally benefits from doing so.

Our result has one limitation that we used sub-
word symbols in the source side. However, this
has allowed us a more fine-grained analysis, but in
the future, a setting where the source side is also
represented as a character sequence must be inves-
tigated.

Acknowledgments

The authors would like to thank the developers
of Theano (Team et al., 2016). We acknowledge
the support of the following agencies for research

funding and computing support: NSERC, Calcul
Québec, Compute Canada, the Canada Research
Chairs, CIFAR and Samsung. KC thanks the sup-
port by Facebook, Google (Google Faculty Award
2016) and NVIDIA (GPU Center of Excellence
2015-2016). JC thanks Orhan Firat for his con-
structive feedbacks.

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-

gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proceedings of
the International Conference on Learning Represen-
tations (ICLR).

Yoshua Bengio, Patrice Simard, and Paolo Frasconi.
1994. Learning long-term dependencies with gradi-
ent descent is difficult. IEEE Transactions on Neu-
ral Networks, 5(2):157–166.

Yoshua Bengio, Réjean Ducharme, and Pascal Vincent.
2001. A neural probabilistic language model. In Ad-
vances in Neural Information Processing Systems,
pages 932–938.

Geert Booij. 2012. The grammar of words: An intro-
duction to linguistic morphology. Oxford University
Press.

Jan A Botha and Phil Blunsom. 2014. Compositional
morphology for word representations and language
modelling. In ICML 2014.

Rohan Chitnis and John DeNero. 2015. Variable-
length word encodings for neural translation models.
In Proceedings of the 2015 Conference on Empiri-
cal Methods in Natural Language Processing, pages
2088–2093.

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Fethi Bougares, Holger Schwenk, and Yoshua
Bengio. 2014. Learning phrase representations
using RNN encoder-decoder for statistical machine
translation. In Proceedings of the Empiricial
Methods in Natural Language Processing (EMNLP
2014), October.

Junyoung Chung, Caglar Gulcehre, Kyunghyun Cho,
and Yoshua Bengio. 2015. Gated feedback recur-
rent neural networks. In Proceedings of the 32nd
International Conference on Machine Learning.

Marta R Costa-Jussà and José AR Fonollosa. 2016.
Character-based neural machine translation. arXiv
preprint arXiv:1603.00810.

Mathias Creutz and Krista Lagus. 2005. Unsupervised
morpheme segmentation and morphology induction
from text corpora using Morfessor 1.0. Helsinki
University of Technology.

1701



Nadir Durrani, Barry Haddow, Philipp Koehn, and
Kenneth Heafield. 2014. Edinburgh’s phrase-based
machine translation systems for wmt-14. In Pro-
ceedings of the ACL 2014 Ninth Workshop on Sta-
tistical Machine Translation, Baltimore, MD, USA,
pages 97–104.

Markus Freitag, Stephan Peitz, Joern Wuebker, Her-
mann Ney, Matthias Huck, Rico Sennrich, Nadir
Durrani, Maria Nadejde, Philip Williams, Philipp
Koehn, et al. 2014. Eu-bridge mt: Combined ma-
chine translation.

Dan Gillick, Cliff Brunk, Oriol Vinyals, and Amarnag
Subramanya. 2015. Multilingual language process-
ing from bytes. arXiv preprint arXiv:1512.00103.

Barry Haddow, Matthias Huck, Alexandra Birch, Niko-
lay Bogoychev, and Philipp Koehn. 2015. The edin-
burgh/jhu phrase-based machine translation systems
for wmt 2015. In Proceedings of the Tenth Work-
shop on Statistical Machine Translation, pages 126–
133.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Sepp Hochreiter. 1998. The vanishing gradient
problem during learning recurrent neural nets and
problem solutions. International Journal of Un-
certainty, Fuzziness and Knowledge-Based Systems,
6(02):107–116.

Changning Huang and Hai Zhao. 2007. Chinese word
segmentation: A decade review. Journal of Chinese
Information Processing, 21(3):8–20.

Sébastien Jean, Kyunghyun Cho, Roland Memisevic,
and Yoshua Bengio. 2015. On using very large
target vocabulary for neural machine translation.
In Proceedings of the 53rd Annual Meeting of the
Association for Computational Linguistics: Short
Papers-Volume 2.

Yoon Kim, Yacine Jernite, David Sontag, and Alexan-
der M Rush. 2015. Character-aware neural lan-
guage models. arXiv preprint arXiv:1508.06615.

Diederik Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980.

Hyoung-Gyu Lee, JaeSong Lee, Jun-Seok Kim, and
Chang-Ki Lee. 2015. Naver machine translation
system for wat 2015. In Proceedings of the 2nd
Workshop on Asian Translation (WAT2015), pages
69–73.

Wang Ling, Tiago Luı́s, Luı́s Marujo, Ramón Fernan-
dez Astudillo, Silvio Amir, Chris Dyer, Alan W
Black, and Isabel Trancoso. 2015a. Finding
function in form: Compositional character models
for open vocabulary word representation. arXiv
preprint arXiv:1508.02096.

Wang Ling, Isabel Trancoso, Chris Dyer, and Alan W
Black. 2015b. Character-based neural machine
translation. arXiv preprint arXiv:1511.04586.

Thang Luong, Richard Socher, and Christopher D
Manning. 2013. Better word representations
with recursive neural networks for morphology. In
CoNLL, pages 104–113.

Minh-Thang Luong, Hieu Pham, and Christopher D
Manning. 2015a. Effective approaches to attention-
based neural machine translation. arXiv preprint
arXiv:1508.04025.

Minh-Thang Luong, Ilya Sutskever, Quoc V Le, Oriol
Vinyals, and Wojciech Zaremba. 2015b. Address-
ing the rare word problem in neural machine trans-
lation. arXiv preprint arXiv:1410.8206.

Tomas Mikolov, Martin Karafiát, Lukas Burget, Jan
Cernockỳ, and Sanjeev Khudanpur. 2010. Recur-
rent neural network based language model. In IN-
TERSPEECH, volume 2, page 3.

Tomas Mikolov, Ilya Sutskever, Anoop Deoras, Hai-
Son Le, Stefan Kombrink, and J Cernocky. 2012.
Subword language modeling with neural networks.
Preprint.

Graham Neubig, Taro Watanabe, Shinsuke Mori, and
Tatsuya Kawahara. 2013. Substring-based machine
translation. Machine translation, 27(2):139–166.

Razvan Pascanu, Caglar Gulcehre, Kyunghyun Cho,
and Yoshua Bengio. 2013. How to construct
deep recurrent neural networks. arXiv preprint
arXiv:1312.6026.

Raphael Rubino, Tommi Pirinen, Miquel Espla-Gomis,
N Ljubešic, Sergio Ortiz Rojas, Vassilis Papavassil-
iou, Prokopis Prokopidis, and Antonio Toral. 2015.
Abu-matran at wmt 2015 translation task: Morpho-
logical segmentation and web crawling. In Proceed-
ings of the Tenth Workshop on Statistical Machine
Translation, pages 184–191.

Cicero D Santos and Bianca Zadrozny. 2014. Learning
character-level representations for part-of-speech
tagging. In Proceedings of the 31st International
Conference on Machine Learning (ICML-14), pages
1818–1826.

Holger Schwenk. 2007. Continuous space language
models. Computer Speech & Language, 21(3):492–
518.

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2015. Neural machine translation of rare words with
subword units. arXiv preprint arXiv:1508.07909.

Rupesh K Srivastava, Klaus Greff, and Jürgen Schmid-
huber. 2015. Training very deep networks. In Ad-
vances in Neural Information Processing Systems,
pages 2368–2376.

1702



Ilya Sutskever, James Martens, and Geoffrey E Hin-
ton. 2011. Generating text with recurrent neural
networks. In Proceedings of the 28th International
Conference on Machine Learning (ICML’11), pages
1017–1024.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In Advances in Neural Information Process-
ing Systems, pages 3104–3112.

The Theano Development Team, Rami Al-Rfou,
Guillaume Alain, Amjad Almahairi, Christof
Angermueller, Dzmitry Bahdanau, Nicolas Ballas,
Frédéric Bastien, Justin Bayer, Anatoly Belikov,
et al. 2016. Theano: A python framework for fast
computation of mathematical expressions. arXiv
preprint arXiv:1605.02688.

David Vilar, Jan-T Peter, and Hermann Ney. 2007.
Can we translate letters? In Proceedings of the
Second Workshop on Statistical Machine Transla-
tion, pages 33–39. Association for Computational
Linguistics.

Philip Williams, Rico Sennrich, Maria Nadejde,
Matthias Huck, and Philipp Koehn. 2015. Edin-
burgh’s syntax-based systems at wmt 2015. In Pro-
ceedings of the Tenth Workshop on Statistical Ma-
chine Translation, pages 199–209.

Yijun Xiao and Kyunghyun Cho. 2016. Efficient
character-level document classification by combin-
ing convolution and recurrent layers. arXiv preprint
arXiv:1602.00367.

Xiang Zhang, Junbo Zhao, and Yann LeCun. 2015.
Character-level convolutional networks for text clas-
sification. In Advances in Neural Information Pro-
cessing Systems, pages 649–657.

1703


