



















































Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics


Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1745–1755
Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/P17-1160

Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1745–1755
Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/P17-1160

Generic Axiomatization of Families of Noncrossing Graphs in
Dependency Parsing

Anssi Yli-Jyrä
University of Helsinki, Finland

anssi.yli-jyra@helsinki.fi

Carlos Gómez-Rodrı́guez
Universidade da Coruña, Spain
carlos.gomez@udc.es

Abstract

We present a simple encoding for unla-
beled noncrossing graphs and show how
its latent counterpart helps us to repre-
sent several families of directed and undi-
rected graphs used in syntactic and seman-
tic parsing of natural language as context-
free languages. The families are separated
purely on the basis of forbidden patterns
in latent encoding, eliminating the need to
differentiate the families of non-crossing
graphs in inference algorithms: one algo-
rithm works for all when the search space
can be controlled in parser input.

1 Introduction

Dependency parsing has received wide attention in
recent years, as accurate and efficient dependency
parsers have appeared that are applicable to many
languages. Traditionally, dependency parsers have
produced syntactic analyses in tree form, includ-
ing exact inference algorithms that search for max-
imum projective trees (Eisner and Satta, 1999) and
maximum spanning trees (McDonald et al., 2005)
in weighted digraphs, as well as greedy and beam-
search approaches that forgo exact search for extra
efficiency (Zhang and Nivre, 2011).

Recently, there has been growing interest in pro-
viding a richer analysis of natural language by go-
ing beyond trees. In semantic dependency parsing
(Oepen et al., 2015; Kuhlmann and Oepen, 2016),
the desired syntactic representations can have in-
degree greater than 1 (re-entrancy), suggesting the
search for maximum acyclic subgraphs (Schluter,
2014, 2015). As this inference task is intractable
(Guruswami et al., 2011), noncrossing digraphs
have been studied instead, e.g. by Kuhlmann and
Johnsson (2015) who provide a O(n3) parser for
maximum noncrossing acyclic subgraphs.

Yli-Jyrä (2005) studied how to axiomatize de-
pendency trees as a special case of noncrossing di-
graphs. This gave rise to a new homomorphic rep-
resentation of context-free languages that proves
the classical Chomsky and Schützenberger theo-
rem using a quite different internal language. In
this language, the brackets indicate arcs in a de-
pendency tree in a way that is reminiscent to en-
coding schemes used earlier by Greibach (1973)
and Oflazer (2003). Cubic-time parsing algo-
rithms that are incidentally or intentionally appli-
cable to this kind of homomorphic representations
have been considered, e.g., by Nederhof and Satta
(2003), Hulden (2011), and Yli-Jyrä (2012).

Extending these insights to arbitrary noncross-
ing digraphs, or to relevant families of them, is far
from obvious. In this paper, we develop (1) a lin-
ear encoding supporting general noncrossing di-
graphs, and (2) show that the encoded noncrossing
digraphs form a context-free language. We then
give it (3) two homomorphic, nonderivative repre-
sentations and use the latent local features of the
latter to characterize various families of digraphs.

Apart from the obvious relevance to the theory
of context-free languages, this contribution has the
practical potential to enable (4) generic context-
free parsers that produce different families of non-
crossing graphs with the same set of inference
rules while the search space in each case is re-
stricted with lexical features and the grammar.

Outline After some background on graphs and
parsing as inference (Section 2), we use an on-
tology of digraphs to illustrate natural families
of noncrossing digraphs in Section 3. We then
develop, in Section 4, the first latent context-
free representation for the set of noncrossing di-
graphs, then extended in Section 5 with additional
latent states supporting our finite-state axiomati-
zation of digraph properties, and allowing us to

1745

https://doi.org/10.18653/v1/P17-1160
https://doi.org/10.18653/v1/P17-1160


control the search space using the lexicon. The
experiments in Section 6 cross-validate our ax-
ioms and sample the growth of the constrained
search spaces. Section 7 outlines the applications
for practical parsing, and Section 8 concludes.

2 Background

Graphs and Digraphs A graph is a pair (V,E)
where V is a finite set of vertices and E ⊆
{{u,v} ⊆ V} is a set of edges. A sequence
of edges of the form {v0,v1}, {v1,v2}, ...,
{vm−1,vm}, with no repetitions in v1, ...,vm, is a
path between vertices v0 and vm and empty if m =
0. A graph is a forest if no vertex has a non-empty
path to itself and connected if all pairs of vertices
have a path. A tree is a connected forest.

A digraph is a pair (V,A) where A ⊆ V ×V is
a set of arcs u→ v, thus a directed graph. Its un-
derlying graph, (V,EA), has edges EA = {{u,v} |
(u,v) ∈ A}. A sequence of arcs v0 → v1,v1 →
v2, ...,vm−1→ vm, with no repetitions in v1, . . . ,vm,
is a directed path, and empty if m = 0.

A digraph without self-loops v→ v is loop-free
(property DIGRAPHLF). We will focus on loop-
free digraphs unless otherwise specified, and de-
note them just by DIGRAPH for brevity. A di-
graph is d-acyclic (ACYCD), aka a dag if no ver-
tex has a non-empty directed path to itself, u-
acyclic (ACYCU) aka a m(ixed)-forest if its under-
lying graph is a forest, and weakly connected (w.c.,
CONNW) if its underlying graph is connected.

Dependency Parsing The complete digraph
GS(V,A) of a sentence S = x1...xn consists of ver-
tices V = {1, ...,n} and all possible arcs A = V ×
V −{(i, i)}. The vertex i ∈ V corresponds to the
word xi and the arc i → j ∈ A corresponds to a
possible dependency between the words xi and x j.

The task of dependency parsing is to find a con-
strained subgraph G′S(V,A

′) of the complete di-
graph GS of the sentence. The standard solution
is a rooted directed tree called a dependency tree
or a dag called a dependency graph.

Constrained Inference In arc-factored parsing
(McDonald et al., 2005), each possible arc i→ j is
equipped with a positive weight wi j, usually com-
puted as a weighted sum wi j = w ·Φ(S, i → j)
where w is a weight vector and Φ(x, i→ j) a fea-
ture vector extracted from the sentence x, con-
sidering the dependency relation from word xi to
word x j. Parsing then consists in finding an arc

subset A′ ⊆ A that gives us a constrained sub-
graph (V,A′) ∈ Constrained(V,A) of the complete
digraph (V,A) with maximum sum of arc weights:

(V,A′) = argmax
(V,A′) ∈ Constrained(V,A)

∑
i→ j∈A′

wi, j.

The complexity of this inference task depends on
the constraints imposed on the subgraph. Un-
der no constraints, we simply set A′ = A. Infer-
ence over dags is intractable (Guruswami et al.,
2011). Efficient solutions are known for projective
trees (Eisner, 1996), various classes of mildly non-
projective trees (Gómez-Rodrı́guez, 2016), unre-
stricted spanning trees (McDonald et al., 2005),
and both unrestricted and weakly connected non-
crossing dags (Kuhlmann and Johnsson, 2015).

Parsimony Semantic parsers must be able to
produce more than projective trees because the
share of projective trees is pretty low (under 3%)
in semantic graph banks (Kuhlmann and Johnsson,
2015). However, if we know that the parses have
some restrictions, it is better to use them to restrict
the search space as much as possible.

There are two strategies for reducing the search
space. One is to develop a specialized infer-
ence algorithm for a particular natural language or
family of dags, such as weakly connected graphs
(Kuhlmann and Johnsson, 2015). The other strat-
egy is to control the local complexity of digraphs
through lexical categories (Baldridge and Kruijff,
2003) or equivalent mechanisms. This strategy
produces a more sensitive model of the language,
but requires a principled insight on how the com-
plexity of digraphs can be characterized.

3 Constraints on the Search Space

We will now present a classification of digraphs on
the basis of their formal properties.

The Noncrossing Property For convenience,
graphs and digraphs may be ordered like in a
complete digraph of a sentence. Two edges
{i, j}, {k, l} in an ordered graph or arcs i →
j,k → l in an ordered digraph are said to be
crossing if min{i, j} < min{k, l} < max{i, j} <
max{k, l}. A graph or digraph is noncrossing if
it has no crossing edges or arcs. Noncrossing
(di)graphs (NC-(DI)GRAPH) are the largest pos-
sible (di)graphs that can be drawn on a circle with-
out crossing arcs. In the following, we assume that
all digraphs and graphs are noncrossing.

1746



An arc x→ y is (properly) covered by an arc z→
t if ({x,y} 6= {z, t}) and min{z, t} ≤ min{x,y} ≤
max{x,y} ≤max{z, t}.

Ontology Fig. 1 presents an ontology of such
families of loop-free noncrossing digraphs that
can be distinguished by digraphs with 5 vertices.

In the digraph ontology, a multitree aka man-
grove is a dag with the property of being strongly
unambiguous (UNAMBS), which asserts that,
given two distinct vertices, there is at most one
repeat-free path between them (Lange, 1997).1 A
polytree (Rebane and Pearl, 1987) is a multitree
whose underlying graph is a tree. The out property
(OUT) of a digraph (V,E) means that no vertex
i ∈V has two incoming arcs { j,k}→ i s.t. j 6= k.

NC-DIGRAPH
+5460

CONNW
+43571

UNAMBS
+80

ORIENTED
+140

ACYCU
+1200

OUT
+10

w.c.unamb.
+600

w.c.or.
+1160

unamb.or.
+80

ACYCD
+840

out oriented
+130

out m-forest
+435

mixed tree
+3355

multitree
+10

w.c.dag
+2960

w.c.unamb.or.
+370

out mixed tree
+220

w.c. out oriented
+132

w.c.multitree
+50

or.forest
+300

polytree
+605

out or.forest
+481

out or.tree
+275

Figure 1: Basic properties split the set of 62464
noncrossing digraphs for 5 vertices into 23 classes

An ordered digraph is weakly projective
(PROJW) if for all vertices i, j and k, if k→ j→ i,
then either {i, j}< k or {i, j}> k. In other words,
the constraint, aka the outside-to-inside constraint
(Yli-Jyrä, 2005), states that no outgoing arc of a
vertex properly covers an incoming arc. This is
implied by a stronger constraint known as Harper,
Hays, Lecerf and Ihm projectivity (Marcus, 1967).

We can embed the ontology of graphs (un-
restricted, connected, forests and trees) into the
ontology of digraphs by viewing an undirected
graph (V,E) as an inverse digraph (V,{(i, j),( j, i) |
{i, j} ∈ E}). This kind of digraph has an inverse
property (INV). Its opposite is an oriented (or.) di-
graph (V,A) where i→ j ∈ A implies j → i /∈ A
(defines the property ORIENTED). Out forests
and trees are, by convention, oriented digraphs
with an underlying forest or tree, respectively.

1A different definition forbids diamonds as minors.

Distinctive Properties A few important proper-
ties of digraphs are local and can be verified by
inspecting each vertex separately with its incident
arcs. These include (i) the out property (OUT), (ii)
the nonstandard projectivity property (PROJW),
(iii) the inverse property (INV) and (iv) the ori-
entedness (or.) property.

Properties UNAMBS, ACYCD, CONNW, and
ACYCU are nonlocal properties of digraphs and
cannot be generally verified locally, through finite
spheres of vertices (Grädel et al., 2005). The fol-
lowing proposition covers the configurations that
we have to detect in order to decide the nonlocal
properties of noncrossing digraphs.

Proposition 1. Let G = (V,E) be a noncrossing
digraph.

• If G /∈ UNAMBS, then the digraph contains
one of the following four configurations or
their reversals:

u v y u v y u v y u v x y

• If G /∈ ACYCD, then the graph contains one
of the configurations

u v y u v y u v

• If G /∈ ACYCU, then the underlying graph
contains the following configuration:

u v y

• If G /∈ CONNW, then the underlying graph
contains one of the following configurations:

... v y ...

no arc no arc

... v ...

no arc no arc

Proposition 1 gives us a means to implement the
property tests in practice. It tells us intuitively that
although the paths can be arbitrarily long, any un-
derlying cycle containing more than 2 arcs con-
sists of one covering arc and a linear chain of
edges between its end points.

4 The Set of Digraphs as a Language

In this section, we show that the set of noncross-
ing digraphs is isomorphic to an unambiguous
context-free language over a bracket alphabet.

4.1 Basic Encoding
Any noncrossing ordered graph ([1, ...,n],E), even
with self-loops, can be encoded as a string of
brackets using the algorithm enc in Fig. 2. For
example, the output for the ordered graph

1747



func enc(n,E): func dec(stdin):
for i in [1,...,n]: n = 1; E = {}; s = []

for j in [i-1,...,2,1]: while c in stdin:
if {j,i} in E: if c == "[":

print "]" s.push(n)
for j in [n,n-1,...,i+1]: if c == "]":

if {i,j} in E: i = s.pop()
print "[" E.insert((i,n))

if {i,i} in E: if c == "{":
print "[]" n = n + 1

if i<n:
print "{}" return (n,E)

Figure 2: The encoding and decoding algorithms

1 2 3 4
n = 4, E =

{
{1,2}, {2,2}
{2,4}, {1,4}

}

is the string [[{}][[]{}{}]]. Intuitively, pairs of
brackets of the form {} can be interpreted as spaces
between vertices, and then each set of matching
brackets [...] encodes an arc that covers the
spaces represented inside the brackets.

Any noncrossing ordered digraph ([1, . . . ,n],A)
can be encoded with slight modifications to the
algorithm. Instead of printing [ ] for an edge
{i, j} ∈ EA, i≤ j, the algorithm should now print

/ > if (i, j) ∈ A,( j, i) 6∈ A;
<
/ if (i, j) /∈ A,( j, i) ∈ A;

[ ] if (i, j),( j, i) ∈ A.

In this way, we can simply encode the di-
graph ({1,2,3,4},{(1,2),(2,2),(4,1),(4,2)}) as
the string </{}><[]{}{}//.
Proposition 2. The encoding respects concatena-
tion where the adjacent nonempty operands have
a common vertex.

Context-Freeness Arbitrary strings with bal-
anced brackets form a context-free language that
is known, generically, as a Dyck language. It is
easy to see that the graphs NC-GRAPH are en-
coded with strings that belong to the Dyck lan-
guage D2 generated by the context-free gram-
mar: S→ [S]S | {S}S | ε . The encoded graphs,
LNC-GRAPH, are, however, generated exactly by
the context-free grammar S → [S′] S | {} S | ε ,
S′→ [S′] T | {} S, T → [S′] S | {} S. This lan-
guage is an unambiguous context-free language.

Proposition 3. The encoded graphs, LNC-GRAPH,
make an unambiguous context-free language.

The practical significance of Proposition 3 is
that there is a bijection between LNC-GRAPH and
the derivation trees of a context-free grammar.

4.2 Bracketing Beyond the Encoding
Non-Derivational Representation A non-
derivational representation for any context-free

language L has been given by Chomsky and
Schützenberger (1963). This replaces the stack
with a Dyck language D and the grammar rules
with co-occurrence patterns specified by a regular
language Reg. To hide the internal alphabet from
the strings of the represented language, there is
a homomorphism that cleans the internal strings
of Reg and D from internal markup to get actual
strings of the target language:

LNC-GRAPH = h(D∩Reg).

To make this concrete, replace the previous con-
text free grammar by S′′ → [′S′]′ S | {} S | ε ,
S→ [S′] S | {} S | ε , S′→ [′S′]′ T | {} S, T →
[S′] S | {} S. The homomorphism h (Fig. 3a)
would now relate this language to the original lan-
guage, mapping the string [′[′{}]′[[′{}]′{}]]′ to
the string [[{}][[{}]{}]], for example. The Dyck
language D = D3 checks that the internal brack-
ets are balanced, and the regular component Reg
(Fig. 3b) checks that the new brackets are used
correctly. A similar representation for the lan-
guage LNC-DIGRAPH of encoded digraphs can be
obtained with straightforward extensions.

�

������������
������������

�

�� ��
�

�
�

� �

���
�

�

(a) (b)
Figure 3: The h and Reg components

The representation L = h(D ∩ Reg) is unam-
biguous if, for every word w ∈ L, the preimage
h−1(w)∩D∩Reg is a single string. This implies
that L is an unambiguous context-free language.

Proposition 4. The set of encoded digraphs,
LNC-DIGRAPH, has an unambiguous representation.

Proposition 5. Let Li = h(D∩ Ri), i ∈ {0,1,2}
be unambiguous representations with R1,R2 ⊆ R0.
Then L3 = h(D∩ (R1 ∩ R2)) is an unambiguous
context-free language and the same as L1∩L2.
Proof. It is immediate that L3 ⊆ L1∩L2 and L3 is
an unambiguous context-free language. To show
that L1 ∩ L2 ⊆ L3, take an arbitrary s ∈ L1 ∩ L2.
Since R1,R2 ⊆ R0 there is a unique s′ ∈ h−1(s)
such that s′ ∈ D∩ (R1∩R2). Thus s ∈ L3.

5 Latent Bracketing

In this section, we extend the internal strings of the
non-derivational representation of LNC-DIGRAPH in

1748



such a way that the configurations given in Propo-
sition 1 can be detected locally from these.

Classification of Underlying Chains A maxi-
mal linear chain is a maximally long sequence of
one or more edges that correspond to an under-
lying left-to-right path in the underlying graph in
such a way that no edge in this chain is properly
covered by an edge that does not properly cover
all the edges in the chain. For example, the graph

[′[′{}]′[[′{}]′[{}]][[′{}]′{}[{}]]]′[{}[{ }]{}]

I

II III

II
III

II I

IV V VI

contains six maximal linear chains, indicated with
their Roman numbers on each arc. We decide non-
local properties of noncrossing digraphs by recog-
nizing maximal linear chains as parts of configu-
rations presented in Proposition 1.

Every loose chain (like V and VI) starts with
a bracket that is adjacent to a }-bracket. Such a
chain can contribute only a covering edge to an un-
derlying cycle. In contrast, a bracket with an apos-
trophe marks the beginning of a non-loose chain
that can either start at the first vertex, or share
starting point with a covering chain. When a non-
loose chain is covered, it can be touched twice by
a covering edge. The prefixes of chains are classi-
fied incrementally, from left to right, with a finite
automaton (Figure 4). All states of the automaton
are final and correspond to distinct classes of the
chains. These classes are encoded to an extended
set of brackets.

�

������

�

����
����
����
���� �

����

�����������������
�������������������������

�

����

�

����
����
����

�

����

����
����
���� ����

�

���

�

����

������
������
������

�

����
����

����
����
����

�

�

����

����

����
����
����

�

������
��������

������
������
������

�

������

�����

����
����
����

���� ����
����
����
���� �

����

������������������
����������������������������

����

����
����
����

����
����
����

����
����

����
����
����

Figure 4: The finite automaton whose state 0 be-
gins non-loose chains and state 1 loose chains

The automaton is symmetric: states with
uppercase names are symmetrically related with

corresponding lowercase states. Thus, it suffices
to define the initial and uppercase-named states:

0 the initial state for a non-loose chain;
I a bidirectional chain: u↔ (v↔)y;
A a primarily bidirectional forward chain: u↔ v→ y;
F a forward chain: u→ v→ y;
Q a primarily forward chain: u→ v↔ (· · · →)y;
C a primarily forward 1-turn chain: u→ v← y;
E a primarily forward 2-turn chain: u→ v← x→ y;
Z a 3-turn chain;
1 the initial (and only) state for a loose chain;

Recognition of ambiguous paths in configurations
u
−−−−−→←−−→→v←y and u

−−−−−−−−−−→←−−−−−−−← v→ x←←y involves three
chain levels. To support the recognition, subtypes
of edges are defined according to the chains they
cover. The brackets >I’, \I’, >I, \I, \A, >a, \Q, >Q,
>q,\q, >C, \c, \E, >e indicate edges that constitute a
cycle with the chain they cover. The brackets >V’,
\v’, >V, \v indicate edges that cover 2-turn chains.
Not all states make these distinctions.

Extended Representation The extended brack-
ets encode the latent structure of digraphs: the ori-
entation and the subtype of the edge and the class
of the chain. The total alphabet Σ of the strings
now contains the boundary brackets {} and 54
pairs of brackets (Figure 4) for edges from which
we obtain a new Dyck language, D55, and an ex-
tended homomorphism hlat.

The Reg component of the language representa-
tion is replaced with Reglat, that is, an intersection
of (1) an inverse homomorphic image of Reg to
strings over the extended alphabet, (2) a local lan-
guage that constrains adjacent edges according to
Figure 4, (3) a local language specifying how the
chains start, and (4) a local language that distin-
guishes pure oriented edges from those that cover
a cycle or a 2-turn chain. The new component re-
quires only 24 states as a deterministic automaton.

Proposition 6. hlat(D55∩Reglat) is an unambigu-
ous representation for LNC-DIGRAPH.

The internal language LNC-DIGRAPHlat = D55 ∩
Reglat is called the set of latent encoded digraphs.

Example Here is a digraph with its latent
encoding:

<f′ [I′︸ ︷︷ ︸
1

{}]I′ /0 /F′︸ ︷︷ ︸
2

{} >F′︸︷︷︸
3

{} <.︸︷︷︸
4

{} /.︸︷︷︸
5

{} >.︸︷︷︸
6

{}/. >0 /f′︸ ︷︷ ︸
7

The brackets in the extended representation con-
tain information that helps us recognize, through
local patterns, that this graph has a directed cycle

1749



Forbidden patterns in noncrossing digraphş Property Constraint language

RlooseR
a nonloose chain ACYCU AU = Σ∗−Σ∗RlooseRΣ∗

Rloose(no connecting edges) (a vertex without edges) CONNW CW = Σ
∗−Σ∗Rloose(ε ∪BΣ∗)− (BΣ∗∪Σ∗B)

RrightR/ RleftR>
forward backward

inverted arc ACYCD AD = Σ∗−Σ∗(RrightR/∪RleftR>∪Σinv)Σ∗

RrightR> RleftR/ RvergentR
forward backward con/divergent

Rleft2R> Rright2R\
divergent backward forward divergent

UNAMBS US = Σ
∗−Σ∗(RrightR>∪RleftR/∪RvergentR)Σ∗
−Σ∗(Rleft2R>∪Rright2R\)Σ∗

L/L< R>R/
PROJW PW = Σ∗−Σ∗(L/L<∪R>R/)Σ∗

(an arc without inverse) INV I = Σ∗−Σ∗ΣorΣ∗
(a state with more than 2 incoming arcs) OUT Out = Σ∗−Σ∗Σin(Σ−B)∗ΣinΣ∗

(an inverted edge) ORIENTED O = Σ∗−Σ∗ΣinvΣ∗

Table 1: Properties of encoded noncrossing digraphs as constraint languages

(directed path 1→ 2→ 7→ 1), is strongly am-
biguous (two directed paths 2→ 1 and 2→ 7→ 1)
and is not weakly connected (vertices 5 and 6 are
not connected to the rest of the digraph).

Expressing Properties via Forbidden Patterns
We now demonstrate that all the mentioned non-
local properties of graphs have become local in
the extended internal representation of the code
strings LNC-DIGRAPH for noncrossing digraphs.

These distinctive properties of graph families
reduce to forbidden patterns in bracket strings and
then compile into regular constraint languages.
These are presented in Table 1. To keep the pat-
terns simple, subsets of brackets are defined:

L/ [-,/-brackets L< [-,<-brackets
R> ]-,>-brackets R/ ]-,\-brackets
B {, } R R>∪R\
Rloose }, >., /., ]. Rloose R−Rloose
Rright R reaching F,Q,I,A Rleft R reaching f,q,i,a
Rright2 >P, >2, >E, \E, ]E Rleft2 \p, \2, \e, >e, ]e
Σin L<∪R> B Σ−B
Rvergent non-’ R reaching I,Q,q,A,a,C,c
Σor all brackets for oriented edges
Σinv all brackets for inverted edges

6 Validation Experiments

The current experiments were designed (1) to help
in developing the components of Reglat and the
constraint languages of axiomatic properties, (2)
to validate the representation, the constraint lan-
guages and their unambiguity, (3) to learn about
the ontology and (4) to sample the integer se-
quences associated with the cardinality of each

family in the ontology.

Finding the Components Representations of
Reglat were built with scripts written using a finite-
state toolkit (Hulden, 2009) that supports rapid ex-
ploration with regular languages and transducers.

Validation of Languages Our scripts presented
alternative approaches to compute languages of
encoded digraphs with n vertices up to n = 9. We
also implemented a Python script that enumerated
elements of families of graphs up to n = 6. The
solutions were used to cross-validate one another.

The constraint Gn = B
∗
({}B∗)n−1 ensures n-

vertices in encoded digraphs. The finite set of
encoded acyclic 5-vertex digraphs was computed
with a finite-state approach (Yli-Jyrä et al., 2012)
that takes the input projection of the composition

Id(Reglat∩AD∩G5)◦T55◦T55◦T55◦T55◦T55◦ Id(ε)

where Id defines an identity relation and trans-
ducer T55 eliminates matching adjacent brack-
ets. This composition differs from the typical use
where the purpose is to construct a regular relation
(Kaplan and Kay, 1994) or its output projection
(Roche, 1996; Oflazer, 2003).

For digraphs with a lot of vertices, we had an
option to employ a dynamic programming scheme
(Yli-Jyrä, 2012) that uses weighted transducers.

Building the Ontology To build the ontology in
Figure 1 we first found out which combinations of
digraph properties co-occur to define distinguish-
able families of digraphs. After the nodes of the

1750



lattice were found, we were able to see the partial
order between these.

Integer Sequences We sampled, for important
families of digraphs, the prefixes of their related
integer sequences. We found out that each family
of graphs is pretty much described by its cardi-
nality, see Table 2. In many cases, the number se-
quence was already well documented (OEIS Foun-
dation Inc., 2017).

7 The Formal Basis of Practical Parsing

While presenting a practical parser implementa-
tion is outside of the scope of this paper, which
focuses in the theory, we outline in this section
the aspects to take into account when applying our
representation to build practical natural language
parsers.

Positioned Brackets In order to do inference in
arc-factored parsing, we incorporate weights to the
representation. For each vertex in Gn, the brackets
are decorated with the respective position number.
Then, we define an input-specific grammar repre-
sentation where each pair of brackets in D gets an
arc-factored weight given the directions and the
vertex numbers associated with the brackets.

Grammar Intersection We associate, to each
Gn, a quadratic-size context-free grammar that
generates all noncrossing digraphs with n vertices.
This grammar is obtained by computing (or even
precomputing) the intersection D55 ∩ Reglat ∩Gn
in any order, exploiting the closure of context-
free languages under intersection with regular
languages (Bar-Hillel et al., 1961). The intro-
duction of the position numbers and weights in
the Dyck language gives us, instead, a weighted
grammar and its intersection (Lang, 1994). This
grammar is a compact representation for a finite
set of weighted latent encoded digraphs. Addi-
tional constraints during the intersection tailors the
grammar to different families of digraphs.

Dynamic Programming The heaviest digraph
is found with a dynamic programming algorithm
that computes, for each nonterminal in the gram-
mar, the weight of the heaviest subtree. A care-
ful reader may notice some connections to Eisner
algorithm (Eisner and Satta, 1999), context-free
parsing through intersection (Nederhof and Satta,
2003), and a dynamic programming scheme that

uses contracting transducers and factorized com-
position (Yli-Jyrä, 2012). Unfortunately, space
does not permit discussing the connections here.

Lexicalized Search Space In practical parsing,
we want the parser behavior and the dependency
structure to be sensitive to the lexical entries or
features of each word. We can replace the generic
vertex description B∗ in Gn with subsets that de-
pend on respective lexical entries. Graphical con-
straints can be applied to some vertices but relaxed
for others. This application of current results gives
a principled, graphically motivated solution to lex-
icalized control over the search space.

8 Conclusion

We have investigated the search space of parsers
that produce noncrossing digraphs. Parsers that
can be adapted to different needs are less depen-
dent on artificial assumptions on the search space.
Adaptivity gives us freedom to model how the
properties of digraphs are actually distributed in
linguistic data. As the adaptive data analysis de-
serves to be treated in its own right, the current
work focuses on the separation of the parsing al-
gorithm from the properties of the search space.

This paper makes four significant contributions.

Contribution 1: Digraph Encoding The paper
introduces, for noncrossing digraphs, an encoding
that uses brackets to indicate edges.

Bracketed trees are widely used in generative
syntax, treebanks and structured document for-
mats. There are established conversions between
phrase structure and projective dependency trees,
but the currently advocated edge bracketing is ex-
pressive and captures more than just projective
dependency trees. This capacity is welcome as
syntactic and semantic analysis with dependency
graphs is a steadily growing field.

The edge bracketing creates new avenues for
the study of connections between noncrossing
graphs and context-free languages, as well as their
recognizable properties. By demonstrating that
digraphs can be treated as strings, we suggest
that practical parsing to these structures could be
implemented with existing methods that restrict
context-free grammars to a regular yield language.

Contribution 2: Context-Free Properties
Acyclicity and other important properties of
noncrossing digraphs are expressible as unam-
biguous context-free sets of encoded noncrossing

1751



Table 2: Characterizations for some noncrossing families of digraphs and graphs
Name Sequence prefix for n = 2,3, ... Example Name Sequence prefix for n = 2,3, ... Example
digraph (KJ): 4,64,1792,62464,2437120,101859328

hlat(D55 ∩Gn ∩Reglat) 1 2 3 4 5
weakly projective
digraph

4,36,480,7744,138880,2661376
hlat(D55 ∩Gn ∩Reglat ∩PW ) 1 2 3 4 5

w.c.digraph 3,54,1539,53298,2051406,84339468
hlat(D55 ∩Gn ∩Reglat ∩CW ) 1 2 3 4 5

w.p. w.c.digraph 3,26,339,5278,90686,1658772
hlat(D55 ∩Gn ∩Reglat ∩PW ∩CW ) 1 2 3 4 5

unamb.digr. 4,39,529,8333,142995,2594378
hlat(D55 ∩Gn ∩Reglat ∩US) 1 2 3 4 5

w.p. unamb.digr. 4,29,275,3008,35884,453489
hlat(D55 ∩Gn ∩Reglat ∩PW ∩US) 1 2 3 4 5

m-forest 4,37,469,6871,109369,1837396,32062711
hlat(D55 ∩Gn ∩Reglat ∩AU ) 1 2 3 4 5

w.p. m-forest 4,29,273,2939,34273,421336
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AU ) 1 2 3 4 5

out digraph 4,27,207,1683,14229,123840,1102365
hlat(D55 ∩Gn ∩Reglat ∩Out) 1 2 3 4 5

w.p. out digraph 4,21,129,867,6177,45840,350379
hlat(D55 ∩Gn ∩Reglat ∩PW ∩Out) 1 2 3 4 5

or. digraph 3,27,405,7533,156735,3492639,77539113
hlat(D55 ∩Gn ∩Reglat ∩O) 1 2 3 4 5

w.p. or.digraph see w.p.dag
hlat(D55 ∩Gn ∩Reglat ∩PW ∩O) see w.p.dag

dags (A246756): 3,25,335,5521,101551
hlat(D55 ∩Gn ∩Reglat ∩AD) 1 2 3 4 5

w.p. dag 3,21,219,2757,38523, 574725, 8967675
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD) 1 2 3 4 5

w.c. dag (KJ): 2,18,242,3890,69074,1306466
hlat(D55 ∩Gn ∩Reglat ∩AD ∩CW ) 1 2 3 4 5

w.p. w.c. dag 2,14,142,1706,22554,316998,4480592
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩CW ) 1 2 3 4 5

multitree 3,19,167,1721,19447,233283,2917843
hlat(D55 ∩Gn ∩Reglat ∩AD ∩US)

see oriented forest
or w.c. multitree

w.p. multitree 3,17,129,1139,11005,112797,1203595
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩US) 1 2 3 4 5

or.forest 3,19,165,1661,18191,210407,2528777
hlat(D55 ∩Gn ∩Reglat ∩AD ∪AU ) 1 2 3 4 5

w.p. or.forest 3,17,127,1089,10127,99329,1010189
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∪AU ) 1 2 3 4 5

w.c. multitree 2,12,98,930,9638,105798,1201062
hlat(D55 ∩Gn ∩Reglat ∩AD ∩US ∩CW ) 1 2 3 4 5

w.p. w.c. multitree 2,10,68,538,4650,42572,404354
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩US ∩CW ) 1 2 3 4 5

out or.forest 3,16,105,756,5738,45088,363221
hlat(D55 ∩Gn ∩Reglat ∩AD ∩Out) 1 2 3 4 5

w.p. out or.forest (A003169): 3,14,79,494,3294,22952
hlat(D55 ∩Gn ∩Reglat ∩PW ∩AD ∩Out) 1 2 3 4 5

polytree (A153231): 2,12,96,880,8736,91392
hlat(D55 ∩Gn ∩Reglat ∩AD ∩CW ∩AU ) 1 2 3 4 5

w.p. polytree (A027307):2,10,66,498,4066,34970
hlat(D55∩Gn∩Reglat∩PW ∩AD∩CW ∩AU ) 1 2 3 4 5

out or.tree (A174687): 2,9,48,275,1638,9996
hlat(D55 ∩Gn ∩Reglat ∩AD ∩CW ∩Out) 1 2 3 4 5

projective
out or.tree

(A006013): 2,7,30,143,728,3876,21318
hlat(D55∩Gn∩Reglat∩PW ∩AD∩CW ∩Out) 1 2 3 4 5

graph (A054726): 2,8,48,352,2880,25216
hlat(D55 ∩Gn ∩Reglat ∩ I) 1 2 3 4 5

connected graph (A007297): 1,4,23,156,1162,9192
hlat(D55 ∩Gn ∩Reglat ∩ I∩CW ) 1 2 3 4 5

forest (A054727): 2,7,33,181,1083,6854
hlat(D55 ∩Gn ∩Reglat ∩ I∩AU ) 1 2 3 4 5

tree (A001764,YJ): 1,3,12,55,273,1428,7752
hlat(D55 ∩Gn ∩Reglat ∩ I∩AU ∩CW ) 1 2 3 4 5

A = (OEIS Foundation Inc., 2017), KJ = Kuhlmann (2015) or Kuhlmann and Johnsson (2015), YJ = Yli-Jyrä (2012)

digraphs. This facilitates the incorporation
of property testing to dynamic programming
algorithms that implement exact inference.

Descriptive complexity helps us understand to
which degree various graphical properties are lo-
cal and could be incorporated into efficient dy-
namic programming during exact inference. It is
well known that acyclicity and connecticity are
not definable in first-order logic (FO) while they
can be defined easily in monadic second order
logic (MSO) (Courcelle, 1997). MSO involves
set-valued variables whose use in dynamic pro-
gramming algorithms and tabular parsing is inef-
ficient. MSO queries have a brute force transfor-
mation to first-order (FO) logic, but this does not
generally help either as it is well known that MSO
can express intractable problems.

The interesting observation of the current work
is that some MSO definable properties of digraphs
become local in our extended encoding. This en-
coding is linear compared to the size of digraphs:
each string over the extended bracket alphabet en-
codes a fixed assignment of MSO variables. The
properties of noncrossing digraphs now reduce to
properties of bracketed trees with linear amount of

func noncrossing_ACYCU(n,E):
for {u,y} in E and u < y: # covering edge

[v,p] = [u,u]
while p != -1: # chain continues

[v,p] = [p,-1]
for vv in [v+1,...,y]: # next vertex

if {v,vv} in E and {v,vv} != {u,y}:
if vv == y:

return False # found cycle uvy
p = vv # find longest edge

return True # acyclic

Figure 5: Testing ACYCU in logarithmic space

latent information that is fixed for each digraph.
A deeper explanation for our observation comes

from the fact that the treewidth of noncrossing and
other outerplanar graphs is bounded to 2. When
the treewidth is bounded, all MSO definable prop-
erties, including the intractable ones, become lin-
ear time decidable for individual structures (Cour-
celle, 1990). They can also be decided in a loga-
rithmic amount of writable space (Elberfeld et al.,
2010), e.g. with element indices instead of sets.
By combining this insight with Proposition 1, we
obtain a logspace solution for testing acyclicity of
a noncrossing graph (Figure 5).

Although bounded treewidth is a weaker con-
straint than so-called bounded treedepth that
would immediately guarantee first-order definabil-

1752



ity (Elberfeld et al., 2016), it can sometimes turn
intractable search problems to dynamic program-
ming algorithms (Akutsu and Tamura, 2012). In
our case, Proposition 1 gave rise to unambigu-
ous context-free subsets of LNC-DIGRAPH. These
can be recognized with dynamic programming and
used in efficient constrained inference when we
add vertex indices to the brackets and weights to
the grammar of the corresponding Dyck language.

Contribution 3: Digraph Ontology The
context-free properties of encoded digraphs have
elegant nonderivative language representations
and they generate a semi-lattice under language
intersection. Although context-free languages
are not generally closed under intersection, all
combinations of the properties in this lattice
are context-free and define natural families of
digraphs. The nonderivative representations for
our axiomatic properties share the same Dyck lan-
guage D55 and homomorphism, but differ in terms
of forbidden patterns. As a consequence, also
any conjunctive combination of these two prop-
erties shares these components and thus define a
context-free language. The obtained semilattice is
an ontology of families of noncrossing digraphs.

Our ontology contains important families of
noncrossing digraphs used in syntactic and se-
mantic dependency parsing: out trees, dags, and
weakly connected digraphs. It shows the entail-
ment between the properties and proves the exis-
tence of less known families of noncrossing di-
graphs such as strongly unambiguous digraphs
and oriented graphs, multitrees, oriented forests
and polytrees. These are generalizations of out
oriented trees. However, these families can still
be weakly projective. Table 2 shows integer se-
quences obtained by enumerating digraphs in each
family. At least twelve of these sequences are pre-
viously known, which indicates that the families
are natural.

We used a finite-state toolkit to build the com-
ponents of the nongenerative language representa-
tion for latent encoded digraphs and the axioms.2

Contribution 4: Generic Parsing The fourth
contribution of this paper is to show that parsing
algorithms can be separated from the formal prop-
erties of their search space.

2The finite-state toolkit scripts and a Python-based graph
enumerator are available at
https://github.com/amikael/ncdigraphs .

All the presented families of digraphs can be
treated by parsers and other algorithms (e.g. enu-
meration algorithms) in a uniform manner. The
parser’s inference rules can stay constant and the
choice of the search space is made by altering the
regular component of the language representation.

The ontology of the search space can be com-
bined with a constraint relaxation strategy, for ex-
ample, when an out tree is a preferred analysis, but
a dag is also possible as an analysis when no tree is
strong enough. The flexibility applies also to dy-
namic programming algorithms that complement
with the encoding and allow inference of best de-
pendency graphs in a family simply by intersec-
tion with a weighted CFG grammar for a Dyck
language that models position-indexed edges of
the complete digraph.

Since the families of digraphs are distinguished
by forbidden local patterns, the choice of search
space can be made purely on lexical grounds,
blending well with lexicalized parsing and allow-
ing possibilities such as choosing, per each word,
what kind of structures the word can go with.

Future work We are planning to extend the cov-
erage of the approach by exploring 1-endpoint-
crossing and MHk trees (Pitler et al., 2013;
Gómez-Rodrı́guez, 2016), and related digraphs
— see (Yli-Jyrä, 2004; Gómez-Rodrı́guez et al.,
2011). Properties such as weakly projective, out,
and strongly unambiguous prompt further study.

An interesting avenue for future work is to ex-
plore higher order factorizations for noncrossing
digraphs and the related inference. We would also
like to have more insight on the transformation
of MSO definable properties to the current frame-
work and to logspace algorithms.

Acknowledgements

AYJ has received funding as Research Fellow
from the Academy of Finland (dec. No 270354
- A Usable Finite-State Model for Adequate Syn-
tactic Complexity) and Clare Hall Fellow from
the University of Helsinki (dec. RP 137/2013).
CGR has received funding from the European Re-
search Council (ERC) under the European Union’s
Horizon 2020 research and innovation programme
(grant agreement No 714150 - FASTPARSE) and
from the TELEPARES-UDC project (FFI2014-
51978-C2-2-R) from MINECO. The comments of
Juha Kontinen, Mark-Jan Nederhof and the anony-
mous reviewers helped to improve the paper.

1753



References
Tatsuya Akutsu and Takeyuki Tamura. 2012. A

polynomial-time algorithm for computing the
maximum common subgraph of outerplanar graphs
of bounded degree. In Branislav Rovan, Vladimiro
Sassone, and Peter Widmayer, editors, Mathemat-
ical Foundations of Computer Science 2012: 37th
International Symposium, MFCS 2012, Bratislava,
Slovakia, August 27-31, 2012. Proceedings,
Springer Berlin Heidelberg, Berlin, Heidelberg,
pages 76–87. https://doi.org/10.1007/978-3-642-
32589-2 10.

Jason Baldridge and Geert-Jan M. Kruijff. 2003.
Multi-modal combinatory categorial gram-
mar. In Proceedings of EACL’03: the Tenth
Conference on European Chapter of the As-
sociation for Computational Linguistics -
Volume 1. Association for Computational Lin-
guistics, Budapest, Hungary, pages 211–218.
https://doi.org/10.3115/1067807.1067836.

Yehoshua Bar-Hillel, Micha Perles, and Eliahu Shamir.
1961. On formal properties of simple phrase
structure grammars. Zeitschrift für Phonologie,
Sprachwissenschaft und Kommunikationsforschung
14:113–124.

Noam Chomsky and Marcel-Paul Schützenberger.
1963. The algebraic theory of context-free lan-
guages. Computer Programming and Formal Sys-
tems pages 118–161.

Bruno Courcelle. 1990. The monadic second-order
logic of graphs. I. recognizable sets of finite
graphs. Information and Computation 85(1):12 –
75. https://doi.org/10.1016/0890-5401(90)90043-
H.

Bruno Courcelle. 1997. The expression of graph prop-
erties and graph transformations in monadic second-
order logic. In G. Rozenberg, editor, Handbook of
Graph Grammars and Computing by Graph Trans-
formations, World Scientific, New-Jersey, London,
volume 1, chapter 5, pages 313–400.

Jason Eisner. 1996. Three new probabilistic
models for dependency parsing: An explo-
ration. In Proceedings of the 16th Inter-
national Conference on Computational Linguis-
tics (COLING-96). Copenhagen, Denmark, pages
340–345. http://aclweb.org/anthology/C/C96/C96-
1058.pdf.

Jason Eisner and Giorgio Satta. 1999. Efficient parsing
for bilexical context-free grammars and Head Au-
tomaton Grammars. In Proceedings of the 37th An-
nual Meeting of the Association for Computational
Linguistics. Association for Computational Linguis-
tics, College Park, Maryland, USA, pages 457–464.
https://doi.org/10.3115/1034678.1034748.

Michael Elberfeld, Martin Grohe, and Till Tantau.
2016. Where first-order and monadic second-
order logic coincide. ACM Trans. Comput. Logic
17(4):25:1–25:18. https://doi.org/10.1145/2946799.

Michael Elberfeld, Andreas Jakoby, and Till Tan-
tau. 2010. Logspace versions of the theorems of
Bodlaender and Courcelle. In Proceedings of the
2010 IEEE 51st Annual Symposium on Founda-
tions of Computer Science. IEEE Computer Society,
Washington, DC, USA, FOCS ’10, pages 143–152.
https://doi.org/10.1109/FOCS.2010.21.

Carlos Gómez-Rodrı́guez. 2016. Restricted
non-projectivity: Coverage vs. efficiency.
Computational Linguistics 42(4):809–817.
https://doi.org/10.1162/COLI a 00267.

Carlos Gómez-Rodrı́guez, John A. Carroll, and
David J. Weir. 2011. Dependency parsing
schemata and mildly non-projective dependency
parsing. Computational Linguistics 37(3):541–586.
https://doi.org/10.1162/COLI a 00060.

Erich Grädel, P. G. Kolaitis, L. Libkin, M. Marx,
J. Spencer, Moshe Y. Vardi, Y. Venema, and Scott
Weinstein. 2005. Finite Model Theory and Its Ap-
plications (Texts in Theoretical Computer Science.
An EATCS Series). Springer-Verlag New York, Inc.,
Secaucus, NJ, USA.

Sheila Greibach. 1973. The hardest context-free lan-
guage. SIAM Journal on Computing 2(4):304–310.
https://doi.org/10.1137/0202025.

Venkatesan Guruswami, Johan Håstad, Rajsekar
Manokaran, Prasad Raghavendra, and Moses
Charikar. 2011. Beating the random ordering is
hard: Every ordering CSP is approximation resis-
tant. SIAM Journal on Computing 40(3):878914.
https://doi.org/10.1137/090756144.

Mans Hulden. 2009. Foma: a finite-state compiler
and library. In Proceedings of the Demonstrations
Session at EACL 2009. Association for Computa-
tional Linguistics, Athens, Greece, pages 29–32.
http://www.aclweb.org/anthology/E09-2008.

Mans Hulden. 2011. Parsing CFGs and PCFGs with
a Chomsky-Schützenberger representation. In Zyg-
munt Vetulani, editor, Human Language Technol-
ogy. Challenges for Computer Science and Lin-
guistics: 4th Language and Technology Confer-
ence, LTC 2009, Poznan, Poland, November 6-
8, 2009, Revised Selected Papers, Springer Berlin
Heidelberg, Berlin, Heidelberg, pages 151–160.
https://doi.org/10.1007/978-3-642-20095-3 14.

Ronald M. Kaplan and Martin Kay. 1994. Reg-
ular models of phonological rule systems.
Computational Linguistics 20(3):331–378.
http://dl.acm.org/citation.cfm?id=204915.204917.

Marco Kuhlmann. 2015. Tabulation of non-
crossing acyclic digraphs. arXiv:1504.04993.
https://arxiv.org/abs/1504.04993.

Marco Kuhlmann and Peter Johnsson. 2015. Parsing to
noncrossing dependency graphs. Transactions of the
Association for Computational Linguistics 3:559–
570. http://aclweb.org/anthology/Q/Q15/Q15-
1040.pdf.

1754



Marco Kuhlmann and Stephan Oepen. 2016. To-
wards a catalogue of linguistic graph banks.
Computational Linguistics 42(4):819–827.
https://doi.org/10.1162/COLI a 00268.

Bernard Lang. 1994. Recognition can
be harder than parsing. Compu-
tational Intelligence 10(4):486–494.
http://onlinelibrary.wiley.com/doi/10.1111/j.1467-
8640.1994.tb00011.x/full.

Klaus-Jörn Lange. 1997. An unambiguous class
possessing a complete set. In Morvan Reis-
chuk, editor, STACKS’97 Proceedings. Springer,
volume 1200 of Lecture Notes in Computer Science.
http://dl.acm.org/citation.cfm?id=695352.

S. Marcus. 1967. Algebraic Linguistics; Analytical
Models, volume 29 of Mathematics in Science and
Engineering. Academic Press, New York and Lon-
don.

Ryan McDonald, Fernando Pereira, Kiril Ribarov,
and Jan Hajic. 2005. Non-projective depen-
dency parsing using spanning tree algorithms.
In Proceedings of Human Language Technol-
ogy Conference and Conference on Empirical
Methods in Natural Language Processing. As-
sociation for Computational Linguistics, Van-
couver, British Columbia, Canada, pages 523–
530. http://www.aclweb.org/anthology/H/H05/H05-
1066.pdf.

Mark-Jan Nederhof and Giorgio Satta. 2003. Proba-
bilistic parsing as intersection. In 8th International
Workshop on Parsing Technologies. LORIA, Nancy,
France, pages 137–148.

OEIS Foundation Inc. 2017. The on-line encyclopedia
of integer sequences. http://oeis.org, read
on 15 January 2017.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinkova, Dan Flickinger,
Jan Hajic, and Zdenka Uresova. 2015. Se-
meval 2015 task 18: Broad-coverage semantic de-
pendency parsing. In Proceedings of the 9th
International Workshop on Semantic Evaluation
(SemEval 2015). Association for Computational
Linguistics, Denver, Colorado, pages 915–926.
http://www.aclweb.org/anthology/S15-2153.

Kemal Oflazer. 2003. Dependency pars-
ing with an extended finite-state approach.
Computational Linguistics 29(4):515–544.
https://doi.org/10.1162/089120103322753338.

Emily Pitler, Sampath Kannan, and Mitchell
Marcus. 2013. Finding optimal 1-endpoint-
crossing trees. Transactions of the Associa-
tion for Computational Linguistics 1:13–24.
http://aclweb.org/anthology/Q13-1002.

George Rebane and Judea Pearl. 1987. The
recovery of causal poly-trees from statistical
data. In Proceedings of the 3rd Annual

Conference on Uncertainty in Artificial Intelli-
gence (UAI 1987). Seattle, WA, pages 222–228.
http://dl.acm.org/citation.cfm?id=3023784.

Emmanuel Roche. 1996. Transducer pars-
ing of free and frozen sentences. Natu-
ral Language Engineering 2(4):345–350.
https://doi.org/10.1017/S1351324997001605.

Natalie Schluter. 2014. On maximum spanning
DAG algorithms for semantic DAG parsing.
In Proceedings of the ACL 2014 Workshop on
Semantic Parsing. Association for Computa-
tional Linguistics, Baltimore, MD, pages 61–65.
http://www.aclweb.org/anthology/W/W14/W14-
2412.pdf.

Natalie Schluter. 2015. The complexity of finding
the maximum spanning DAG and other restrictions
for DAG parsing of natural language. In Proceed-
ings of the Fourth Joint Conference on Lexical and
Computational Semantics. Association for Compu-
tational Linguistics, Denver, Colorado, pages 259–
268. http://www.aclweb.org/anthology/S15-1031.

Anssi Yli-Jyrä. 2004. Axiomatization of re-
stricted non-projective dependency trees through
finite-state constraints that analyse crossing
bracketings. In Geert-Jan M. Kruijff and
Denys Duchier, editors, COLING 2004 Re-
cent Advances in Dependency Grammar.
COLING, Geneva, Switzerland, pages 25–32.
https://www.aclweb.org/anthology/W/W04/W04-
1504.pdf.

Anssi Yli-Jyrä. 2005. Approximating dependency
grammars through intersection of star-free regular
languages. Int. J. Found. Comput. Sci. 16(3):565–
579. https://doi.org/10.1142/S0129054105003169.

Anssi Yli-Jyrä. 2012. On dependency analysis via con-
tractions and weighted FSTs. In Diana Santos, Kris-
ter Lindén, and Wanjiku Ng’ang’a, editors, Shall
We Play the Festschrift Game?, Essays on the Oc-
casion of Lauri Carlson’s 60th Birthday. Springer,
pages 133–158. https://doi.org/10.1007/978-3-642-
30773-7 10.

Anssi Yli-Jyrä, Jussi Piitulainen, and Atro Vouti-
lainen. 2012. Refining the design of a con-
tracting finite-state dependency parser. In Iñaki
Alegria and Mans Hulden, editors, Proceedings
of the 10th International Workshop on Finite
State Methods and Natural Language Process-
ing. Association for Computational Linguistics,
Donostia–San Sebastián, Spain, pages 108–115.
http://www.aclweb.org/anthology/W12-6218.

Yue Zhang and Joakim Nivre. 2011. Transition-based
dependency parsing with rich non-local features. In
Proceedings of the 49th Annual Meeting of the Asso-
ciation for Computational Linguistics: Human Lan-
guage Technologies. Association for Computational
Linguistics, Portland, Oregon, USA, pages 188–
193. http://www.aclweb.org/anthology/P11-2033.

1755


	Generic Axiomatization of Families of Noncrossing Graphs in Dependency Parsing

