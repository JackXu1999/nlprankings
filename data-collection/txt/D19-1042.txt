



















































Hierarchical Text Classification with Reinforced Label Assignment


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 445–455,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

445

Hierarchical Text Classification with Reinforced Label Assignment

Yuning Mao1, Jingjing Tian2, Jiawei Han1, Xiang Ren3
1Department of Computer Science, University of Illinois at Urbana-Champaign, IL, USA

3Department of Computer Science, Peking University, Beijing, China
3Department of Computer Science, University of Southern California, CA, USA
1{yuningm2, hanj}@illinois.edu 2tianjj97@pku.edu.cn 3xiangren@usc.edu

Abstract

While existing hierarchical text classification
(HTC) methods attempt to capture label hier-
archies for model training, they either make
local decisions regarding each label or com-
pletely ignore the hierarchy information dur-
ing inference. To solve the mismatch between
training and inference as well as modeling la-
bel dependencies in a more principled way,
we formulate HTC as a Markov decision pro-
cess and propose to learn a Label Assignment
Policy via deep reinforcement learning to de-
termine where to place an object and when to
stop the assignment process. The proposed
method, HiLAP, explores the hierarchy dur-
ing both training and inference time in a con-
sistent manner and makes inter-dependent de-
cisions. As a general framework, HiLAP can
incorporate different neural encoders as base
models for end-to-end training. Experiments
on five public datasets and four base models
show that HiLAP yields an average improve-
ment of 33.4% in Macro-F1 over flat classifiers
and outperforms state-of-the-art HTC methods
by a large margin.1

1 Introduction

In recent years there has been a surge of interest
in leveraging hierarchies (taxonomies) to organize
objects (e.g., documents), leading to the develop-
ment of hierarchical text classification (HTC)—a
task that aims to predict for an object multiple ap-
propriate labels in a given label hierarchy, which
together constitute a sub-tree. HTC methods have
found a wide range of applications such as ques-
tion answering (Qu et al., 2012), online advertis-
ing (Agrawal et al., 2013), and scientific litera-
ture organization (Peng et al., 2016). In contrast
to “flat” classification, the key challenges of HTC

1Data and code can be found at https://github.com/
morningmoni/HiLAP.

X

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

Label Hierarchy

Inconsistent Prediction Single-Path Prediction

Mandatory Leaf Node Prediction Non-mandatory Leaf Node Prediction

Yelp Business

X

X

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

X

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

Figure 1: We aim at consistent, multi-path, and non-
mandatory leaf node prediction. For a Caribbean
restaurant with a beer bar, inconsistent prediction may
place it to node “Beer Bars” but not “Bars”, which con-
tradicts with each other; Single-path prediction may
only recognize that it is a beer bar; Mandatory leaf node
prediction would have to assign a leaf node “Domini-
can” even if the nation of the cuisine is uncertain.

lie in modeling the large-scale, imbalanced, and in
particular, structured label space.

Based on how the hierarchy is explored, HTC
methods can be summarized into flat, local, and
global approaches (Silla and Freitas, 2011). Flat
approaches (Hayete and Bienkowska, 2005; John-
son and Zhang, 2014) assume all the labels in the
given hierarchy are independent. Some predict la-
bels at the leaf nodes and heuristically add their
ancestor labels, which is problematic as the labels
of some objects may not be at the leaf nodes (non-
mandatory leaf node prediction, see Fig. 1) and
all the non-leaf nodes are completely neglected.
Some simply ignore the hierarchy and perform
standard multi-label classification, in which la-
bel inconsistencies (one label is predicted pos-
itive but its ancestors are not) may occur and
post-processing is needed to correct such contra-
dictions. Local approaches (Koller and Sahami,
1997; Cesa-Bianchi et al., 2006) train a set of local
classifiers that function independently and predic-
tions are usually made in a top-down order: one
node is visited if and only if its ancestors have

https://github.com/morningmoni/HiLAP
https://github.com/morningmoni/HiLAP


446

STOP is taken
t = 0 t = 1 t = 2 t = 6

0

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

0

1

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

0

1

2

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

0

31

2 4

5

ROOT

Restaurants

Caribbean  

American Italian

Bars

Nightlife

Beer Bars Wine BarsDominican  Haitian  Puerto Rican 

Figure 2: An illustrative example of the label assignment policy. At t = 0, xi is placed at the root label and the
policy would decide if xi should be placed to its two children (red). At t = 1, xi is placed at label “Restaurants”,
which adds its three children as the candidates. At t = 6, the stop action is taken and the label assignment is thus
terminated. We then take all the labels where xi has been placed (blue) as xi’s labels.

been predicted positive. One critical issue is that
the number of local classifiers depends on the size
of the label hierarchy, making local approaches in-
feasible to scale.

Global approaches use one single classifier and
model the label hierarchy more explicitly. Tra-
ditional global approaches (Wang et al., 2001;
Silla Jr and Freitas, 2009) are largely based on
specific flat models and often make unrealistic as-
sumptions (Cai and Hofmann, 2004) as in flat ap-
proaches. Recent neural approaches (Kim, 2014;
Yang et al., 2016) mainly focus on flat classifi-
cation while their performance in HTC is rela-
tively less studied. Even if the classification is
supposed to be hierarchical, prior work (Gopal and
Yang, 2013; Johnson and Zhang, 2014; Peng et al.,
2018) still make flat and independent predictions
or utilize simple constraints without considering
the holistic quality of label assignment. One re-
cent framework (Wehrmann et al., 2018) attempts
to leverage both local and global information but it
uses static features as input and its inference pro-
cess is still flat.

In this paper, we formulate HTC as a Markov
decision process to better capture label dependen-
cies and measure the holistic quality of label as-
signment. We present HiLAP, a global framework
that learns a label assignment policy to determine
where to place the objects and when to stop the as-
signment process. HiLAP explores the label hier-
archy during both training and inference in a con-
sistent manner, which alleviates the exposure bias
often found in prior local and global approaches.
By learning when to stop, HiLAP is more flexi-
ble than approaches that only support mandatory
leaf node prediction or require thresholding. In
addition, HiLAP supports multi-path prediction
and its predictions of one object on different paths
are inter-dependent, which not only guarantees la-
bel consistency but matches the nature of HTC.

Furthermore, HiLAP estimates the holistic quality
of all the labels assigned to one object via rein-
forcement learning instead of evaluating each la-
bel independently via maximum likelihood as in
prior studies. To summarize, HiLAP achieves bet-
ter effectiveness compared to flat and local ap-
proaches as it examines the label hierarchy dur-
ing both training and inference. HiLAP has more
flexibility and generalization capacity than previ-
ous global approaches in that it has no constraints
on the structure of the hierarchy or the labels of the
objects (Cai and Hofmann, 2004), generalizes to
neural representation learning models (Gopal and
Yang, 2013), and makes inter-dependent predic-
tions while ensuring label consistency (Wehrmann
et al., 2018; Peng et al., 2018).

HiLAP can be combined with various neural
encoding models and trained in an end-to-end
fashion. In our experiments, we select four rep-
resentative encoding models as the base models
to evaluate the effectiveness of HiLAP. Experi-
mental results on five public datasets from differ-
ent domains show that combining the base mod-
els with HiLAP yields an average performance
improvement of 33.4% in Macro-F1 over corre-
sponding flat classifiers and outperforms state-of-
the-art HTC methods by a large margin. In par-
ticular, ablation study shows that HiLAP is espe-
cially beneficial to those unpopular labels at the
bottom levels.

2 Hierarchical Label Assignment

2.1 Overview
Problem Formulation. We define a label hier-
archy H = (L,E) as a tree or DAG (directed
acyclic graph)-structured hierarchy with a set of
nodes (labels) L and a set of edges E indicating
the parent-child relation between the labels. Tak-
ing a set of objects X = {x1, x2, ..., xN} and their
labels L = {L1, L2, ..., LN} as input, we aim to



447

Object Embedding ed

Word Embedding

Max Pooling

Convolutional Layer

Base Model

Flat Probability Pf

Action Embeddings At Policy Network

State St

lt

 ed

Caribbean 
American 
Italian 
Nightlife 
Stop 

C
ar

ib
be

an
 

A
m

er
ic

an
 

Ita
lia

n 

N
ig

ht
lif

e 
R

es
ta

ur
an

ts
 

B
ar

s 
D

om
in

ic
an

 
H

ai
tia

n 
Pu

er
to

 R
ic

an
 

B
ee

r B
ar

s 
W

in
e 

B
ar

s 
C

ar
ib

be
an

 
A

m
er

ic
an

 
Ita

lia
n 

N
ig

ht
lif

e 
St

op
 

Action Probability Pt 

Figure 3: The architecture of the proposed framework HiLAP. One CNN model (Kim, 2014) is used as the
base model for illustration. The object embedding ed generated by the base model is combined with the embedding
of currently assigned label lt and used as the state representation st, based on which actions are taken by the policy
network. The time corresponds to t = 1 in Fig. 2.

learn a label assignment policy P to place each
object xi to its labels Li on the label hierarchy
H . The label assignment is supposed to be con-
sistent, multi-path, and non-mandatory leaf node
prediction (refer to Figs. 1 and 2). We define one
base model B as a mapping f that converts raw
object xi to a finite dimensional vector, i.e., the
object embedding ed ∈ RD. B can be any neural
representation learning model and its output ed is
used as the input ofP for policy learning. The ma-
jor challenge, compared to standard classification
setup, is that we need to model E, i.e., the relation
between labels.

Our Framework. Prior studies either have a mis-
match between training and inference as different
routines are followed in the two phases, or com-
pute losses with respect to each individual label
and make flat predictions during inference time. In
contrast, we learn a policy that (1) makes consis-
tent, inter-dependent predictions by traversing the
label hierarchy and maintaining state representa-
tion; (2) measures the holistic quality of label as-
signment via reinforcement learning. Specifically,
the policy P puts xi at the root label in the begin-
ning. At each time step, P decides which label xi
should be further placed to, among all the children
labels of where xi has been placed, until a special
stop action is taken. An illustration of how HiLAP
labels one object is shown in Fig. 2 and the overall
architecture of HiLAP is shown in Fig. 3.

2.2 Reinforcement Learning for Hierarchical
Label Assignment

We describe the details of policy learning includ-
ing its actions, rewards, states, and the policy
network in this section. We formulate HTC as

a Markov decision process (MDP): at each time
step, the agent observes current state, takes an ac-
tion, and receives a reward. The end goal is to train
a policy network to determine where to place the
objects and when to stop.

Actions. Specifically, we regard the process of
placing an object xi to the right positions on the
label hierarchy as making a sequence of actions,
where an action at at time step t is to select one
label lt+1 from the action space At and place xi
to that label lt+1. We denote the children of label
lt as C(lt). At the beginning of each episode, xi
is placed at the root label l0 and the action space
A0 = C(l0), i.e., all the labels at level 1. When xi
is placed at another label l1, its children C(l1) are
then added to the action space A1 while l1 itself
is removed. In addition, one stop action with em-
bedding estop ∈ RC is included in the action space
so that the model can automatically learn when to
stop placing object xi to new labels. Intuitively,
when the confidence of placing xi to another label
is lower than the stop action, the label assignment
process would be terminated.

In short, the action space At consists of all the
unvisited children labels of where the object xi has
been placed and the stop action. One distinction
of HiLAP is that it takes the inter-dependencies of
labels across different paths and levels into consid-
eration while previous approaches make indepen-
dent predictions on different paths. For example,
HiLAP can first place xi to a label at level 3 if the
probability of that label is high and then place it to
another label at level 1 on another path.

Rewards. The agent receives scalar rewards as
feedback for its actions. Different from exist-



448

ing work where each label of one example2 is
treated independently, HiLAP measures the qual-
ity of all the labels assigned to each example xi
by rewarding the agent with the Example-based
F1 (see Sec. 4.1 for details of this metric). Intu-
itively, the agent would realize how similar the as-
signed and the ground-truth labels of one example
are. Instead of waiting until the end of the label
assignment process and comparing the predicted
labels with the gold labels, we use reward shap-
ing (Mao et al., 2018), i.e., giving intermediate re-
wards at each time step, to accelerate the learning
process. Specifically, we set the reward r of xi at
time step t to be the difference of Example-based
F1 scores between current and the last time step:
rxit = F1

xi
t − F1

xi
t−1.

If current F1 is better than that at the last time
step, the reward would be positive, and vice versa.
The cumulative reward from current time step to
the end of an episode would cancel the intermedi-
ate rewards and thus reflect whether the current ac-
tion improves the holistic label assignment or not.
As a result, the learned policy would not focus on
the current placement but have a long-term view
that takes following actions into account.

States and Policy Network. We parameterize ac-
tion at by a policy network π(a | s;W). For each
object, its representation ed is generated by the
base model B. For each label, a label embedding
l ∈ RC is randomly initialized and updated during
training. The embeddings of the object ed and cur-
rently assigned label lt are concatenated and pro-
jected to a vector st ∈ RC via a two-layer feed-
forward network. st has the same size as the label
embedding l and is used as the state representation
at time step t. By stacking the action embeddings
(i.e., the embeddings of candidate labels and stop
action), we obtain an action matrix At with size
|A| × C. At is multiplied with the state embed-
ding st, which outputs the probability distribution
of actions. Finally, an action at is sampled based
on the probability distribution of the action space.

st = ReLU(W1l ReLU(W
2
l [ed; lt])),

π(at | s;W) = softmax(Atst),
at ∼ π(at | s;W).

We use policy gradient (Williams, 1992) as the op-
timization algorithm. In addition, we adopt a self-
critical training approach (Rennie et al., 2017).

2We use “example” and “object” interchangeably.

For each object xi, two label assignments are gen-
erated: L̃xi is sampled from the probability dis-
tribution, and L̂xi , the baseline label assignment,
is greedily obtained by choosing the action with
the highest probability at each time step. We use

r̃xit = r
L̃xi
t − r

L̂xi
t as the actual reward, which en-

sures that the policy network learns to place the
object to positions with higher F1 score than the
greedy baseline. Formally, we measure the global
loss Og as follows.

Og = −
N∑
i=1

T∑
t=1

logπxi(at | s;W)× vxit ,

where vxij =
∑T

t=j γ
t−j r̃xit is the cumulative fu-

ture reward at time j and γ ∈ [0, 1] is the discount
factor. At the time of inference, we greedily select
labels with the highest probability as L̂xi .

3 End-to-End Model Learning

3.1 Top-Down Supervised Pre-Training

Instead of learning from scratch, we use super-
vised learning to pre-train HiLAP. We denote the
supervised variant as HiLAP-SL. While most pa-
rameters of HiLAP-SL are shared and used to ini-
tialize HiLAP (except that estop is randomly ini-
tialized), its way of exploring the label hierarchy
H is dissimilar.

The major difference is that HiLAP-SL explores
the label hierarchy H in a top-down manner inde-
pendently. At each time step t, the object goes
down one level on the hierarchy and the labels
under the same parent are discriminated locally.
Specifically, the local per-parent label probabil-
ity distribution pLocalt is estimated as pLocalt =
σ(Ctst), where σ denotes the sigmoid function,
and Ct ∈ R|C(lt)|×C denotes the candidate em-
beddings of HiLAP-SL, i.e., an embedding matrix
consisting of the children of current label lt, rather
than all the labels where xi has been placed.

Another difference is that in HiLAP the ac-
tions are sampled and thus might place the objects
to incorrect labels, while in HiLAP-SL only the
ground-truth positions are traversed during train-
ing. Specifically, if there are K(≥ 1) ground-
truth labels at the same level, the object embed-
ding ed would be copied K times and losses on
the K different paths would be measured inde-
pendently (see Fig. 6 in Appendix for illustra-
tion). The local loss of HiLAP-SL is defined as
Ol =

∑T
t=0Ot, where T is the lowest label’s



449

level of one example and Ot estimates the bi-
nary cross entropy over the candidate labels C(lt):
Ot = −

∑N
i=1

∑
l∈C(lt,i) Li(l) × logp

Local
t,i (l) +

(1− Li(l))× log(1− pLocalt,i (l)), where Li(l) and
pLocalt,i (l) evaluate label l of xi. Intuitively, HiLAP-
SL works as if there were a set of local classifiers,
although most of its parameters (except for the la-
bel embedding l) are shared by all the labels so
that there is no need to train multiple classifiers.

3.2 Combining Flat, Local, and Global
Information for Policy Learning

We further add a flat component to HiLAP as
a regularization of the base model. Specifically,
the flat component is a feed-forward network that
projects the object embedding ed to a label proba-
bility distribution pFlat of all the labels on the hi-
erarchy: pFlat = σ(WFlated). The combination
of the base model and the flat component func-
tions the same as a flat model and ensures that the
object representation ed has the capability of flat
classification. We denote the flat loss that mea-
sures the binary cross entropy over all the labels
byOf = −

∑N
i=1

∑
l∈L Li(l)× logpFlati (l)+(1−

Li(l)) × log(1 − pFlati (l)). Combining the flat
and local losses, the supervised loss in HiLAP-SL
is defined as OSL = λOf + (1 − λ)Ol, where
λ ∈ [0, 1] is the mixing ratio. Similar to Celiky-
ilmaz et al. (2018), we also found that mixing a
proportion of the supervised loss is beneficial to
the learning process of HiLAP. Further combining
the global informationOg (i.e.,ORL), the total loss
of HiLAP is defined as O = ORL + αOSL, where
α is a scaling factor accounting for the difference
in magnitude between ORL and OSL. While we
do not use the flat component during inference, it
helps the representation learning of the base model
and improves the performance of both HiLAP-SL
and HiLAP (see Sec. 4.5).

4 Experiments

4.1 Experiment Setup

Datasets. We conduct extensive experiments on
five public datasets from various domains (sum-
marized in Table 1 and detailed in Appendix A).
The first two datasets are related to news catego-
rization, including RCV1 (Lewis et al., 2004) and
the NYT annotated corpus (Sandhaus, 2008). The

Table 1: Statistics of the datasets. |L| denotes the
number of labels in the label hierarchy. Avg(|Li|) and
Max(|Li|) denote the average and maximum number of
labels of one object, respectively.

Dataset Hierarchy |L| Avg(|Li|) Max(|Li|) Training Validation Test

RCV1 Tree 103 3.24 17 23,149 2,315 781,265
NYT Tree 115 2.52 14 25,279 2,528 10,828
Yelp DAG 539 3.77 32 87,375 8,737 37,265

FunCat Tree 499 8.76 45 1,628 848 1,281
GO DAG 4,125 34.9 141 1,625 848 1,278

third dataset is the Yelp Dataset Challenge 20183.
We hypothesize that one business can be repre-
sented by its reviews and use the reviews to predict
business categories. The last two datasets are re-
lated to protein functional catalogue (FunCat) and
gene ontology (GO) prediction (Vens et al., 2008),
which are used to test the generalization ability of
HiLAP to non-textual data. For all the datasets,
the lowest labels of one example may not be at the
leaf nodes and there could be multiple labels at
each level, making them harder and more realistic
than mandatory-leaf or single-path datasets such
as IPC (WIPO, 2014) and LSHTC (Partalas et al.,
2015).

Evaluation Metrics. We use standard met-
rics (Johnson and Zhang, 2014; Meng et al., 2018;
Peng et al., 2018) for HTC, including Micro-F1,
Macro-F1, and Example-based F1 (EBF) (Par-
talas et al., 2015; Peng et al., 2016). Let TPi,
FPi, FNi denote the true positive, false positive,
and false negative for the i-th example xi in ob-
ject set X , respectively. EBF calculates the F1
scores of all the examples independently and av-
erages them. P xi = TPiTPi+FPi , R

xi = TPiTPi+FNi ,

F1xi = 2P
xi×Rxi

Pxi+Rxi , and EBF =
1
N

∑N
i=1 F1

xi . Re-
call that F1xi is used as the reward in HiLAP.

Base Models for Feature Encoding. Different
from most of existing global HTC methods that
rely on pre-specified features (Gopal and Yang,
2013) as input or build on specific models (Cai
and Hofmann, 2004; Vens et al., 2008; Silla Jr
and Freitas, 2009), our framework is trained in
an end-to-end manner by leveraging a differen-
tiable feature representation learning model as the
base model. Specifically, we use TextCNN (Kim,
2014), HAN (Yang et al., 2016), bow-CNN (John-
son and Zhang, 2014) on the three textual datasets,
and a feed-forward network on the two non-
textual datasets. The details of the base models

3https://www.yelp.com/dataset/
challenge

https://www.yelp.com/dataset/challenge
https://www.yelp.com/dataset/challenge


450

Table 2: Performance comparison on RCV1. * de-
notes the results reported in Peng et al. (2018) on the
same dataset split. Note that the results of HR-SVM
reported in Gopal and Yang (2013) are not comparable
as they use a different hierarchy with 137 labels.

Method Micro-F1 Macro-F1 EBF

Fl
at

Leaf-SVM∗ 69.1 33.0 -
SVM 80.4 46.2 80.5
TextCNN 76.6 43.0 75.8
HAN 75.3 40.6 76.1
bow-CNN 82.7 44.7 83.3

L
oc

al
&

G
lo

ba
l

TD-SVM 80.1 50.7 80.5
HSVM∗ 69.3 33.3 -
HR-SVM∗ 72.8 38.6 -
HR-DGCNN∗ 76.1 43.2 -
HMCN 80.8 54.6 82.2
HiLAP (TextCNN) 78.6 50.5 80.1
HiLAP (HAN) 75.4 45.5 77.4
HiLAP (bow-CNN) 83.3 60.1 85.0

are provided in Appendix C due to limited space.
To incorporate one base model into our frame-

work, we remove its final feed-forward layer that
projects the object representation ed to a flat prob-
ability distribution of all labels (pFlat), and use ed
directly as the input of HiLAP. As one will see
in the later experiments, HiLAP consistently im-
proves the base model by modeling the label hier-
archy in an effective manner.

4.2 Compared Methods

1. Traditional HTC Methods. A major line of
work for HTC is Support Vector Machines (SVM)
and its hierarchical variants. Specifically, SVM
performs standard multi-label classification using
one-vs-the-rest (OvR) strategy. Leaf-SVM treats
each leaf node as a label and adds the ances-
tors of predicted leaf nodes. Variants such as
HSVM (Tsochantaridis et al., 2005), Top-Down
SVM (TD-SVM) (Liu et al., 2005), and Hierarchi-
cally Regularized SVM (HR-SVM) (Gopal and
Yang, 2013) are also tested. Other state-of-the-
art HTC methods that we compare with include
Clus-HMC (Vens et al., 2008) and CSSA (Bi and
Kwok, 2011).

2. Neural HTC Methods. There are not many
neural methods that specifically target HTC. We
mainly compare with two latest neural mod-
els: HR-DGCNN (Peng et al., 2018), which
extends hierarchical regularization (Gopal and
Yang, 2013) to Graph-CNN and compares fa-
vorably to flat models like RCNN (Lai et al.,

Table 3: Performance comparison on the NYT and
Yelp datasets. We mainly compare with competitive
baselines that perform well on RCV1.

Method NYT Yelp

Micro-F1 Macro-F1 EBF Micro-F1 Macro-F1 EBF

SVM 72.4 37.1 74.0 66.9 36.3 68.0
TextCNN 69.5 39.5 71.6 62.8 27.3 63.1
HAN 62.8 22.8 65.5 66.7 29.0 67.9
bow-CNN 72.9 33.4 74.1 63.6 23.9 63.9
TD-SVM 73.7 43.7 75.0 67.2 40.5 67.8
HMCN 72.2 47.4 74.2 66.4 42.7 67.6

HiLAP (TextCNN) 69.9 43.2 72.8 65.5 37.3 68.4
HiLAP (HAN) 65.2 28.7 68.0 69.7 38.1 72.4
HiLAP (bow-CNN) 74.6 51.6 76.6 68.9 42.8 71.5

2015) and XML-CNN (Liu et al., 2017), and
HMCN (Wehrmann et al., 2018), which out-
performs state-of-the-art HTC methods such as
HMC-LMLP (Cerri et al., 2016). We also com-
pare with the base models that we use for feature
encoding. The main aim is to see how much gain
they could obtain by combining each one of them
with HiLAP.

4.3 Implementation Details
For datasets without held-out set, we randomly
sample 10% from the training set as the validation
set following Johnson and Zhang (2014); Peng
et al. (2018). We only use the first 256 tokens of
each document for representation learning. All the
models are trained using an Adam optimizer with
initial learning rate 1e-3 and weight decay 1e-6.
We use GloVe (Pennington et al., 2014) with size
50 as word embeddings for TextCNN (Kim, 2014)
and HAN (Yang et al., 2016). We create a vocabu-
lary of the most frequent 30,000 words in the train-
ing data and generate multi-hot vectors as the input
of bow-CNN (Johnson and Zhang, 2014). For our
framework, since the parameter updates are per-
formed after T steps, we cache the object repre-
sentation ed and reuse it at each step for better ef-
ficiency. More details are provided in Appendix D
for reproducibility.

4.4 Performance Comparison
1. Comparison with State-of-the-art Meth-
ods. We compare the performance of HiLAP
to state-of-the-art HTC methods and show the
results in Tables 2 and 3. On RCV1, Hi-
LAP (HAN) achieves similar performance to HR-
DGCNN even though the corresponding base
model HAN is originally worse than HR-DGCNN.
HiLAP (TextCNN) outperforms most baselines in
Macro-F1 and perform similarly to TD-SVM de-
spite that it uses one global classifier while TD-



451

Micro-F1 Macro-F1 Samples-F1

TextCNN

0

20

40

60

80
R

C
V

1
78.1

33.4

78.676.6

43.0

75.877.8

45.1

77.278.6

50.5

80.1
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1

HAN

0

20

40

60

80 77.4

38.9

78.9
75.3

40.6

76.175.4

41.7

76.775.4

45.5

77.4HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1

bow-CNN

0

20

40

60

80 80.6

39.4

80.882.7

44.7

83.382.5

55.3

83.083.3

60.1

85.0
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1
0

10

20

30

40

50

60

70

N
Y

T

68.4

30.0

70.369.5

39.5

71.6
68.8

40.6

71.269.9

43.2

72.8
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1
0

10

20

30

40

50

60

70
63.7

21.8

65.9
62.8

22.8

65.5
60.5

23.2

64.065.2

28.7

68.0
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1
0

20

40

60

80
73.4

34.6

74.272.9

33.4

74.174.0

47.2

75.574.6

51.6

76.6
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1
0

10

20

30

40

50

60

70

Y
el

p

55.9

6.7

57.3
62.8

27.3

63.162.1

32.4

62.7
65.5

37.3

68.4
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1
0

10

20

30

40

50

60

70
70.8

18.7

72.0
66.7

29.0

67.967.0

30.1

68.769.7

38.1

72.4
HMCN
Flat
HiLAP-SL
HiLAP

Micro-F1 Macro-F1 Samples-F1
0

10

20

30

40

50

60

70

58.0

7.3

59.3
63.6

23.9

63.964.9

25.4

66.2
68.9

42.8

71.5
HMCN
Flat
HiLAP-SL
HiLAP

Figure 4: Performance comparison of different classification frameworks using the same base models. We
compare HiLAP with its flat, supervised variants, and HMCN. Results show that HiLAP exhibits consistent im-
provement over flat classifiers and larger gains than HMCN.

SVM uses a set of classifiers. Among all com-
pared methods, HiLAP (bow-CNN) achieves the
best performance on all the three metrics.4 On
NYT, similar results are observed: TextCNN and
HAN are both improved when combining with
HiLAP and HiLAP (bow-CNN) again achieves
the best performance. On Yelp, HiLAP (HAN)
achieves the best Micro-F1 and EBF, while HiLAP
(bow-CNN) obtains the highest Macro-F1.

2. Comparison using Same Base Models. We
compare the performance of different frameworks
that support the use of exactly the same base mod-
els and summarize the results in Fig. 4.5 Due to the
extreme imbalance of the data, directly applying a
flat model may suffer from low Macro-F1, i.e., the
predictions of flat models are inevitably biased to
the most popular labels. HMCN also has the same
issue, resulting in Macro-F1 lower than 10 when
combining with some base models. In contrast,
HiLAP outperforms the baselines significantly in
Macro-F1, which implies that our method is bet-

4The results are not comparable with Johnson and Zhang
(2014) due to implementation details and the fact that
they tune the threshold for each label using k-fold cross-
validation. See Appendix B for more discussions.

5For HMCN, we replace its static features with the same
base model for fair comparison.

Table 4: Performance comparison on Functional
Catalogue and Gene Ontology. We compare with
state-of-the-art hierarchical classification methods that
take exactly the same raw features as input (i.e., we ex-
clude models designed specifically for text objects).

Method FunCat GO

Micro-F1 Macro-F1 EBF Micro-F1 Macro-F1 EBF

SVM 2.72 1.21 3.42 34.1 1.46 36.8
CSSA 16.0 4.60 14.8 11.6 0.76 11.5
CLUS-HMC 25.2 4.14 24.1 41.4 3.01 40.3
HMCN 21.3 5.07 21.5 43.2 3.81 43.3
HiLAP 26.5 7.50 27.4 45.4 5.87 45.2

ter at tackling labels with relatively few examples.
It is also observed that HiLAP-SL sometimes may
have a negative effect in terms of Micro-F1, al-
though it is usually marginal compared with the
gains in Macro-F1. However, such negative ef-
fects are eliminated by HiLAP through better ex-
ploration of the label hierarchy. Overall, HiLAP
achieves the highest performance on 24 of 27 re-
sults among the combinations of three datasets,
three base models, and three evaluation metrics. In
particular, HiLAP yields an average improvement
of 33.4% in Macro-F1 compared to corresponding
base models.

3. Results on Functional Genomics Predic-
tion. We compare HiLAP with CSSA (Bi and



452

Table 5: Ablation study of HiLAP. We evaluate vari-
ants of HiLAP using bow-CNN (Johnson and Zhang,
2014) on RCV1 (Lewis et al., 2004).

Method Micro-F1 Macro-F1 EBF

Flat-Only 82.7 44.7 83.3
HiLAP-SL-NoFlat 81.0 52.1 81.7
HiLAP-SL 82.5 55.3 83.0
HiLAP-NoSL 83.2 59.3 85.0
HiLAP-NoFlat 83.0 59.8 84.7
HiLAP 83.3 60.1 85.0

Kwok, 2011), CLUS-HMC (Vens et al., 2008),
and HMCN (Wehrmann et al., 2018) on the Fun-
Cat and GO datasets, as they represent the state-
of-the-art on these datasets. An SVM classifier is
also evaluated to better understand the difficulties
of the task. We use the same raw features as the
input of all the methods for apples-to-apples com-
parison and list the results in Table 4. Note that
the metric area under the average precision-recall
curve (AUPRC) (Wehrmann et al., 2018) is not ap-
plicable because HiLAP does not use a flat prob-
ability distribution of all the labels. As one can
see, HiLAP outperforms all the baselines on both
datasets by a large margin. In particular, we ob-
serve significant improvement on Macro-F1 over
the best baseline (47.9% and 53.9%, respectively),
which shows that our method is especially better at
classifying sparse labels than previous approaches.

4.5 Performance Analysis

1. Ablation Study on Different Framework
Components. We show the ablation analysis of
HiLAP in Table 5. Using Flat-Only degener-
ates HiLAP to the flat baseline. By comparing
the results of Flat-Only and HiLAP-SL-NoFlat (a
variant of HiLAP-SL without flat loss), we fur-
ther confirm that flat approaches are likely to ne-
glect sparse labels, which results in low Macro-
F1. Local approaches (HiLAP-SL-NoFlat), on the
other hand, are slightly worse in terms of Micro-
F1 and EBF but significantly better on Macro-F1.
By combining flat and local information, HiLAP-
SL achieves performance close to Flat-Only on
Micro-F1 and EBF, and even higher Macro-F1
than HiLAP-SL-NoFlat. HiLAP-NoSL is initial-
ized by the pre-trained HiLAP-SL model without
mixing the supervised loss during its training. We
can see that using the reinforced loss alone still
improves the performance on all the three metrics.
After removing the flat loss during the training of

HiLAP, HiLAP-NoFlat shows slightly lower per-
formance than the full HiLAP model, indicating
that the flat component serves as a regularization
of the base model and is beneficial to the overall
performance.

2. Performance Study on Label Granularity
and Popularity. We analyze the sources of perfor-
mance gains by dividing the labels based on their
levels and number of supporting examples. Fig. 5
shows the absolute Macro-F1 differences between
several methods and the base model. We observe
similar results for other setups and omit them for
a clearer view. As depicted in Fig. 5, HiLAP and
HiLAP-SL are especially beneficial to unpopular
labels (P3) at the bottom levels (L3).

L1 L2 L3

Level-based Macro-F1 Gains

0

5

10

15

20

A
bs

ol
ut

e 
D

iff
er

en
ce

HiLAP
HiLAP-SL
HMCN

P1 P2 P3

Popularity-based Macro-F1 Gains

0

5

10

15

20

25

30

A
bs

ol
ut

e 
D

iff
er

en
ce

HiLAP
HiLAP-SL
HMCN

Figure 5: Performance Study on Label Granular-
ity and Popularity. We compute level-based and
popularity-based Macro-F1 gains on NYT with bow-
CNN as base model. We denote the levels of the hier-
archy with L1, L2, and L3 (left) and divide the labels
into three equal sized categories (P1, P2, and P3) in a
descending order by their number of examples (right).

3. Analysis of Label Inconsistency. Label incon-
sistencies often happen in approaches that perform
flat inference, but they are not measured by stan-
dard evaluation metrics like F1 scores. To provide
a picture of how severe the issue is, we further
conduct experiments to check the percentage of
objects that are predicted with inconsistent labels
(Table 6). We found, for example, 29,186/781,265
(3.74%) predictions of TextCNN have inconsistent
on RCV1. In contrast, HiLAP ensures 0% label
inconsistency without the need of post-processing,
because its predictions are always valid sub-trees
of the label hierarchy (refer to Fig. 2).

Table 6: Analysis of Label Inconsistency. We com-
pare various methods by the percentage of predictions
with inconsistent labels on RCV1 (Lewis et al., 2004).

SVM TextCNN HMCN HiLAP

4.83% 3.74% 3.84% 0%



453

5 Related Work

Hierarchical classification approaches have been
developed for many applications. For text clas-
sification, both traditional methods (Lewis et al.,
2004; Gopal and Yang, 2013) and neural meth-
ods (Johnson and Zhang, 2014; Peng et al., 2018)
have been proposed to classify, e.g., the topics of
newswire and web content (Sun and Lim, 2001)
or categories of laws and patents (Bi and Kwok,
2015; Cai and Hofmann, 2004; Rousu et al.,
2005). Many previous studies (Liu et al., 2005;
Sun and Lim, 2001) train a set of local classifiers
and make predictions in a top-down manner. In
particular, Bi and Kwok (2015) develop Bayes-
optimal predictions that minimize the global risks
but their model is still locally trained. Such local
approaches are not popularly used among recent
neural-based HTC models (Johnson and Zhang,
2014; Peng et al., 2018) since it is usually infea-
sible to train many neural classifiers locally.

Global methods, on the other hand, train only
one classifier. Although global methods are de-
sirable, they are relatively less studied due to the
complexity of the problem. Existing global mod-
els are generally modified based on specific flat
models. Hierarchical-SVM (Cai and Hofmann,
2004; Qiu et al., 2009) generalizes Support Vec-
tor Machine (SVM) learning based on discrimi-
nant functions that are structured in a way that
mirrors the label hierarchy. One limitation is that
Hierarchical-SVM only supports balanced tree (all
possible labels are presumed to be at the same
level in their experiments). Hierarchical naive
Bayes (Silla Jr and Freitas, 2009) modifies naive
Bayes by updating weights of one’s ancestors as
well whenever one label’s weights are updated.
There are other global methods that are based on
association rules (Wang et al., 2001), C4.5 (Clare
and King, 2003), kernel machines (Rousu et al.,
2005), and decision tree (Vens et al., 2008). Con-
straints such as the regularization that enforces
the parameters of one node and its parent to be
similar (Gopal and Yang, 2013) are also proposed
to leverage the label hierarchy while maintaining
scalability. However, their use of the label hierar-
chies is somewhat limited compared with HiLAP.

6 Conclusions

We proposed an end-to-end reinforcement learn-
ing approach to hierarchical text classification
(HTC) where objects are labeled by placing them

at the proper positions in the label hierarchy.
The proposed framework makes consistent and
inter-dependent predictions, in which any neural-
based representation learning model can be used
as a base model and a label assignment policy is
learned to determine where to place the objects
and when to stop the assignment process. Exper-
iments on five public datasets and four base mod-
els showed that our approach outperforms state-
of-the-art HTC methods significantly. For future
work, we will explore the effectiveness of the pro-
posed framework on other base models and forms
of data (e.g., images). We will introduce more
losses covering other aspects in the objective func-
tion to further improve the performance of our
framework.

Acknowledgments

Research was sponsored in part by U.S. Army
Research Lab under Cooperative Agreement
No. W911NF-09-2-0053 (NSCTA), DARPA un-
der Agreement No. W911NF-17-C-0099, Na-
tional Science Foundation IIS 16-18481, IIS 17-
04532, and IIS-17-41317, grant 1U54GM-114838
awarded by NIGMS, National Science Founda-
tion SMA 18-29268, DARPA MCS and GAILA,
IARPA BETTER, Schmidt Family Foundation,
Amazon Faculty Award, Google Research Award,
Snapchat Gift, and JP Morgan AI Research Award.
We thank Chao Zhang, Xiao-Yang Liu, Qingrong
Chen, Jun Yan, collaborators in the INK research
lab, and anonymous reviewers for their help and
valuable feedback.

References
Rahul Agrawal, Archit Gupta, Yashoteja Prabhu, and

Manik Varma. 2013. Multi-label learning with
millions of labels: Recommending advertiser bid
phrases for web pages. In WWW, pages 13–24.
ACM.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. arXiv preprint
arXiv:1409.0473.

Wei Bi and Jame T Kwok. 2015. Bayes-optimal
hierarchical multilabel classification. TKDE,
27(11):2907–2918.

Wei Bi and James T Kwok. 2011. Multi-label classi-
fication on tree-and dag-structured hierarchies. In
ICML-11, pages 17–24.



454

Lijuan Cai and Thomas Hofmann. 2004. Hierarchi-
cal document categorization with support vector ma-
chines. In CIKM, pages 78–87. ACM.

Asli Celikyilmaz, Antoine Bosselut, Xiaodong He, and
Yejin Choi. 2018. Deep communicating agents for
abstractive summarization. In NAACL, pages 1662–
1675.

Ricardo Cerri, Rodrigo C Barros, André CPLF de Car-
valho, and Yaochu Jin. 2016. Reduction strate-
gies for hierarchical multi-label classification in
protein function prediction. BMC bioinformatics,
17(1):373.

Nicolò Cesa-Bianchi, Claudio Gentile, and Luca Zani-
boni. 2006. Hierarchical classification: combining
bayes with svm. In ICML, pages 177–184. ACM.

Amanda Clare and Ross D King. 2003. Predicting gene
function in saccharomyces cerevisiae. Bioinformat-
ics, 19(suppl 2):ii42–ii49.

Siddharth Gopal and Yiming Yang. 2013. Recursive
regularization for large-scale classification with hi-
erarchical and graphical dependencies. In KDD,
pages 257–265. ACM.

Boris Hayete and Jadwiga R Bienkowska. 2005.
Gotrees: predicting go associations from protein do-
main composition using decision trees. In Biocom-
puting 2005, pages 127–138. World Scientific.

Rie Johnson and Tong Zhang. 2014. Effective
use of word order for text categorization with
convolutional neural networks. arXiv preprint
arXiv:1412.1058.

Yoon Kim. 2014. Convolutional neural net-
works for sentence classification. arXiv preprint
arXiv:1408.5882.

Daphne Koller and Mehran Sahami. 1997. Hierarchi-
cally classifying documents using very few words.
In ICML, pages 170–178. Morgan Kaufmann Pub-
lishers Inc.

Siwei Lai, Liheng Xu, Kang Liu, and Jun Zhao. 2015.
Recurrent convolutional neural networks for text
classification. In AAAI, volume 333, pages 2267–
2273.

David D Lewis, Yiming Yang, Tony G Rose, and Fan
Li. 2004. Rcv1: A new benchmark collection for
text categorization research. Journal of machine
learning research, 5(Apr):361–397.

Jingzhou Liu, Wei-Cheng Chang, Yuexin Wu, and
Yiming Yang. 2017. Deep learning for extreme
multi-label text classification. In Proceedings of the
40th International ACM SIGIR Conference on Re-
search and Development in Information Retrieval,
pages 115–124. ACM.

Tie-Yan Liu, Yiming Yang, Hao Wan, Hua-Jun Zeng,
Zheng Chen, and Wei-Ying Ma. 2005. Support vec-
tor machines classification with a very large-scale
taxonomy. Acm Sigkdd Explorations Newsletter,
7(1):36–43.

Yuning Mao, Xiang Ren, Jiaming Shen, Xiaotao Gu,
and Jiawei Han. 2018. End-to-end reinforcement
learning for automatic taxonomy induction. In ACL,
pages 2462–2472. Association for Computational
Linguistics.

Yu Meng, Jiaming Shen, Chao Zhang, and Jiawei Han.
2018. Weakly-supervised neural text classification.
In CIKM.

Ioannis Partalas, Aris Kosmopoulos, Nicolas Baskiotis,
Thierry Artières, George Paliouras, Éric Gaussier,
Ion Androutsopoulos, Massih-Reza Amini, and
Patrick Gallinari. 2015. LSHTC: A bench-
mark for large-scale text classification. CoRR,
abs/1503.08581.

Hao Peng, Jianxin Li, Yu He, Yaopeng Liu, Mengjiao
Bao, Lihong Wang, Yangqiu Song, and Qiang Yang.
2018. Large-scale hierarchical text classification
with recursively regularized deep graph-cnn. In
WWW, pages 1063–1072.

Shengwen Peng, Ronghui You, Hongning Wang,
Chengxiang Zhai, Hiroshi Mamitsuka, and Shan-
feng Zhu. 2016. Deepmesh: deep semantic repre-
sentation for improving large-scale mesh indexing.
Bioinformatics, 32(12):i70–i79.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. Glove: Global vectors for word
representation. In EMNLP, pages 1532–1543.

Xipeng Qiu, Wenjun Gao, and Xuanjing Huang. 2009.
Hierarchical multi-class text categorization with
global margin maximization. In acl-ijcnlp 2009,
pages 165–168.

Bo Qu, Gao Cong, Cuiping Li, Aixin Sun, and Hong
Chen. 2012. An evaluation of classification models
for question topic categorization. JASIST, 63:889–
903.

Steven J Rennie, Etienne Marcheret, Youssef Mroueh,
Jarret Ross, and Vaibhava Goel. 2017. Self-critical
sequence training for image captioning. In CVPR,
page 3.

Juho Rousu, Craig Saunders, Sandor Szedmak, and
John Shawe-Taylor. 2005. Learning hierarchical
multi-category text classification models. In ICML,
pages 744–751. ACM.

Evan Sandhaus. 2008. The new york times annotated
corpus. Linguistic Data Consortium, Philadelphia,
6(12):e26752.

Carlos N Silla and Alex A Freitas. 2011. A survey
of hierarchical classification across different appli-
cation domains. Data Mining and Knowledge Dis-
covery, 22(1-2):31–72.



455

Carlos N Silla Jr and Alex A Freitas. 2009. A global-
model naive bayes approach to the hierarchical pre-
diction of protein functions. In ICDM’09, pages
992–997. IEEE.

Aixin Sun and Ee-Peng Lim. 2001. Hierarchical text
classification and evaluation. In ICDM.

Ioannis Tsochantaridis, Thorsten Joachims, Thomas
Hofmann, and Yasemin Altun. 2005. Large mar-
gin methods for structured and interdependent out-
put variables. Journal of machine learning research,
6(Sep):1453–1484.

Celine Vens, Jan Struyf, Leander Schietgat, Sašo
Džeroski, and Hendrik Blockeel. 2008. Decision
trees for hierarchical multi-label classification. Ma-
chine Learning, 73(2):185.

Ke Wang, Senqiang Zhou, and Yu He. 2001. Hierar-
chical classification of real life documents. In SDM,
pages 1–16. SIAM.

Jonatas Wehrmann, Ricardo Cerri, and Rodrigo Barros.
2018. Hierarchical multi-label classification net-
works. In ICML, pages 5225–5234.

Ronald J Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine learning, 8(3-4):229–256.

IPC WIPO. 2014. International patent classification
(ipc). World Intellectual Property Organization,
Geneve.

Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He,
Alex Smola, and Eduard Hovy. 2016. Hierarchical
attention networks for document classification. In
NAACL, pages 1480–1489.


