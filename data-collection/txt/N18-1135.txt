



















































Learning Joint Semantic Parsers from Disjoint Data


Proceedings of NAACL-HLT 2018, pages 1492–1502
New Orleans, Louisiana, June 1 - 6, 2018. c©2018 Association for Computational Linguistics

Learning Joint Semantic Parsers from Disjoint Data

Hao Peng♦ Sam Thomson♣ Swabha Swayamdipta♣ Noah A. Smith♦
♦ Paul G. Allen School of Computer Science & Engineering, University of Washington

♣ School of Computer Science, Carnegie Mellon University
{hapeng,nasmith}@cs.washington.edu, {sthomson,swabha}@cs.cmu.edu

Abstract
We present a new approach to learning se-
mantic parsers from multiple datasets, even
when the target semantic formalisms are dras-
tically different, and the underlying corpora do
not overlap. We handle such “disjoint” data
by treating annotations for unobserved for-
malisms as latent structured variables. Build-
ing on state-of-the-art baselines, we show im-
provements both in frame-semantic parsing
and semantic dependency parsing by model-
ing them jointly. Our code is open-source
and available at https://github.com/
Noahs-ARK/NeurboParser.

1 Introduction

Semantic parsing aims to automatically predict
formal representations of meaning underlying nat-
ural language, and has been useful in question an-
swering (Shen and Lapata, 2007), text-to-scene
generation (Coyne et al., 2012), dialog systems
(Chen et al., 2013) and social-network extraction
(Agarwal et al., 2014), among others. Various for-
mal meaning representations have been developed
corresponding to different semantic theories (Fill-
more, 1982; Palmer et al., 2005; Flickinger et al.,
2012; Banarescu et al., 2013). The distributed
nature of these efforts results in a set of anno-
tated resources that are similar in spirit, but not
strictly compatible. A major axis of structural di-
vergence in semantic formalisms is whether based
on spans (Baker et al., 1998; Palmer et al., 2005)
or dependencies (Surdeanu et al., 2008; Oepen
et al., 2014; Banarescu et al., 2013; Copestake
et al., 2005, inter alia). Depending on applica-
tion requirements, either might be most useful in a
given situation.

Learning from a union of these resources seems
promising, since more data almost always trans-
lates into better performance. This is indeed the
case for two prior techniques—parameter sharing

Only a few books fell in the reading

arg1

room .
arg1

mwe
arg1 arg1

arg2

BV

compound

top

in.prep

Locative 
RelationFigure Ground

fall.v
Motion

DirectionalTheme Place
a few.art  

Quantity Individuals

Figure 1: An example sentence from the FrameNet
1.5 corpus, shown with an author-annotated DM
semantic dependency graph (above) and frame-
semantic annotation (below). Two more gold
frames (and their arguments) have been omitted
for space.

(FitzGerald et al., 2015; Kshirsagar et al., 2015),
and joint decoding across multiple formalisms us-
ing cross-task factors that score combinations of
substructures from each (Peng et al., 2017). Pa-
rameter sharing can be used in a wide range of
multitask scenarios, when there is no data overlap
or even any similarity between the tasks (Collobert
and Weston, 2008; Søgaard and Goldberg, 2016).
But techniques involving joint decoding have so
far only been shown to work for parallel annota-
tions of dependency-based formalisms, which are
structurally very similar to each other (Lluı́s et al.,
2013; Peng et al., 2017). Of particular interest is
the approach of Peng et al., where three kinds of
semantic graphs are jointly learned on the same in-
put, using parallel annotations. However, as new
annotation efforts cannot be expected to use the
same original texts as earlier efforts, the utility of
this approach is limited.

We propose an extension to Peng et al.’s formu-
lation which addresses this limitation by consid-
ering disjoint resources, each containing only a
single kind of annotation. Moreover, we consider
structurally divergent formalisms, one dealing
with semantic spans and the other with semantic

1492



dependencies. We experiment on frame-semantic
parsing (Gildea and Jurafsky, 2002; Das et al.,
2010), a span-based semantic role labeling (SRL)
task (§2.1), and on a dependency-based minimum
recursion semantic parsing (DELPH-IN MRS, or
DM; Flickinger et al., 2012) task (§2.2). See Fig-
ure 1 for an example sentence with gold FrameNet
annotations, and author-annotated DM representa-
tions.

Our joint inference formulation handles missing
annotations by treating the structures that are not
present in a given training example as latent vari-
ables (§3).1 Specifically, semantic dependencies
are treated as a collection of latent variables when
training on FrameNet examples.

Using this latent variable formulation, we
present an approach for relating spans and depen-
dencies, by explicitly scoring affinities between
pairs of potential spans and dependencies. Be-
cause there are a huge number of such pairs, we
limit our consideration to only certain pairs—our
design is inspired by the head rules of Surdeanu
et al. (2008). Further possible span-dependency
pairs are pruned using an `1-penalty technique
adapted from sparse structure learning (§5). Neu-
ral network architectures are used to score frame-
semantic structures, semantic dependencies, as
well as cross-task structures (§4).

To summarize, our contributions include:
• using a latent variable formulation to ex-

tend cross-task scoring techniques to scenar-
ios where datasets do not overlap;
• learning cross-task parts across structurally

divergent formalisms; and
• using an `1-penalty technique to prune the

space of cross task parts.
Our approach results in a new state-of-the-art
in frame-semantic parsing, improving prior
work by 0.8% absolute F1 points (§6), and
achieves competitive performance on semantic
dependency parsing. Our code is available
at https://github.com/Noahs-ARK/
NeurboParser.

2 Tasks and Related Work

We describe the two tasks addressed in this
work—frame-semantic parsing (§2.1) and seman-
tic dependency parsing (§2.2)—and discuss how

1Following past work on support vector machines with
latent variables (Yu and Joachims, 2009), we use the term
“latent variable,” even though the model is not probabilistic.

their structures relate to each other (§2.3).

2.1 Frame-Semantic Parsing

Frame-semantic parsing is a span-based task, un-
der which certain words or phrases in a sentence
evoke semantic frames. A frame is a group of
events, situations, or relationships that all share the
same set of participant and attribute types, called
frame elements or roles. Gold supervision for
frame-semantic parses comes from the FrameNet
lexicon and corpus (Baker et al., 1998).

Concretely, for a given sentence, x, a frame-
semantic parse y consists of:

• a set of targets, each being a short span (usu-
ally a single token2) that evokes a frame;
• for each target t, the frame f that it evokes;

and
• for each frame f , a set of non-overlapping ar-

gument spans in the sentence, each argument
a = (i, j, r) having a start token index i, end
token index j and role label r.

The lemma and part-of-speech tag of a target
comprise a lexical unit (or LU). The FrameNet
ontology provides a mapping from an LU ` to
the set of possible frames it could evoke, F`.
Every frame f ∈ F` is also associated with
a set of roles, Rf under this ontology. For
example, in Figure 1, the LU “fall.v” evokes
the frame MOTION DIRECTIONAL. The roles
THEME and PLACE (which are specific to MO-
TION DIRECTIONAL), are filled by the spans
“Only a few books” and “in the reading room” re-
spectively. LOCATIVE RELATION has other roles
(PROFILED REGION, ACCESSIBILITY, DEIXIS,
etc.) which are not realized in this sentence.

In this work, we assume gold targets and LUs
are given, and parse each target independently,
following the literature (Johansson and Nugues,
2007; FitzGerald et al., 2015; Yang and Mitchell,
2017; Swayamdipta et al., 2017, inter alia). More-
over, following Yang and Mitchell (2017), we per-
form frame and argument identification jointly.
Most prior work has enforced the constraint that
a role may be filled by at most one argument span,
but following Swayamdipta et al. (2017) we do not
impose this constraint, requiring only that argu-
ments for the same target do not overlap.

296.5% of targets in the training data are single tokens.

1493



2.2 Semantic Dependency Parsing

Broad-coverage semantic dependency parsing
(SDP; Oepen et al., 2014, 2015, 2016) represents
sentential semantics with labeled bilexical depen-
dencies. The SDP task mainly focuses on three
semantic formalisms, which have been converted
to dependency graphs from their original annota-
tions. In this work we focus on only the DELPH-
IN MRS (DM) formalism.

Each semantic dependency corresponds to a la-
beled, directed edge between two words. A sin-
gle token is also designated as the top of the
parse, usually indicating the main predicate in the
sentence. For example in Figure 1, the left-most
arc has head “Only”, dependent “few”, and label
arg1. In semantic dependencies, the head of an
arc is analogous to the target in frame semantics,
the destination corresponds to the argument, and
the label corresponds to the role. The same set of
labels are available for all arcs, in contrast to the
frame-specific roles in FrameNet.

2.3 Spans vs. Dependencies

Early semantic role labeling was span-based
(Gildea and Jurafsky, 2002; Toutanova et al.,
2008, inter alia), with spans corresponding to syn-
tactic constituents. But, as in syntactic parsing,
there are sometimes theoretical or practical rea-
sons to prefer dependency graphs. To this end,
Surdeanu et al. (2008) devised heuristics based on
syntactic head rules (Collins, 2003) to transform
PropBank (Palmer et al., 2005) annotations into
dependencies. Hence, for PropBank at least, there
is a very direct connection (through syntax) be-
tween spans and dependencies.

For many other semantic representations, such
a direct relationship might not be present. Some
semantic representations are designed as graphs
from the start (Hajič et al., 2012; Banarescu et al.,
2013), and have no gold alignment to spans. Con-
versely, some span-based formalisms are not an-
notated with syntax (Baker et al., 1998; He et al.,
2015),3 and so head rules would require using
(noisy and potentially expensive) predicted syn-
tax.

Inspired by the head rules of Surdeanu et al.
(2008), we design cross-task parts, without relying

3 In FrameNet, phrase types of arguments and their gram-
matical function in relation to their target have been anno-
tated. But in order to apply head rules, the internal structure
of arguments (or at least their semantic heads) would also re-
quire syntactic annotations.

on gold or predicted syntax (which may be either
unavailable or error-prone) or on heuristics.

3 Model

Given an input sentence x, and target t with
its LU `, denote the set of valid frame-semantic
parses (§2.1) as Y(x, t, `), and valid semantic de-
pendency parses as Z(x).4 We learn a parameter-
ized function S that scores candidate parses. Our
goal is to jointly predict a frame-semantic parse
and a semantic dependency graph by selecting the
highest scoring candidates:

(ŷ, ẑ) = arg max
(y,z)∈Y(x,t,`)×Z(x)

S(y, z,x, t, `). (1)

The overall score S can be decomposed into the
sum of frame SRL score Sf, semantic dependency
score Sd, and a cross-task score Sc:

S(y, z,x, t, `) = Sf(y,x, t, `) + Sd(z,x)

+Sc(y, z,x, t,`).
(2)

Sf and Sc require access to the target and LU, in
addition to x, but Sd does not. For clarity, we omit
the dependence on the input sentence, target, and
lexical unit, whenever the context is clear. Below
we describe how each of the scores is computed
based on the individual parts that make up the
candidate parses.
Frame SRL score. The score of a frame-
semantic parse consists of
• the score for a predicate part, sf (p) where

each predicate is defined as a combination of
a target t, the associated LU, `, and the frame
evoked by the LU, f ∈ F`;
• the score for argument parts, sf (a), each as-

sociated with a token span and semantic role
fromRf .

Together, this results in a set of frame-semantic
parts of size O(n2 |F`| |Rf |).5 The score for a
frame semantic structure y is the sum of local
scores of parts in y:

Sf(y) =
∑

yi∈y
sf(yi). (3)

The computation of sf is described in §4.2.
4For simplicity, we consider only a single target here; han-

dling of multiple targets is discussed in §6.
5With pruning (described in §6) we reduce this to a num-

ber of parts linear in n. Also, |F`| is usually small (averaging
1.9), as is |Rf | (averaging 9.5).

1494



includes
include.v
Inclusion

Evidence to support this argument
Total

…

Figure 2: An example of cross-task parts from the
FrameNet 1.5 development set. We enumerate
all unlabeled semantic dependencies from the first
word of the target (includes) to any token inside
the span. The red bolded arc indicates the predic-
tion of our model.

Semantic dependency score. Following Mar-
tins and Almeida (2014), we consider three types
of parts in a semantic dependency graph: seman-
tic heads, unlabeled semantic arcs, and labeled se-
mantic arcs. Analogous to Equation 3, the score
for a dependency graph z is the sum of local
scores:

Sd(z) =
∑

zj∈z
sd(zj), (4)

The computation of sd is described in §4.3.
Cross task score. In addition to task-specific
parts, we introduce a set C of cross-task parts.
Each cross-task part relates an argument part from
y to an unlabeled dependency arc from z. Based
on the head-rules described in §2.3, we consider
unlabeled arcs from the target to any token inside
the span.6 Intuitively, an argument in FrameNet
would be converted into a dependency from its tar-
get to the semantic head of its span. Since we do
not know the semantic head of the span, we con-
sider all tokens in the span as potential modifiers
of the target. Figure 2 shows examples of cross-
task parts. The cross-task score is given by

Sc(y, z) =
∑

(yi,zj)∈(y×z)∩C
sc(yi, zj). (5)

The computation of sc is described in §4.4.
In contrast to previous work (Lluı́s et al., 2013;

Peng et al., 2017), where there are parallel annota-
tions for all formalisms, our input sentences con-
tain only one of the two—either the span-based
frame SRL annotations, or semantic dependency
graphs from DM. To handle missing annotations,
we treat semantic dependencies z as latent when

6Most targets are single-words (§2.1). For multi-token
targets, we consider only the first token, which is usually
content-bearing.

decoding frame-semantic structures.7 Because the
DM dataset we use does not have target anno-
tations, we do not use latent variables for frame
semantic structures when predicting semantic de-
pendency graphs. The parsing problem here re-
duces to

ẑ = arg max
z∈Z

Sd(z), (6)

in contrast with Equation 1 .

4 Parameterizations of Scores

This section describes the parametrization of the
scoring functions from §3. At a very high level:
we learn contextualized token and span vectors
using a bidirectional LSTM (biLSTM; Graves,
2012) and multilayer perceptrons (MLPs) (§4.1);
we learn lookup embeddings for LUs, frames,
roles, and arc labels; and to score a part, we
combine the relevant representations into a single
scalar score using a (learned) low-rank multilin-
ear mapping. Scoring frames and arguments is
detailed in §4.2, that of dependency structures in
§4.3, and §4.4 shows how to capture interactions
between arguments and dependencies. All param-
eters are learned jointly, through the optimization
of a multitask objective (§5).
Tensor notation. The order of a tensor is the
number of its dimensions—an order-2 tensor is a
matrix and an order-1 tensor is a vector. Let ⊗
denote tensor product; the tensor product of two
order-2 tensors A and B yields an order-4 tensor
where (A ⊗B)i,j,k,l = Ai,jBk,l. We use 〈·, ·〉 to
denote inner products.

4.1 Token and Span Representations

The representations of tokens and spans are
formed using biLSTMs followed by MLPs.

Contextualized token representations. Each
token in the input sentence x is mapped to an
embedding vector. Two LSTMs (Hochreiter and
Schmidhuber, 1997) are run in opposite directions
over the input vector sequence. We use the con-
catenation of the two hidden representations at
each position i as a contextualized word embed-
ding for each token:

hi =
[−→
h i;
←−
h i
]
. (7)

7Semantic dependency parses over a sentence are not con-
strained to be identical for different frame-semantic targets.

1495



Span representations. Following Lee et al.
(2017), span representations are computed based
on boundary word representations and discrete
length and distance features. Concretely, given a
target t and its associated argument a = (i, j, r)
with boundary indices i and j, we compute three
features φt(a) based on the length of a, and the
distances from i and j to the start of t. We con-
catenate the token representations at a’s boundary
with the discrete features φt(a). We then use a
two-layer tanh-MLP to compute the span repre-
sentation:

gspan(i, j) = MLPspan
(
[hi;hj ;φt(a)]

)
. (8)

The target representation gtgt(t) is similarly com-
puted using a separate MLPtgt, with a length fea-
ture but no distance features.

4.2 Frame and Argument Scoring
As defined in §3, the representation for a predi-
cate part incorporates representations of a target
span, the associated LU and the frame evoked by
the LU. The score for a predicate part is given by
a multilinear mapping:

gpred(f) = gfr(f)⊗ gtgt(t)⊗ glu(`) (9a)
sf(p) =

〈
W,gpred(f)

〉
, (9b)

where W is a low-rank order-3 tensor of learned
parameters, and gfr(f) and glu(`) are learned
lookup embeddings for the frame and LU.

A candidate argument consists of a span and its
role label, which in turn depends on the frame, tar-
get and LU. Hence the score for argument part,
a = (i, j, r) is given by extending definitions from
Equation 9:

garg(a) = gspan(i, j)⊗ grole(r), (10a)
sf(a) =

〈
W⊗U,gpred(f)⊗ garg(a)

〉
, (10b)

where U is a low-rank order-2 tensor of learned
parameters and grole(r) is a learned lookup em-
bedding of the role label.

4.3 Dependency Scoring
Local scores for dependencies are implemented
with two-layer tanh-MLPs, followed by a final
linear layer reducing the represenation to a single
scalar score. For example, let u = i→j denote
an unlabeled arc (ua). Its score is:

gua(u) = MLPua
(
[hi;hj ]

)
(11a)

sd(u) = w
ua · gua(u), (11b)

where wua is a vector of learned weights. The
scores for other types of parts are computed simi-
larly, but with separate MLPs and weights.

4.4 Cross-Task Part Scoring

As shown in Figure 2, each cross-task part c con-
sists of two first-order parts: a frame argument part
a, and an unlabeled dependency part, u. The score
for a cross-task part incorporates both:

sc (c) =
〈
W⊗U⊗V,gpred(f)⊗ garg(a)

⊗ wua ⊗ gua(u)
〉
,

(12)

where V is a low-rank order-2 tensor of parame-
ters. Following previous work (Lei et al., 2014;
Peng et al., 2017), we construct the parameter ten-
sors W, U, and V so as to upper-bound their ranks.

5 Training and Inference

All parameters from the previous sections are
trained using a max-margin training objective
(§5.1). For inference, we use a linear program-
ming procedure, and a sparsity-promoting penalty
term for speeding it up (§5.2).

5.1 Max-Margin Training

Let y∗ denote the gold frame-semantic parse, and
let δ (y,y∗) denote the cost of predicting y with
respect to y∗. We optimize the latent structured
hinge loss (Yu and Joachims, 2009), which gives a
subdifferentiable upper-bound on δ:

L (y∗) = max
(y,z)∈Y×Z

{S (y, z) + δ (y,y∗)}

−max
z∈Z
{S (y∗, z)} .

(13)

Following Martins and Almeida (2014), we use a
weighted Hamming distance as the cost function,
where, to encourage recall, we use costs 0.6 for
false negative predictions and 0.4 for false posi-
tives. Equation 13 can be evaluated by applying
the same max-decoding algorithm twice—once
with cost-augmented inference (Crammer et al.,
2006), and once more keeping y∗ fixed. Train-
ing then aims to minimize the average loss over
all training instances.8

Another potential approach to training a model
on disjoint data would be to marginalize out the

8We do not use latent frame structures when decoding se-
mantic dependency graphs (§3). Hence, the loss reduces to
structured hinge (Tsochantaridis et al., 2004) when training
on semantic dependencies.

1496



latent structures and optimize the conditional log-
likelihood (Naradowsky et al., 2012). Although
max-decoding and computing marginals are both
NP-hard in general graphical models, there are
more efficient off-the-shelf implementations for
approximate max-decoding, hence, we adopt a
max-margin formulation.

5.2 Inference

We formulate the maximizations in Equation 13
as 0–1 integer linear programs and use AD3 to
solve them (Martins et al., 2011). We only
enforce a non-overlapping constraint when de-
coding FrameNet structures, so that the argu-
ment identification subproblem can be efficiently
solved by a dynamic program (Kong et al., 2016;
Swayamdipta et al., 2017). When decoding se-
mantic dependency graphs, we enforce the deter-
minism constraint (Flanigan et al., 2014), where
certain labels may appear on at most one arc out-
going from the same token.
Inference speedup by promoting sparsity. As
discussed in §3, even after pruning, the number of
within-task parts is linear in the length of the in-
put sentence, so the number of cross-task parts is
quadratic. This leads to potentially very slow in-
ference. We address this problem by imposing an
`1 penalty on the cross-task part scores:

L
(
y∗
)
+ λ

∑

(yi,zj)∈C

∣∣sc(yi, zj)
∣∣, (14)

where λ is a hyperparameter, set to 0.01 as a prac-
tical tradeoff between efficiency and development
set performance. Whenever the score for a cross-
task part is driven to zero, that part’s score no
longer needs to be considered during inference.
It is important to note that by promoting sparsity
this way, we do not prune out any candidate solu-
tions. We are instead encouraging fewer terms in
the scoring function, which leads to smaller, faster
inference problems even though the space of fea-
sible parses is unchanged.

The above technique is closely related to a line
of work in estimating the structure of sparse graph-
ical models (Yuan and Lin, 2007; Friedman et al.,
2008), where an `1 penalty is applied to the inverse
covariance matrix in order to induce a smaller
number of conditional dependencies between vari-
ables. To the best of our knowledge, we are the
first to apply this technique to the output of neural
scoring functions. Here, we are interested in learn-

Train Exemplars Dev. Test

FN 1.5 17,143 153,952 2,333 4,457
FN 1.7 19,875 192,460 2,308 6,722

DM id 33,961 - 1,692 1,410
DM ood - - - 1,849

Table 1: Number of instances in datasets.

ing sparse graphical models only because they re-
sult in faster inference, not because we have any a
priori belief about sparsity. This results in roughly
a 14× speedup in our experiments, without any
significant drop in performance.

6 Experiments

Datasets. Our model is evaluated on two differ-
ent releases of FrameNet: FN 1.5 and FN 1.7,9

using splits from Swayamdipta et al. (2017). Fol-
lowing Swayamdipta et al. (2017) and Yang and
Mitchell (2017), each target annotation is treated
as a separate training instance. We also include
as training data the exemplar sentences, each an-
notated for a single target, as they have been re-
ported to improve performance (Kshirsagar et al.,
2015; Yang and Mitchell, 2017). For semantic de-
pendencies, we use the English DM dataset from
the SemEval 2015 Task 18 closed track (Oepen
et al., 2015).10 DM contains instances from the
WSJ corpus for training and both in-domain (id)
and out-of-domain (ood) test sets, the latter from
the Brown corpus.11 Table 1 summarizes the sizes
of the datasets.
Baselines. We compare FN performance of our
joint learning model (FULL) to two baselines:
BASIC: A single-task frame SRL model, trained

using a structured hinge objective.
NOCTP: A joint model without cross-task parts.

It demonstrates the effect of sharing parame-
ters in word embeddings and LSTMs (like in
FULL). It does not use latent semantic depen-
dency structures, and aims to minimize the
sum of training losses from both tasks.

We also compare semantic dependency parsing
performance against the single task model by Peng

9https://FN.icsi.berkeley.edu/
fndrupal/

10http://sdp.delph-in.net/. The closed track
does not have access to any syntactic analyses. The impact of
syntactic features on SDP performance is extensively studied
in Ribeyre et al. (2015).

11Our FN training data does not overlap with the DM test
set. We remove the 3 training sentences from DM which ap-
pear in FN test data.

1497



Model Prec. Rec. F 1
Roth 72.2 68.0 70.0
Täckström 75.4 65.8 70.3
FitzGerald 74.8 65.5 69.9
FitzGerald (10×) 75.0 67.3 70.9
open-SESAME 71.0 67.8 69.4
open-SESAME (5×) 71.2 70.5 70.9
Yang and Mitchell (REL) 77.1 68.7 72.7
†∗Yang and Mitchell (ALL) 78.8 74.5 76.6
†This work (FULL) 80.4 73.5 76.8
†This work (FULL, 2×) 80.4 74.7 77.4
†This work (BASIC) 79.2 71.7 75.3
†This work (NOCTP) 76.9 74.8 75.8

Table 2: FN 1.5 full structure extraction test per-
formance. † denotes the models jointly predicting
frames and arguments, and other systems imple-
ment two-stage pipelines and use the algorithm by
Hermann et al. (2014) to predict frames. K× de-
notes a product-of-experts ensemble of K mod-
els. ∗Ensembles a sequential tagging CRF and a
relational model. Bold font indicates best perfor-
mance among all systems.

et al. (2017), denoted as NeurboParser (BASIC).
To ensure fair comparison with our FULL model,
we made several modifications to their implemen-
tation (§6.3). We observed performance improve-
ments from our reimplementation, which can be
seen in Table 5.
Pruning strategies. For frame SRL, we
discard argument spans longer than 20 to-
kens (Swayamdipta et al., 2017). We further
pretrain an unlabeled model and prune spans with
posteriors lower than 1/n2, with n being the input
sentence length. For semantic dependencies, we
generally follow Martins and Almeida (2014),
replacing their feature-rich pruner with neural net-
works. We observe that O(n) spans/arcs remain
after pruning, with around 96% FN development
recall, and more than 99% for DM.12

6.1 Empirical Results
FN parsing results. Table 2 compares our full
frame-semantic parsing results to previous sys-
tems. Among them, Täckström et al. (2015) and
Roth (2016) implement a two-stage pipeline and
use the method from Hermann et al. (2014) to
predict frames. FitzGerald et al. (2015) uses the

12On average, around 0.8n argument spans, and 5.7n un-
labeled dependency arcs remain after pruning.

Model All Ambiguous

Hartmann 87.6 -
Yang and Mitchell 88.2 -

Hermann 88.4 73.1
†This work (BASIC) 89.2 76.3
†This work (NOCTP) 89.2 76.4
†This work (FULL) 89.9 77.7
†This work (FULL, 2×) 90.0 78.0

Table 3: Frame identification accuracy on the FN
1.5 test set. Ambiguous evaluates only on lexical
units having more than one possible frames. † de-
notes joint frame and argument identification, and
bold font indicates best performance.13

same pipeline formulation, but improves the frame
identification of Hermann et al. (2014) with better
syntactic features. open-SESAME (Swayamdipta
et al., 2017) uses predicted frames from FitzGer-
ald et al. (2015), and improves argument identi-
fication using a softmax-margin segmental RNN.
They observe further improvements from product
of experts ensembles (Hinton, 2002).

The best published FN 1.5 results are due
to Yang and Mitchell (2017). Their relational
model (REL) formulates argument identification
as a sequence of local classifications. They ad-
ditionally introduce an ensemble method (denoted
as ALL) to integrate the predictions of a sequen-
tial CRF. They use a linear program to jointly pre-
dict frames and arguments at test time. As shown
in Table 2, our single-model performance outper-
forms their REL model, and is on par with their
ALL model. For a fair comparison, we build an
ensemble (FULL, 2×) by separately training two
models, differing only in random seeds, and aver-
aging their part scores. Our ensembled model out-
performs previous best results by 0.8% absolute.

Table 3 compares our frame identification re-
sults with previous approaches. Hermann et al.
(2014) and Hartmann et al. (2017) use distributed
word representations and syntax features. We fol-
low the FULL LEXICON setting (Hermann et al.,
2014) and extract candidate frames from the offi-

13Our comparison to Hermann et al. (2014) is based
on their updated version: http://www.aclweb.org/
anthology/P/P14/P14-1136v2.pdf. Ambiguous
frame identification results by Yang and Mitchell (2017) and
Hartmann et al. (2017) are 75.7 and 73.8. Their ambiguous
lexical unit sets are different from the one extracted from the
official frame directory, and thus the results are not compara-
ble to those in Table 3.

1498



Full Structure Frame Id.

Model Prec. Rec. F 1 All Amb.

BASIC 78.0 72.1 75.0 88.6 76.6
NOCTP 79.8 72.4 75.9 88.5 76.3
FULL 80.2 72.9 76.4 89.1 77.5

Table 4: FN 1.7 full structure extraction and frame
identification test results. Bold font indicates best
performance. FN 1.7 test set is an extension of FN
1.5 test, hence the results here are not comparable
to those reported in Table 2.

Model id F 1 ood F 1
NeurboParser (BASIC) 89.4 84.5
NeurboParser (FREDA3) 90.4 85.3

NeurboParser (BASIC, reimpl.) 90.0 84.6

This work (NOCTP) 89.9 85.2
This work (FULL) 90.5 85.9
This work (FULL, 2×) 91.2 86.6

Table 5: Labeled parsing performance in F1 score
for DM semantic dependencies. id denotes in-
domain WSJ test data, and ood denotes out-of-
domain brown corpus test data. Bold font indi-
cates best performance.

cial directories. The Ambiguous setting compares
lexical units with more than one possible frames.
Our approach improves over all previous models
under both settings, demonstrating a clear benefit
from joint learning.

We observe similar trends on FN 1.7 for both
full structure extraction and for frame identifica-
tion only (Table 4). FN 1.7 extends FN 1.5 with
more consistent annotations. Its test set is different
from that of FN 1.5, so the results are not directly
comparable to Table 2. We are the first to report
frame-semantic parsing results on FN 1.7, and we
encourage future efforts to do so as well.

Semantic dependency parsing results. Table 5
compares our semantic dependency parsing per-
formance on DM with the baselines. Our reim-
plementation of the BASIC model slightly im-
proves performance on in-domain test data. The
NOCTP model ties parameters from word embed-
dings and LSTMs when training on FrameNet and
DM, but does not use cross-task parts or joint pre-
diction. NOCTP achieves similar in-domain test
performance, and improves over BASIC on out-
of-domain data. By jointly predicting FrameNet

Rel. Err. (%)

Operation Description BASIC FULL

Frame error Frame misprediction. 11.3 11.1

Role error Matching span with incorrectrole.
12.6
(5.2)

13.4
(5.9)

Span error Matching role with incorrectspan. 11.4 12.3

Arg. error Predicted argument does notoverlap with any gold span. 18.6 22.4

Missing arg. Gold argument does not overlapwith any predicted span. 43.5 38.0

Table 6: Percentage of errors made by BASIC
and FULL models on the FN 1.5 development
set. Parenthesized numbers show the percentage
of role errors when frame predictions are correct.

structures and semantic dependency graphs, the
FULL model outperforms the baselines by more
than 0.6% absolute F1 scores under both settings.

Previous state-of-the-art results on DM are
due to the joint learning model of Peng et al.
(2017), denoted as NeurboParser (FREDA3). They
adopted a multitask learning approach, jointly pre-
dicting three different parallel semantic depen-
dency annotations. Our FULL model’s in-domain
test performance is on par with FREDA3, and im-
proves over it by 0.6% absolute F1 on out-of-
domain test data. Our ensemble of two FULL
models achieves a new state-of-the-art in both in-
domain and out-of-domain test performance.

6.2 Analysis
Error type breakdown. Similarly to He et al.
(2017), we categorize prediction errors made by
the BASIC and FULL models in Table 6. Entirely
missing an argument accounts for most of the er-
rors for both models, but we observe fewer er-
rors by FULL compared to BASIC in this category.
FULL tends to predict more arguments in general,
including more incorrect arguments.

Since candidate roles are determined by frames,
frame and role errors are highly correlated. There-
fore, we also show the role errors when frames
are correctly predicted (parenthesized numbers in
the second row). When a predicted argument span
matches a gold span, predicting the semantic role
is less challenging. Role errors account for only
around 13% of all errors, and half of them are due
to mispredictions of frames.
Performance by argument length. Figure 3
plots dev. precision and recall of both BASIC and
FULL against binned argument lengths. We ob-

1499



0 1 2 3 4 5 6

0.
2

0.
4

0.
6

0.
8

1.
0

Binned Argument Length

P
re

ci
si

on
/R

ec
al

l
Basic Precision
Basic Recall
Full Precision
Full Recall

Figure 3: FN 1.5 development precision and re-
call of BASIC and FULL by different argument
lengths. Length ` is binned to blog1.6 `c, and
precision/recall values are smoothed with loess,
with a smoothing parameter of 0.1.

serve two trends: (a) FULL tends to predict longer
arguments (averaging 3.2) compared to BASIC
(averaging 2.9), while keeping similar precision;14

(b) recall improvement in FULL mainly comes
from arguments longer than 4.

6.3 Implementation Details

Our implementation is based on DyNet (Neubig
et al., 2017).15 We use predicted part-of-speech
tags and lemmas using NLTK (Bird et al., 2009).16

Parameters are optimized with stochastic sub-
gradient descent for up to 30 epochs, with `2
norms of gradients clipped to 1. We use 0.33 as
initial learning rate, and anneal it at a rate of 0.5
every 10 epochs. Early stopping is applied based
on FN development F1. We apply logarithm with
base 2 to all discrete features, e.g., log2(d+1) for
distance feature valuing d. To speed up training,
we randomly sample a 35% subset from the FN
exemplar instances each epoch.
Hyperparameters. Each input token is repre-
sented as the concatenation a word embedding
vector, a learned lemma vector, and a learned vec-
tor for part-of speech, all updated during train-
ing. We use 100-dimensional GloVe (Pennington
et al., 2014) to initialize word embeddings. We ap-
ply word dropout (Iyyer et al., 2015) and randomly
replace a word w with a special UNK symbol with
probability α1+#(w) , with #(w) being the count of
w in the training set. We follow the default param-
eters initialization procedure by DyNet, and an `2

14Average gold span length is 3.4 after discarding those
longer than 20.

15https://github.com/clab/dynet
16http://www.nltk.org/

Hyperparameter Value

Word embedding dimension 100 (32)
Lemma embedding dimension 50 (16)
POS tag embedding dimension 50 (16)
MLP dimension 100 (32)
Tensor rank r 100 (32)
BiLSTM layers 2 (1)
BiLSTM dimensions 200 (64)
α for word dropout 1.0 (1.0)

Table 7: Hyperparameters used in the experiments.
Parenthesized numbers indicate those used by the
pretrained pruners.

penalty of 10−6 is applied to all weights. See Ta-
ble 7 for other hyperparameters.
Modifications to Peng et al. (2017). To ensure
fair comparisons, we note two implementation
modifications to Peng et al.’s basic model. We use
a more recent version (2.0) of the DyNet toolkit,
and we use 50-dimensional lemma embeddings in-
stead of their 25-dimensional randomly-initialized
learned word embeddings.

7 Conclusion

We presented a novel multitask approach to learn-
ing semantic parsers from disjoint corpora with
structurally divergent formalisms. We showed
how joint learning and prediction can be done
with scoring functions that explicitly relate spans
and dependencies, even when they are never ob-
served together in the data. We handled the re-
sulting inference challenges with a novel adapta-
tion of graphical model structure learning to the
deep learning setting. We raised the state-of-
the-art on DM and FrameNet parsing by learn-
ing from both, despite their structural differ-
ences and non-overlapping data. While our
selection of factors is specific to spans and
dependencies, our general techniques could be
adapted to work with more combinations of struc-
tured prediction tasks. We have released our
implementation at https://github.com/
Noahs-ARK/NeurboParser.

Acknowledgments

We thank Kenton Lee, Luheng He, and Rowan
Zellers for their helpful comments, and the anony-
mous reviewers for their valuable feedback. This
work was supported in part by NSF grant IIS-
1562364.

1500



References
Apoorv Agarwal, Sriramkumar Balasubramanian,

Anup Kotalwar, Jiehan Zheng, and Owen Rambow.
2014. Frame semantic tree kernels for social net-
work extraction from text. In Proc. of EACL.

Collin F. Baker, Charles J. Fillmore, and John B. Lowe.
1998. The Berkeley FrameNet project. In Proc.
ACL.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proc. LAW-ID.

Steven Bird, Ewan Klein, and Edward Loper. 2009.
Natural Language Processing with Python: Ana-
lyzing Text with the Natural Language Toolkit. ”
O’Reilly Media, Inc.”.

Yun-Nung Chen, William Yang Wang, and Alexander I
Rudnicky. 2013. Unsupervised induction and filling
of semantic slots for spoken dialogue systems using
frame-semantic parsing. In Proc. of ASRU-IEEE.

Michael Collins. 2003. Head-driven statistical models
for natural language parsing. Computational Lin-
guistics 29(4):589–637.

Ronan Collobert and Jason Weston. 2008. A unified
architecture for natural language processing: Deep
neural networks with multitask learning. In Proc.
ICML.

Ann Copestake, Dan Flickinger, Ivan A. Sag, and Carl
Pollard. 2005. Minimal recursion semantics: An in-
troduction. Research on Language & Computation
3(4):281–332.

Bob Coyne, Alex Klapheke, Masoud Rouhizadeh,
Richard Sproat, and Daniel Bauer. 2012. Annota-
tion tools and knowledge representation for a text-
to-scene system. In Proc. of COLING.

Koby Crammer, Ofer Dekel, Joseph Keshet, Shai
Shalev-Shwartz, and Yoram Singer. 2006. Online
passive-aggressive algorithms. JMLR 7:551–585.

Dipanjan Das, Nathan Schneider, Desai Chen, and
Noah A. Smith. 2010. Probabilistic frame-semantic
parsing. In Proc. of NAACL.

Charles Fillmore. 1982. Frame semantics. Linguistics
in the morning calm pages 111–137.

Nicholas FitzGerald, Oscar Täckström, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
labeling with neural network factors. In Proc. of
EMNLP.

Jeffrey Flanigan, Sam Thomson, Jaime Carbonell,
Chris Dyer, and Noah A. Smith. 2014. A discrim-
inative graph-based parser for the abstract meaning
representation. In Proc. ACL.

Daniel Flickinger, Yi Zhang, and Valia Kordoni. 2012.
DeepBank: A dynamically annotated treebank of the
Wall Street Journal. In Proc. of TLT . pages 85–96.

Jerome Friedman, Trevor Hastie, and Robert Tibshi-
rani. 2008. Sparse inverse covariance estimation
with the graphical lasso. Biostatistics 9(3):432–441.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics 28(3):245–288.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Jan Hajič, Eva Hajičová, Jarmila Panevová, Petr
Sgall, Ondřej Bojar, Silvie Cinková, Eva Fučı́ková,
Marie Mikulová, Petr Pajas, Jan Popelka, Jiřı́
Semecký, Jana Šindlerová, Jan Štěpánek, Josef
Toman, Zdeňka Urešová, and Zdeněk Žabokrtský.
2012. Announcing Prague Czech-English depen-
dency treebank 2.0. In Proc. of LREC.

Silvana Hartmann, Ilia Kuznetsov, Teresa Martin, and
Iryna Gurevych. 2017. Out-of-domain FrameNet
semantic role labeling. In Proc. of EACL.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and whats next. In Proc. of ACL.

Luheng He, Mike Lewis, and Luke S. Zettlemoyer.
2015. Question-answer driven semantic role label-
ing: Using natural language to annotate natural lan-
guage. In Proc. of EMNLP.

Karl Moritz Hermann, Dipanjan Das, Jason Weston,
and Kuzman Ganchev. 2014. Semantic frame iden-
tification with distributed word representations. In
Proc. of ACL.

Geoffrey E. Hinton. 2002. Training products of experts
by minimizing contrastive divergence. Neural Com-
putation 14(8):1771–1800.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long Short-Term Memory. Neural Computation
9(8):1735–1780.

Mohit Iyyer, Varun Manjunatha, Jordan Boyd-Graber,
and Hal Daumé III. 2015. Deep unordered compo-
sition rivals syntactic methods for text classification.
In Proc. of ACL.

Richard Johansson and Pierre Nugues. 2007. LTH: Se-
mantic structure extraction using nonprojective de-
pendency trees. In Proc. of SemEval.

Lingpeng Kong, Chris Dyer, and Noah A. Smith. 2016.
Segmental recurrent neural networks. In Proc. of
ICLR.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A. Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. ACL.

1501



Kenton Lee, Luheng He, Mike Lewis, and Luke Zettle-
moyer. 2017. End-to-end neural coreference resolu-
tion. In Proc. of EMNLP.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proc. ACL.

Xavier Lluı́s, Xavier Carreras, and Lluı́s Màrquez.
2013. Joint arc-factored parsing of syntactic and se-
mantic dependencies. TACL 1:219–230.

André F. T. Martins and Mariana S. C. Almeida. 2014.
Priberam: A turbo semantic parser with second or-
der features. In Proc. of SemEval.

André F. T. Martins, Noah A. Smith, Pedro M. Q.
Aguiar, and Mário A. T. Figueiredo. 2011. Dual de-
composition with many overlapping components. In
Proc. of EMNLP.

Jason Naradowsky, Sebastian Riedel, and David A.
Smith. 2012. Improving NLP through marginaliza-
tion of hidden syntactic structure. In Proc. EMNLP.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, Kevin Duh, Manaal
Faruqui, Cynthia Gan, Dan Garrette, Yangfeng
Ji, Lingpeng Kong, Adhiguna Kuncoro, Gau-
rav Kumar, Chaitanya Malaviya, Paul Michel,
Yusuke Oda, Matthew Richardson, Naomi Saphra,
Swabha Swayamdipta, and Pengcheng Yin. 2017.
DyNet: The dynamic neural network toolkit.
arXiv:1701.03980.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinkova, Dan Flickinger, Jan
Hajic, and Zdenka Uresova. 2015. SemEval 2015
task 18: Broad-coverage semantic dependency pars-
ing. In Proc. of SemEval.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Silvie Cinková, Dan Flickinger,
Jan Hajič, Angelina Ivanova, and Zdeňka Urešová.
2016. Towards comparability of linguistic graph
banks for semantic parsing. In Proc. of LREC.

Stephan Oepen, Marco Kuhlmann, Yusuke Miyao,
Daniel Zeman, Dan Flickinger, Jan Hajic, Angelina
Ivanova, and Yi Zhang. 2014. SemEval 2014 task
8: Broad-coverage semantic dependency parsing. In
Proc. of SemEval.

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The proposition bank: An annotated corpus of
semantic roles. Computional Linguistics 31(1):71–
106.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Corentin Ribeyre, Éric Villemonte De La Clergerie,
and Djamé Seddah. 2015. Because Syntax does
Matter: Improving Predicate-Argument Structures
Parsing Using Syntactic Features. In Proc. of
NAACL.

Michael Roth. 2016. Improving frame semantic pars-
ing via dependency path embeddings. In Book of
Abstracts of the 9th International Conference on
Construction Grammar.

Dan Shen and Mirella Lapata. 2007. Using semantic
roles to improve question answering. In Proc. of
EMNLP-CoNLL.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Mihai Surdeanu, Richard Johansson, Adam Meyers,
Lluı́s Màrquez, and Joakim Nivre. 2008. The
CoNLL-2008 shared task on joint parsing of syntac-
tic and semantic dependencies. In Proc. of CoNLL.

Swabha Swayamdipta, Sam Thomson, Chris Dyer, and
Noah A. Smith. 2017. Frame-semantic parsing with
softmax-margin segmental RNNs and a syntactic
scaffold. arXiv:1706.09528.

Oscar Täckström, Kuzman Ganchev, and Dipanjan
Das. 2015. Efficient inference and structured learn-
ing for semantic role labeling. TACL 3:29–41.

Kristina Toutanova, Aria Haghighi, and Christopher D.
Manning. 2008. A global joint model for semantic
role labeling. Computational Linguistics 34(2):161–
191.

Ioannis Tsochantaridis, Thomas Hofmann, Thorsten
Joachims, and Yasemin Altun. 2004. Support vector
machine learning for interdependent and structured
output spaces. In Proc. of ICML.

Bishan Yang and Tom Mitchell. 2017. A joint sequen-
tial and relational model for frame-semantic parsing.
In Proc. of EMNLP.

Chun-Nam John Yu and Thorsten Joachims. 2009.
Learning structural SVMs with latent variables. In
Proc. of ICML.

Ming Yuan and Yi Lin. 2007. Model selection and esti-
mation in the gaussian graphical model. Biometrika
94(1):19–35.

1502


