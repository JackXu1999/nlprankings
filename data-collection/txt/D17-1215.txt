



















































Adversarial Examples for Evaluating Reading Comprehension Systems


Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2021–2031
Copenhagen, Denmark, September 7–11, 2017. c©2017 Association for Computational Linguistics

Adversarial Examples for Evaluating Reading Comprehension Systems

Robin Jia
Computer Science Department

Stanford University
robinjia@cs.stanford.edu

Percy Liang
Computer Science Department

Stanford University
pliang@cs.stanford.edu

Abstract

Standard accuracy metrics indicate that
reading comprehension systems are mak-
ing rapid progress, but the extent to which
these systems truly understand language
remains unclear. To reward systems
with real language understanding abili-
ties, we propose an adversarial evalua-
tion scheme for the Stanford Question An-
swering Dataset (SQuAD). Our method
tests whether systems can answer ques-
tions about paragraphs that contain adver-
sarially inserted sentences, which are au-
tomatically generated to distract computer
systems without changing the correct an-
swer or misleading humans. In this ad-
versarial setting, the accuracy of sixteen
published models drops from an average
of 75% F1 score to 36%; when the ad-
versary is allowed to add ungrammatical
sequences of words, average accuracy on
four models decreases further to 7%. We
hope our insights will motivate the de-
velopment of new models that understand
language more precisely.

1 Introduction

Quantifying the extent to which a computer sys-
tem exhibits intelligent behavior is a longstanding
problem in AI (Levesque, 2013). Today, the stan-
dard paradigm is to measure average error across
a held-out test set. However, models can succeed
in this paradigm by recognizing patterns that hap-
pen to be predictive on most of the test examples,
while ignoring deeper, more difficult phenomena
(Rimell et al., 2009; Paperno et al., 2016).

In this work, we propose adversarial evaluation
for NLP, in which systems are instead evaluated
on adversarially-chosen inputs. We focus on the

Article: Super Bowl 50
Paragraph: “Peyton Manning became the first quarter-
back ever to lead two different teams to multiple Super
Bowls. He is also the oldest quarterback ever to play
in a Super Bowl at age 39. The past record was held
by John Elway, who led the Broncos to victory in Super
Bowl XXXIII at age 38 and is currently Denver’s Execu-
tive Vice President of Football Operations and General
Manager. Quarterback Jeff Dean had jersey number 37
in Champ Bowl XXXIV.”
Question: “What is the name of the quarterback who
was 38 in Super Bowl XXXIII?”
Original Prediction: John Elway
Prediction under adversary: Jeff Dean

Figure 1: An example from the SQuAD dataset.
The BiDAF Ensemble model originally gets the
answer correct, but is fooled by the addition of an
adversarial distracting sentence (in blue).

SQuAD reading comprehension task (Rajpurkar
et al., 2016), in which systems answer questions
about paragraphs from Wikipedia. Reading com-
prehension is an appealing testbed for adversarial
evaluation, as existing models appear successful
by standard average-case evaluation metrics: the
current state-of-the-art system achieves 84.7% F1
score, while human performance is just 91.2%.1

Nonetheless, it seems unlikely that existing sys-
tems possess true language understanding and rea-
soning capabilities.

Carrying out adversarial evaluation on SQuAD
requires new methods that adversarially alter read-
ing comprehension examples. Prior work in com-
puter vision adds imperceptible adversarial pertur-
bations to input images, relying on the fact that
such small perturbations cannot change an image’s
true label (Szegedy et al., 2014; Goodfellow et al.,
2015). In contrast, changing even one word of a

1https://rajpurkar.github.io/
SQuAD-explorer/

2021



paragraph can drastically alter its meaning. In-
stead of relying on semantics-preserving perturba-
tions, we create adversarial examples by adding
distracting sentences to the input paragraph, as
shown in Figure 1. We automatically generate
these sentences so that they confuse models, but
do not contradict the correct answer or confuse
humans. For our main results, we use a simple
set of rules to generate a raw distractor sentence
that does not answer the question but looks related;
we then fix grammatical errors via crowdsourc-
ing. While adversarially perturbed images punish
model oversensitivity to imperceptible noise, our
adversarial examples target model overstability—
the inability of a model to distinguish a sentence
that actually answers the question from one that
merely has words in common with it.

Our experiments demonstrate that no published
open-source model is robust to the addition of ad-
versarial sentences. Across sixteen such models,
adding grammatical adversarial sentences reduces
F1 score from an average of 75% to 36%. On
a smaller set of four models, we run additional
experiments in which the adversary adds non-
grammatical sequences of English words, causing
average F1 score to drop further to 7%. To encour-
age the development of new models that under-
stand language more precisely, we have released
all of our code and data publicly.

2 The SQuAD Task and Models

2.1 Task

The SQuAD dataset (Rajpurkar et al., 2016) con-
tains 107,785 human-generated reading compre-
hension questions about Wikipedia articles. Each
question refers to one paragraph of an article, and
the corresponding answer is guaranteed to be a
span in that paragraph.

2.2 Models

When developing and testing our methods, we
focused on two published model architectures:
BiDAF (Seo et al., 2016) and Match-LSTM (Wang
and Jiang, 2016). Both are deep learning architec-
tures that predict a probability distribution over the
correct answer. Each model has a single and an
ensemble version, yielding four systems in total.

We also validate our major findings on twelve
other published models with publicly available
test-time code: ReasoNet Single and Ensem-
ble versions (Shen et al., 2017), Mnemonic

Reader Single and Ensemble versions (Hu et al.,
2017), Structural Embedding of Dependency
Trees (SEDT) Single and Ensemble versions (Liu
et al., 2017), jNet (Zhang et al., 2017), Rumi-
nating Reader (Gong and Bowman, 2017), Multi-
Perspective Context Matching (MPCM) Single
version (Wang et al., 2016), RaSOR (Lee et al.,
2017), Dynamic Chunk Reader (DCR) (Yu et al.,
2016), and the Logistic Regression Baseline (Ra-
jpurkar et al., 2016). We did not run these models
during development, so they serve as a held-out set
that validates the generality of our approach.

2.3 Standard Evaluation
Given a model f that takes in paragraph-question
pairs (p, q) and outputs an answer â, the standard
accuracy over a test set Dtest is simply

Acc(f) def=
1
|Dtest|

∑
(p,q,a)∈Dtest

v((p, q, a), f),

where v is the F1 score between the true answer
a and the predicted answer f(p, q) (see Rajpurkar
et al. (2016) for details).

3 Adversarial Evaluation

3.1 General Framework
A model that relies on superficial cues without
understanding language can do well according
to average F1 score, if these cues happen to be
predictive most of the time. Weissenborn et al.
(2017) argue that many SQuAD questions can
be answered with heuristics based on type and
keyword-matching. To determine whether exist-
ing models have learned much beyond such simple
patterns, we introduce adversaries that confuse de-
ficient models by altering test examples. Consider
the example in Figure 1: the BiDAF Ensemble
model originally gives the right answer, but gets
confused when an adversarial distracting sentence
is added to the paragraph.

We define an adversary A to be a function that
takes in an example (p, q, a), optionally with a
model f , and returns a new example (p′, q′, a′).
The adversarial accuracy with respect to A is

Adv(f) def=
1
|Dtest|

∑
(p,q,a)∈Dtest

v(A(p, q, a, f), f)).

While standard test error measures the fraction of
the test distribution over which the model gets the
correct answer, the adversarial accuracy measures

2022



Image Reading
Classification Comprehension

Possible
Input

Tesla moved
to the city of
Chicago in 1880.

Similar
Input

Tadakatsu moved
to the city of
Chicago in 1881.

Semantics Same Different
Model’s Considers the two Considers the two
Mistake to be different to be the same
Model Overly Overly
Weakness sensitive stable

Table 1: Adversarial examples in computer vi-
sion exploit model oversensitivity to small per-
turbations. In contrast, our adversarial examples
work because models do not realize that a small
perturbation can completely change the meaning
of a sentence. Images from Szegedy et al. (2014).

the fraction over which the model is robustly cor-
rect, even in the face of adversarially-chosen alter-
ations. For this quantity to be meaningful, the ad-
versary must satisfy two basic requirements: first,
it should always generate (p′, q′, a′) tuples that are
valid—a human would judge a′ as the correct an-
swer to q′ given p′. Second, (p′, q′, a′) should be
somehow “close” to the original example (p, q, a).

3.2 Semantics-preserving Adversaries

In image classification, adversarial examples are
commonly generated by adding an imperceptible
amount of noise to the input (Szegedy et al., 2014;
Goodfellow et al., 2015). These perturbations do
not change the semantics of the image, but they
can change the predictions of models that are over-
sensitive to semantics-preserving changes. For
language, the direct analogue would be to para-
phrase the input (Madnani and Dorr, 2010). How-
ever, high-precision paraphrase generation is chal-
lenging, as most edits to a sentence do actually
change its meaning.

3.3 Concatenative Adversaries

Instead of relying on paraphrasing, we use pertur-
bations that do alter semantics to build concatena-
tive adversaries, which generate examples of the
form (p + s, q, a) for some sentence s. In other
words, concatenative adversaries add a new sen-
tence to the end of the paragraph, and leave the
question and answer unchanged. Valid adversarial
examples are precisely those for which s does not
contradict the correct answer; we refer to such sen-
tences as being compatible with (p, q, a). We use

semantics-altering perturbations to that ensure that
s is compatible, even though it may have many
words in common with the question q. Existing
models are bad at distinguishing these sentences
from sentences that do in fact address the question,
indicating that they suffer not from oversensitivity
but from overstability to semantics-altering edits.
Table 1 summarizes this important distinction.

The decision to always append s to the end of
p is somewhat arbitrary; we could also prepend
it to the beginning, though this would violate the
expectation of the first sentence being a topic sen-
tence. Both are more likely to preserve the validity
of the example than inserting s in the middle of p,
which runs the risk of breaking coreference links.

Now, we describe two concrete concatenative
adversaries, as well as two variants. ADDSENT,
our main adversary, adds grammatical sentences
that look similar to the question. In contrast,
ADDANY adds arbitrary sequences of English
words, giving it more power to confuse models.
Figure 2 illustrates these two main adversaries.

3.3.1 ADDSENT
ADDSENT uses a four-step procedure to generate
sentences that look similar to the question, but do
not actually contradict the correct answer. Refer
to Figure 2 for an illustration of these steps.

In Step 1, we apply semantics-altering perturba-
tions to the question, in order to guarantee that the
resulting adversarial sentence is compatible. We
replace nouns and adjectives with antonyms from
WordNet (Fellbaum, 1998), and change named en-
tities and numbers to the nearest word in GloVe
word vector space2 (Pennington et al., 2014) with
the same part of speech.3 If no words are changed
during this step, the adversary gives up and im-
mediately returns the original example. For exam-
ple, given the question “What ABC division han-
dles domestic television distribution?”, we would
change “ABC” to “NBC” (a nearby word in vec-
tor space) and “domestic” to “foreign” (a WordNet
antonym), resulting in the question, “What NBC
division handles foreign television distribution?”

In Step 2, we create a fake answer that has the
same “type” as the original answer. We define a set

2 We use 100-dimensional GloVe vectors trained on
Wikipedia and Euclidean distance to define nearby words.

3 We choose the nearest word whose most common gold
POS tag in the Penn Treebank (Marcus et al., 1999) matches
the predicted POS tag of the original word, according to
CoreNLP. If none of the nearest 100 words satisfy this, we
just return the single closest word.

2023



Article: Nikola Tesla
Paragraph: "In January 1880, two of Tesla's uncles 
put together enough money to help him leave 
Gospić for Prague where he was to study. 
Unfortunately, he arrived too late to enroll at 
Charles-Ferdinand University; he never studied 
Greek, a required subject; and he was illiterate in 
Czech, another required subject. Tesla did, however, 
attend lectures at the university, although, as an 
auditor, he did not receive grades for the courses."
Question: "What city did Tesla move to in 1880?"
Answer: Prague
Model Predicts: Prague

Tadakatsu moved the city of 
Chicago to in 1881.

Chicago

What city did Tesla move to 
in 1880?

What city did Tadakatsu move to 
in 1881?

Prague

Adversary Adds: Tadakatsu moved to the city 
of Chicago in 1881.
Model Predicts: Chicago

(Step 1)
Mutate

question

(Step 3)
Convert into 
statement

(Step 4)
Fix errors with
crowdworkers, 
verify resulting
sentences with
other crowdworkers

AddSent

spring attention income getting reached

spring attention income other reached

Adversary Adds: tesla move move other george
Model Predicts: george

Repeat many times

Randomly initialize d words:
AddAny

Greedily change one word

(Step 2) 
Generate 

fake answer

Figure 2: An illustration of the ADDSENT and ADDANY adversaries.

of 26 types, corresponding to NER and POS tags
from Stanford CoreNLP (Manning et al., 2014),
plus a few custom categories (e.g., abbreviations),
and manually associate a fake answer with each
type. Given the original answer to a question, we
compute its type and return the corresponding fake
answer. In our running example, the correct an-
swer was not tagged as a named entity, and has
the POS tag NNP, which corresponds to the fake
answer “Central Park.”

In Step 3, we combine the altered question and
fake answer into declarative form, using a set of
roughly 50 manually-defined rules over CoreNLP
constituency parses. For example, “What ABC di-
vision handles domestic television distribution?”
triggers a rule that converts questions of the
form “what/which NP1 VP1 ?” to “The NP1 of
[Answer] VP1”. After incorporating the alter-
ations and fake answer from the previous steps, we
generate the sentence, “The NBC division of Cen-
tral Park handles foreign television distribution.”

The raw sentences generated by Step 3 can be
ungrammatical or otherwise unnatural due to the
incompleteness of our rules and errors in con-
stituency parsing. Therefore, in Step 4, we fix er-
rors in these sentences via crowdsourcing. Each
sentence is edited independently by five workers
on Amazon Mechanical Turk, resulting in up to

five sentences for each raw sentence. Three addi-
tional crowdworkers then filter out sentences that
are ungrammatical or incompatible, resulting in a
smaller (possibly empty) set of human-approved
sentences. The full ADDSENT adversary runs the
model f as a black box on every human-approved
sentence, and picks the one that makes the model
give the worst answer. If there are no human-
approved sentences, the adversary simply returns
the original example.

A model-independent adversary. ADDSENT
requires a small number of queries to the model
under evaluation. To explore the possibility of an
adversary that is completely model-independent,
we also introduce ADDONESENT, which adds
a random human-approved sentence to the para-
graph. In contrast with prior work in computer
vision (Papernot et al., 2017; Narodytska and
Kasiviswanathan, 2016; Moosavi-Dezfooli et al.,
2017), ADDONESENT does not require any access
to the model or to any training data: it generates
adversarial examples based solely on the intuition
that existing models are overly stable.

3.3.2 ADDANY

For ADDANY, the goal is to choose any sequence
of d words, regardless of grammaticality. We use
local search to adversarially choose a distracting

2024



sentence s = w1 w2 . . . wd. Figure 2 shows an
example of ADDANY with d = 5 words; in our
experiments, we use d = 10.

We first initialize words w1, . . . , wd randomly
from a list of common English words.4 Then, we
run 6 epochs of local search, each of which iterates
over the indices i ∈ {1, . . . , d} in a random order.
For each i, we randomly generate a set of candi-
date words W as the union of 20 randomly sam-
pled common words and all words in q. For each
x ∈W , we generate the sentence with x in the i-th
position and wj in the j-th position for each j 6= i.
We try adding each sentence to the paragraph and
query the model for its predicted probability distri-
bution over answers. We update wi to be the x that
minimizes the expected value of the F1 score over
the model’s output distribution. We return imme-
diately if the model’s argmax prediction has 0 F1
score. If we do not stop after 3 epochs, we ran-
domly initialize 4 additional word sequences, and
search over all of these random initializations in
parallel.

ADDANY requires significantly more model ac-
cess than ADDSENT: not only does it query the
model many times during the search process, but
it also assumes that the model returns a probabil-
ity distribution over answers, instead of just a sin-
gle prediction. Without this assumption, we would
have to rely on something like the F1 score of the
argmax prediction, which is piecewise constant
and therefore harder to optimize. “Probabilistic”
query access is still weaker than access to gradi-
ents, as is common in computer vision (Szegedy
et al., 2014; Goodfellow et al., 2015).

We do not do anything to ensure that the sen-
tences generated by this search procedure do not
contradict the original answer. In practice, the
generated “sentences” are gibberish that use many
question words but have no semantic content (see
Figure 2 for an example).

Finally, we note that both ADDSENT and
ADDANY try to incorporate words from the ques-
tion into their adversarial sentences. While this is
an obvious way to draw the model’s attention, we
were curious if we could also distract the model
without such a straightforward approach. To this
end, we introduce a variant of ADDANY called
ADDCOMMON, which is exactly like ADDANY
except it only adds common words.

4 We define common words as the 1000 most frequent
words in the Brown corpus (Francis and Kucera, 1979).

Match Match BiDAF BiDAF
Single Ens. Single Ens.

Original 71.4 75.4 75.5 80.0
ADDSENT 27.3 29.4 34.3 34.2
ADDONESENT 39.0 41.8 45.7 46.9
ADDANY 7.6 11.7 4.8 2.7
ADDCOMMON 38.9 51.0 41.7 52.6

Table 2: Adversarial evaluation on the Match-
LSTM and BiDAF systems. All four systems can
be fooled by adversarial examples.

Model Original ADDSENT ADDONESENT
ReasoNet-E 81.1 39.4 49.8
SEDT-E 80.1 35.0 46.5
BiDAF-E 80.0 34.2 46.9
Mnemonic-E 79.1 46.2 55.3
Ruminating 78.8 37.4 47.7
jNet 78.6 37.9 47.0
Mnemonic-S 78.5 46.6 56.0
ReasoNet-S 78.2 39.4 50.3
MPCM-S 77.0 40.3 50.0
SEDT-S 76.9 33.9 44.8
RaSOR 76.2 39.5 49.5
BiDAF-S 75.5 34.3 45.7
Match-E 75.4 29.4 41.8
Match-S 71.4 27.3 39.0
DCR 69.3 37.8 45.1
Logistic 50.4 23.2 30.4

Table 3: ADDSENT and ADDONESENT on all six-
teen models, sorted by F1 score the original exam-
ples. S = single, E = ensemble.

4 Experiments

4.1 Setup

For all experiments, we measure adversarial F1
score (Rajpurkar et al., 2016) across 1000 ran-
domly sampled examples from the SQuAD devel-
opment set (the test set is not publicly available).
Downsampling was helpful because ADDANY
and ADDCOMMON can issue thousands of model
queries per example, making them very slow. As
the effect sizes we measure are large, this down-
sampling does not hurt statistical significance.

4.2 Main Experiments

Table 2 shows the performance of the Match-
LSTM and BiDAF models against all four adver-
saries. Each model incurred a significant accu-
racy drop under every form of adversarial evalua-
tion. ADDSENT made average F1 score across the
four models fall from 75.7% to 31.3%. ADDANY
was even more effective, making average F1 score
fall to 6.7%. ADDONESENT retained much of the
effectiveness of ADDSENT, despite being model-
independent. Finally, ADDCOMMON caused aver-

2025



Human
Original 92.6
ADDSENT 79.5
ADDONESENT 89.2

Table 4: Human evaulation on adversarial exam-
ples. Human accuracy drops on ADDSENT mostly
due to unrelated errors; the ADDONESENT num-
bers show that humans are robust to adversarial
sentences.

age F1 score to fall to 46.1%, despite only adding
common words.

We also verified that our adversaries were gen-
eral enough to fool models that we did not use dur-
ing development. We ran ADDSENT on twelve
published models for which we found publicly
available test-time code; we did not run ADDANY
on these models, as not all models exposed out-
put distributions. As seen in Table 3, no model
was robust to adversarial evaluation; across the
sixteen total models tested, average F1 score fell
from 75.4% to 36.4% under ADDSENT.

It is noteworthy that the Mnemonic Reader
models (Hu et al., 2017) outperform the other
models by about 6 F1 points. We hypothesize that
Mnemonic Reader’s self-alignment layer, which
helps model long-distance relationships between
parts of the paragraph, makes it better at locating
all pieces of evidence that support the correct an-
swer. Therefore, it can be more confident in the
correct answer, compared to the fake answer in-
serted by the adversary.

4.3 Human Evaluation
To ensure our results are valid, we verified that
humans are not also fooled by our adversarial ex-
amples. As ADDANY requires too many model
queries to run against humans, we focused on
ADDSENT. We presented each original and ad-
versarial paragraph-question pair to three crowd-
workers, and asked them to select the correct an-
swer by copy-and-pasting from the paragraph. We
then took a majority vote over the three responses
(if all three responses were different, we picked
one at random). These results are shown in Ta-
ble 4. On original examples, our humans are
actually slightly better than the reported number
of 91.2 F1 on the entire development set. On
ADDSENT, human accuracy drops by 13.1 F1
points, much less than the computer systems.

Moreover, much of this decrease can be ex-
plained by mistakes unrelated to our adversarial

sentences. Recall that ADDSENT picks the worst
case over up to five different paragraph-question
pairs. Even if we showed the same original exam-
ple to five sets of three crowdworkers, chances are
that at least one of the five groups would make a
mistake, just because humans naturally err. There-
fore, it is more meaningful to evaluate humans on
ADDONESENT, on which their accuracy drops by
only 3.4 F1 points.

4.4 Analysis

Next, we sought to better understand the behavior
of our four main models under adversarial evalua-
tion. To highlight errors caused by the adversary,
we focused on examples where the model origi-
nally predicted the (exact) correct answer. We di-
vided this set into “model successes”—examples
where the model continued being correct during
adversarial evaluation—and “model failures”—
examples where the model gave a wrong answer
during adversarial evaluation.

4.4.1 Manual verification
First, we verified that the sentences added by
ADDSENT are actually grammatical and compat-
ible. We manually checked 100 randomly cho-
sen BiDAF Ensemble failures. We found only
one where the sentence could be interpreted as an-
swering the question: in this case, ADDSENT re-
placed the word “Muslim” with the related word
“Islamic”, so the resulting adversarial sentence
still contradicted the correct answer. Addition-
ally, we found 7 minor grammar errors, such
as subject-verb disagreement (e.g., “The Alaskan
Archipelago are made up almost entirely of ham-
sters.”) and misuse of function words (e.g., “The
gas of nitrogen makes up 21.8 % of the Mars’s at-
mosphere.”), but no errors that materially impeded
understanding of the sentence.

We also verified compatibility for ADDANY.
We found no violations out of 100 randomly cho-
sen BiDAF Ensemble failures.

4.4.2 Error analysis
Next, we wanted to understand what types of er-
rors the models made on the ADDSENT examples.
In 96.6% of model failures, the model predicted
a span in the adversarial sentence. The lengths of
the predicted answers were mostly similar to those
of correct answers, but the BiDAF models occa-
sionally predicted very long spans. The BiDAF
Single model predicted an answer of more than

2026



29 words—the length of the longest answer in the
SQuAD development set—on 5.0% of model fail-
ures; for BiDAF Ensemble, this number was 1.6%.
Since the BiDAF models independently predict
the start and end positions of the answer, they can
predict very long spans when the end pointer is in-
fluenced by the adversarial sentence, but the start
pointer is not. Match-LSTM has a similar struc-
ture, but also has a hard-coded rule that stops it
from predicting very long answers.

We also analyzed human failures—examples
where the humans were correct originally, but
wrong during adversarial evaluation. Humans
predicted from the adversarial sentence on only
27.3% of these error cases, which confirms that
many errors are normal mistakes unrelated to ad-
versarial sentences.

4.4.3 Categorizing ADDSENT sentences
We then manually examined sentences generated
by ADDSENT. In 100 BiDAF Ensemble fail-
ures, we found 75 cases where an entity name
was changed in the adversarial sentence, 17 cases
where numbers or dates were changed, and 33
cases where an antonym of a question word was
used.5 Additionally, 7 sentences had other mis-
cellaneous perturbations made by crowdworkers
during Step 4 of ADDSENT. For example, on a
question about the “Kalven Report”, the adver-
sarial sentence discussed “The statement Kalven
cited” instead; in another case, the question, “How
does Kenya curb corruption?” was met by the
unhelpful sentence, “Tanzania is curbing corrup-
tion” (the model simply answered, “corruption”).

4.4.4 Reasons for model successes
Finally, we sought to understand the factors that
influence whether the model will be robust to ad-
versarial perturbations on a particular example.
First, we found that models do well when the ques-
tion has an exact n-gram match with the original
paragraph. Figure 3 plots the fraction of exam-
ples for which an n-gram in the question appears
verbatim in the original passage; this is much
higher for model successes. For example, 41.5%
of BiDAF Ensemble successes had a 4-gram in
common with the original paragraph, compared to
only 21.0% of model failures.

We also found that models succeeded more of-
ten on short questions. Figure 4 shows the dis-

5 These numbers add up to more than 100 because more
than one word can be altered per example.

2 3 4 5 6 7

0
20

40
60

80
10

0

n (size of n−gram)

Pe
rc

en
t o

f 
ex

am
pl

es
 w

ith
 n

−
gr

am
 m

at
ch ●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

●

● Model success
Model failure
ML Single
ML Ensemble
BiDAF Single
BiDAF Ensemble

Figure 3: Fraction of model successes and fail-
ures on ADDSENT for which the question has an
exact n-gram match with the original paragraph.
For each model and each value of n, successes are
more likely to have an n-gram match than failures.

Model under Evaluation

Targeted Model ML ML BiDAF BiDAFSingle Ens. Single Ens.
ADDSENT
ML Single 27.3 33.4 40.3 39.1
ML Ens. 31.6 29.4 40.2 38.7
BiDAF Single 32.7 34.8 34.3 37.4
BiDAF Ens. 32.7 34.2 38.3 34.2
ADDANY
ML Single 7.6 54.1 57.1 60.9
ML Ens. 44.9 11.7 50.4 54.8
BiDAF Single 58.4 60.5 4.8 46.4
BiDAF Ens. 48.8 51.1 25.0 2.7

Table 5: Transferability of adversarial examples
across models. Each row measures performance
on adversarial examples generated to target one
particular model; each column evaluates one (pos-
sibly different) model on these examples.

tribution of question length on model successes
and failures; successes tend to involve shorter
questions. For example, 32.7% of the questions
in BiDAF Ensemble successes were 8 words or
shorter, compared to only 11.8% for model fail-
ures. This effect arises because ADDSENT always
changes at least one word in the question. For
long questions, changing one word leaves many
others unchanged, so the adversarial sentence still
has many words in common with the question. For
short questions, changing one content word may
be enough to make the adversarial sentence com-
pletely irrelevant.

2027



5 10 15 20

0
20

40
60

80
10

0

k (number of words in question)

Pe
rc

en
t o

f 
qu

es
tio

ns
 w

ith
 a

t m
os

t k
 w

or
ds

 (
%

)

●

●

●

●

●

●

●

●
●

●

●
● ●

●
● ●

●

●

●

●

●

●

●

●
●

●
●

● ●
● ●

●

●

●

●

●

●

●

●

●

●

●
●

● ●
● ● ●

●

●

●

●

●

●

●

●

●
●

●
● ●

●
● ●

● Model success
Model failure
ML Single
ML Ensemble
BiDAF Single
BiDAF Ensemble

Figure 4: For model successes and failures on
ADDSENT, the cumulative distribution function of
the number of words in the question (for each k,
what fraction of questions have ≤ k words). Suc-
cesses are more likely to involve short questions.

4.5 Transferability across Models

In computer vision, adversarial examples that fool
one model also tend to fool other models (Szegedy
et al., 2014; Moosavi-Dezfooli et al., 2017); we
investigate whether the same pattern holds for us.
Examples from ADDONESENT clearly do transfer
across models, since ADDONESENT always adds
the same adversarial sentence regardless of model.

Table 5 shows the results of evaluating the
four main models on adversarial examples gen-
erated by running either ADDSENT or ADDANY
against each model. ADDSENT adversarial ex-
amples transfer between models quite effectively;
in particular, they are harder than ADDONESENT
examples, which implies that examples that fool
one model are more likely to fool other mod-
els. The ADDANY adversarial examples exhibited
more limited transferability between models. For
both ADDSENT and ADDANY, examples trans-
ferred slightly better between single and ensemble
versions of the same model.

4.6 Training on Adversarial Examples

Finally, we tried training on adversarial examples,
to see if existing models can learn to become more
robust. Due to the prohibitive cost of running
ADDSENT or ADDANY on the entire training set,
we instead ran only Steps 1-3 of ADDSENT (ev-
erything except crowdsourcing) to generate a raw
adversarial sentence for each training example.
We then trained the BiDAF model from scratch on

Training data
Test data Original Augmented
Original 75.8 75.1
ADDSENT 34.8 70.4
ADDSENTMOD 34.3 39.2

Table 6: Effect of training the BiDAF Single
model on the original training data alone (first
column) versus augmenting the data with raw
ADDSENT examples (second column).

the union of these examples and the original train-
ing data. As a control, we also trained a second
BiDAF model on the original training data alone.6

The results of evaluating these models are
shown in Table 6. At first glance, training on ad-
versarial data seems effective, as it largely protects
against ADDSENT. However, further investigation
shows that training on these examples has only
limited utility. To demonstrate this, we created
a variant of ADDSENT called ADDSENTMOD,
which differs from ADDSENT in two ways: it
uses a different set of fake answers (e.g., PERSON
named entities map to “Charles Babbage” instead
of “Jeff Dean”), and it prepends the adversarial
sentence to the beginning of the paragraph in-
stead of appending it to the end. The retrained
model does almost as badly as the original one on
ADDSENTMOD, suggesting that it has just learned
to ignore the last sentence and reject the fake an-
swers that ADDSENT usually proposed. In order
for training on adversarial examples to actually
improve the model, more care must be taken to
ensure that the model cannot overfit the adversary.

5 Discussion and Related Work

Despite appearing successful by standard evalu-
ation metrics, existing machine learning systems
for reading comprehension perform poorly un-
der adversarial evaluation. Standard evaluation is
overly lenient on models that rely on superficial
cues. In contrast, adversarial evaluation reveals
that existing models are overly stable to perturba-
tions that alter semantics.

To optimize adversarial evaluation metrics, we
may need new strategies for training models. For
certain classes of models and adversaries, efficient
training strategies exist: for example, Globerson
and Roweis (2006) train classifiers that are opti-
mally robust to adversarial feature deletion. Ad-

6 All previous experiments used parameters released by
Seo et al. (2016)

2028



versarial training (Goodfellow et al., 2015) can be
used for any model trained with stochastic gra-
dient descent, but it requires generating new ad-
versarial examples at every iteration; this is fea-
sible for images, where fast gradient-based adver-
saries exist, but is infeasible for domains where
only slower adversaries are available.

We contrast adversarial evaluation, as studied
in this work, with generative adversarial models.
While related in name, the two have very different
goals. Generative adversarial models pit a gen-
erative model, whose goal is to generate realis-
tic outputs, against a discriminative model, whose
goal is to distinguish the generator’s outputs from
real data (Smith, 2012; Goodfellow et al., 2014).
Bowman et al. (2016) and Li et al. (2017) used
such a setup for sentence and dialogue generation,
respectively. Our setup also involves a genera-
tor and a discriminator in an adversarial relation-
ship; however, our discriminative system is tasked
with finding the right answer, not distinguishing
the generated examples from real ones, and our
goal is to evaluate the discriminative system, not
to train the generative one.

While we use adversaries as a way to evalu-
ate language understanding, robustness to adver-
sarial attacks may also be its own goal for tasks
such as spam detection. Dalvi et al. (2004) formu-
lated such tasks as a game between a classifier and
an adversary, and analyzed optimal strategies for
each player. Lowd and Meek (2005) described an
efficient attack by which an adversary can reverse-
engineer the weights of a linear classifier, in or-
der to then generate adversarial inputs. In contrast
with these methods, we do not make strong struc-
tural assumptions about our classifiers.

Other work has proposed harder test datasets
for various tasks. Levesque (2013) proposed the
Winograd Schema challenge, in which comput-
ers must resolve coreference resolution problems
that were handcrafted to require extensive world
knowledge. Paperno et al. (2016) constructed the
LAMBADA dataset, which tests the ability of lan-
guage models to handle long-range dependencies.
Their method relies on the availability of a large
initial dataset, from which they distill a difficult
subset; such initial data may be unavailable for
many tasks. Rimell et al. (2009) showed that de-
pendency parsers that seem very accurate by stan-
dard metrics perform poorly on a subset of the
test data that has unbounded dependency construc-

tions. Such evaluation schemes can only test mod-
els on phenomena that are moderately frequent in
the test distribution; by perturbing test examples,
we can introduce out-of-distribution phenomena
while still leveraging prior data collection efforts.

While concatenative adversaries are well-suited
to reading comprehension, other adversarial meth-
ods may prove more effective on other tasks. As
discussed previously, paraphrase generation sys-
tems (Madnani and Dorr, 2010) could be used for
adversarial evaluation on a wide range of language
tasks. Building on our intuition that existing mod-
els are overly stable, we could apply meaning-
altering perturbations to inputs on tasks like ma-
chine translation, and adversarially choose ones
for which the model’s output does not change. We
could also adversarially generate new examples
by combining multiple existing ones, in the spirit
of Data Recombination (Jia and Liang, 2016).
The Build It, Break It shared task (Bender et al.,
2017) encourages researchers to adversarially de-
sign minimal pairs to fool sentiment analysis and
semantic role labeling systems.

Progress on building systems that truly under-
stand language is only possible if our evaluation
metrics can distinguish real intelligent behavior
from shallow pattern matching. To this end, we
have released scripts to run ADDSENT on any
SQuAD system, as well as code for ADDANY. We
hope that our work will motivate the development
of more sophisticated models that understand lan-
guage at a deeper level.

Acknowledgments. We thank Pranav Rajpurkar
for his help with various SQuAD models. This
work was supported by the NSF Graduate Re-
search Fellowship under Grant No. DGE-114747,
and funding from Facebook AI Research and Mi-
crosoft.

Reproducibility. All code, data, and
experiments for this paper are avail-
able on the CodaLab platform at https:
//worksheets.codalab.org/worksheets/

0xc86d3ebe69a3427d91f9aaa63f7d1e7d/.

References
E. M. Bender, H. Daume III, A. Ettinger, H. Kannan,

S. Rao, and E. Rothschild. 2017. Build it, break
it: The language edition. https://bibinlp.
umiacs.umd.edu/.

S. R. Bowman, L. Vilnis, O. Vinyals, A. M. Dai,

2029



R. Jozefowicz, and S. Bengio. 2016. Generating
sentences from a continuous space. In Computa-
tional Natural Language Learning (CoNLL).

N. Dalvi, P. Domingos, Mausam, S. Sanghai, and
D. Verma. 2004. Adversarial classification. In Inter-
national Conference on Knowledge Discovery and
Data Mining (KDD).

C. Fellbaum. 1998. WordNet: An Electronic Lexical
Database. MIT Press.

W. N. Francis and H. Kucera. 1979. Brown Corpus
Manual.

A. Globerson and S. Roweis. 2006. Nightmare at test
time: robust learning by feature deletion. In Inter-
national Conference on Machine Learning (ICML),
pages 353–360.

Y. Gong and S. R. Bowman. 2017. Ruminating reader:
Reasoning with gated multi-hop attention. arXiv.

I. J. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Ben-
gio. 2014. Generative adversarial nets. In Advances
in Neural Information Processing Systems (NIPS).

I. J. Goodfellow, J. Shlens, and C. Szegedy. 2015. Ex-
plaining and harnessing adversarial examples. In
International Conference on Learning Representa-
tions (ICLR).

M. Hu, Y. Peng, and X. Qiu. 2017. Mnemonic reader
for machine comprehension. arXiv.

R. Jia and P. Liang. 2016. Data recombination for neu-
ral semantic parsing. In Association for Computa-
tional Linguistics (ACL).

K. Lee, S. Salant, T. Kwiatkowski, A. Parikh, D. Das,
and J. Berant. 2017. Learning recurrent span repre-
sentations for extractive question answering. arXiv.

H. J. Levesque. 2013. On our best behaviour. In Inter-
national Joint Conference on Artificial Intelligence
(IJCAI).

J. Li, W. Monroe, T. Shi, A. Ritter, and D. Jurafsky.
2017. Adversarial learning for neural dialogue gen-
eration. arXiv preprint arXiv:1701.06547.

R. Liu, J. Hu, W. Wei, Z. Yang, and E. Nyberg. 2017.
Structural embedding of syntactic trees for machine
comprehension. arXiv.

D. Lowd and C. Meek. 2005. Adversarial learning. In
International Conference on Knowledge Discovery
and Data Mining (KDD).

N. Madnani and B. J. Dorr. 2010. Generating phrasal
and sentential paraphrases: A survey of data-driven
methods. Computational Linguistics, 36(3):341–
387.

C. D. Manning, M. Surdeanu, J. Bauer, J. Finkel, S. J.
Bethard, and D. McClosky. 2014. The stanford
coreNLP natural language processing toolkit. In
ACL system demonstrations.

M. Marcus, B. Santorini, M. A. Marcinkiewicz, and
A. Taylor. 1999. Treebank-3.

S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and
P. Frossard. 2017. Universal adversarial perturba-
tions. In Computer Vision and Pattern Recognition
(CVPR).

N. Narodytska and S. P. Kasiviswanathan. 2016. Sim-
ple black-box adversarial perturbations for deep net-
works. arXiv preprint arXiv:1612.06299.

D. Paperno, G. Kruszewski, A. Lazaridou, Q. N. Pham,
R. Bernardi, S. Pezzelle, M. Baroni, G. Boleda, and
R. Fernandez. 2016. The LAMBADA dataset: Word
prediction requiring a broad discourse context. In
Association for Computational Linguistics (ACL).

N. Papernot, P. McDaniel, I. Goodfellow, S. Jha, Z. Ce-
lik, and A. Swami. 2017. Practical black-box attacks
against deep learning systems using adversarial ex-
amples. In Proceedings of the ACM Asia Conference
on Computer and Communications Security.

J. Pennington, R. Socher, and C. D. Manning. 2014.
Glove: Global vectors for word representation. In
Empirical Methods in Natural Language Processing
(EMNLP).

P. Rajpurkar, J. Zhang, K. Lopyrev, and P. Liang. 2016.
Squad: 100,000+ questions for machine comprehen-
sion of text. In Empirical Methods in Natural Lan-
guage Processing (EMNLP).

L. Rimell, S. Clark, and M. Steedman. 2009. Un-
bounded dependency recovery for parser evaluation.
In Empirical Methods in Natural Language Process-
ing (EMNLP).

M. Seo, A. Kembhavi, A. Farhadi, and H. Hajishirzi.
2016. Bidirectional attention flow for machine com-
prehension. arXiv.

Y. Shen, P. Huang, J. Gao, and W. Chen. 2017. Rea-
sonet: Learning to stop reading in machine compre-
hension. In International Conference on Knowledge
Discovery and Data Mining (KDD).

N. A. Smith. 2012. Adversarial evaluation for
models of natural language. arXiv preprint
arXiv:1207.0245.

C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Er-
han, I. Goodfellow, and R. Fergus. 2014. Intriguing
properties of neural networks. In International Con-
ference on Learning Representations (ICLR).

S. Wang and J. Jiang. 2016. Machine comprehen-
sion using match-LSTM and answer pointer. arXiv
preprint arXiv:1608.07905.

2030



Z. Wang, H. Mi, W. Hamza, and R. Florian. 2016.
Multi-perspective context matching for machine
comprehension. arXiv.

D. Weissenborn, G. Wiese, and L. Seiffe. 2017. Mak-
ing neural qa as simple as possible but not simpler.
arXiv.

Y. Yu, W. Zhang, K. Hasan, M. Yu, B. Xiang, and
B. Zhou. 2016. End-to-end answer chunk extraction
and ranking for reading comprehension. arXiv.

J. Zhang, X. Zhu, Q. Chen, L. Dai, S. Wei, and
H. Jiang. 2017. Exploring question understanding
and adaptation in neural-network-based question an-
swering. arXiv.

2031


