







































Spurious Ambiguity and Focalization


Spurious Ambiguity and Focalization

Glyn Morrill
Department of Computer Science
Universitat Politècnica de Catalunya
Barcelona
morrill@cs.upc.edu

Oriol Valentı́n
Department of Computer Science
Universitat Politècnica de Catalunya
Barcelona
oriol.valentin@gmail.com

Spurious ambiguity is the phenomenon whereby distinct derivations in grammar may assign the
same structural reading, resulting in redundancy in the parse search space and inefficiency in
parsing. Understanding the problem depends on identifying the essential mathematical structure
of derivations. This is trivial in the case of context free grammar, where the parse structures
are ordered trees; in the case of type logical categorial grammar, the parse structures are proof
nets. However, with respect to multiplicatives, intrinsic proof nets have not yet been given for
displacement calculus, and proof nets for additives, which have applications to polymorphism,
are not easy to characterize. In this context we approach here multiplicative-additive spurious
ambiguity by means of the proof-theoretic technique of focalization.

1. Introduction

In context free grammar (CFG), sequential rewriting derivations exhibit spurious ambi-
guity: Distinct rewriting derivations may correspond to the same parse structure (tree)
and the same structural reading.1 In this case, it is transparent to develop parsing algo-
rithms avoiding spurious ambiguity by reference to parse trees. In categorial grammar
(CG), the problem is more subtle. The Cut-free Lambek sequent proof search space
is finite, but involves a combinatorial explosion of spuriously ambiguous sequential
proofs. This spurious ambiguity in CG can be understood, analogously to CFG, as
involving inessential rule reorderings, which we parallelize in underlying geometric
parse structures that are (planar) proof nets.

The planarity of Lambek proof nets reflects that the formalism is continuous or
concatenative. But the challenge of natural grammar is discontinuity or apparent dis-
placement, whereby there is syntactic/semantic mismatch, or elements appearing out

1 This paper is a revised and expanded version of Morrill and Valentı́n (2015).

Submission received: 21 May 2017; revised version received: 7 February 2018; accepted for publication:
16 March 2018.

doi:10.1162/COLI a 00316

© 2018 Association for Computational Linguistics
Published under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International
(CC BY-NC-ND 4.0) license



Computational Linguistics Volume 44, Number 2

of place. Hence the subsumption of Lambek calculus by displacement calculus D,
including intercalation as well as concatenation (Morrill, Valentı́n, and Fadda 2011).

Proof nets for D must be partially non-planar; steps towards intrinsic correctness
criteria for displacement proof nets are made in Fadda (2010) and Moot (2014, 2016).
Additive proof nets are considered in Hughes and van Glabbeck (2005) and Abrusci
and Maieli (2016). However, even in the case of Lambek calculus, it is not clear that in
practice parsing by reference to intrinsic criteria (Morril 2011; Moot and Retoré 2012,
Appendix B) is more efficient than parsing by reference to extrinsic criteria of uniform
sequent calculus (Miller et al. 1991; Hendriks 1993). In its turn, on the other hand,
uniform proof does not extend to product left rules and product unit left rules, nor
to additives. The focalization of Andreoli (1992) is a methodology midway between
proof nets and uniform proof. Here, we apply the focusing discipline to the parsing as
deduction of D with additives.

In Chaudhuri, Miller, and Saurin (2008), multifocusing is defined for unit-free
multiplicative-additive linear logic, providing canonical sequent proofs; an eventual
goal would be to formulate multifocusing for multiplicative-additive categorial logic
and for categorial logic generally. In this respect the present article represents an inter-
mediate step (and includes units, which have linguistic use). Note that Simmons (2012)
develops focusing for Lambek calculus with additives, but not for displacement logic,
for which we show completeness of focusing here.

The article is structured as follows. In Sections 1.1 and 1.2 we describe spurious
ambiguity in context-free grammar and Lambek calculus. In Section 2 we recall the
displacement calculus with additives. In Section 3 we contextualize the problem of
spurious ambiguity in computational linguistics. In Section 4 we discuss focalization.
In Section 5 we present focalization for the displacement calculus with additives. In
Section 6 we prove the completeness of focalization for displacement calculus with
additives. In Section 7 we exemplify focalization and evaluate it compared with uniform
proof. We conclude in Section 8. In Appendix A we prove the auxiliary technical result
of Cut-elimination for weak focalization.

1.1 Spurious Ambiguity in CFG

Consider the following production rules:

(1) S→ QP VP
QP→ Q CN
VP→ TV N

These generate the following sequential rewriting derivations:

(2) S→ QP VP→ Q CN VP→ Q CN TV N
S→ QP VP→ QP TV N→ Q CN TV N

These sequential rewriting derivations correspond to the same parellelized parse
structure:

(3)

S

QP VP

Q CN TV N

286



Morrill and Valentı́n Spurious Ambiguity and Focalization

And they correspond to the same structural reading; sequential rewriting in CFG has,
then, spurious ambiguity, and the underlying geometric parse structures are ordered
trees.

1.2 Spurious Ambiguity in CG

Lambek calculus L (Lambek 1958) is a logic of strings with the operation + of concate-
nation. Recall the definitions of types, configurations, and sequents of L in terms of a set
P of primitive types;2 in Backus Naur form (BNF) notation where F is the set of types,
O the set of configurations, and Seq(L) the set of sequents:

(4) Types F ::= P | F\F | F/F | F•F
Configurations O ::= F | F ,O
Sequents Seq(L) ::= O⇒ F

Lambek calculus types have the following interpretation in semigroups or monoids:

(5) [[A\C]] = {s2| ∀s1 ∈ [[A]], s1+s2 ∈ [[C]]}
[[C/B]] = {s1| ∀s2 ∈ [[B]], s1+s2 ∈ [[C]]}
[[A•B]] = {s1+s2| s1 ∈ [[A]] & s2 ∈ [[B]]}

Where A, B, C, D are types and Γ, ∆ are configurations, the logical rules of Lambek
calculus are as follows:

(6)
Γ⇒ A ∆(C)⇒ D

\L
∆(Γ, A\C)⇒ D

A, Γ⇒ C
\R

Γ⇒ A\C

Γ⇒ B ∆(C)⇒ D
/L

∆(C/B, Γ)⇒ D
Γ, B⇒ C

/R
Γ⇒ C/B

∆(A, B)⇒ D
•L

∆(A•B)⇒ D
∆⇒ A Γ⇒ B

•R
∆, Γ⇒ A•B

There is completeness when the types are interpreted in free semigroups or monoids
Pentus (1993, 1998).

Even among Cut-free proofs there is spurious ambiguity; consider, for example,
the sequential derivations of Figure 1. These have the same parallelized parse structure
(proof net), given in Figure 2: The structures that represent Lambek proofs without spu-
rious ambiguity are planar graphs that must satisfy certain global and local properties,
and are called proof nets; for a survey see Lamarche and Retoré (1996). Proof nets
provide a geometric perspective on derivational equivalence. Alternatively, we may
identify the same algebraic parse structure (Curry-Howard term):

(7) ((xQ xCN ) λx((xTV xN ) x))

2 The original Lambek calculus did not include the product unit and had a non-empty antecedent
condition (“Lambek’s restriction”). The displacement calculus used in the present article conservatively
extends the Lambek calculus without Lambek’s restriction and with product units.

287



Computational Linguistics Volume 44, Number 2

CN⇒ CN

N⇒ N
N⇒ N S⇒ S

\L
N, N\S⇒ S

/L
N, (N\S)/N, N⇒ S

\R
(N\S)/N, N⇒ N\S S⇒ S

/L
S/(N\S), (N\S)/N, N⇒ S

/L
(S/(N\S))/CN, CN, (N\S)/N, N⇒ S

N⇒ N
CN⇒ CN

N⇒ N S⇒ S
\L

N, N\S⇒ S
\R

N\S⇒ N\S S⇒ S
/L

S/(N\S), N\S⇒ S
/L

(S/(N\S))/CN, CN, N\S⇒ S
/L

(S/(N\S))/CN, CN, (N\S)/N, N⇒ S

Figure 1
Spurious ambiguity in CG.

S◦ N•

S• \◦ N◦ S•

/• CN◦ \• N◦

S◦ /• CN• /• N•

Figure 2
Proof net: The parsing structure of categorial grammar (Morrill 2000).

But Lambek calculus is continuous (planarity). A major issue in grammar is disconti-
nuity, namely, syntax/semantics mismatch (e.g., the fact that quantifier phrases occur
in situ but take sentential scope; or “gapping” coordination), hence the displacement
calculus. This provides a general accommodation of discontinuity in grammar, by
contrast with, for example, Combinatory Categorial Grammar (Steedman 2000), which
seeks minimal case by case augmentations of the formalism to deal with quantification,
gapping, and so on.3

2. D with Additives, DA

The basic categorial grammar of Ajdukiewicz and Bar-Hillel is concatenative/
continuous/projective, and this feature is reflected in the fact that it is context-
free equivalent in weak generative power (Bar-Hillel, Gaifman, and Shamir 1960).
The same is true of the logical categorial grammar of Lambek (1958), which is
still context free in generative power (Pentus 1992). The main challenge in natu-
ral grammar comes from syntax/semantics mismatch or displacement; such non-
concatenativity/discontinuity/non-projectivity is treated in mainstream linguistics by
overt movement (e.g., the verb-raising of cross-serial dependencies) and covert move-
ment (e.g., the quantifier-raising of quantification). The displacement calculus is a

3 Indeed, Sorokin (2013) and Wijnholds (2014) show that Displacement calculus recognizes the class of
well-nested multiple context free languages (Kanazawa 2009); but Combinatory Categorial Grammar
recognizes only the class of tree adjoining languages (Joshi, Vijay-Shanker, and Weir 1991).

288



Morrill and Valentı́n Spurious Ambiguity and Focalization

α + β

=

α β

append + : Li, Lj → Li+j

α 1 γ

×k
β

=

α β γ

plug ×k : Li+1, Lj → Li+j
Figure 3
Append and plug.

response to this challenge, which preserves all the good design features of Lambek
calculus while extending the generative power and capturing “movement” phenomena
such as cross-serial dependencies and quantifer-raising.4

In this section we present displacement calculus D, and a displacement logic DA
comprising D with additives. Although D is indeed a conservative extension of the
Lambek calculus allowing empty antecedents (L*), we think of it not just as an extension
of Lambek calculus but as a generalization, because it involves a whole reformulation to
deal with discontinuity while conserving L* as a special case.

Displacement calculus is a logic of discontinuous strings—strings punctuated by a
separator 1 and subject to operations of append (+; concatenation) and plug (×k; interca-
lation at the kth separator, counting from the left); see Figure 3. Recall the definition of
types and their sorts, configurations and their sorts, and sequents, for the displacement
calculus with additives (i and j range over the naturals 0, 1, . . .):

(8) Where Pi are primitive types of sort i,
Types Fi ::= Pi

Fj ::= Fi\Fi+j
Fi ::= Fi+j/Fj
Fi+j ::= Fi•Fj
F0 ::= I
Fj ::= Fi+1↓kFi+j 1 ≤ k ≤ i+1

Fi+1 ::= Fi+j↑kFj 1 ≤ k ≤ i+1
Fi+j ::= Fi+1�kFj 1 ≤ k ≤ i+1
F1 ::= J
Fi ::= Fi&Fi
Fi ::= Fi⊕Fi

Sort s(A) = the i s.t. A ∈ Fi
For example, s((S↑1N)↑2N) = s((S↑1N)↑1N) = 2 where s(N) = s(S) = 0

4 It is known that displacement calculus (without additives) generates a well-known class of mildly
context free languages: the well-nested multiple context free languages (Sorokin 2013; Wijnholds 2014).
At the time of writing, only this and other lower bounds are known; tight upper bounds on the weak
generative capacity of displacement calculus constitute an open question.

289



Computational Linguistics Volume 44, Number 2

Where Λ is the metasyntactic empty string there is now the BNF definition of
configurations:
Configurations O ::= Λ | T ,O

T ::= 1 | F0 | Fi>0{O : . . . : O︸ ︷︷ ︸
iO′s

}

For example, there is the configuration (S↑1N)↑2N{N, 1 : S↑1N{N}, S}, 1, N, 1

Sort s(O) = |O|1
For example s((S↑1N)↑2N{N, 1 : S↑1N{N}, S}, 1, N, 1) = 3

Sequents Seq(DA) ::= O⇒ A s.t. s(O) = s(A)

The figure −→A of a type A is defined by:

(9) −→A =


A if s(A) = 0
A{1 : . . . : 1︸ ︷︷ ︸

s(A) 1′s

} if s(A) > 0

Where Γ is a configuration of sort i and ∆1, . . . , ∆i are configurations, the fold
Γ⊗ 〈∆1 : . . . : ∆i〉 is the result of replacing the successive 1’s in Γ by ∆1, . . . , ∆i
respectively. For example ((S↑1N)↑2N{N, 1 : S↑1N{N}, S}, 1, N, 1)⊗ 〈1 : N, N\S : Λ〉 is
(S↑1N)↑2N{N, 1 : S↑1N{N}, S}, N, N\S, N.

Where ∆ is a configuration of sort i > 0 and Γ is a configuration, the kth metalin-
guistic wrap ∆ |k Γ, 1 ≤ k ≤ i, is given by

(10) ∆ |k Γ =df ∆⊗ 〈1 : . . . : 1︸ ︷︷ ︸
k−1 1’s

: Γ : 1 : . . . : 1︸ ︷︷ ︸
i−k 1’s

〉

that is, ∆ |k Γ is the configuration resulting from replacing by Γ the kth separator in ∆.
In intuitive terms, syntactical interpretation of displacement calculus is as follows

(see Valentı́n [2016] for completeness results):

(11) [[A\C]] = {s2| ∀s1 ∈ [[A]], s1+s2 ∈ [[C]]}
[[C/B]] = {s1| ∀s2 ∈ [[B]], s1+s2 ∈ [[C]]}
[[A•B]] = {s1+s2| s1 ∈ [[A]] & s2 ∈ [[B]]}

[[I]] = {0}

[[A↓kC]] = {s2| ∀s1 ∈ [[A]], s1×ks2 ∈ [[C]]}
[[C↑kB]] = {s1| ∀s2 ∈ [[B]], s1×ks2 ∈ [[C]]}

[[A�kB]] = {s1×ks2| s1 ∈ [[A]] & s2 ∈ [[B]]}
[[J]] = {1}

The logical rules of the displacement calculus with additives are as follows,
where the hyperoccurrence notation ∆〈Γ〉 abbreviates ∆0(Γ⊗ 〈∆1 : . . . : ∆i〉), that is,

290



Morrill and Valentı́n Spurious Ambiguity and Focalization

a potentially discontinuous distinguished occurrence Γ with external context ∆0 and
internal contexts ∆1, . . . , ∆n:

(12)
Γ⇒ A ∆〈−→C 〉 ⇒ D

\L
∆〈Γ,−−→A\C〉 ⇒ D

−→A , Γ⇒ C
\R

Γ⇒ A\C

Γ⇒ B ∆〈−→C 〉 ⇒ D
/L

∆〈−−→C/B, Γ〉 ⇒ D
Γ,−→B ⇒ C

/R
Γ⇒ C/B

∆〈−→A ,−→B 〉 ⇒ D
•L

∆〈−−→A•B〉 ⇒ D

∆⇒ A Γ⇒ B
•R

∆, Γ⇒ A•B

∆〈Λ〉 ⇒ A
IL

∆〈−→I 〉 ⇒ A
IR

Λ⇒ I

(13)
Γ⇒ A ∆〈−→C 〉 ⇒ D

↓kL
∆〈Γ |k

−−−→A↓kC〉 ⇒ D

−→A |k Γ⇒ C ↓kR
Γ⇒ A↓kC

Γ⇒ B ∆〈−→C 〉 ⇒ D
↑kL

∆〈−−→C↑kB |k Γ〉 ⇒ D
Γ |k
−→B ⇒ C

↑kR
Γ⇒ C↑kB

∆〈−→A |k
−→B 〉 ⇒ D

�kL
∆〈−−−→A�kB〉 ⇒ D

∆⇒ A Γ⇒ B
�kR

∆ |k Γ⇒ A�kB

∆〈1〉 ⇒ A
JL

∆〈−→J 〉 ⇒ A
JR

1⇒ J

(14)
Γ〈−→A 〉 ⇒ C

&L1
Γ〈−−→A&B〉 ⇒ C

Γ〈−→B 〉 ⇒ C
&L2

Γ〈−−→A&B〉 ⇒ C

Γ⇒ A Γ⇒ B
&R

Γ⇒ A&B

Γ〈−→A 〉 ⇒ C Γ〈−→B 〉 ⇒ C
⊕L

Γ〈−−→A⊕B〉 ⇒ C

Γ⇒ A
⊕R1

Γ⇒ A⊕B
Γ⇒ B

⊕R2
Γ⇒ A⊕B

The continuous multiplicatives {\, •, /, I} of Lambek (1958, 1988), which are de-
fined in relation to concatenation, are the basic means of categorial (sub)categorization.
The directional divisions over, /, and under, \, are exemplified by assignments such

291



Computational Linguistics Volume 44, Number 2

as the: N/CN for the man: N and sings: N\S for John sings: S, and loves: (N\S)/N for
John loves Mary: S. Hence, for the man:

(15)
CN⇒ CN N⇒ N

/L
N/CN, CN⇒ N

And for John sings and John loves Mary:

(16)
N⇒ N S⇒ S

\L
N, N\S⇒ S

N⇒ N
N⇒ N S⇒ S

\L
N, N\S⇒ S

/L
N, (N\S)/N, N⇒ S

The continuous product • is exemplified by a “small clause” assignment such as
considers: (N\S)/ (N•(CN/CN)) for John considers Mary socialist: S.

(17) N⇒ N

CN⇒ CN CN⇒ CN
/L

CN/CN, CN⇒ CN
/R

CN/CN⇒ CN/CN
•R

N, CN/CN⇒ N•(CN/CN)
N⇒ N S⇒ S

\L
N, N\S⇒ S

/L
N, (N\S)/(N•(CN/CN)), N, CN/CN⇒ S

Of course, this use of product is not essential: We could just as well have used
((N\S)/(CN/CN))/N because in general we have both A/(C•B)⇒ (A/B)/C (currying)
and (A/B)/C⇒ A/(C•B) (uncurrying).

The discontinuous multiplicatives {↓, �, ↑, J}, the displacement connectives, of
Morrill and Valentı́n (2010) and Morrill, Valentı́n, and Fadda (2011) are defined in
relation to intercalation. When the value of the k subscript is 1 it may be omitted (i.e.,
it defaults to one). Circumfixation, or extraction, ↑, is exemplified by a discontinuous
particle-verb assignment calls+1+up: (N\S)↑N for Mary calls the man up: S:

(18)

CN⇒ CN N⇒ N
/L

N/CN, CN⇒ N
N⇒ N S⇒ S

\L
N, N\S⇒ S

↑L
N, (N\S)↑N{N/CN, CN} ⇒ S

Infixation, ↓, and extraction together are exemplified by a quantifier assignment
everyone: (S↑N)↓S simulating Montague’s S14 rule of quantifying whereby a quantifier
phrase can occur where a name can occur (but takes sentential scope):

(19)

. . . , N, . . . ⇒ S
↑R

. . . , 1, . . . ⇒ S↑N
id

S⇒ S
↓L

. . . , (S↑N)↓S, . . . ⇒ S

292



Morrill and Valentı́n Spurious Ambiguity and Focalization

Circumfixation and discontinuous product, �, are illustrated in an assignment
to a relative pronoun that: (CN\CN)/((S↑N)�I) allowing both peripheral and medial
extraction, that John likes: CN\CN and that John saw today: CN\CN:

(20)

N, (N\S)/N, N⇒ S
↑R

N, (N\S)/N, 1⇒ S↑N
IL

⇒ I
�R

N, (N\S)/N⇒ (S↑N)�I CN\CN⇒ CN\CN
/L

(CN\CN)/((S↑N)�I), N, (N\S)/N⇒ CN\CN

(21)

N, (N\S)/N, N, S\S⇒ S
↑R

N, (N\S)/N, 1, S\S⇒ S↑N
IL

⇒ I
�R

N, (N\S)/N, S\S⇒ (S↑N)�I CN\CN⇒ CN\CN
/L

(CN\CN)/((S↑N)�I), N, (N\S)/N, S\S⇒ CN\CN

The additive conjunction and disjunction {&, ⊕} of Lambek (1961), Morrill (1990),
and Kanazawa (1992) capture polymorphism. For example, the additive conjunction &
can be used for rice: N&CN as in rice grows: S and the rice grows: S:

(22)

N⇒ N
&L1

N&CN⇒ N S⇒ S
\L

N&CN, N\S⇒ S

N/CN, CN, N\S⇒ S
&L2

N/CN, N&CN, N\S⇒ S

The additive disjunction ⊕ can be used for is: (N\S)/(N⊕(CN/CN)) as in
Tully is Cicero: S and Tully is humanist: S:

(23)

N⇒ N
⊕R1

N⇒ N⊕(CN/CN) N\S⇒ N\S
/L

(N\S)/(N⊕(CN/CN)), N⇒ N\S

CN/CN⇒ CN/CN
⊕R2

CN/CN⇒ N⊕(CN/CN) N\S⇒ N\S
/L

(N\S)/(N⊕(CN/CN)), CN/CN⇒ N\S

3. The Problem of Spurious Ambiguity in Computational Linguistics

This section elaborates the bibliographic context of so-called spurious ambiguity, a
problem frequently arising in varieties of parsing of different formalisms. The spurious
ambiguity that has been discussed in the literature falls in two broad classes: that for
categorial parsing and that for dependency parsing.

The literature on spurious ambiguity for categorial parsing is represented by the
following.r Hepple (1990) provides an analysis of normal form theorem proving

for Cut-free Lambek calculus without product. Two systems are

293



Computational Linguistics Volume 44, Number 2

considered: first, a notion of normalization for this implicative Lambek
calculus, and second, a constructive calculus generating all and only the
normal forms of the first. The latter consists of applying right rules as
much as possible and then switching to left rules, which revert to the right
phase in the minor premise and which conserve the value active type in
the major premise. Hepple shows that the system is sound and complete
and that it delivers a unique proof in each Cut-free semantic equivalence
class. This amounts to uniform proof (Miller et al. 1991), but was
developed independently. Retrospectively, it can be seen as focusing for
the implicative fragment of Lambek calculus. It is straightforwardly
extendible to product right (Hendriks 1993), but not product left, which
requires the deeper understanding of the focusing method.r Eisner (1996) provides a normal form framework for Combinatory
Categorial Grammar (CCG) with generalized binary composition rules.
CCG is a version of categorial grammar with a small number of
combinatory schemata (or a version of CFG with an infinite number of
non-terminals) in which the basic directional categorial cancellation rules
are extended with phrase structure schemata corresponding to
combinators of combinatory logic. Eisner, following Hepple and Morrill
(1989), defines a notion of normal form by a restriction on which rule
mothers can serve as which daughters of subsequent rules in bottom–up
parsing. Eisner notes that his marking of rules has a rough resemblance to
the rule regulation of Hendriks (1993) (which is focusing). But whereas the
former is Cut-based rule normalization, the latter is Cut-free metarule
normalization. Eisner’s method applies to a wide range of harmonic and
non-harmonic composition rules, but not to type-lifting rules. It has been
suggested by G. Penn (personal communication) that it is not clear
whether CCG is actually categorial grammar; at least, it is not logical
categorial grammar; in any case, the focusing methodology we use here is
still normalization, but represents a much more general discipline than
that used by Eisner.r Moortgat and Moot (2011) study versions of proof nets and focusing for
so-called Lambek-Grishin calculus. Lambek-Grishin calculus is like
Lambek calculus but includes a disjunctive multiplicative connective
family as well as the conjunctive multiplicative connective family of the
Lambek calculus L, and it is thus multiple-conclusioned. For the case LG
considered, suitable structural linear distributivity postulates facilitate
the capacity to describe non-context free patterns. By contrast with
displacement calculus D, which is single-conclusioned (it is intuitionistic),
and which absorbs the structural properties in the sequent syntax (it has
no structural postulates), LG has a non-classical term regime that can
assign multiple readings to a proof net, and has semantically non-neutral
focusing and defocusing rules. Thus it is quite different from the system
considered here in several respects. The multiplicative focusing for LG is a
straightforward adaptation of that for linear logic and additives are not
addressed; importantly, the backward-chaining focused LG search space
still requires the linear distributivity postulates (which leave no trace in
the terms assigned), whereas the backward chaining D search space has no
structural postulates.

294



Morrill and Valentı́n Spurious Ambiguity and Focalization

The literature on spurious ambiguity for dependency parsing is represented by the
following.

r Huang, Vogel, and Chen (2011) address the problem of word alignment
between pairs of corresponding sentences in (statistical) machine
translation. Because this task may be very complex (in fact the search space
may grow exponentially), a technique called synchronous parsing is used
to constrain the search space. However, this approach exhibits the problem
of spurious ambiguity, which that paper elaborates in depth. We do not
know at this moment whether this work can bring us useful techniques to
deal with spurious ambiguity in the field of logic theorem-proving.r Goldberg and Nivre (2012) and Cohen, Gómez-Rodrı́guez, and Satta
(2012) focus on the problem of spurious ambiguity of a general technique
for dependency parsing called transition-based dependency parsing. The
spurious ambiguity investigated in that paper arises in transition systems
where different sequences of transitions yield the same dependency tree.
The framework of dependency grammars is non-logical in its nature and
the spurious ambiguity referred here is completely different from the one
addressed in our article, and unfortunately not useful to our work.r Hayashi, Kondo, and Matsumoto (2013), which is situated in the field of
dependency parsing, proposes sophisticated parsing techniques that may
have spurious ambiguity. A method is presented in order to deal with it
based on normalization and canonicity of sequences of actions of
appropriate transition systems.

All these approaches tackle by a kind of normalization the general phenomena
of spurious ambiguity, whereby different but equivalent alternative applications of
operations result in the same output. Focalization in particular is applicable to logical
grammar, in which parsing is deduction. This turns out to be quite a deep methodology,
revealing, for example, not only invertible (“reversible”) rules, which were known to the
early proof-theorists, but also dual focusing (“irreversible”) rules, providing a general
discipline for logical normalization, which we now elaborate.

4. Reducing Spurious Ambiguity: On Focalization

In previous sections we have shown the proof machinery of DA. A further sequent rule
is missing, the so-called Cut rule, which incorporates in the sequent calculus the notion
of (contextualised) transitivity:

(24)
Γ⇒ A ∆〈−→A 〉 ⇒ B

Cut
∆〈Γ〉 ⇒ B

Note that the Cut rule does not have the property that every type in the premises is a
(sub)type of the conclusion (the subformula property), hence it is an obstacle to proof
search. Any standard logic should have the Cut rule because this encodes transitivity
of the entailment relation, but at the same time a major result of logics presented as
sequent calculi is the Cut-elimination theorem, or as it is usually known after Gentzen,

295



Computational Linguistics Volume 44, Number 2

Haupsatz. This very important theorem gives as a byproduct the subformula property
and decidability in the case of DA.5

4.1 Properties of Cut-Free Proof Search

“Reversible” rules are rules in which the conclusions are provable if and only if the
premises are provable. The reversible rules of displacement calculus with additives are:
/R, \R, •L, IL, ↑kR, ↓kR,�kL, JL, &R, and ⊕L. By way of example, consider /R:

(25) a. Γ⇒ C/B b. Γ, B⇒ C

We can safely reverse sequent (25a) into sequent (25b) because both provability and non-
provability are preserved—that is, Γ⇒ C/B is provable iff Γ, B⇒ C is provable. We say
that the type-occurrence of C/B in the succedent of (25a) is reversible.6 This means that
in the face of alternative reversible rule options a choice can be made arbitrarily and the
other possibilities forgotten (don’t care nondeterminism).

Dually, “irreversible” rules are rules in which it is not the case that the conclusions
are provable if and only if the premises are provable. The irreversible rules of displace-
ment calculus with additives are: /L, \L, •R, IR, ↑kL, ↓kL,�kR, JR, &L and ⊕R. By way of
example, consider the /L rule:

(26)
Γ⇒ B ∆(C)⇒ D

/L
∆(C/B, Γ)⇒ D

We cannot assume safely that there exist configurations Γ and ∆(C) that match the
antecedent of the end-sequent, and that preserve provability: We do not have that
∆(C/B, Γ)⇒ D is provable iff Γ⇒ B and ∆(C)⇒ D are provable. In this case, we say
that the distinguished type-occurrence C/B in the above sequent is irreversible.7 In the
face of alternative irreversible rule options, the choice matters and different possibilities
must be tried (don’t know nondeterminism).

4.1.1 On Reversible Rules. Consider the following sequents where two distinguished
type-occurrences have been underlined:

((N\S)/N)/N, N •N⇒ N\S ((N\S)/N)/N, N •N⇒ N\S

There are the following two commutative derivation fragments:

N, ((N\S)/N)/N, N, N⇒ S
•L

N, ((N\S)/N)/N, N•N⇒ S
\R

((N\S)/N)/N, N•N⇒ N\S

5 This is because in Cut-free backward-chaining proof search for a given goal sequent a finite number of
rules can be applied backwards in only a finite number of ways to generate subgoals at each step, and
these subgoals have lower complexity (fewer connectives) than the goal matched; hence the proof search
space is finite.

6 Other terms found in the literature are invertible, asynchronous, or negative.
7 Other terms found in the literature are non-invertible, synchronous, or positive.

296



Morrill and Valentı́n Spurious Ambiguity and Focalization

N, ((N\S)/N)/N, N, N⇒ S
\R

((N\S)/N)/N, N, N⇒ N\S
•L

((N\S)/N)/N, N•N⇒ N\S

r Applying the two rules in either order, both (proof) derivations have the
same syntactic structure (and the same semantic lambda-term labeling,
which we introduce later when we present focused calculus).r The reversible rules •L and \R commute in the order of application in the
proof search. These commutations contribute to spurious ambiguity.r Reversible rules can be applied don’t care nondeterministically. This result
was already known by proof-theorists in the 1930s (Gentzen, and others
such as Kleene). These rules were called invertible rules.

4.1.2 On Irreversible Rules. Consider the following:

CN⇒ CN

/L
N, (N\S)/N, N⇒ S

\R
(N\S)/N, N⇒ N\S S⇒ S

/L
S/(N\S), (N\S)/N, N⇒ S

/L
(S/(N\S))/CN, CN, (N\S)/N, N⇒ S

N⇒ N

CN⇒ CN S/(N\S), N\S⇒ S
/L

(S/(N\S))/CN, CN, N\S⇒ S
/L

(S/(N\S))/CN, CN, (N\S)/N, N⇒ S

r Dually, both (proof) derivations have the same syntactic structure,
(i.e., proof net), as well as the same semantic term labeling codifying
the structure of derivations.r The irreversible rules for /(S/(N\S))/CN and /(N\S)/N commute in the order of
application in the proof search. These commutations also contribute to
spurious ambiguity.r Contrary to the behavior of reversible types, the choice of the active type
(the type decomposed) is critical when it is irreversible.

4.2 Consequencesr A combinatorial explosion in the finite Cut-free proof search space due to
the aforementioned rule commutativity.r The solution: proof nets. But proof nets for categorial logic in general are
not fully understood, for example, in the case of units and additive
connectives.r This problem is exacerbated in displacement calculus because there are
more connectives and hence more rules giving rise to spurious
ambiguities.r A good partial solution: the discipline of focalization.

297



Computational Linguistics Volume 44, Number 2

4.3 Toward a (Considerable) Elimination of Spurious Ambiguity: Focalization

Reversible rules commute in their order of application and their key property is re-
versability. Dually, irreversible rules also commute and their key property (completely
unknown to the early proof-theorists8) is so-called focalization, which was defined by
Andreoli in Andreoli (1992).

4.4 The Discipline of Focalization

Given a sequent, reversible rules are applied in a don’t care nondeterministic fashion
until no longer possible. When there are no occurrences of reversible types, one chooses
an irreversible type don’t know nondeterministically as active type-occurrence; we say
that this type occurrence is in focus, or that it is focalized; and one applies proof
search to its subtypes while these remain irreversible. When one finds a reversible
type, reversible rules are applied in a don’t care nondeterministic fashion again until
no longer possible, when another irreversible type is chosen, and so on.

4.4.1 A Non-focalized Proof: A “Gymkhana in the Proof-search”. Let us consider the
following provable sequent with types Q = S/(N\S), and TV = (N\S)/N.

(27) Q/CN, CN, TV, N⇒ S

Sequent (27) has the algebraic Curry-Howard term:

(28) ((xQ/CN xCN ) λx((xTV xN ) x))

Consider the proof fragment:

(29)
CN⇒ CN

N⇒ N

...
/L

Q, N\S⇒ S
/L

Q, TV, N⇒ S
/L

Q/CN, CN, TV, N⇒ S

This fragment of proof concludes into a correct proof derivation. But crucially, the
discipline of focalization is not applied resulting—in the words of the father of linear
logic—in a gymkhana! (In the sense of jumping back and forth.) The foci on irreversible
types are not preserved and alternating irreversible types are chosen. Concretely, the
underlines show how the active irreversible type in the right premise is not a subtype of
the active irreversible type in the endsequent. The discipline of Andreoli’s focalization
consists of maintaining the focus on the irreversible subtypes, hence reducing the search
space and reducing spurious ambiguity. This rests on the focusing property: that if an
irreversible rule instance leads to a proof, it leads to a proof in which the subtypes of
the active type are the active types of the premises, if they are irreversible. This is the re-
markable proof-theoretic discovery of Andreoli, which fortunately can be applied in the

8 Unknown even to the inventor of Linear Logic, J.-Y. Girard.

298



Morrill and Valentı́n Spurious Ambiguity and Focalization

present case as this article explains. The discipline of focalization reduces dramatically
the combinatorial explosion of categorial proof-search.

4.4.2 A Focalized Proof Derivation. A fragment of focalized proof derivation for (27) is as
follows:

(30)
CN⇒ CN

...
\R

TV, N⇒ N\S S⇒ S
/L

Q, TV, N⇒ S
/L

Q/CN, CN, TV, N⇒ S

Note that the focus is correctly propagated to the irreversible subtype of the focused
irreversible type in the endsequent.

4.5 A Last Ingredient in the Focalization Discipliner What happens with literal types? Can they be considered reversible or
irreversible? What happens then in the focalized proof-search paradigm?r The answers: Literals can be assigned what is called in the literature a
reversible or irreversible bias in any manner according to which they
belong to the set of reversible or irreversible types. (As we state later we
leave open the question of which biases may be favorable.)

Depending on the context, we will say compound reversible or irreversible types, or
atomic reversible or irreversible types.

5. Focalization for DA

In focalization, situated (in the antecedent of a sequent, input: •; in the succedent
of a sequent, output: ◦) compound types are classified as of reversible or irreversible
polarity according to whether their associated rule is reversible or not; situated atoms
obviously do not have associated rules, but we can extend the concept of polar-
ity to them, overloading the terms reversible and irreversible, applying the previously
mentioned concept of bias. We define in Example (31) a BNF grammar for arbitrary
types (observe that atomic types are classified as either At• or At◦):

(31) P ::= At◦ | A•B | I | A�kB | J | A⊕B
Q ::= At• | C/B | A\C | C↑kB | A↓kC | A&B

P and Q in Example (31) denote reversible types (including atomic types) occurring in
input and output position, respectively. Dually, if P and Q occur in the output and input
position, respectively, then they are said to occur with irreversible polarity. In the atomic
case, the same terms (reversible and irreversible) are also used. The table in Example (32)

299



Computational Linguistics Volume 44, Number 2

summarizes the notational convention on arbitrary (atomic or compound) polarized
formulas P and Q:

(32)

input output

rev. P Q

irrev. Q P

Notice that in Example (32) arbitrary polarized types exhibit a kind of De Morgan
duality: If reversible output types Q occur in input position, then they are irreversible;
whereas if reversible output types P occur in input position, then they are irreversible.

−→A : x, Γ⇒ C:χ ¬ foc
\R

Γ⇒ A\C: λxχ ¬ foc ∧ rev
Γ,−→B : y⇒ C:χ ¬ foc

/R
Γ⇒ C/B: λyχ ¬ foc ∧ rev

∆〈−→A : x,−→B : y〉 ⇒ D:ω ¬ foc
•L

∆〈−−→A•B: z〉 ⇒ D:ω{π1z/x,π2z/y} ¬ foc ∧ rev

∆〈Λ〉 ⇒ A:φ ¬ foc
IL

∆〈−→I : x〉 ⇒ A:φ ¬ foc ∧ rev

−→A : x |k Γ⇒ C:χ ¬ foc ↓kR
Γ⇒ A↓kC: λxχ ¬ foc ∧ rev

Γ |k
−→B : y⇒ C:χ ¬ foc

↑kR
Γ⇒ C↑kB: λyχ ¬ foc ∧ rev

∆〈−→A : x |k
−→B : y〉 ⇒ D:ω ¬ foc

�kL
∆〈−−−→A�kB: z〉 ⇒ D:ω{π1z/x,π2z/y} ¬ foc ∧ rev

∆〈1〉 ⇒ A:φ ¬ foc
JL

∆〈−→J : x〉 ⇒ A:φ ¬ foc ∧ rev
Figure 4
Reversible multiplicative rules.

Γ⇒ A:φ ¬ foc Γ⇒ B:ψ ¬ foc
&R

Γ⇒ A&B: (φ,ψ) ¬ foc ∧ rev

Γ〈−→A : x〉 ⇒ C:χ1 ¬ foc Γ〈
−→B : y〉 ⇒ C:χ2 ¬ foc ⊕L

Γ〈−−→A⊕B: z〉 ⇒ C: z→ x.χ1; y.χ2 ¬ foc ∧ rev
Figure 5
Reversible additive rules.

300



Morrill and Valentı́n Spurious Ambiguity and Focalization

Γ⇒ P :φ foc ∧ ¬ rev ∆〈
−→
Q : z〉 ⇒ D:ω foc ∧ ¬ rev

\L
∆〈Γ,

−−−→
P\Q : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ P1 :φ foc ∧ ¬ rev ∆〈
−→P2: z〉 ⇒ D:ω ¬ foc \L

∆〈Γ,
−−−−→
P1\P2 : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ Q1:φ ¬ foc ∆〈
−−→
Q2 : z〉 ⇒ D:ω foc ∧ ¬ rev \L

∆〈Γ,
−−−−−→
Q1\Q2 : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ Q:φ ¬ foc ∆〈−→P : z〉 ⇒ D:ω ¬ foc
\L

∆〈Γ,
−−−→
Q\P : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ P :ψ foc ∧ ¬ rev ∆〈
−→
Q : z〉 ⇒ D:ω foc ∧ ¬ rev

/L
∆〈
−−−→
Q/P : x, Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Γ⇒ Q1:ψ ¬ foc ∆〈
−−→
Q2 : z〉 ⇒ D:ω foc ∧ ¬ rev

/L
∆〈
−−−−−→
Q2/Q1 : x, Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Γ⇒ P1 :ψ foc ∧ ¬ rev ∆〈
−→P2: z〉 ⇒ D:ω ¬ foc

/L
∆〈
−−−−→
P2/P1 : x, Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Γ⇒ Q:ψ ¬ foc ∆〈−→P : z〉 ⇒ D:ω ¬ foc
/L

∆〈
−−−→
P/Q : x, Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Figure 6
Left irreversible continuous multiplicative rules.

6. Completeness of Focalization for DA

In order to prove that DA is complete with respect to focalization, we define a logic
DAFoc with the following features: (a) the set of configurations O is extended to the
set Obox, (b) the set of sequents Seq(DA) is extended to the set Seq(DAFoc), (c) a
new set of logical rules. The set of configurations Obox contains O, and in addition
it contains boxed configurations, by which we understand configurations where a
unique irreversible type-occurrence is decorated with a box, thus: A . The set of se-
quents Seq(DAFoc) includes DA sequents with possibly a box in the sequent. We have
then Seq(DA) ( Seq(DAFoc). Sequents of Seq(DAFoc) can contain at most one boxed

301



Computational Linguistics Volume 44, Number 2

Γ⇒ P :φ foc ∧ ¬ rev ∆〈
−→
Q : z〉 ⇒ D:ω foc ∧ ¬ rev

↓kL
∆〈Γ |k

−−−−→
P↓kQ : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ P1 :φ foc ∧ ¬ rev ∆〈
−→P2: z〉 ⇒ D:ω ¬ foc ↓kL

∆〈Γ |k
−−−−−→
P1↓kP2 : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ Q1:φ ¬ foc ∆〈
−−→
Q2 : z〉 ⇒ D:ω foc ∧ ¬ rev ↓kL

∆〈Γ |k
−−−−−−→
Q1↓kQ2 : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ Q:φ ¬ foc ∆〈−→P : z〉 ⇒ D:ω ¬ foc
↓kL

∆〈Γ |k
−−−−→
Q↓kP : y〉 ⇒ D:ω{(y φ)/z} foc ∧ ¬ rev

Γ⇒ P :ψ foc ∧ ¬ rev ∆〈
−→
Q : z〉 ⇒ D:ω foc ∧ ¬ rev

↑kL
∆〈
−−−−→
Q↑kP : x |k Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Γ⇒ Q1:ψ ¬ foc ∆〈
−−→
Q2 : z〉 ⇒ D:ω foc ∧ ¬ rev ↑kL

∆〈
−−−−−−→
Q2↑kQ1 : x |k Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Γ⇒ P1 :ψ foc ∧ ¬ rev ∆〈
−→P2: z〉 ⇒ D:ω ¬ foc ↑kL

∆〈
−−−−−→
P2↑kP1 : x |k Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Γ⇒ Q:ψ ¬ foc ∆〈−→P : z〉 ⇒ D:ω ¬ foc
↑kL

∆〈
−−−−→
P↑kQ : x |k Γ〉 ⇒ D:ω{(x ψ)/z} foc ∧ ¬ rev

Figure 7
Left irreversible discontinuous multiplicative rules.

type-occurrence. The meaning of such a box is to mark in the proof-search an irre-
versible (possibly atomic) type-occurrence either in the antecedent or in the succedent
of a sequent. We will say that such a sequent is focalized.

Additionally, the set Seq(DAFoc) is constrained as follows:

(33) Boxed sequents cannot contain compound reversible types

We will use judgements foc and rev on DAFoc-sequents. Where S ∈ Seq(DAFoc),
S foc means that S contains a boxed type occurrence, and S rev means that there is
a complex reversible type occurrence. It follows that Constraint (33) can be judged as

302



Morrill and Valentı́n Spurious Ambiguity and Focalization

Γ〈
−→
Q : x〉 ⇒ C:χ foc ∧ ¬ rev

&L1
Γ〈
−−−−→
Q&B : z〉 ⇒ C:χ{π1z/x} foc ∧ ¬ rev

Γ〈−→P : x〉 ⇒ C:χ ¬ foc
&L1

Γ〈
−−−→
P&B : z〉 ⇒ C:χ{π1z/x} foc ∧ ¬ rev

Γ〈
−→
Q : y〉 ⇒ C:χ foc ∧ ¬ rev

&L2
Γ〈
−−−−→
A&Q : z〉 ⇒ C:χ{π2z/y} foc ∧ ¬ rev

Γ〈−→P : y〉 ⇒ C:χ ¬ foc
&L2

Γ〈
−−−−→
A&P : z〉 ⇒ C:χ{π2z/y} foc ∧ ¬ rev

Figure 8
Left irreversible additive rules.

∆⇒ P1 :φ foc ∧ ¬ rev Γ⇒ P2 :ψ foc ∧ ¬ rev •R
∆, Γ⇒ P1•P2 : (φ,ψ) foc ∧ ¬ rev

∆⇒ P :φ foc ∧ ¬ rev Γ⇒ Q:ψ ¬ foc
•R

∆, Γ⇒ P•Q : (φ,ψ) foc ∧ ¬ rev

∆⇒ N:φ ¬ foc Γ⇒ P :ψ foc ∧ ¬ rev
•R

∆, Γ⇒ N•P : (φ,ψ) foc ∧ ¬ rev

∆⇒ N1:φ¬ foc Γ⇒ N2:ψ foc •R
∆, Γ⇒ N1•N2 : (φ,ψ) foc ∧ ¬ rev

IR
Λ⇒ I : 0 foc ∧ ¬ rev

Figure 9
Right irreversible continuous multiplicative rules.

S foc ∧ ¬ rev. The judgment S¬ foc means that S is not focalized (and so may contain
reversible type-occurrences).

The rules for focused inference are given in Figures 4–12, where sequents are accom-
panied by judgments: focalized or not focalized and reversible or not reversible. The
constraint (33) is key in determining the judgments; in the figures showing irreversible
additive or multiplicative rules, when the premise is not focalized only the correspond-
ing subtype can be reversible. This system, which is Cut-free, is what we call strongly
focalized and induces maximal alternating phases of reversible and irreversible rule

303



Computational Linguistics Volume 44, Number 2

∆⇒ P1 :φ foc ∧ ¬ rev Γ⇒ P2 :ψ foc ∧ ¬ rev �kR
∆ |k Γ⇒ P1�kP2 : (φ,ψ) foc ∧ ¬ rev

∆⇒ P :φ foc ∧ ¬ rev Γ⇒ Q:ψ ¬ foc
�kR

∆ |k Γ⇒ P�kQ : (φ,ψ) foc ∧ ¬ rev

∆⇒ Q:φ ¬ foc Γ⇒ P :ψ foc ∧ ¬ rev
�kR

∆ |k Γ⇒ Q�kP : (φ,ψ) foc ∧ ¬ rev

∆⇒ Q1:φ ¬ foc Γ⇒ Q2:ψ ¬ foc �kR
∆ |k Γ⇒ Q1�kQ2 : (φ,ψ) foc ∧ ¬ rev

JR
1⇒ J : 0 foc ∧ ¬ rev

Figure 10
Right irreversible discontinuous multiplicative rules.

Γ⇒ P :φ foc ∧ ¬ rev
⊕R1

Γ⇒ P⊕B : ι1φ foc ∧ ¬ rev

Γ⇒ Q:φ ¬ foc
⊕R1

Γ⇒ Q⊕B : ι1φ foc ∧ ¬ rev

Γ⇒ P :ψ foc ∧ ¬ rev
⊕R2

Γ⇒ A⊕P : ι2ψ foc ∧ ¬ rev

Γ⇒ Q:ψ ¬ foc
⊕R2

Γ⇒ A⊕Q : ι2ψ foc ∧ ¬ rev

Figure 11
Right irreversible additive rules.

∆〈 −→Q 〉 ⇒ A
foc

∆〈−→Q 〉 ⇒ A
∆⇒ P

foc
∆⇒ P

Figure 12
Foc rule for DAFoc.

application. Pseudo-code for a recursive algorithm of strongly focalized proof search is
as follows:

bool. function prove(Σ: unfocused sequent);

/* prove(Σ) returns true if the unfocused sequent Σ is provable; otherwise
it returns false. */

return prove rev lst([Σ]).

bool. function prove rev lst(Ls: list of unfocused sequents);

/* prove rev lst(Ls) returns true if the list of unfocused sequents Ls are
provable; otherwise it returns false. */

304



Morrill and Valentı́n Spurious Ambiguity and Focalization

while Ls contains a sequent Σ with a reversible type do
Ls := Ls with Σ replaced by the premises of the rule for the

reversible type;

return prove rev lst(Ls).

bool. function prove irrev lst(Ls: list of unfocused sequents);

/* prove irrev lst(Ls) returns true if the list of unfocused sequents
without reversible types Ls are provable; otherwise it returns false. */

var Success: bool;
if Ls = [] then return true

else where Ls = [Σ|T] do
begin
Success := true;
for each irreversible type in Σ do

if Success then
begin
focus this irreversible type to Σ′;
Success := prove irrev(Σ′);
end;

end;
return Success and prove irrev lst(T).

bool. function prove irrev(Σ: focused sequent);

/* prove irrev(Σ) returns true if the focused sequent Σ is provable;
otherwise it returns false. */

var Success: bool;
var Ls rev: list of unfocused sequents;
var Ls irrev: list of focused sequents;
Success := true;
for each rule application to the focused type in Σ do

if Success then
begin
Ls rev := its reversible premises;

Ls irrev := its irreversible premises;

Success := prove rev lst(Ls rev) and prove irrev lst(Ls irrev);
end;

return Success.

The top level call to determine whether a sequent S is provable is prove(S). The
routine prove(S) calls the routine prove rev lst with actual parameter the unitary list
[S]. The routine prove rev lst then applies reversible rules to its list of sequents Ls in a
don’t care nondeterministic manner until none of the sequents contain any reversible
type (i.e., it closes Ls under reversible rules). Then prove irrev lst is called on the list of
sequents. This calls prove irrev(S′) for focusings S′ of each sequent, and if some focusing
of each sequent is provable the result true is returned, otherwise false is returned. The

305



Computational Linguistics Volume 44, Number 2

procedure prove irrev applies focusing rules and recurses back on prove rev lst and
prove irrev lst to determine provability for the given focusing.

In order to prove completeness of (strong) focalization we invoke also an interme-
diate weakly focalized system. In all we shall be dealing with three systems: the dis-
placement calculus with additives DA with sequents notated ∆⇒ A, the weakly focalized
displacement calculus with additives DAfoc with sequents notated ∆=⇒wA, and the
strongly focalized displacement calculus with additives DAFoc with sequents notated
∆=⇒A. Sequents of both DAfoc and DAFoc may contain at most one focalized formula.
When a DAfoc sequent is notated ∆=⇒wA3focalized, it means that the sequent possibly
contains a (unique) focalized formula. Otherwise, ∆=⇒wA means that the sequent does
not contain a focus. In DAfoc Constraint (33) is not imposed. Thus, whereas strong
focalization imposes maximal alternating phases of reversible and irreversible rule
application, weak focalization does not impose this maximality. In this section we prove
the strong focalization property for the displacement calculus with additives DA, that
is, strong focalization is complete.

The focalization property for Linear Logic was defined by Andreoli (1992). In this
article we follow the proof idea from Laurent (2004), which we adapt to the intuitionistic
non-commutative case DA with twin multiplicative modes of combination, the contin-
uous (concatenation), and the discontinuous (intercalation) products. The proof relies
heavily on the Cut-elimination property for weakly focalized DA, which is proved
in Appendix A. In our presentation of focalization we have avoided the react rules
of Andreoli (1992) and Chaudhuri (2006), and use instead our simpler box notation
suitable for non-commutativity.

DAFoc is a subsystem of DAfoc. DAfoc has the focusing rules foc and Cut rules
p-Cut1, p-Cut2, n-Cut1, and n-Cut2

9 shown in Equation (34), and the reversible and
irreversible rules displayed in the figures, which are read as allowing in irreversible
rules the occurrence of reversible types, and in reversible rules as allowing arbitrary
sequents possibly with a focalized type; when 3focalized appears in both premise and
conclusion, it means that they are either both focused or both unfocused:

(34) ∆〈
−→
Q 〉=⇒wA

foc
∆〈−→Q 〉=⇒wA

∆=⇒w P
foc

∆=⇒wP

Γ=⇒w P ∆〈
−→P 〉=⇒wC 3focalized

p-Cut1
∆〈Γ〉=⇒wC 3focalized

Γ=⇒wQ 3focalized ∆〈
−→
Q 〉=⇒wC

p-Cut2
∆〈Γ〉=⇒wC 3focalized

Γ=⇒wP 3focalized ∆〈
−→P 〉=⇒wC

n-Cut1
∆〈Γ〉=⇒wC 3focalized

Γ=⇒wQ ∆〈
−→Q 〉=⇒wC 3focalized

n-Cut2
∆〈Γ〉=⇒wC 3focalized

9 If it is convenient, we may drop the subscripts.

306



Morrill and Valentı́n Spurious Ambiguity and Focalization

With respect to bias assignment, consider the provable sequent n, n\s, s\q⇒ q. The
biases n ∈ At◦ and q, and s ∈ At• mean that we have the identity axioms n⇒ n ,
q ⇒ q, and s ⇒ s.

n⇒ n
∗

s , s\q⇒ q
\L

n, n\s , s\q⇒ q
foc

n, n\s, s\q⇒ q

n⇒ n s ⇒ s
\L

n, n\s ⇒ s
foc

n, n\s⇒ s q ⇒ q
\L

n, n\s, s\q ⇒ q
foc

n, n\s, s\q⇒ q

On the contrary, if we have the biases n, s ∈ At◦ and q ∈ At• we have the following
blocked derivation:

∗
n, n\s⇒ s q⇒ q

\L
n, n\s, s\q ⇒ q

foc
n, n\s, s\q⇒ q

Whereas we have:

n⇒ n

s⇒ s
q ⇒ q

foc
q⇒ q

\L
s, s\q ⇒ q

foc
s, s\q⇒ q

\L
n, n\s , s\q, ⇒ q

foc
n, n\s, s\q⇒ q

6.1 Embedding of DA into DAfoc

The identity axiom Id we consider for DA and for both DAfoc and DAFoc is restricted
to atomic types; recalling that atomic types are classified into irreversible bias At◦ and
reversible bias At•:

(35) If p ∈ At◦, p=⇒w p and p=⇒ p
If q ∈ At•, q =⇒wq and q =⇒q

307



Computational Linguistics Volume 44, Number 2

In fact, the identity axiom holds of any type A. The generalized case is called the
identity rule Id. It has the following formulation in the sequent calculi considered here:

(36)


−→A ⇒ A in DA
−→P =⇒w P

−→
Q =⇒wQ in DAfoc

−→P =⇒P −→Q=⇒Q in DAFoc

The identity rule Id, which applies not just to atomic types (like Id), but to all types
is easy to prove in both DA and DAfoc, but the same is not the case for DAFoc. This is
the reason to consider what we have called weak focalization, which helps us to prove
smoothly this crucial property for the proof of strong focalization.

Theorem 1 (Embedding of DA into DAfoc)
For any configuration ∆ and type A, we have that if ` ∆⇒ A then ` ∆=⇒wA.

Proof. We proceed by induction on the length of the derivation of DA proofs. In the
following lines, we apply the induction hypothesis (i.h.) for each premise of DA rules
(with the exception of the identity rule and the right rules of units):

− Identity axiom, where p and q denote, respectively, positive and negative
atoms:

−→p =⇒w p
foc−→p =⇒wp

−→
q =⇒wq

foc−→q =⇒wq

− Cut rule: just apply n-Cut.

− Units

IR
Λ⇒ I ;

IR
Λ=⇒w I

foc
Λ=⇒wI

JR
1⇒ J ;

JR
1=⇒w J

foc
1=⇒wJ

Left unit rules apply as in the case of DA.

− Left discontinuous product: Directly translates.

308



Morrill and Valentı́n Spurious Ambiguity and Focalization

− Right discontinuous product: There are cases P1�kP2, Q1�kQ2, Q�kP, and
P�kQ. We show one representative example:

∆⇒ P Γ⇒ Q
�kR

∆ |k Γ⇒ P�kQ
;

Γ=⇒wQ
∆=⇒wP

Id−→P =⇒w P

Id
−→Q =⇒wQ

foc−→Q=⇒wQ �kR−→P |k
−→Q ⇒ P�kQ

foc−→P |k
−→Q=⇒wP�kQ

n-Cut1
∆ |k
−→Q=⇒wP�kQ

n-Cut2
∆ |k Γ=⇒wP�kQ

− Left discontinuous ↑k rule (the left rule for ↓k is entirely similar): As in the
case for the right discontinuous product �k rule, we only show one
representative example:

Γ⇒ P ∆〈−→Q 〉 ⇒ A
↑kL

∆〈−−−→Q↑kP |k Γ〉 ⇒ A
;

Γ=⇒wP

Id−→P =⇒w P
Id−→

Q =⇒wQ ↑kL−−−−→
Q↑kP |k

−→P =⇒wQ
foc−−−→Q↑kP |k

−→P =⇒wQ ∆〈
−→Q 〉=⇒wA

n-Cut2
∆〈−−−→Q↑kP |k

−→P 〉=⇒wA
n-Cut1

∆〈−−−→Q↑kP |k Γ〉=⇒wA

− Right discontinuous ↑k rule (the right discontinuous rule for ↓k is entirely
similar):

∆ |k
−→A ⇒ B

↑kR
∆⇒ B↑kA

;
∆ |k
−→A =⇒wB ↑kR

∆=⇒wB↑kA

− Product and implicative continuous rules: These follow the same pattern
as the discontinuous case. We interchange the metalinguistic k-th
intercalation |k with the metasyntactic concatenation ’,’, and we
interchange �k, ↑k, and ↓k with •, /, and \, respectively.

309



Computational Linguistics Volume 44, Number 2

Concerning additives, conjunction right translates directly and we consider then
conjunction left (disjunction is symmetric):

∆〈−→P 〉 ⇒ C
&L1

∆〈−−→P&Q〉 ⇒ C
;

Id
P=⇒w P

foc
P=⇒wP

&L1−−−−→
P&Q =⇒wP

foc−−→P&Q=⇒wP ∆〈
−→P 〉=⇒wC

n-Cut1
∆〈−−→P&Q〉=⇒wC

where by Id and application of the foc rule, we have −−→P&Q=⇒wP. �

6.2 Embedding of DAfoc into DAFoc

Theorem 2
Let S be a DAFoc sequent. The following holds:

If DAfoc ` S then DAFoc ` S

Proof. We proceed by induction on the size of DAfoc-provable S sequents, namely on
|S|.10 Since DAfoc is Cut-free (see Appendix A) we consider Cut-free DAfoc proofs of S.

− Case |S| = 0. This corresponds to the axiom case, which is the same for
both calculi DAfoc and DAFoc —- see Equation (35).

− Suppose |S| > 0. Because |S| > 0, S does not correspond to an axiom.
Hence S is derivable with at least one logical rule. Otherwise, the size of S
would be equal to 0. The last rule ? can be either a logical rule or a foc rule
(keep in mind we are considering Cut-free DAfoc proofs!). We have two
cases:

a) If ? is logical, because S is supposed to belong to Seq(DAFoc), it follows
that its premises (possibly only one premise) belong also to Seq(DAFoc).
The premises have size strictly less than S. Therefore, we can safely apply
i.h., whence we conclude.

10 For a given type A, the size of A, |A|, is the number of connectives in A. By recursion on configurations
we have:

|Λ| ::= 0
|−→A , ∆| ::= |A|+ |∆|, for s(A) = 0
|1, ∆| ::= |∆|

|A{∆1 : · · · : ∆s(A)}| ::= |A|+
s(A)∑
i=1
|∆i|

Moreover, we have:

|∆〈
−−→
Q 〉=⇒wA| = |∆〈

−→Q 〉=⇒wA|

|∆=⇒w P | = |∆=⇒wP|

310



Morrill and Valentı́n Spurious Ambiguity and Focalization

b) Suppose ? is the foc rule, that is:

S ′
foc

S
Observe that |S ′| = |S|, because the size | · | function counts connectives, and not

boxes of focalized type-occurrences. Because |S ′| > 0, it follows that in the proof of S ′
there must be at least one logical rule. S ′ can have the following judgments:

S ′ foc ∧ ¬ rev
S ′ foc ∧ rev

We consider the two cases:

− S ′ foc ∧ ¬ rev. Because S is focalized and there is no reversible type
occurrence, the last rule of S ′ must correspond either to a multiplicative or
additive irreversible rule. The premises (possibly only one premise) have
size strictly less than S. We can then safely apply the induction hypothesis
(i.h.), which gives us DAFoc provable premises to which we can apply the ?
rule. Whence DAFoc ` S ′, and hence DAFoc ` S.

− S ′ foc ∧ rev.

The size of S ′ equals that of the end-sequent S, and moreover the premise is
foc ∧ rev, which does not belong to Seq(DAFoc). Clearly, we cannot apply i.h.. What

can we do?
Thanks to the flexibility of DAfoc we can overcome this difficulty. S ′ contains at least

one reversible formula. We see three cases that are illustrative of the situation:

(37) a) ∆〈−−−→A�kB〉=⇒w P
b) ∆〈

−→
Q 〉=⇒wB↑kA

c) ∆〈
−→
Q 〉=⇒wA&B

We consider these in turn:

a) We have by Id that −−−→A�kB=⇒w
−−−−→
A�kB . We apply to this sequent the

reversible �k left rule, whence
−→A |k
−→B =⇒w

−−−−→
A�kB . In case (37a), we have

the following proof in DAfoc:

(38)

−→A |k
−→B =⇒w

−−−−→
A�kB ∆〈

−−−→A�kB〉=⇒w P
p-Cut1

∆〈−→A |k
−→B 〉=⇒w P

foc
∆〈−→A |k

−→B 〉=⇒wP

To this DAfoc proof we apply Cut-elimination and we get the Cut-free
DAfoc end-sequent ∆〈

−→A |k
−→B 〉 =⇒wP. We have |∆〈

−→A |k
−→B 〉=⇒wP| <

|∆〈−−−→A�kB〉=⇒wP|. We can apply then i.h. and we derive the provable
DAFoc sequent ∆〈

−→A |k
−→B 〉=⇒P, to which we can apply the left �k rule. We

have obtained ∆〈−−−→A�kB〉=⇒P.

311



Computational Linguistics Volume 44, Number 2

b) In the same way, we have that
−−−−→
B↑kA |k

−→A =⇒wB. Thus, in case (37b), we
have the following proof in DAfoc:

(39)

∆〈
−→
Q 〉=⇒wB↑kA

−−−−→
B↑kA |k

−→A =⇒wB
p-Cut2

∆〈
−→
Q 〉 |k

−→A =⇒wB
foc

∆〈−→Q 〉 |k
−→A =⇒wB

As before, we apply Cut-elimination to the above proof. We get the
Cut-free DAfoc end-sequent ∆〈

−→Q 〉|k
−→A =⇒wB. It has size less than

|∆〈−→Q 〉=⇒wB↑kA|. We can apply i.h. and we obtain the DAFoc provable
sequent ∆〈−→Q 〉|k

−→A =⇒B, to which we apply the ↑k right rule.

c) We have

(40) ∆〈
−→
Q 〉=⇒wA&B

foc
∆〈−→Q 〉=⇒wA&B

by applying the foc rule and the invertibility of &R we obtain the provable
DAfoc sequents ∆〈

−→Q 〉=⇒wA and ∆〈
−→Q 〉=⇒wB. These sequents have

smaller size than ∆〈−→Q 〉=⇒wA&B. The aforementioned sequents have a
Cut-free proof in DAfoc. We apply i.h. and we obtain ∆〈

−→Q 〉=⇒A and
∆〈−→Q 〉=⇒B. We apply the & right rule in DAFoc, and we obtain
∆〈−→Q 〉=⇒A&B. �

Let ProvΣ(C) be the class of Σ sequents provable in calculus C.

Theorem 3
Strong focalization is complete.

Proof. Observe that in particular ProvSeq(DA)(DAFoc) = ProvSeq(DA)(DAfoc). Because,
by Theorem 1 ProvSeq(DA)(DAfoc) = Prov(DA), we have that ProvSeq(DA)(DAFoc) =
Prov(DA). �

7. Evaluation and Exemplification

CatLog version f1.2, CatLog1 (Morrill 2012), is a parser/theorem-prover using uni-
form proof and count-invariance for multiplicatives. CatLog version k2, CatLog3
(Morrill 2017), is a parser/theorem-prover using focusing, as expounded here, and
count-invariance for multiplicatives, additives, brackets, and exponentials (Kuznetsov,
Morrill, and Valentı́n 2017). To evaluate the performance of uniform proof and fo-
cusing, we created a system version clock3f1.2 made by substituting the theorem-
proving engine of CatLog1 into the theorem-proving environment of CatLog3 so that
count-invariance and other factors were kept constant while the uniform and focusing
theorem-proving engines were compared.

We performed the Montague test (Morrill and Valentı́n 2016) on the two systems,
that is, the task of providing a computational grammar of the Montague fragment.
In particular, we ran exhaustive parsing of the minicorpus given in Figure 13. The

312



Morrill and Valentı́n Spurious Ambiguity and Focalization

str(dwp(’(7-7)’), [b([john]), walks], s(f)).
str(dwp(’(7-16)’), [b([every, man]), talks], s(f)).
str(dwp(’(7-19)’), [b([the, fish]), walks], s(f)).
str(dwp(’(7-32)’), [b([every, man]), b([b([walks, or, talks])])], s(f)).
str(dwp(’(7-34)’), [b([b([b([every, man]), walks, or, b([every, man]), talks])])], s(f)).
str(dwp(’(7-39)’), [b([b([b([a, woman]), walks, and, b([she]), talks])])], s(f)).
str(dwp(’(7-43, 45)’), [b([john]), believes, that, b([a, fish]), walks], s(f)).
str(dwp(’(7-48, 49, 52)’), [b([every, man]), believes, that, b([a, fish]), walks], s(f)).
str(dwp(’(7-57)’), [b([every, fish, such, that, b([it]), walks]), talks], s(f)).
str(dwp(’(7-60, 62)’), [b([john]), seeks, a, unicorn], s(f)).
str(dwp(’(7-73)’), [b([john]), is, bill], s(f)).
str(dwp(’(7-76)’), [b([john]), is, a, man], s(f)).
str(dwp(’(7-83)’), [necessarily, b([john]), walks], s(f)).
str(dwp(’(7-86)’), [b([john]), walks, slowly], s(f)).
str(dwp(’(7-91)’), [b([john]), tries, to, walk], s(f)).
str(dwp(’(7-98)’), [b([john]), finds, a, unicorn], s(f)).
str(dwp(’(7-105)’), [b([every, man, such, that, b([he]), loves, a, woman]), loses, her], s(f)).
str(dwp(’(7-110)’), [b([john]), walks, in, a, park], s(f)).
str(dwp(’(7-116, 118)’), [b([every, man]), doesnt, walk], s(f)).

Figure 13
Montague test minicorpus for evaluation.

Montague lexicon was as in Figure 14. The tests were executed in XGP Prolog on a
MacBook Air. The running times in seconds for exhaustive parsing were as follows:

(41) clock3f1.2 (uniform) 36

k2 (focusing) 17

The tests for the minicorpus show that the focusing parsing/proof-search runs in half
the time of the uniform parsing/proof-search.

We could have also made comparison with proof net parsing/theorem proving
(Moot 2016), but our proposal includes additives for which proof nets are still an
open question, and not just the displacement calculus multiplicatives, and the point of
focalization is that it is a general methodology extendible to, for example, exponentials
and other modalities also, for which proof nets are also still under investigation. That
is, our focalization approach is scaleable in a way that proof nets currently are not, and
in this sense comparison with proof nets is not quite appropriate.

Here we illustrate propagation of focused types in derivations with output of
CatLog3. Note that in the derivations produced by CatLog the application of focusing
rules is hidden, and derivations can terminate at an unfocused identity axiom (which
is derivable by focusing and applying a focused identity axiom). Atomic types are
given a reversible bias uniformly. We give an example of quantificational ambiguity
involving discontinuous types, and examples of polymorphism of the copula including
coordination of unlike types involving additive types. The lexicon is as follows:

and : ((((Nt(s(A))\Sf )/(NB⊕(CNC/CNC)))\(Nt(s(A))\Sf ))\(((Nt(s(A))\Sf )/(NB⊕(CNC/CNC)))\
(Nt(s(A))\Sf )))/(((Nt(s(A))\Sf )/(NB⊕(CNC/CNC)))\(Nt(s(A))\Sf )) :
λDλEλFλG[((E F) G) ∧ ((D F) G)]
Cicero : Nt(s(m)) : c
everyone : (SA↑Nt(s(B)))↓SA : λC∀D[(person D)→ (C D)]
humanist : CNA/CNA : λBλC[(B C) ∧ (humanist C)]
is : (Nt(s(A))\Sf )/(NB⊕(CNC/CNC)) : λDλE(D→ F.[E = F]; G.((G λH[H = E]) E))
loves : (Nt(s(A))\Sf )/NB : love
someone : (SA↑Nt(s(B)))↓SA : λC∃D[(person D) ∧ (C D)]
Tully : Nt(s(m)) : t

313



Computational Linguistics Volume 44, Number 2

The (classical) quantification example is:

(foc(1)) everyone+loves+someone : Sf

For this lexical lookup yields:

(SA↑Nt(s(B)))↓SA : λC∀D[(person D)→ (C D)],
(Nt(s(E))\Sf )/NF : love, (SG↑Nt(s(H)))↓SG : λI∃J[(person J) ∧ (I J)] ⇒ Sf

a : �∀g(∀f ((Sf ↑�Nt(s(g)))↓Sf )/CNs(g)) : λAλB∃C[(A C) ∧ (B C)]
and : �∀f ((�?Sf\[]−1[]−1Sf )/�Sf ) : (Φn+ 0 and)
and : �∀a∀f ((�?(〈〉Na\Sf )\[]−1[]−1(〈〉Na\Sf ))/�(〈〉Na\Sf )) : (Φn+ (s 0) and)
believes : �((〈〉∃gNt(s(g))\Sf )/(CPthatt�Sf )) : ˆλAλB(Pres ((ˇbelieve A) B))
bill : �Nt(s(m)) : b
catch : �((〈〉∃aNa\Sb)/∃aNa) : ˆλAλB((ˇcatch A) B)
doesnt : �∀g∀a((Sg↑((〈〉Na\Sf )/(〈〉Na\Sb)))↓Sg) : λA¬(A λBλC(B C))
eat : �((〈〉∃aNa\Sb)/∃aNa) : ˆλAλB((ˇeat A) B)
every : �∀g(∀f ((Sf ↑Nt(s(g)))↓Sf )/CNs(g)) : λAλB∀C[(A C)→ (B C)]
finds : �((〈〉∃gNt(s(g))\Sf )/∃aNa) : ˆλAλB(Pres ((ˇfind A) B))
fish : �CNs(n) : fish
he : �[]−1∀g((�Sg|�Nt(s(m)))/(〈〉Nt(s(m))\Sg)) : λAA
her : �∀g∀a(((〈〉Na\Sg)↑�Nt(s(f )))↓(�(〈〉Na\Sg)|�Nt(s(f )))) : λAA
in : �(∀a∀f ((〈〉Na\Sf )\(〈〉Na\Sf ))/∃aNa) : ˆλAλBλC((ˇin A) (B C))
is : �((〈〉∃gNt(s(g))\Sf )/(∃aNa⊕(∃g((CNg/CNg)t(CNg\CNg))−I))) :
λAλB(Pres (A→ C.[B = C]; D.((D λE[E = B]) B)))
it : �∀f∀a(((〈〉Na\Sf )↑�Nt(s(n)))↓(�(〈〉Na\Sf )|�Nt(s(n)))) : λAA
it : �[]−1∀f ((�Sf |�Nt(s(n)))/(〈〉Nt(s(n))\Sf )) : λAA
john : �Nt(s(m)) : j
loses : �((〈〉∃gNt(s(g))\Sf )/∃aNa) : ˆλAλB(Pres ((ˇlose A) B))
loves : �((〈〉∃gNt(s(g))\Sf )/∃aNa) : ˆλAλB(Pres ((ˇlove A) B))
man : �CNs(m) : man
necessarily : �(SA/�SA) : Nec
or : �∀f ((�?Sf\[]−1[]−1Sf )/�Sf ) : (Φn+ 0 or)
or : �∀a∀f ((�?(〈〉Na\Sf )\[]−1[]−1(〈〉Na\Sf ))/�(〈〉Na\Sf )) : (Φn+ (s 0) or)
or : �∀f ((�?(Sf/(〈〉∃gNt(s(g))\Sf ))\[]−1[]−1(Sf/(〈〉∃gNt(s(g))\Sf )))/�(Sf/(〈〉∃gNt(s(g))\Sf ))) :
(Φn+ (s 0) or)
park : �CNs(n) : park
seeks : �((〈〉∃gNt(s(g))\Sf )/�∀a∀f (((Na\Sf )/∃bNb)\(Na\Sf ))) :
ˆλAλB((ˇtries ˆ((ˇA ˇfind) B)) B)
she : �[]−1∀g((�Sg|�Nt(s(f )))/(〈〉Nt(s(f ))\Sg)) : λAA
slowly : �∀a∀f (�(〈〉Na\Sf )\(〈〉�Na\Sf )) : ˆλAλB(ˇslowly ˆ(ˇA ˇB))
such+that : �∀n((CNn\CNn)/(Sf |�Nt(n))) : λAλBλC[(B C) ∧ (A C)]
talks : �(〈〉∃gNt(s(g))\Sf ) : ˆλA(Pres (ˇtalk A))
that : �(CPthat/�Sf ) : λAA
the : �∀n(Nt(n)/CNn) : ι
to : �((PPto/∃aNa)u∀n((〈〉Nn\Si)/(〈〉Nn\Sb))) : λAA
tries : �((〈〉∃gNt(s(g))\Sf )/�(〈〉∃gNt(s(g))\Si)) : ˆλAλB((ˇtries ˆ(ˇA B)) B)
unicorn : �CNs(n) : unicorn
walk : �(〈〉∃aNa\Sb) : ˆλA(ˇwalk A)
walks : �(〈〉∃gNt(s(g))\Sf ) : ˆλA(Pres (ˇwalk A))
woman : �CNs(f ) : woman

Figure 14
Montague Test lexicon.

314



Morrill and Valentı́n Spurious Ambiguity and Focalization

There is the wide-scope object derivation:

Nt(s(A)) ⇒ Nt(s(A))
Nt(s(A)) ⇒ Nt(s(A)) Sf ⇒ Sf

\L
Nt(s(A)), Nt(s(A))\Sf ⇒ Sf

/L
Nt(s(A)), (Nt(s(A))\Sf )/Nt(s(B)) , Nt(s(B)) ⇒ Sf

↑R
1, (Nt(s(A))\Sf )/Nt(s(B)), Nt(s(B)) ⇒ Sf ↑Nt(s(A)) Sf ⇒ Sf

↓L
(Sf ↑Nt(s(A)))↓Sf , (Nt(s(A))\Sf )/Nt(s(B)), Nt(s(B)) ⇒ Sf

↑R
(Sf ↑Nt(s(A)))↓Sf, (Nt(s(A))\Sf )/Nt(s(B)), 1 ⇒ Sf ↑Nt(s(B)) Sf ⇒ Sf

↓L
(Sf ↑Nt(s(A)))↓Sf, (Nt(s(A))\Sf )/Nt(s(B)), (Sf ↑Nt(s(B)))↓Sf ⇒ Sf

∃B[(person B) ∧ ∀E[(person E)→ ((love B) E)]]

And the wide-scope subject derivation:

Nt(s(A)) ⇒ Nt(s(A))
Nt(s(A)) ⇒ Nt(s(A)) Sf ⇒ Sf

\L
Nt(s(A)), Nt(s(A))\Sf ⇒ Sf

/L
Nt(s(A)), (Nt(s(A))\Sf )/Nt(s(B)) , Nt(s(B)) ⇒ Sf

↑R
Nt(s(A)), (Nt(s(A))\Sf )/Nt(s(B)), 1 ⇒ Sf ↑Nt(s(B)) Sf ⇒ Sf

↓L
Nt(s(A)), (Nt(s(A))\Sf )/Nt(s(B)), (Sf ↑Nt(s(B)))↓Sf ⇒ Sf

↑R
1, (Nt(s(A))\Sf )/Nt(s(B)), (Sf ↑Nt(s(B)))↓Sf ⇒ Sf ↑Nt(s(A)) Sf ⇒ Sf

↓L
(Sf ↑Nt(s(A)))↓Sf , (Nt(s(A))\Sf )/Nt(s(B)), (Sf ↑Nt(s(B)))↓Sf ⇒ Sf

∀B[(person B)→ ∃E[(person E) ∧ ((love E) B)]]

The weak polymorphism of the copula with respect to nominal and adjectival comple-
ments is illustrated as follows.

(foc(2)) Tully+is+Cicero : Sf

Nt(s(m)) : t, (Nt(s(A))\Sf )/(NB⊕(CNC/CNC)) : λDλE(D→ F.[E =
F]; G.((G λH[H = E]) E)), Nt(s(m)) : c ⇒ Sf

Nt(s(m)) ⇒ Nt(s(m))
⊕R

Nt(s(m)) ⇒ Nt(s(m))⊕(CNA/CNA)
Nt(s(m)) ⇒ Nt(s(m)) Sf ⇒ Sf

\L
Nt(s(m)), Nt(s(m))\Sf ⇒ Sf

/L
Nt(s(m)), (Nt(s(m))\Sf )/(Nt(s(m))⊕(CNA/CNA)) , Nt(s(m)) ⇒ Sf

315



Computational Linguistics Volume 44, Number 2

[t = c]

(foc(3)) Tully+is+humanist : Sf

Nt(s(m)) : t, (Nt(s(A))\Sf )/(NB⊕(CNC/CNC)) : λDλE(D→ F.[E =
F]; G.((G λH[H = E]) E)), CNI/CNI : λJλK[(J K) ∧ (humanist K)] ⇒ Sf

CNA ⇒ CNA CNA ⇒ CNA
/L

CNA/CNA , CNA ⇒ CNA
/R

CNA/CNA ⇒ CNA/CNA
⊕R

CNA/CNA ⇒ NB⊕(CNA/CNA)
Nt(s(m)) ⇒ Nt(s(m)) Sf ⇒ Sf

\L
Nt(s(m)), Nt(s(m))\Sf ⇒ Sf

/L
Nt(s(m)), (Nt(s(m))\Sf )/(NA⊕(CNB/CNB)) , CNB/CNB ⇒ Sf

(humanist t)

Finally, the presence of such polymorphism in the coordination of unlike types (Bayer
1996; Morrill 1990) is illustrated by the following; the derivation is fragmented in two
parts in Figure 15.

(foc(4)) Tully+is+Cicero+and+humanist : Sf

Nt(s(m)) : t, (Nt(s(A))\Sf )/(NB⊕(CNC/CNC)) : λDλE(D→ F.[E =
F]; G.((G λH[H = E]) E)), Nt(s(m)) : c, ((((Nt(s(I))\Sf )/(NJ⊕(CNK/CNK)))\
(Nt(s(I))\Sf ))\(((Nt(s(I))\Sf )/(NJ⊕(CNK/CNK)))\(Nt(s(I))\Sf )))/
(((Nt(s(I))\Sf )/(NJ⊕(CNK/CNK)))\(Nt(s(I))\Sf )) : λLλMλNλO[((M N) O)∧
((L N) O)], CNP/CNP : λQλR[(Q R) ∧ (humanist R)] ⇒ Sf

[[t = c] ∧ (humanist t)]

8. Conclusion

We have claimed that just as the parse structures of context free grammar are ordered
trees, the parse structures of categorial grammar are proof nets. Thus, just as we think of
context free algorithms as finding ordered trees, bottom–up, top–down, and so forth, we
can think of categorial algorithms as finding proof nets. The complication is that proof
nets are much more sublime objects than ordered trees: They embody not only syntactic
coherence but also semantic coherence. Focalization is a step on the way to eliminating
spurious ambiguity by building such proof nets systematically. A further step on the
way, eliminating all spurious ambiguity, would be multifocusing. This remains a topic
for future study. Another topic for further study in focusing is the question of which
assignments of bias are favorable for the processing of given lexica/corpora.

Alternatively, for context free grammar one can perform chart parsing, or tabular-
ization, and at least for the basic case of Lambek calculus suitable notions of proof net
also support tabularization (Morrill 1996; de Groote 1999; Pentus 2010; Kanovich et al.
2017). This also remains a topic for future study.

For the time being, however, we hope to have motivated the relevance of focaliza-
tion to categorial parsing as deduction in relation to the DA categorial logic fragment,
which leads naturally to the program of focalization of extensions of this fragment with
connectives such as exponentials.

316



Morrill and Valentı́n Spurious Ambiguity and Focalization

N
t(s(m

))
⇒

N
t(s(m

))
⊕

R
N

t(s(m
))
⇒

N
t(s(m

))⊕
(C

N
A
/C

N
A

)

N
t(s(m

))
⇒

N
t(s(m

))
Sf
⇒

Sf
\L

N
t(s(m

)),
N

t(s(m
))\Sf

⇒
Sf
/L

N
t(s(m

)),
(N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

))
,N

t(s(m
))
⇒

Sf

C
N

A
⇒

C
N

A
C

N
A
⇒

C
N

A
/L

C
N

A
/C

N
A

,C
N

A
⇒

C
N

A
/R

C
N

A
/C

N
A
⇒

C
N

A
/C

N
A

⊕
R

C
N

A
/C

N
A
⇒

N
t(s(m

))⊕
(C

N
A
/C

N
A

)

N
t(s(m

))
⇒

N
t(s(m

))
Sf
⇒

Sf
\L

N
t(s(m

)),
N

t(s(m
))\Sf

⇒
Sf
/L

N
t(s(m

)),
(N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

))
,C

N
A
/C

N
A
⇒

Sf
⊕

L
N

t(s(m
)),(N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

)),N
t(s(m

))⊕
(C

N
A
/C

N
A

)
⇒

Sf
\R

(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)),N
t(s(m

))⊕
(C

N
A
/C

N
A

)
⇒

N
t(s(m

))\Sf
/R

(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

))
⇒

(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

))
1©

C
N

A
⇒

C
N

A
C

N
A
⇒

C
N

A
/L

C
N

A
/C

N
A

,C
N

A
⇒

C
N

A
/R

C
N

A
/C

N
A
⇒

C
N

A
/C

N
A

⊕
R

C
N

A
/C

N
A
⇒

N
t(s(m

))⊕
(C

N
A
/C

N
A

)

N
t(s(m

))
⇒

N
t(s(m

))
Sf
⇒

Sf
\L

N
t(s(m

)),
N

t(s(m
))\Sf

⇒
Sf
/L

N
t(s(m

)),
(N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

))
,C

N
A
/C

N
A
⇒

Sf
\R

(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)),C
N

A
/C

N
A
⇒

N
t(s(m

))\Sf
\R

C
N

A
/C

N
A
⇒

((N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)))\(N
t(s(m

))\Sf)

N
t(s(m

))
⇒

N
t(s(m

))
⊕

R
N

t(s(m
))
⇒

N
t(s(m

))⊕
(C

N
A
/C

N
A

)

N
t(s(m

))
⇒

N
t(s(m

))
Sf
⇒

Sf
\L

N
t(s(m

)),
N

t(s(m
))\Sf

⇒
Sf
/L

N
t(s(m

)),
(N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

))
,N

t(s(m
))
⇒

Sf
\R

(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)),N
t(s(m

))
⇒

N
t(s(m

))\Sf
\R

N
t(s(m

))
⇒

((N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)))\(N
t(s(m

))\Sf)

1©

N
t(s(m

))
⇒

N
t(s(m

))
Sf
⇒

Sf
\L

N
t(s(m

)),
N

t(s(m
))\Sf

⇒
Sf

\L
N

t(s(m
)),(N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

)),
((N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

)))\(N
t(s(m

))\Sf)
⇒

Sf
\L

N
t(s(m

)),(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)),N
t(s(m

)),
(((N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

)))\(N
t(s(m

))\Sf))\(((N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)))\(N
t(s(m

))\Sf))
⇒

Sf
/L

N
t(s(m

)),(N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)),N
t(s(m

)),
((((N

t(s(m
))\Sf)/(N

t(s(m
))⊕

(C
N

A
/C

N
A

)))\(N
t(s(m

))\Sf))\(((N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)))\(N
t(s(m

))\Sf)))/(((N
t(s(m

))\Sf)/(N
t(s(m

))⊕
(C

N
A
/C

N
A

)))\(N
t(s(m

))\Sf))
,C

N
A
/C

N
A
⇒

Sf

Figure 15
Coordination of unlike types.

317



Computational Linguistics Volume 44, Number 2

Appendix A. Cut Elimination in DAfoc

We prove this by induction on the complexity (d, h) of topmost instances of Cut, where
d is the size11 of the cut formula and h is the length of the Cut-free derivation above
the Cut rule. There are four cases to consider: Cut with axiom in the minor premise,
Cut with axiom in the major premise, principal Cuts, and permutation conversions. In
each case, the complexity of the Cut is reduced. In order to save space, we will not be
exhaustively showing all the cases because many follow the same pattern. In particular,
for any irreversible logical rule there are always four cases to consider corresponding to
the polarity of the subformulas. In the following, we will show only one representative
example. Concerning continuous and discontinuous formulas, we will show only the
discontinuous cases (discontinuous connectives are less well-known than the continu-
ous ones of the plain Lambek calculus). For the continuous instances, the reader has
only to interchange the meta-linguistic wrap |k with the meta-syntactic concatenation
′,′, �k with •, ↑k with / and ↓k with \. The units cases (principal case and permutation
conversion cases) are completely trivial.

Proof. Identity cases.

−→P =⇒w P ∆〈
−→P 〉=⇒wB3focalized

p-Cut1
∆〈−→P 〉=⇒wB3focalized

; ∆〈−→P 〉=⇒wB3focalized

∆=⇒wQ3focalized
−→
Q =⇒wQ

p-Cut2
∆〈−→Q 〉=⇒wB3focalized

; ∆〈−→Q 〉=⇒wB3focalized

Principal cases:

• foc cases:
∆=⇒w P

foc
∆=⇒wP Γ〈

−→P 〉=⇒wA3focalized
n-Cut1

Γ〈∆〉=⇒wA3focalized

;

∆=⇒w P Γ〈
−→P 〉=⇒wA3focalized

p-Cut1
Γ〈∆〉=⇒wA3focalized

∆=⇒wQ
∆〈 −→Q 〉=⇒wA

foc
Γ〈−→Q 〉=⇒wA

n-Cut2
Γ〈∆〉=⇒wA

;
∆=⇒wQ Γ〈

−→Q 〉=⇒wA
p-Cut2

Γ〈∆〉=⇒wA

• logical connectives:

∆|k
−→P1=⇒wP23focalized ↑kR

∆=⇒wP2↑kP13focalized

Γ1=⇒w P1 Γ2〈
−→P2〉=⇒wA ↑kL

Γ2〈
−−−−−→
P2↑kP1 |kΓ1〉=⇒wA

p-Cut2
Γ2〈∆|kΓ1〉=⇒wA3focalized

;

11 The size of |A| is the number of connectives appearing in A.

318



Morrill and Valentı́n Spurious Ambiguity and Focalization

Γ1=⇒w P1

∆|k
−→P1=⇒wP23focalized Γ2〈

−→P2〉=⇒wA
n-Cut1

Γ2〈∆|k
−→P1〉=⇒wA3focalized

p-Cut1
Γ2〈∆|kΓ1〉=⇒wA3focalized

The case of ↓k is entirely similar to the ↑k case.

∆1=⇒w P ∆2=⇒wQ �kR
∆1|k∆2=⇒w P�kQ

Γ〈−→P |k
−→Q 〉=⇒wA3focalized �kL

Γ〈−−−→P�kQ〉=⇒wA3focalized
p-Cut1

Γ〈∆1|k∆2〉=⇒wA3focalized

;

∆2=⇒wQ
∆1=⇒w P Γ〈

−→P |k
−→Q 〉=⇒wA3focalized

p-Cut1
Γ〈∆1|k

−→Q 〉=⇒wA3focalized
n-Cut2

Γ〈∆1|k∆2〉=⇒wA3focalized

∆=⇒wQ3focalized ∆=⇒wP3focalized
&R

∆=⇒wQ&P3focalized

Γ〈
−→
Q 〉=⇒wB

&L
Γ〈
−−−−→
Q&P =⇒wB

p-Cut2
Γ〈∆〉=⇒wB3focalized

;

∆=⇒wQ3focalized Γ〈
−→
Q 〉=⇒wB

p-Cut2
Γ〈∆〉=⇒wB3focalized

∆=⇒wP3focalized ∆=⇒wQ3focalized
&R

∆=⇒wP&Q3focalized

Γ〈−→P 〉=⇒wB
&L

Γ〈
−−−−→
P&Q 〉=⇒wB

p-Cut2
Γ〈∆〉=⇒wB3focalized

;

∆=⇒wP3focalized Γ〈
−→P 〉=⇒wB

n-Cut1
Γ〈∆〉=⇒wB3focalized

Left commutative p-Cut conversions:

∆〈
−→
Q 〉=⇒wQ2

foc
∆〈−→Q 〉=⇒wQ2 Γ〈

−−→
Q2 〉=⇒wC

p-Cut2
Γ〈∆〈−→Q 〉〉=⇒wC

;

∆〈
−→
Q 〉=⇒wQ2 Γ〈

−−→
Q2 〉=⇒wC

p-Cut2
Γ〈∆〈

−→
Q 〉〉=⇒wC

foc
Γ〈∆〈−→Q 〉〉=⇒wC

319



Computational Linguistics Volume 44, Number 2

∆〈−→A |k
−→B 〉=⇒w P �kL

∆〈−−−→A�kB〉=⇒w P Γ〈
−→P 〉=⇒wC3focalized

p-Cut1
Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

;

∆〈−→A |k
−→B 〉=⇒w P Γ〈

−→P 〉=⇒wC3focalized
p-Cut1

Γ〈∆〈−→A |k
−→B 〉〉=⇒wC3focalized �kL

Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

∆〈−→A |k
−→B 〉=⇒wQ3focalized �kL

∆〈−−−→A�kB〉=⇒wQ3focalized Γ〈
−→Q 〉=⇒wC

p-Cut2
Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

;

∆〈−→A |k
−→B 〉=⇒wQ3focalized Γ〈

−→Q 〉=⇒wC
p-Cut2

Γ〈∆〈−→A |k
−→B 〉〉=⇒wC3focalized �kL

Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

Γ1=⇒w P Γ2〈
−→
Q 〉=⇒wQ2 ↑kL

Γ2〈
−−−−→
Q↑kP |kΓ1〉=⇒wQ2 Θ〈

−−→
Q2 〉=⇒wC

p-Cut2
Θ〈Γ2〈

−−−−→
Q↑kP |kΓ1〉〉=⇒wC

;

Γ1=⇒w P

Γ1〈
−→
Q 〉=⇒wQ2 Θ〈

−−→
Q2 〉=⇒wC

p-Cut2
Θ〈Γ2〈

−→
Q 〉〉=⇒wC ↑kL

Θ〈Γ2〈
−−−−→
Q↑kP |kΓ1〉〉=⇒wC

Γ〈−→A 〉=⇒w P Γ〈
−→B 〉=⇒w P ⊕L

Γ〈−−→A⊕B〉=⇒w P ∆〈
−→P 〉=⇒wC3focalized

p-Cut1
∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

;

Γ〈−→A 〉=⇒w P ∆〈
−→P 〉=⇒wC3focalized

p-Cut1
∆〈Γ〈−→A 〉〉=⇒wC3focalized

Γ〈−→B 〉=⇒w P ∆〈
−→P 〉=⇒wC3focalized

p-Cut1
∆〈Γ〈−→B 〉〉=⇒wC3focalized

⊕L
∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

Γ〈−→A 〉=⇒wQ3focalized Γ〈
−→B 〉=⇒wQ3focalized ⊕L

Γ〈−−→A⊕B〉=⇒wQ3focalized ∆〈
−→Q 〉=⇒wC

p-Cut2
∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

;

Γ〈−→A 〉=⇒wQ3focalized ∆〈
−→Q 〉=⇒wC

p-Cut2
∆〈Γ〈−→A 〉〉=⇒wC3focalized

Γ〈−→B 〉=⇒wQ3focalized ∆〈
−→Q 〉=⇒wC

p-Cut2
∆〈Γ〈−→B 〉〉=⇒wC3focalized

⊕L
∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

320



Morrill and Valentı́n Spurious Ambiguity and Focalization

Right commutative p-Cut conversions (unordered multiple distinguished occurrences
are separated by semicolons):

∆=⇒w P
Γ〈−→P ;

−→
Q 〉=⇒wC

foc
Γ〈−→P ;−→Q 〉=⇒wC

p-Cut1
Γ〈∆;−→Q 〉=⇒wC

;

∆=⇒w P Γ〈
−→P ;
−→
Q 〉=⇒wC

p-Cut1
Γ〈∆;

−→
Q 〉=⇒wC

foc
Γ〈∆;−→Q 〉=⇒wC

∆=⇒w P1

Γ〈−→P1〉=⇒w P2
foc

Γ〈−→P1〉=⇒wP2
p-Cut1

Γ〈∆〉=⇒wP2

;

∆=⇒w P1 Γ〈
−→P1〉=⇒w P2

p-Cut1
Γ〈∆〉=⇒w P2

foc
Γ〈∆〉=⇒wP2

∆=⇒w P
Γ〈−→P 〉|k

−→A =⇒wB3focalized ↑kR
Γ〈−→P 〉=⇒wB↑kA3focalized

p-Cut1
Γ〈∆〉=⇒wB↑kA3focalized

;

∆=⇒w P Γ〈
−→P 〉|k

−→A =⇒wB3focalized
p-Cut1

Γ〈∆〉|k
−→A =⇒wB3focalized ↑kR

Γ〈∆〉=⇒wB↑kA3focalized

∆=⇒wQ3focalized

Γ〈 −→Q 〉|k
−→A =⇒wB ↑kR

Γ〈 −→Q 〉=⇒wB↑kA
p-Cut2

Γ〈∆〉=⇒wB↑kA3focalized

;

∆=⇒wQ3focalized Γ〈
−→Q 〉|k

−→A =⇒wB
p-Cut2

Γ〈∆〉|k
−→A =⇒wB3focalized ↑kR

Γ〈∆〉=⇒wB↑kA3focalized

∆=⇒w P
Γ〈−→P ;−→A |k

−→B 〉=⇒wC3focalized �kL
Γ〈−→P ;−−−→A�kB〉=⇒wC3focalized

p-Cut1
Γ〈∆;−−−→A�kB〉=⇒wC3focalized

;

∆=⇒w P Γ〈
−→P ;−→A |k

−→B 〉=⇒wC3focalized
p-Cut1

Γ〈∆;−→A |k
−→B 〉=⇒wC3focalized �kL

Γ〈∆;−−−→A�kB〉=⇒wC3focalized

∆=⇒wQ3focalized

Γ〈
−→
Q ;−→A |k

−→B 〉=⇒wC �kL
Γ〈
−→
Q ;−−−→A�kB〉=⇒wC

p-Cut2
Γ〈∆;−−−→A�kB〉=⇒wC3focalized

;

321



Computational Linguistics Volume 44, Number 2

∆=⇒wQ3focalized Γ〈
−→
Q ;−→A |k

−→B 〉=⇒wC
p-Cut2

Γ〈∆;−→A |k
−→B 〉=⇒wC3focalized �kL

Γ〈∆;−−−→A�kB〉=⇒wC3focalized

∆=⇒w P

Γ=⇒w P1 Θ〈
−→P2;
−→P 〉=⇒wC ↑kL

Θ〈
−−−−−→
P2↑kP1 |kΓ;

−→P 〉=⇒wC
p-Cut1

Θ〈
−−−−−→
P2↑kP1 |kΓ; ∆〉=⇒wC

;

Γ=⇒w P1

∆=⇒w P Θ〈
−→P2;
−→P 〉=⇒wC

p-Cut1
Θ〈−→P2; ∆〉=⇒wC ↑kL

Θ〈
−−−−−→
P2↑kP1 |kΓ; ∆〉=⇒wC

∆=⇒w P
Γ〈−→P 〉=⇒wA3focalized Γ〈

−→P 〉=⇒wB3focalized
&R

Γ〈−→P 〉=⇒wA&B3focalized
p-Cut1

Γ〈∆〉=⇒wA&B3focalized

;

∆=⇒w P Γ〈
−→P 〉=⇒wA3focalized

p-Cut1
Γ〈∆〉=⇒wA3focalized

∆=⇒w P Γ〈
−→P 〉=⇒wB3focalized

p-Cut1
Γ〈∆〉=⇒wB3focalized

&R
Γ〈∆〉=⇒wA&B3focalized

∆=⇒wQ3focalized

Γ〈 −→Q 〉=⇒wA Γ〈
−→Q 〉=⇒wB

&R
Γ〈 −→Q 〉=⇒wA&B

p-Cut2
Γ〈∆〉=⇒wA&B3focalized

;

∆=⇒wQ3focalized Γ〈
−→Q 〉=⇒wA

p-Cut2
Γ〈∆〉=⇒wA3focalized

∆=⇒wQ3focalized Γ〈
−→Q 〉=⇒wB

p-Cut2
Γ〈∆〉=⇒wB3focalized &R

Γ〈∆〉=⇒wA&B3focalized

Left commutative n-Cut conversions:

∆〈
−→
Q 〉=⇒wP

foc
∆〈−→Q 〉=⇒wP Γ〈

−→P 〉=⇒wC
n-Cut1

Γ〈∆〈−→Q 〉〉=⇒wC

;

∆
−→
Q =⇒wP Γ〈

−→P 〉=⇒wC
n-Cut1

Γ〈∆〈
−→
Q 〉〉=⇒wC

foc
Γ〈∆〈−→Q 〉〉=⇒wC

∆〈−→A |k
−→B 〉=⇒wP3focalized �kL

∆〈−−−→A�kB〉=⇒wP3focalized Γ〈
−→P 〉=⇒wC

n-Cut1
Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

;

322



Morrill and Valentı́n Spurious Ambiguity and Focalization

∆〈−→A |k
−→B 〉=⇒wP3focalized Γ〈

−→P 〉=⇒wC
n-Cut1

Γ〈∆〈−→A |k
−→B 〉〉=⇒wC3focalized �kL

Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

∆〈−→A |k
−→B 〉=⇒wQ �kL

∆〈−−−→A�kB〉=⇒wQ Γ〈
−→Q 〉=⇒wC3focalized

n-Cut2
Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

;

∆〈−→A |k
−→B 〉=⇒wQ Γ〈

−→Q 〉=⇒wC3focalized
n-Cut2

Γ〈∆〈−→A |k
−→B 〉〉=⇒wC3focalized �kL

Γ〈∆〈−−−→A�kB〉〉=⇒wC3focalized

Γ1=⇒w P1 Γ2〈
−−→
Q1 〉=⇒wP ↑kL

Γ2〈
−−−−−→
Q1↑kP1 |kΓ1〉=⇒wP Θ〈

−→P 〉=⇒wC
n-Cut1

Θ〈Γ2〈
−−−−−→
Q1↑kP1 |kΓ1〉〉=⇒wC

;

Γ1=⇒w P1

Γ2〈
−−→
Q1 〉=⇒wP Θ〈

−→P 〉=⇒wC
n-Cut1

Θ〈Γ2〈
−−→
Q1 〉〉=⇒wC ↑kL

Θ〈Γ2〈
−−−−−→
Q1↑kP1 |kΓ1〉〉=⇒wC

Γ〈−→A 〉=⇒wP3focalized Γ〈
−→B 〉=⇒wP3focalized

⊕L
Γ〈−−→A⊕B〉=⇒wP3focalized ∆〈

−→P 〉=⇒wC3focalized
n-Cut1

∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

;

Γ〈−→A 〉=⇒wP3focalized ∆〈
−→P 〉=⇒wC

n-Cut1
∆〈Γ〈−→A 〉〉=⇒wC3focalized

Γ〈−→B 〉=⇒wP3focalized ∆〈
−→P 〉=⇒wC

n-Cut1
∆〈Γ〈−→B 〉〉=⇒wC3focalized

⊕L
∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

Γ〈−→A 〉=⇒wQ Γ〈
−→B 〉=⇒wQ

⊕L
Γ〈−−→A⊕B〉=⇒wQ ∆〈

−→Q 〉=⇒wC3focalized
n-Cut2

∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

;

Γ〈−→A 〉=⇒wQ ∆〈
−→Q 〉=⇒wC3focalized

n-Cut2
∆〈Γ〈−→A 〉〉=⇒wC3focalized

Γ〈−→B 〉=⇒wQ ∆〈
−→Q 〉=⇒wC3focalized

n-Cut2
∆〈Γ〈−→B 〉〉=⇒wC3focalized

⊕L
∆〈Γ〈−−→A⊕B〉〉=⇒wC3focalized

323



Computational Linguistics Volume 44, Number 2

Right commutative n-Cut conversions:

∆=⇒wQ
Γ〈−→Q ;

−−→
Q2 〉=⇒wC

foc
Γ〈−→Q ;−→Q2〉=⇒wC

n-Cut2
Γ〈∆;−→Q2〉=⇒wC

;

∆=⇒wQ Γ〈
−→Q ;
−−→
Q2 〉=⇒wC

n-Cut2
Γ〈∆;

−−→
Q2 〉=⇒wC

foc
Γ〈∆;−→Q2〉=⇒wC

∆=⇒wQ
Γ〈−→Q 〉=⇒w P

foc
Γ〈−→Q 〉=⇒wP

n-Cut2
Γ〈∆〉=⇒wP

;

∆=⇒wQ Γ〈
−→Q 〉=⇒w P

n-Cut2
Γ〈∆〉=⇒w P

foc
Γ〈∆〉=⇒wP

∆=⇒wP3focalized
Γ〈−→P 〉|k

−→A =⇒wB ↑kR
Γ〈−→P 〉=⇒wB↑kA

n-Cut1
Γ〈∆〉=⇒wB↑kA3focalized

;

∆=⇒wP3focalized Γ〈
−→P 〉|k

−→A =⇒wB
n-Cut1

Γ〈∆〉|k
−→A =⇒wB3focalized ↑kR

Γ〈∆〉=⇒wB↑kA3focalized

∆=⇒wQ
Γ〈−→Q 〉|k

−→A =⇒wB3focalized ↑kR
Γ〈−→Q 〉=⇒wB↑kA3focalized

n-Cut2
Γ〈∆〉=⇒wB↑kA3focalized

;

∆=⇒wQ Γ〈
−→Q 〉|k

−→A =⇒wB3focalized
n-Cut2

Γ〈∆〉|k
−→A =⇒wB3focalized ↑kR

Γ〈∆〉=⇒wB↑kA3focalized

∆=⇒wP3focalized
Γ〈−→P ;−→A |k

−→B 〉=⇒wC �kL
Γ〈−→P ;−−−→A�kB〉=⇒wC

n-Cut1
Γ〈∆;−−−→A�kB〉=⇒wC3focalized

;

∆=⇒wP3focalized Γ〈
−→P ;−→A |k

−→B 〉=⇒wC
n-Cut1

Γ〈∆;−→A |k
−→B 〉=⇒wC3focalized �kL

Γ〈∆;−−−→A�kB〉=⇒wC3focalized

∆=⇒wQ
Γ〈−→Q ;−→A |k

−→B 〉=⇒wC3focalized �kL
Γ〈−→Q ;−−−→A�kB〉=⇒wC3focalized

n-Cut2
Γ〈∆;−−−→A�kB〉=⇒wC3focalized

;

324



Morrill and Valentı́n Spurious Ambiguity and Focalization

∆=⇒wQ Γ〈
−→Q ;−→A |k

−→B 〉=⇒wC3focalized
n-Cut2

Γ〈∆;−→A |k
−→B 〉=⇒wC3focalized �kL

Γ〈∆;−−−→A�kB〉=⇒wC3focalized

∆=⇒wQ

Γ=⇒w P1 Θ〈
−→P2;
−→Q 〉=⇒wC ↑kL

Θ〈
−−−−−→
P2↑kP1 |kΓ;

−→Q 〉=⇒wC
n-Cut2

Θ〈
−−−−−→
P2↑kP1 |kΓ; ∆〉=⇒wC

;

Γ=⇒w P1

∆=⇒wQ Θ〈
−→P2;
−→Q 〉=⇒wC

n-Cut2
Θ〈−→P2; ∆〉=⇒wC ↑kL

Θ〈
−−−−−→
P2↑kP1 |kΓ; ∆〉=⇒wC

∆=⇒wP3focalized
Γ〈−→P 〉=⇒wA Γ〈

−→P 〉=⇒wB
&R

Γ〈−→P 〉=⇒wA&B
n-Cut1

Γ〈∆〉=⇒wA&B3focalized

;

∆=⇒wP3focalized Γ〈
−→P 〉=⇒wA

n-Cut1
Γ〈∆〉=⇒wA3focalized

∆=⇒wP3focalized Γ〈
−→P 〉=⇒wB

n-Cut1
Γ〈∆〉=⇒wB3focalized &R

Γ〈∆〉=⇒wA&B3focalized

∆=⇒wQ
Γ〈−→Q 〉=⇒wA3focalized Γ〈

−→Q 〉=⇒wB3focalized
&R

Γ〈−→Q 〉=⇒wA&B3focalized
n-Cut2

Γ〈∆〉=⇒wA&B3focalized

;

∆=⇒wQ Γ〈
−→Q 〉=⇒wA3focalized

n-Cut2
Γ〈∆〉=⇒wA3focalized

∆=⇒wQ Γ〈
−→Q 〉=⇒wB3focalized

n-Cut2
Γ〈∆〉=⇒wB3focalized &R

Γ〈∆〉=⇒wA&B3focalized

This completes the proof. �

Acknowledgments
We thank anonymous Computational
Linguistics referees for comments and
suggestions that have improved this article.
This research was supported by grant
TIN2017-89244-R from MINECO (Ministerio
de Economia, Industria y Competitividad).

References
Abrusci, Vito Michele and Roberto Maieli.

2016. Cyclic multiplicative-additive proof
nets of linear logic with an application
to language parsing. In Proceedings of

Formal Grammar: 20th and 21st International
Conferences, FG 2015, pages 43–59, Bozen.

Andreoli, J. M. 1992. Logic programming
with focusing in linear logic. Journal of
Logic and Computation, 2(3):297–347.

Bar-Hillel, Y., C. Gaifman, and E. Shamir.
1960. On categorial and phrase structure
grammars. Bulletin of the Research Council
of Israel, 9F:1–16.

Bayer, Samuel. 1996. The coordination of
unlike categories. Language, 72(3):579–616.

Chaudhuri, Kaustuv. 2006. The Focused
Inverse Method for Linear Logic. Ph.D. thesis,
Carnegie Mellon University, Pittsburgh,
PA, USA. AAI3248489.

325

https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.2307%2F416279&citationId=p_4
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1093%2Flogcom%2F2.3.297&citationId=p_2
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1093%2Flogcom%2F2.3.297&citationId=p_2


Computational Linguistics Volume 44, Number 2

Chaudhuri, Kaustuv, Dale Miller, and
Alexis Saurin. 2008. Canonical sequent
proofs via multi-focusing. In Fifth IFIP
International Conference on Theoretical
Computer Science - TCS 2008, IFIP 20th
World Computer Congress, pages 383–396,
Milano.

Cohen, Shay B., Carlos Gómez-Rodrı́guez,
and Giorgio Satta. 2012. Elimination of
spurious ambiguity in transition-based
dependency parsing. CoRR, abs/1206.6735.

Eisner, Jason. 1996. Efficient normal-form
parsing for combinatory categorial
grammar. In Proceedings of the 34th Annual
Meeting of the Association for Computational
Linguistics, pages 79–86, Stroudsburg, PA.

Fadda, Mario. 2010. Geometry of Grammar:
Exercises in Lambek Style. Ph.D. thesis,
Universitat Politècnica de Catalunya,
Barcelona.

Goldberg, Yoav and Joakim Nivre. 2012. A
dynamic oracle for arc-eager dependency
parsing. In COLING 2012, 24th International
Conference on Computational Linguistics,
Proceedings of the Conference: Technical
Papers, pages 959–976, Mumbai.

de Groote, Philippe. 1999. A dynamic
programming approach to categorial
deduction. In Proceedings of the 16th
International Conference on Automated
Deduction (CADE), pages 1–15, Trento.

Hayashi, Katsuhiko, Shuhei Kondo, and Yuji
Matsumoto. 2013. Efficient stacked
dependency parsing by forest reranking.
TACL, 1:139–150.

Hendriks, H. 1993. Studied Flexibility.
Categories and Types in Syntax and
Semantics. Ph.D. thesis, Universiteit van
Amsterdam, ILLC, Amsterdam.

Hepple, Mark. 1990. Normal form theorem
proving for the Lambek calculus.
In Proceedings of COLING, pages 173–178,
Stockholm.

Hepple, Mark and Glyn Morrill. 1989.
Parsing and derivational equivalence.
In Proceedings of the Fourth Conference of the
European Chapter of the Association for
Computational Linguistics, pages 10–18,
Stroudsburg, PA.

Huang, Shujian, Stephan Vogel, and Jiajun
Chen. 2011. Dealing with spurious
ambiguity in learning ITG-based word
alignment. In Proceedings of the 49th Annual
Meeting of the Association for Computational
Linguistics: Human Language Technologies:
Short Papers - Volume 2, pages 379–383,
Stroudsburg, PA.

Hughes, Dominic J. D. and Rob J. van
Glabbeck. 2005. Proof nets for unit-free
multiplicative-additive linear logic. ACM

Transactions on Computational Logic (TOCL),
6(4):784–842.

Joshi, A. K., K. Vijay-Shanker, and D. Weir.
1991. The convergence of mildly
context-sensitive grammar formalisms.
In P. Sells, S. M. Shieber, and T. Wasow,
editors, Foundational Issues in Natural
Language Processing, The MIT Press,
Cambridge, MA, pages 31–81.

Kanazawa, M. 1992. The Lambek calculus
enriched with additional connectives.
Journal of Logic, Language and Information,
1:141–171.

Kanazawa, Makoto. 2009. The pumping
lemma for well-nested multiple
context-free languages. In Developments in
Language Theory: 13th International
Conference, DLT 2009, pages 312–325,
Stuttgart.

Kanovich, Max, Stepan Kuznetsov, Glyn
Morrill, and Andreu Scedrov. 2017. A
polynomial-time algorithm for the Lambek
calculus with brackets of bounded order.
In Proceedings of the 2nd International
Conference on Formal Structures for
Computation and Deduction (FSCD 2017),
pages 22.1–22.17, Leibniz.

Kuznetsov, Stepan, Glyn Morrill, and Oriol
Valentı́n. 2017. Count-invariance including
exponentials. In 15th Meeting on
Mathematics of Language, pages 128–139,
London.

Lamarche, F. and C. Retoré. 1996. Proof nets
for the Lambek calculus - an overview. In
Proofs and Linguistic Categories - Applications
of Logic to the Analysis and Implementation of
Natural Language, pages 241–626, Bologna.

Lambek, Joachim. 1958. The mathematics of
sentence structure. American Mathematical
Monthly, 65:154–170.

Lambek, Joachim. 1961. On the calculus of
syntactic types. In Roman Jakobson, editor,
Structure of Language and its Mathematical
Aspects, Proceedings of the Symposia in
Applied Mathematics XII, pages 166–178,
Providence, RI.

Lambek, Joachim. 1988. Categorial and
categorical grammars. In Richard T.
Oehrle, Emmon Bach, and Deidre Wheeler,
editors, Categorial Grammars and Natural
Language Structures, volume 32 of Studies in
Linguistics and Philosophy, D. Reidel,
Dordrecht, pages 297–317.

Laurent, Olivier. 2004. A proof of the
focalization property of linear logic.
Unpublished manuscript, CNRS -
Université Paris VII.

Miller, D., G. Nadathur, F. Pfenning, and
A. Scedrov. 1991. Uniform proofs as a
foundation for logic programming.

326

https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1080%2F00029890.1958.11989160&citationId=p_24
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1080%2F00029890.1958.11989160&citationId=p_24
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1145%2F1094622.1094629&citationId=p_17
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1145%2F1094622.1094629&citationId=p_17
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1007%2FBF00171695&citationId=p_19


Morrill and Valentı́n Spurious Ambiguity and Focalization

Annals of Pure and Applied Logic,
51:125–157.

Moortgat, Michael and Richard Moot. 2011.
Proof nets for the Lambek-Grishin
calculus. CoRR, abs/1112.6384.

Moot, Richard. 2014. Extended Lambek
calculi and first-order linear logic. In
Casadio, Claudia, Bob Coeke, Michael
Moortgat, and Philip Scott, editors,
Categories and Types in Logic, Language and
Physics: Essays Dedicated to Jim Lambek on
the Occasion of His 90th Birthday,
volume 8222 of LNCS, FoLLI Publications in
Logic, Language and Information, Springer,
Berlin, pages 297–330.

Moot, Richard. 2016. Proof nets for the
displacement calculus. In Annie Foret,
Glyn Morrill, Reinhard Muskens, Rainer
Osswald, and Sylvain Pogodalla, editors,
Formal Grammar: 20th and 21st International
Conferences, FG 2015, pages 273–289,
Bozen.

Moot, Richard and Christian Retoré.
2012. The Logic of Categorial Grammars:
A Deductive Account of Natural Language
Syntax and Semantics. Springer, Heidelberg.

Morrill, Glyn. 1990. Grammar and Logical
Types. In Martin, Stockhof, and Leen
Torenvliet, editors, Proceedings of the
Seventh Colloquium, pages 429–450,
Amsterdam.

Morrill, Glyn. 1996. Memoisation of
categorial proof nets: Parallelism in
categorial processing. In Proofs and
Linguistic Categories, Proceedings 1996
Roma Workshop, pages 157–169, Bologna.

Morrill, Glyn. 2000. Incremental Processing
and Acceptability. Computational
Linguistics, 26(3):319–338.

Morrill, Glyn. 2012. CatLog: A categorial
parser/theorem-prover. In LACL 2012
System Demonstrations, pages 13–16,
Nantes.

Morrill, Glyn. 2017. Parsing logical grammar:
Catlog3. In Proceedings of the Workshop on
Logic and Algorithms in Computational
Linguistics 2017, pages 107–131, Stockholm
University.

Morrill, Glyn and Oriol Valentı́n. 2010.
Displacement calculus. Linguistic Analysis,
36(1–4):167–192. Special issue Festschrift
for Joachim Lambek.

Morrill, Glyn and Oriol Valentı́n. 2015.
Multiplicative-additive focusing for
parsing as deduction. In First International
Workshop on Focusing, Workshop Affiliated
with LPAR 2015, pages 29–54, Suva.

Morrill, Glyn and Oriol Valentı́n. 2016.
Computational coverage of type logical

grammar: The Montague test. In C. Piñón,
editor, Empirical Issues in Syntax and
Semantics, volume 11. Colloque de Syntaxe
et Sémantique Ĺ Paris (CSSP), Paris,
pages 141–170.

Morrill, Glyn, Oriol Valentı́n, and Mario
Fadda. 2011. The displacement calculus.
Journal of Logic, Language and Information,
20(1):1–48.

Morrill, Glyn V. 2011. Categorial Grammar:
Logical Syntax, Semantics, and Processing.
Oxford University Press.

Pentus, M. 1992. Lambek grammars are
context-free. Technical report, Department
of Mathematics and Logic, Steklov Math.
Institute, Moskow Also published as ILLC
Report, University of Amsterdam, 1993,
and in Proceedings Eighth Annual IEEE
Symposium on Logic in Computer Science.
Montreal, 1993.

Pentus, M. 1998. Free monoid completeness
of the Lambek calculus allowing empty
premises. In J. M. Larrazabal, D. Lascar,
and Mints G., editors, Logic Colloquium ’96,
volume 12. Springer, pages 171–209.

Pentus, Mati. 1993. Lambek calculus is
L-complete, ILLC Report, University of
Amsterdam. Shortened version published
as Language completeness of the Lambek
calculus, Proceedings of the Ninth Annual
IEEE Symposium on Logic in Computer
Science, pages 487–496, Paris.

Pentus, Mati. 2010. A polynomial-time
algorithm for Lambek grammars of
bounded order. Linguistic Analysis,
36(1–4):441–472. Special issue Festschrift
for Joachim Lambek.

Simmons, Robert J. 2012. Substructural Logical
Specifications. Ph.D. thesis, Carnegie
Mellon University, Pittsburgh.

Sorokin, Alexey. 2013. Normal forms for
multiple context-free languages and
displacement Lambek grammars. In
Sergei Artemov and Anil Nerode, editors,
Logical Foundations of Computer Science:
International Symposium, pages 319–334,
San Diego, CA.

Steedman, Mark. 2000. The Syntactic Process,
MIT Press, Cambridge, MA.

Valentı́n, Oriol. 2016. Models for the
displacement calculus. In Formal Grammar:
20th and 21st International Conferences,
pages 147–163, Bozen.

Wijnholds, Gijs Jasper. 2014. Conversions
between D and MCFG: Logical
characterizations of the mildly
context-sensitive languages. Computational
Linguistics in the Netherlands Journal,
4:137–148.

327

https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1007%2Fs10849-010-9129-2&citationId=p_41
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&system=10.1162%2F089120100561728&citationId=p_35
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&system=10.1162%2F089120100561728&citationId=p_35
https://www.mitpressjournals.org/action/showLinks?doi=10.1162%2Fcoli_a_00316&crossref=10.1016%2F0168-0072%2891%2990068-W&citationId=p_28

