



















































Action-Sensitive Phonological Dependencies


Proceedings of the 16th Workshop on Computational Research in Phonetics, Phonology, and Morphology, pages 218–228
Florence, Italy. August 2, 2019 c©2019 Association for Computational Linguistics

218

Action-Sensitive Phonological Dependencies

Yiding Hao
Yale University

New Haven, CT, USA
yiding.hao@yale.edu

Dustin Bowers
University of Arizona

Tucson, AZ, USA
bowersd@email.arizona.edu

Abstract

This paper defines a subregular class of
functions called the tier-based synchronized
strictly local (TSSL) functions. These func-
tions are similar to the the tier-based input–
output strictly local (TIOSL) functions, except
that the locality condition is enforced not on
the input and output streams, but on the com-
putation history of the minimal subsequential
finite-state transducer. We show that TSSL
functions naturally describe rhythmic syncope
while TIOSL functions cannot, and we argue
that TSSL functions provide a more restricted
characterization of rhythmic syncope than ex-
isting treatments within Optimality Theory.

1 Introduction

The subregular program in phonology seeks to de-
fine subclasses of the regular languages and finite-
state functions that describe attested phonotactic
constraints and phonological processes. These
subclasses provide a natural framework for ty-
pological classification of linguistic phenomena
while allowing for the development of precise the-
ories of language learning and processing. The
traditional view in subregular phonology is that
most phonotactic dependencies are described by
tier-based strictly local languages (TSL, Heinz
et al., 2011; McMullin and Hansson, 2016; Mc-
Mullin, 2016), while most phonological process
are described by strictly local functions (Chan-
dlee, 2014; Chandlee et al., 2015, In prep). These
classes of languages and functions are defined by
a principle known as locality—that dependencies
between symbols must occur over a bounded dis-
tance within the string. To account for longer-
distance dependencies, Heinz et al. (2011) pro-
poses a tier projection mechanism that allows ir-
relevant intervening symbols to be exempt from
the locality condition.

Recent work in subregular phonology has iden-
tified a number of exceptions to the traditional
view. On the language side, unbounded culmi-
native stress systems (Baek, 2018), Uyghur back-
ness harmony (Mayer and Major, 2018), and San-
skrit n-retroflexion (Graf and Mayer, 2018) have
been shown to lie outside the class of TSL lan-
guages. These observations have led to an en-
hancement of Heinz et al.’s (2011) tier projection
system. On the function side, a number of pro-
cesses, including bidirectional harmony systems
(Heinz and Lai, 2013) and certain tonal processes
(Jardine, 2016), have been shown to be not subse-
quential, and therefore not strictly local. At least
two proposals, both known as the weakly deter-
ministic functions, have been made in order to cap-
ture these processes (Heinz and Lai, 2013; McCol-
lum et al., 2018).

This paper identifies rhythmic syncope as an ad-
ditional example of a phonological process that is
not strictly local. In rhythmic syncope, every sec-
ond vowel of an underlying form is deleted in the
surface form, starting with either the first or the
second vowel. While rhythmic syncope cannot be
expressed as a local dependency between symbols,
it can be viewed as a local dependency between
actions in the computation history of the mini-
mal subsequential finite-state transducer (SFST).
We formalize such dependencies by proposing
the tier-based synchronized strictly local functions
(TSSL). See Bowers and Hao (To appear) for a
discussion of TSSL functions oriented towards the
phonological literature.

This paper is structured as follows. Section 2
enumerates standard definitions and notation used
throughout the paper, while Section 3 reviews ex-
isting work on strictly local functions. Section 4
introduces rhythmic syncope and shows that it is
not strictly local. Section 5 presents two equiv-
alent definitions of the TSSL functions—an al-



219

gebraic definition and a definition in terms of a
canonical SFST. Section 6 develops some formal
properties of the TSSL functions, showing that
they are incomparable to the full class strictly lo-
cal functions. Section 7 compares our proposal to
existing OT treatments of rhythmic syncope, and
Section 8 concludes.

2 Preliminaries

As usual, N denotes the set of nonnegative inte-
gers. Σ and Γ denote finite alphabets not including
the left and right word boundary symbols o and
n, respectively. The length of a string x is denoted
by |x|, and λ denotes the empty string. Alphabet
symbols are identified with strings of length 1, and
individual strings are identified with singleton sets
of strings. For k ∈ N, αk denotes α concatenated
with itself k-many times, α<k denotes

⋃k−1
i=0 α

i,
α∗ denotes

⋃∞
i=0 α

i, and α+ denotes αα∗. The
longest common prefix of a set of strings A is the
longest string lcp(A) such that every string in A
begins with lcp(A). The k-suffix of a string x, de-
noted suffk(x), is the string consisting of the last
k-many symbols of okx.

A subsequential finite-state transducer (SFST)
is a 6-tuple T = 〈Q,Σ,Γ, q0,→, σ〉, where

• Q is the set of states, with q0 ∈ Q being the
start state;

• Σ and Γ are the input and output alphabets,
respectively;

• → : Q× Σ→ Q× Γ∗ is the transition func-
tion; and

• σ : Q→ Γ∗ is the final output function.

For x ∈ Σ∗; y ∈ Γ∗; and q, r ∈ Q, the notation
q

x:y−−→ r means that T emits y to the output stream
and transitions to state r if it reads x in the input
stream while it is in state q. Letting f : Σ∗ → Γ∗,
we say that T computes f if for every x ∈ Σ∗,
f(x) = yσ(q), where q0

x:y−−→ q. A function is
subsequential if it is computed by an SFST.

An SFST T = 〈Q,Σ,Γ, q0,→, σ〉 is onward if
for every state q other than q0,

lcp
({
y
∣∣∣∃x∃r.q x:y−−→ r} ∪ {σ(q)}) = λ.

Putting T in onward form allows us to impose
structure on the timing with which SFSTs produce
output symbols.

Definition 1. Let f : Σ∗ → Γ∗. We define the
function f← : Σ∗ → Γ∗ by

f←(x) := lcp ({f(xy)|y ∈ Σ∗}) .

For any x, y ∈ Σ∗, f→x (y) denotes the string such
that f(xy) = f←(x)f→x (y). We refer to f

→
x as

the translation of f by x and to f← as f top.1

Suppose T computes f . The following facts are
apparent.

• Fixw, x ∈ Σ∗ and write q0
x:y−−→ q and q0

x:z−−→
r. If q = r, then f→w = f

→
y .

• T is onward if and only if for all q ∈ Q\{q0},
if q0

x:y−−→ q, then y = f←(x).

These observations allow us to construct the min-
imal SFST for f by identifying each state with a
possible translation f→x (Raney, 1958).

Let A and B be alphabets that are possibly infi-
nite. A function h : A∗ → B∗ is a homomorphism
if for every x, y ∈ A∗, h(xy) = h(x)h(y).

3 Background

The strictly local functions are classes of subse-
quential functions proposed by Chandlee (2014),
Chandlee et al. (2015), and Chandlee et al. (In
prep) as transductive analogues of the strictly lo-
cal languages (McNaughton and Papert, 1971).
Whereas phonotactic dependencies can usually be
described using tier-based strictly local languages
(Heinz et al., 2011; McMullin and Hansson, 2016;
McMullin, 2016), Chandlee (2014) has argued
that local phonological processes can be modelled
as strictly local functions when they are viewed as
mappings between underlying representations and
surface representations. A survey overview of the
related literature can be found in Heinz (2018).

Intuitively, strictly local functions are functions
computed by SFSTs in which each state represents
the i − 1 most recent symbols in the input stream
and the j − 1 most recent symbols in the output
stream along with the current input symbol, for
some parameter values i, j fixed. Such functions
are “local” in the sense that the action performed
on each input symbol depends only on informa-
tion about symbols in the input and output streams

1This terminology follows Sakarovitch (2009, pp. 692–
693). In the transducer inference literature, Oncina et al.
(1993) refer to f→x as the tails of x in f , and Chandlee et al.
(2015) refer to f← as the prefix function associated to f .



220

within a bounded distance. In this paper, we aug-
ment strictly local functions with tier projection,
a mechanism introduced by Heinz et al. (2011)
and elaborated by Baek (2018), Mayer and Ma-
jor (2018), and Graf and Mayer (2018) that allows
the locality constraint to bypass irrelevant alpha-
bet symbols, extending the distance over which
dependencies may be enforced.

Definition 2. For any alphabet Σ, a tier on Σ is a
homomorphism τ : Σ∗ → Σ∗ such that for each
a ∈ Σ, either τ(a) = a or τ(a) = λ. In the former
case, we say that a is on τ ; in the latter case, we
say that a is off τ .

Chandlee (2014), Chandlee et al. (2015), and
Chandlee et al. (In prep) give two definitions of
the strictly local functions. Firstly, they state the
locality condition in terms of the algebraic repre-
sentation of minimal SFSTs.

Definition 3. Fix i, j > 0 and let τ be a tier on
Σ ∪ Γ. A function f : Σ∗ → Γ∗ is i, j-input–
output strictly local on tier τ (i, j-TIOSL) if for
all w, x ∈ Σ∗, if

• suffi−1(τ(w)) = suffi−1(τ(x)) and

• suffj−1(τ(f←(w))) = suffj−1(τ(f←(x))),

then f→w = f
→
x . A function is i-input strictly local

on tier τ (i-TISL) if it is i, 1-TIOSL on tier τ , and
it is j-output strictly local on tier τ (j-TOSL) if it
is 1, j-TIOSL on tier τ .

Secondly, they define strictly local functions in
terms of canonical SFSTs that directly encode (i−
1)-suffixes of the input stream and (j−1)-suffixes
of the output stream in their state names.

Definition 4. Fix i, j > 0 and let τ be a tier on
Σ ∪ Γ. An SFST T = 〈Q,Σ,Γ, q0,→, σ〉 is i, j-
input–output strictly local on tier τ (i, j-TIOSL) if
the following conditions hold.

• Q = ({o} ∪ Σ)i−1 × ({o} ∪ Γ)j−1 and
q0 =

〈
oi−1,oj−1

〉
.

• If 〈a, b〉 x:y−−→ 〈c, d〉, then c = suffi−1(τ(ax))
and d = suffj−1(τ(by)).

An SFST is i-input strictly local on tier τ (i-TISL)
if it is i, 1-TIOSL on tier τ , and it is j-output
strictly local on tier τ (j-TOSL) if it is 1, j-TIOSL
on tier τ .

These definitions turn out to be equivalent when
the canonical SFSTs are required to be onward.

ostart @ V

C : C

V : @

C : C

V : V

C : C

V : @

Figure 1: An SFST for rhythmic reduction.

Theorem 5 (Chandlee, 2014; Chandlee et al.,
2015, In prep). A function is i, j-TIOSL on tier τ
if and only if it is computed by an onward SFST
that is i, j-TIOSL on tier τ .

Example 6. Rhythmic reduction is a phonological
process in which alternating vowels in a word un-
dergo reduction. The examples in (7) show rhyth-
mic reduction in the Odawa variety of Ojibwe
circa 1912, as documented by Edward Sapir. In
our representation of reduction, vowels are re-
duced to @, starting from the first vowel. There
is no reason to believe that @ appears in underlying
forms.

(7) Rhythmic reduction in Ojibwe circa 1912
(Rhodes et al., 2012)
a. /m2kIzIn2n/ ; [m@kIz@n2n] ‘shoes’
b. /gUtIgUmIn2gIbIna:d/ ;

[g@tIg@mIn@gIb@na:d] ‘if he rolls him’

Figure 1 shows an SFST that implements the
rhythmic reduction pattern illustrated in (7). We
represent the pattern using an alphabet of three
symbols: C, representing consonants; V , repre-
senting vowels that have not been reduced; and @,
representing vowels that have been reduced. Ob-
serve that this SFST is onward and 2-TOSL, with
C off the tier: each state represents the most recent
vowel in the ouput stream.2

4 Rhythmic Syncope

Rhythmic syncope is a phonological process in
which every second vowel in a word is deleted.
The examples of (8) show rhythmic syncope in
Macushi, in which deletion begins with the first
vowel.3

(8) Rhythmic syncope in Macushi (Hawkins,
1950)

2For clarity, we omit the 〈λ, ·〉 portions of the state names.
3The synchronic status of rhythmic syncope is a matter

of current discussion, as its development appears to push a
phonological system into dramatic restructuring (Bowers, To
appear).



221

a. /piripi/ ; [pripi] ‘spindle’
b. /wanamari/ ; [wnamri] ‘mirror’

In this section, we show that rhythmic syncope
is not TIOSL. To see this, we formalize rhythmic
syncope as a function over two alphabet symbols:
C, representing consonants, and V , representing
vowels. This idealization does not affect the ar-
gument that rhythmic syncope is not TIOSL, pre-
sented in Proposition 10.

Definition 9. The rhythmic syncope function ρ :
{C, V }∗ → {C, V }∗ is defined as follows. For
c0, c1, . . . , cn ∈ C∗,

ρ(c0V c1V c2 . . . V cn) = c0v1c1v2c2 . . . vncn,

where for each i, vi = V if i is even and vi = λ if
i is odd.

The intuition underlying the argument pre-
sented below is that (i − 1)-suffixes of the input
and (j − 1)-suffixes of the output do not contain
information about whether vowels occupy even or
odd positions within the input and output strings.
Therefore, while an i, j-TIOSL SFST can record
the most recent vowels read from the input stream
and emitted to the output stream, this information
is not sufficient for determining whether or not the
SFST should delete a vowel.

Proposition 10. The rhythmic syncope function is
not i, j-TIOSL on tier τ for any i, j > 0 and any
τ : {C, V }∗ → {C, V }∗.

Proof. Let k > i be even. Consider the strings
w := V k and x := V k+1. Observe that ρ←(w) =
ρ←(x) = V k/2; thus suffj−1(τ(ρ←(w))) =
suffj−1(τ(ρ←(x))). Now, if V is on τ , then
suffi−1(τ(w)) = V i−1 = suffi−1(τ(x)), and
if V is off τ , then suffi−1(τ(w)) = oi−1 =
suffi−1(τ(x)). Thus, if ρ is i, j-TIOSL on tier τ ,
then ρ→w = ρ

→
x . However, letting y := V

k/2, ob-
serve that

y = ρ(wV ) = ρ←(w) ρ→w (V ) = y ρ
→
w (V )

yV = ρ(xV ) = ρ←(x) ρ→x (V ) = y ρ
→
x (V ).

This means that ρ→w (V ) = λ but ρ
→
x (V ) = V , so

ρ is not i, j-TIOSL on tier τ .

5 Synchronized Strictly Local Functions

Proposition 10 raises the question of how to char-
acterize the kind of computation that effects rhyth-
mic syncope. To investigate this question, Figure 2

ostart V : λ V : V

C : C

V : λ

C : C

V : V

C : C

V : λ

Figure 2: An SFST for rhythmic syncope.

shows a natural SFST implementation of rhythmic
syncope. The states in this SFST record the most
recent action performed by the SFST. If the most
recent action was to delete a vowel (V : λ), then
the next vowel the SFST encounters is not deleted
(V : V ); otherwise, the next vowel is deleted. This
SFST is strikingly similar to the rhythmic reduc-
tion SFST in Figure 1. There, the special sym-
bol @, which is not part of the input alphabet, indi-
cates the location of a reduced vowel, effectively
recording the previous action in the output. Since
there is no way to mark the location of a deleted
symbol, the SFST in Figure 2 explicitly records its
previous action in its state names. Thus, the rhyth-
mic syncope SFST may be seen as a generalization
of the rhythmic reduction SFST. The goal of this
section is to define a class of functions, known as
the tier-based synchronized strictly local (TSSL)
functions, based on this intuition. Following Sec-
tion 2, we begin by defining the TSSL functions
algebraically in terms of the minimal SFST, and
then we define a canonical SFST format for the
TSSL functions.

Recall that at each time step, an SFST must read
exactly one input symbol while producing an out-
put string of any length. Since the minimal SFST
for a function f must produce f←(z) after reading
the input string z, we can determine the possible
actions of f by comparing f←(z) with f←(zx)
for arbitrary z ∈ Σ∗ and x ∈ Σ.
Definition 11. Let f : Σ∗ → Γ∗. The actions
of f are the alphabet A(f) ⊆ Σ × Γ∗ defined as
follows.

A(f) := {〈x, y〉|∃z ∈ Σ∗.f←(zx) = f←(z)y}

We denote elements 〈x, y〉 of A(f) by x : y.
Strings over A(f) represent computation histo-

ries of the minimal SFST for f .

Definition 12. Let x ∈ Σ∗ and let f : Σ∗ → Γ∗.
The run of f on input x is the string f⇐(x) ∈
A(f)∗ defined as follows.



222

• If |x| ≤ 1, then f⇐(x) := x : f←(x).

• If x = yz, where |y| ≥ 1 and |z| = 1, then
f⇐(x) := f⇐(y)(z : w), where w is the
unique string such that f←(x) = f←(y)w.

The notation f⇐ allows us to define the TSSL
functions in a straightforward manner, highlight-
ing the analogy to the TIOSL functions.

Definition 13. Fix k > 0 and let τ be a tier on
Σ×Γ∗. A function f : Σ∗ → Γ∗ is k-synchronized
strictly local on tier τ (k-TSSL) if for all x, y ∈
Σ∗, if suffk−1(τ(f⇐(x))) = suffk−1(τ(f⇐(y))),
then f→x = f

→
y .

Now, let us define the canonical SFSTs for
TSSL functions. We define the actions of an SFST
to be its possible transition labels.

Definition 14. Let T = 〈Q,Σ,Γ, q0,→, σ〉 be an
SFST. The actions of T are the alphabet

A(T ) := {〈x, y〉|∃q∃r.→(q, x) = 〈r, y〉} .

We denote elements 〈x, y〉 of A(T ) by x : y.
Again, the definition of the TSSL SFSTs is di-

rectly analogous to that of the TIOSL SFSTs.

Definition 15. Fix k > 0 and let τ be a tier on
Σ × Γ∗. An SFST T = 〈Q,Σ,Γ, q0,→, σ〉 is k-
synchronized strictly local on tier τ (k-TSSL) if
the following conditions hold.

• Q = ({o} ∪ A(T ))k−1 and q0 = ok−1.

• For every q ∈ Q, if→(q, x) = 〈r, y〉, then

r = suffk−1 (τ (q(x : y))) .

As is the case with TIOSL SFSTs, TSSL SFSTs
compute exactly the class of TSSL functions when
they are required to be onward.

Theorem 16. Fix k > 0, and let τ be a tier on
Σ× Γ∗. A function is k-TSSL on tier τ if and only
if it is computed by an onward SFST that is k-TSSL
on tier τ .

We leave the proof of this fact to Appendix A.

6 Properties of TSSL Functions

Having now defined the TSSL functions, this sec-
tion investigates some of their formal properties.
Subsection 6.1 compares the TSSL functions to
the TISL, TOSL, and TIOSL functions. Subsec-
tion 6.2 observes that TSSL SFSTs compute a
large class of functions when they are not required
to be onward.

6.1 Relation to TIOSL Functions
A natural first question regarding the TSSL func-
tions is that of how they relate to previously-
proposed classes of subregular functions. We
know from the discussion of rhythmic syncope
that the TSSL functions are not a subset of the
TIOSL functions: we have already seen that the
rhythmic syncope function is 2-TSSL but not i, j-
TIOSL for any i, j. We will see in this sub-
section that the TIOSL functions are not a sub-
set of the TSSL functions, though both function
classes fully contain the TISL and TOSL func-
tions. Therefore, the two function classes are in-
comparable, and offer two different ways to gen-
eralize the TISL and TOSL functions.

The fact that the TSSL functions contain the
TISL and TOSL functions follows from the obser-
vation that actions contain information about in-
put and output symbols. Remembering the i most
recent actions automatically entails remembering
the i most recent input symbols, and the j most
recent output symbols can be extracted from the j
most recent actions if deletions are ignored.

Proposition 17. Fix k > 0. Every k-TISL function
and every k-TOSL function is k-TSSL.

Proof. Let f : Σ∗ → Γ∗, and let τ be a tier on
Σ∪Γ. First, suppose that f is k-TISL on tier τ . Let
υ be a tier on Σ×Γ∗ defined as follows: an action
x : y is on υ if and only if x is on τ . Now, suppose
w, x ∈ Σ∗ are such that suffk−1(υ(f⇐(w))) =
suffk−1(υ(f⇐(x))). Write

υ(f⇐(w)) = (w1 : y1)(w2 : y2) . . . (wn : yn)

υ(f⇐(x)) = (x1 : z1)(x2 : z2) . . . (xn : zn).

Then, we have τ(w) = w1w2 . . . wn and τ(x) =
x1x2 . . . xn. For all i > n − k + 1, wi : yi =
xi : zi, and therefore wi = xi. But this means
that suffk−1(τ(w)) = suffk−1(τ(x)), and since f
is k-TISL on tier τ , f←w = f

←
x . We conclude that

f is k-TSSL on tier υ.
Next, suppose that f is k-TOSL on tier τ . Let ϕ

be a tier on Σ×Γ∗ defined as follows: an action x :
y is on ϕ if and only if τ(y) 6= λ. Now, suppose
w, x ∈ Σ∗ are such that suffk−1(ϕ(f⇐(w))) =
suffk−1(ϕ(f⇐(x))). Write

ϕ(f⇐(w)) = (w1 : y1)(w2 : y2) . . . (wn : yn)

ϕ(f⇐(x)) = (x1 : z1)(x2 : z2) . . . (xn : zn).

Now, τ(f←(w)) = y1y2 . . . yn and τ(f←(x)) =
z1z2 . . . zn. Again, for all i > n − k + 1 we have



223

o,ostart

a, a

b, b a, b

b, a
a : a

b : b

a : λ

a : λ

b : d

b : c

b : c

a : λ

a : λ

b : d

Figure 3: An onward 2, 2-TIOSL SFST computing a
function that is not k-TSSL for any k.

wi : yi = xi : zi, so yi = zi. Observe that

suffk−1(τ(f←(w))) = suffk−1(yjyj+1 . . . yn)

= suffk−1(zjzj+1 . . . zn) = suff
k−1(τ(f←(x))),

where j = n − k + 2. Since f is k-TOSL on tier
τ , f→w = f

→
x , so f is k-TSSL on tier ϕ.

This intuition does not carry over to the TIOSL
functions. In Proposition 17, the proposed action
tiers ignore symbols off the input and output tiers,
thus ensuring that the relevant input and output
symbols can always be recovered from the com-
putation history. This approach encounters prob-
lems when an onward TIOSL SFST deletes sym-
bols on the tier. Such SFSTs perform actions of
the form x : λ, where x is on the tier. These ac-
tions do not record any output symbols, but they
must be kept on the tier in a TSSL implementa-
tion so that the input symbol x can be recovered.
If too many (x : λ)s are performed consecutively,
they can overwhelm the memory of a TSSL SFST,
causing it to forget the most recent output sym-
bols. The following construction features exactly
this kind of behavior.

Proposition 18. There exists a function that is i, j-
TIOSL for some i, j but not k-TSSL for any k.

Proof. Let T be the SFST shown in Figure 3, and
let f : {a, b}∗ → {a, b, c, d}∗ be the function
computed by T .4 Observe that T is onward and
2, 2-TIOSL on tier τ , where a and b are on τ but
c and d are not, so f is 2, 2-TIOSL on tier τ . T
always copies the first symbol of its input to the

4The angle brackets are omitted from the state names.

output. Thereafter, T behaves as follows: all as
are deleted; a b is changed to a c if the most recent
input symbol is the same as the first input sym-
bol; a b is changed to a d otherwise. For example,
f(baabb) = bdc.

Let k > 0, and let υ be a tier on {a, b} ×
{a, b, c, d}∗. Suppose that either k = 1 or a : λ
is not on υ, and consider the strings w := ba and
x := b. Observe that f⇐(w) = (b : b)(a : λ) and
f⇐(x) = (b : b). Either suffk−1(υ(f⇐(x))) =
ok−2(b : b) = suffk−1(υ(f⇐(x))) if k > 1 and
b : b is on υ, or suffk−1(υ(f⇐(x))) = ok−1 =
suffk−1(υ(f⇐(x))) if k = 1 or b : b is not on υ.
However, f→w (b) = d but f

→
x (b) = c, so f cannot

be k-TSSL on tier υ.
Next, suppose that k > 1 and a : λ is on υ.

Consider the input strings w := ak+1 and x :=
bak. Observe that f⇐(w) = (a : a)(a : λ)k and
f⇐(x) = (b : b)(a : λ)k, thus

suffk−1(υ(f⇐(w))) = (a : λ)k−1

= suffk−1(υ(f⇐(x))).

However, f→w (b) = c but f
→
x (b) = d, so f is not

k-TSSL on tier υ.

6.2 Non-Onward TSSL SFSTs

The equivalence between the two definitions of the
TSSL functions presented in Section 5 crucially
depends on the criterion that TSSL SFSTs be on-
ward. In this subsection we show that without this
criterion, TSSL SFSTs compute a rich class of
subsequential functions. To illustrate how this is
possible, let us consider an example that witnesses
the separation between TSSL functions and TSSL
SFSTs.

Proposition 19. There exists a 2-TSSL SFST that
computes a function that is not k-TSSL for any k.

Proof. Consider the SFST in Figure 4. This SFST
is clearly 2-TSSL on a tier containing all actions,
and the function it computes is given by f(xy) =
xyx, where x ∈ {a, b} and y ∈ {a, b}∗. Observe
that for any z ∈ {a, b}∗, f←(z) = z. Therefore,
writing z = z1z2 . . . zn with |zi| = 1 for each i,

f⇐(z) = (z1 : z1)(z2 : z2) . . . (zn : zn).

We need to show that f is not k-TSSL for any k >
0 and for any tier τ over {a, b} × {a, b}∗.

Fix k and τ . Suppose a : a is on τ , and consider
the input strings w = ak+1 and x = bak. Observe



224

ostart

a : a

b : b

b : λ

a : aa

a : ba

b : ab

b : bb

a : λ

: a

: a

: bb

: b

: b

: b

: b : ab

a : a

b : ba : a

b : λ

b : bb

a : ba

a : λ

b : λ

a : λ

b : λ

a : λ

b : λ

a : λ

b : λ

a : aa

b : ab

Figure 4: A non-onward 2-TSSL SFST computing a function that is not k-TSSL for any k.

that f⇐(w) = (a : a)k+1 and f⇐(x) = (b : b)(a :
a)k, so

suffk−1(τ(f⇐(w))) = (a : a)k−1

= suffk−1(τ(f⇐(x))).

However, f→w (λ) = a but f
→
x (λ) = b, so f is not

k-TSSL on tier τ .
Next, suppose a : a is not on τ , and consider

the input strings w = b and x = ab. We have
f⇐(w) = b : b and f⇐(x) = (a : a)(b : b), so

suffk−1(τ(f⇐(w))) = suffk−1(τ(b : b))

= suffk−1(τ(a : a)τ(b : b))

= suffk−1(τ((a : a)(b : b)))

= suffk−1(τ(f⇐(x))).

However, f→w (λ) = b but f
→
x (λ) = a, so f is not

k-TSSL on tier τ .

Let f be the function described in Proposition
19. As discussed in the proof, an onward SFST
computing f must copy the current input symbol
to the output stream during each time step. At the
end of the computation, the final output function
is responsible for adding the first input symbol to
the end of the output string. Any onward TSSL
SFST that attempts to compute f will eventually
forget the identity of the first input symbol, so the
final output function cannot determine what to add
to the output. The SFST T in Figure 4 avoids this
problem by exploiting its non-onwardness. If the

first symbol of its input is an a, then T behaves in
an onward manner, copying the current input sym-
bol at each time step. This can be seen in the left
column of the state diagram. If the first symbol
of T ’s input is a b, then T alternates between pro-
ducing no output and producing two symbols of
output. Every time T performs a non-deleting ac-
tion x : y, y contains both the symbol that the on-
ward SFST would produce at the current time step
and the symbol that the onward SFST would have
produced at the previous time step. This way, T
encodes the identity of the first symbol of its input
using the manner in which it produces output—if
T produces output at every time step, then the first
symbol is an a, and if it produces output every two
time steps, then the first symbol is a b. In general,
this kind of encoding trick can be applied to a wide
range of SFSTs, including all SFSTs V that do not
perform deletions. Informally, we enumerate the
states of V by {q0, q1, . . . , qn}, and we construct a
TSSL SFST S that simulates V by producing out-
put at various frequencies. For each i, S produces
output every i + 1 time steps if V is in state qi. If
S remembers at least 2(n+ 1)-many actions, then
it can always deduce V ’s state at any point in the
computation, allowing it to simulate V .

7 Rhythmic Syncope in Phonology

The view of rhythmic syncope we have presented
here differs substantially in approach from exist-
ing treatments of rhythmic syncope in phonolog-



225

ical theory. McCarthy (2008) identifies two ma-
jor approaches to rhythmic syncope in Optimal-
ity Theory. In the pseudo-deletion approach (e.g.,
Kager, 1997), the locations of symbols deleted by
syncope are marked with blank symbols. This
essentially makes rhythmic syncope identical to
rhythmic reduction, which we have seen is 2-
TOSL. McCarthy himself proposes a Harmonic
Serialism approach in which rhythmic syncope is
implemented in multiple steps. Firstly, stress is
assigned to every second vowel in the underlying
form. Then, the unstressed vowels are deleted, re-
sulting in syncope. This kind of derivation is illus-
trated in (20).

(20) Rhythmic syncope in Harmonic Serialism
(McCarthy, 2008)5

/wanamari/ Underlying Form
wanámaŕı Stress
[wnámŕı ] Syncope

In both approaches, rhythmic syncope is de-
composed into a 2-TOSL function and a homo-
morphism. In the pseudo-deletion approach, the
2-TOSL function is rhythmic reduction, and the
homomorphism removes the @s. In (20), the rhyth-
mic stress step is 2-TOSL, while the syncope step
is a homomorphism. In general, this kind of ap-
proach is extremely powerful.

Proposition 21. Every subsequential function f
can be written in the form f = h ◦ g, where g is
2-TOSL and h is a homomorphism.

Proof. Let T = 〈Q,Σ,Γ, q0,→, σ〉 be the mini-
mal SFST for f . Define g as follows. Let g(λ) :=
〈σ, f(λ)〉. For x1, x2, . . . , xn ∈ Σ, write

q0
x1:y1−−−→ q1

x2:y2−−−→ q2
x3:y3−−−→ . . . xn−1:yn−1−−−−−−→ qn.

Then, g(x1x2 . . . xn) := 〈q1, y1〉〈q2, y2〉 . . . 〈qn,
yn〉〈σ, σ(qn)〉. Next, define h so that for any
〈q, y〉, h(〈q, y〉) = y. It is clear that f(x) =
h(g(x)) for every x. We now show that g is 2-
TOSL on a tier containing the full output alphabet.

Fix w, x ∈ Σ∗. Observe that for all z ∈ Σ∗,
g←(z) ∈ (Q × Γ∗)∗. Therefore, suppose that
suff1(g←(w)) = suff1(g←(x)) = 〈q, y〉. This
means that q0

w:u−−→ q and q0
x:v−−→ q for some

u, v ∈ Γ∗, so g→u = g→v by definition.
5The full derivation proposed by McCarthy (2008) in-

cludes syllabification and footing steps, which are omitted
here for simplicity.

In both pseudo-deletion and Harmonic Seri-
alism, non-segmental phonological symbols are
used to encode state information in the output,
making rhythmic syncope 2-TOSL. Proposition
21 shows that this technique can be applied to arbi-
trary SFSTs, and therefore results in massive over-
generation. By contrast, we have already seen that
the TSSL functions are a proper subset of the sub-
sequential functions, making action-sensitivity a
more restrictive alternative to current approaches
to rhythmic syncope.

8 Conclusion

The classic examples of TIOSL phenomena in
phonology are local processes and unidirectional
spreading processes (Chandlee, 2014). Rhythmic
syncope is qualitatively different from these phe-
nomena in that it leaves no evidence that the pro-
cess has occurred. As we have seen in Section
4, the fact that rhythmic syncope is not TIOSL
is a consequence of this property. In defining the
TSSL functions, we have proposed that rhythmic
syncope should be viewed as a dependency be-
tween incremental steps in a derivation, here for-
malized as the actions of the minimal SFST.

A potential risk of such an analysis is that the
notion of “action” is specific to the computational
system used to implement rhythmic syncope, and
therefore potentially subject to a broad range of
interpretations. In this paper, we have used on-
wardness and the existence of the minimal SFST
to formulate a notion of “action-sensitivity” that is
both formalism-independent and implementation-
independent. In Subsection 6.2, we have seen
that action-sensitivity can be made very power-
ful if we relax our assumptions about the nature
of the computation. This means that if action-
sensitivity is to be incorporated into phonological
analyses of rhythmic syncope, then care should be
taken to avoid loopholes like the one featured in
Proposition 19. Based on Proposition 21, a similar
warning can be made regarding the composition
of phonological processes. When decomposing
phonemena into several processes, as McCarthy
(2008) does in the Harmonic Serialism analysis,
care should be taken to ensure that theoretical pro-
posals do not allow for overgeneration.

Outstanding formal questions regarding the
TSSL functions include their closure properties
and the complexity of learning TSSL functions.
We leave such questions to future work.



226

References
Hyunah Baek. 2018. Computational representation of

unbounded stress: Tiers with structural features. In
Proceedings of CLS 53 (2017), volume 53, pages
13–24, Chicago, IL, USA. Chicago Linguistic So-
ciety.

Dustin Bowers. To appear. The Nishnaabemwin Re-
structuring Controversy: New Empirical Evidence.
Phonology.

Dustin Bowers and Yiding Hao. To appear. Rhythmic
Syncope in Subregular Phonology. In Proceedings
of the 42nd Annual Penn Linguistics Conference,
volume 26.1 of Penn Working Papers in Linguistics,
Philadelphia, PA, USA. Penn Graduate Linguistics
Society.

Jane Chandlee. 2014. Strictly Local Phonological Pro-
cesses. PhD Dissertation, University of Delaware,
Newark, DE, USA.

Jane Chandlee, Rémi Eyraud, and Jeffrey Heinz. 2015.
Output Strictly Local Functions. In Proceedings of
the 14th Meeting on the Mathematics of Language,
pages 112–125, Chicago, IL, USA. Association for
Computational Linguistics.

Jane Chandlee, Rémi Eyraud, and Jeffrey Heinz. In
prep. Input–output strictly local functions and their
efficient learnability.

Thomas Graf and Connor Mayer. 2018. Sanskrit n-
Retroflexion is Input–Output Tier-Based Strictly Lo-
cal. In Proceedings of the Fifteenth Workshop on
Computational Research in Phonetics, Phonology,
and Morphology, pages 151–160, Brussels, Bel-
gium. Association for Computational Linguistics.

W. Neil Hawkins. 1950. Patterns of Vowel Loss in Ma-
cushi (Carib). International Journal of American
Linguistics, 16(2):87–90.

Jeffrey Heinz. 2018. The computational nature of
phonological generalizations. In Larry M. Hyman
and Frans Plank, editors, Phonological Typology,
number 23 in Phonology and Phonetics, pages 126–
195. De Gruyter Mouton, Berlin, Germany.

Jeffrey Heinz and Regine Lai. 2013. Vowel Harmony
and Subsequentiality. In Proceedings of the 13th
Meeting on the Mathematics of Language (MoL 13),
pages 52–63, Sofia, Bulgaria. Association for Com-
putational Linguistics.

Jeffrey Heinz, Chetan Rawal, and Herbert G. Tan-
ner. 2011. Tier-based Strictly Local Constraints
for Phonology. In Proceedings of the 49th Annual
Meeting of the Association for Computational Lin-
guistics: Human Language Technologies, pages 58–
64, Portland, OR, USA. Association for Computa-
tional Linguistics.

Adam Jardine. 2016. Computationally, tone is differ-
ent. Phonology, 33(2):247–283.

René Kager. 1997. Rhythmic vowel deletion in Op-
timality Theory. In Iggy Roca, editor, Deriva-
tions and Constraints in Phonology, pages 463–499.
Clarendon Press, Oxford, United Kingdom.

Connor Mayer and Travis Major. 2018. A Challenge
for Tier-Based Strict Locality from Uyghur Back-
ness Harmony. In Formal Grammar 2018, 23rd In-
ternational Conference, FG 2018, Sofia, Bulgaria,
August 11-12, 2018, Proceedings, volume 10950 of
Lecture Notes in Computer Science, pages 62–83,
Berlin, Germany. Springer Berlin Heidelberg.

John J. McCarthy. 2008. The serial interaction of stress
and syncope. Natural Language & Linguistic The-
ory, 26(3):499–546.

Adam McCollum, Eric Baković, Anna Mai, and Eric
Meinhardt. 2018. The expressivity of segmental
phonology and the definition of weak determinism.
LingBuzz, lingbuzz/004197.

Kevin McMullin and Gunnar Ólafur Hansson. 2016.
Long-Distance Phonotactics as Tier-Based Strictly
2-Local Languages. In Proceedings of the 2014 An-
nual Meeting on Phonology, Proceedings of the An-
nual Meetings on Phonology, pages 13–24, Cam-
bridge, MA, USA. Linguistic Society of America.

Kevin James McMullin. 2016. Tier-Based Locality
in Long-Distance Phonotactics: Learnability and
Typology. PhD Dissertation, University of British
Columbia, Vancouver, Canada.

Robert McNaughton and Seymour A. Papert. 1971.
Counter-Free Automata. Number 65 in Research
Monograph. MIT Press, Cambridge, MA, USA.

José Oncina, Pedro Garcia, and Enrique Vidal. 1993.
Learning Subsequential Transducers for Pattern
Recognition Interpretation Tasks. IEEE Transac-
tions on Pattern Analysis and Machine Intelligence,
15(5):448–458.

George N. Raney. 1958. Sequential Functions. Jour-
nal of the Association for Computing Machinery,
5(2):177–180.

Richard A. Rhodes, Karl S. Hele, and J. Randolph
Valentine. 2012. Algonquian Trade Languages Re-
visited. In Papers of the Fortieth Algonquian Con-
ference/Actes Du Congrès Des Algonquinistes, Pa-
pers of the Algonquian Conference, pages 358–369,
Albany, NY, USA. State University of New York
Press.

Jacques Sakarovitch. 2009. Elements of Automata
Theory. Cambridge University Press, Cambridge,
United Kingdom.

A Proof of Theorem 16

This appendix proves the equivalence between
TSSL functions and onward TSSL SFSTs. We be-
gin by showing how to construct an onward TSSL
SFST computing any given TSSL function.

https://doi.org/10.3115/v1/W15-2310
https://doi.org/10.1086/464069
https://doi.org/10.1086/464069
https://doi.org/10.1017/S0952675716000129
https://doi.org/10.1017/S0952675716000129
https://doi.org/10.1007/s11049-008-9051-3
https://doi.org/10.1007/s11049-008-9051-3
http://arxiv.org/abs/1901.05287
http://arxiv.org/abs/1901.05287
https://doi.org/10.3765/amp.v2i0.3750
https://doi.org/10.3765/amp.v2i0.3750
https://doi.org/10.1109/34.211465
https://doi.org/10.1109/34.211465
https://doi.org/10.1145/320924.320930
https://doi.org/10.1017/CBO9781139195218
https://doi.org/10.1017/CBO9781139195218


227

Definition 22. Let f : Σ∗ → Γ∗ be k-TSSL
on tier τ . Define the SFST transducer T (f) =
〈Q,Σ,Γ, q0,→, σ〉 as follows.

• Q := ({o} ∪ A(f))k−1 and q0 := ok−1.

• For each x ∈ Σ, →(q0, x) := 〈r, f←(x)〉,
where r = suffk−1 (τ (x : f←(x))).

• For each q ∈ Q\{q0}, let x ∈ Σ∗ be such
that suffk−1 (τ (f⇐(x))) = q, and let w :
y ∈ A(f) be such that f←(xw) = f←(x)y.
We define →(q, w) := 〈r, y〉, where r =
suffk−1 (τ (q(w : y))).

• Fix q ∈ Q. If q = q0, then σ(q) := f(λ).
Otherwise, we define σ(q) := f→x (λ), where
suffk−1 (τ (f⇐(x))) = q.

Remark 23. T (f) is k-TSSL on tier τ .
Note that in the third and fourth bullet points

of Definition 22, the action w : y and the string
f→x (λ) only depend on q and not on x, since f is
k-TSSL on tier τ . We now need to show that T (f)
computes f and that it is onward.

Lemma 24. Let f : Σ∗ → Γ∗ be k-TSSL on tier τ ,
and write T (f) = 〈Q,Σ,Γ, q0,→, σ〉. For every
x ∈ Σ+, if q0

x:y−−→ r, then y = f←(x).

Proof. Let us induct on |x|. For the base case, sup-
pose |x| = 1. Then, y = f←(x) by definition.

Now, fix n > 1, and suppose that if 0 < |u| < n
and q0

u:v−−→ r, then v = f←(u). Fix w ∈ Σn−1

and x ∈ Σ, and suppose that q0
w:y−−→ s x:z−−→ t. By

the induction hypothesis, y = f←(w). The defini-
tion of T (f) states that z is the unique string such
that f←(wx) = f←(w)z. Thus, yz = f←(w)z =
f←(wx), and the proof is complete.

Lemma 25. Let f : Σ∗ → Γ∗ be k-TSSL on tier τ ,
and write T (f) = 〈Q,Σ,Γ, q0,→, σ〉. For all x ∈
Σ+, if q0

x:y−−→ r, then r = suffk−1(τ(f⇐(x))).

Proof. Let us induct on |x|. For the base case, sup-
pose |x| = 1. Since f⇐(x) = x : f←(x), by
definition r = suffk−1(τ(f⇐(x))).

Now, fix n > 1, and suppose that if |w| < n
and q0

w:y−−→ r, then r = suffk−1 (τ (f⇐(w))).
We need to show that for all w ∈ Σn−1 and
x ∈ Σ, if q0

w:y−−→ r x:z−−→ s, then s =
suffk−1 (τ (f⇐(wx))). The induction hypothe-
sis gives us r = suffk−1 (τ (f⇐(w))). Since
〈s, z〉 =→(r, x), by the definition of T (f),

s = suffk−1(τ(r(x : z)))

= suffk−1(τ(r)τ(x : z))

= suffk−1
(
τ
(

suffk−1(τ(f⇐(w)))
)
τ(x : z)

)
= suffk−1(τ(τ(f⇐(w)))τ(x : z))

= suffk−1(τ(f⇐(w))τ(x : z))

= suffk−1(τ(f⇐(w)(x : z)))

= suffk−1 (τ (f⇐(wx))) , (26)

as desired.

Proposition 27. If f : Σ∗ → Γ∗ is k-TSSL on tier
τ , then T (f) computes f.

Proof. We need to show that for every x ∈ Σ∗,
T (f) outputs f(x) on input x. Write T (f) =
〈Q,Σ,Γ, q0,→, σ〉 and q0

x:y−−→ q. By Lemma
24, y = f←(x), and by Lemma 25, q =
suffk−1(τ(f⇐(x))). Definition 22 then states that
σ(q) = f→x (λ), so yσ(q) = f

←(x)f→x (λ) =
f(x), thus T (f) outputs f(x) on input x.

Corollary 28. If f : Σ∗ → Γ∗ is k-TSSL on tier
τ , then T (f) is onward.

We then complete the proof by showing that ev-
ery onward TSSL SFST computes a TSSL func-
tion.

Lemma 29. Let T = 〈Q,Σ,Γ, q0,→, σ〉 be on-
ward and k-TSSL on tier τ . Let f be the function
computed by T . For all x ∈ Σ∗, if q0

x:y−−→ q, then
q = suffk−1(τ(f⇐(x))).

Proof. Let us induct on |x|. For the base case, sup-
pose |x| = 1. Since T is onward, y = f←(x), so

q = suffk−1
(
τ
(
ok−1(x : y)

))
= suffk−1

(
τ
(
ok−1(x : f←(x))

))
= suffk−1

(
τ
(
ok−1f⇐(x)

))
= suffk−1

(
τ
(
ok−1

)
τ (f⇐(x))

)
= suffk−1 (τ (f⇐(x))) .

Now, fix n > 1, and suppose that if |w| < n
and q0

w:y−−→ q, then q = suffk−1(τ(f⇐(w))).
We need to show that for all w ∈ Σn−1 and
x ∈ Σ, if q0

w:y−−→ r x:z−−→ s, then s =
suffk−1(τ(f⇐(wx))). The induction hypothesis
gives us r = suffk−1(τ(f⇐(w))), and Defini-
tion 15 states that s = suffk−1(τ(r(x : z))). A
derivation similar to equation (26) then gives us
s = suffk−1(τ(f⇐(wx))), as desired.



228

Proof of Theorem 16. Proposition 27 has already
shown the forward direction. Let T =
〈Q,Σ,Γ, q0,→, σ〉 be an onward SFST com-
puting f that is k-TSSL on tier τ . Suppose
x, y ∈ Σ∗ are such that suffk−1(τ(f⇐(w))) =
suffk−1(τ(f⇐(x))). Write q0

w:y−−→ r and q0
x:z−−→

s. By Lemma 29, r = suffk−1(τ(f⇐(w))) =
suffk−1(τ(f⇐(x))) = s, so f→w = f

→
x , thus f

is k-TSSL on tier τ .


