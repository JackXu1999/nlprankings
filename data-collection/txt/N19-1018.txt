



















































Discontinuous Constituency Parsing with a Stack-Free Transition System and a Dynamic Oracle


Proceedings of NAACL-HLT 2019, pages 204–217
Minneapolis, Minnesota, June 2 - June 7, 2019. c©2019 Association for Computational Linguistics

204

Discontinuous Constituency Parsing
with a Stack-Free Transition System and a Dynamic Oracle

Maximin Coavoux∗
Naver Labs Europe

maximin.coavoux@naverlabs.com

Shay B. Cohen
ILCC, School of Informatics

University of Edinburgh
scohen@inf.ed.ac.uk

Abstract

We introduce a novel transition system for dis-
continuous constituency parsing. Instead of
storing subtrees in a stack –i.e. a data structure
with linear-time sequential access– the pro-
posed system uses a set of parsing items, with
constant-time random access. This change
makes it possible to construct any discontinu-
ous constituency tree in exactly 4n − 2 tran-
sitions for a sentence of length n, whereas
existing systems need a quadratic number of
transitions to derive some structures. At each
parsing step, the parser considers every item
in the set to be combined with a focus item
and to construct a new constituent in a bottom-
up fashion. The parsing strategy is based on
the assumption that most syntactic structures
can be parsed incrementally and that the set –
the memory of the parser– remains reasonably
small on average. Moreover, we introduce a
dynamic oracle for the new transition system,
and present the first experiments in discontin-
uous constituency parsing using a dynamic or-
acle. Our parser obtains state-of-the-art results
on three English and German discontinuous
treebanks.

1 Introduction

Discontinuous constituency trees extend standard
constituency trees by allowing crossing branches
to represent long distance dependencies, such as
the wh-extraction in Figure 1. Discontinuous con-
stituency trees can be seen as derivations of Linear
Context-Free Rewriting Systems (LCFRS, Vijay-
Shanker et al., 1987), a class of formal gram-
mars more expressive than context-free grammars,
which makes them much harder to parse. In par-
ticular, exact CKY-style LCFRS parsing has an
O(n3f ) time complexity where f is the fan-out of
the grammar (Kallmeyer, 2010).

∗Work done at the University of Edinburgh.

SBARQ                       
 ┌─────────────┴────┬──────────────────┐  
 │                  SQ                 │ 
 │        ┌─────────┼────┐             │  
 │        │         │    VP            │ 
 │        │    ┌─── │ ───┴─────┐       │  
 │        │    VP   │          │       │ 
 │   ┌─── │ ───┴─── │ ──────── │ ──┐   │  
 │  WHNP  │         NP         │   │   │ 
 │   │    │    ┌────┴────┐     │   │   │  
 RB  WP VBZ   DT   NN   TO  VB  . 
 │   │    │    │         │     │   │   │  
 So what  's   a  parent  to  do  ? 

Figure 1: Discontinuous constituency tree from the
Discontinuous Penn treebank.

A natural alternative to grammar-based chart
parsing is transition-based parsing, that usually re-
lies on fast approximate decoding methods such
as greedy search or beam search. Transition-
based discontinuous parsers construct discontin-
uous constituents by reordering terminals with
the SWAP action (Versley, 2014a,b; Maier, 2015;
Maier and Lichte, 2016; Stanojević and Gar-
rido Alhama, 2017), or by using a split stack and
the GAP action to combine two non-adjacent con-
stituents (Coavoux and Crabbé, 2017a; Coavoux
et al., 2019). These proposals represent the mem-
ory of the parser (i.e. the tree fragments being con-
structed) with data structures with linear-time se-
quential access (either a stack, or a stack coupled
with a double-ended queue). As a result, these
systems need to perform at least n actions to con-
struct a new constituent from two subtrees sepa-
rated by n intervening subtrees. Our proposal aims
at avoiding this cost when constructing discontin-
uous constituents.

We design a novel transition system in which
a discontinuous constituent is constructed in a sin-
gle step, without the use of reordering actions such
as SWAP. The main innovation is that the mem-
ory of the parser is not represented by a stack,



205

Initial configuration (∅, null, 0, ∅) : 0
Goal configuration (∅, {0, 1, . . . , n− 1}, n, C) : 4n− 2

Structural actions Input Output Precondition

SHIFT (S, sf , i, C) : j ⇒ (S ∪ {sf}, {i}, i+ 1, C) : j + 1 i < n, j is even
COMBINE-s (S, sf , i, C) : j ⇒ (S − s, sf ∪ s, i, C) : j + 1 s ∈ S, j is even

Labelling actions

LABEL-X (S, sf , i, C) : j ⇒ (S, sf , i, C ∪ {(X, sf )}) : j + 1 j is odd
NO-LABEL (S, sf , i, C) : j ⇒ (S, sf , i, C) : j + 1 i 6= n or S 6= ∅, j is odd

Table 1: Set-based transition system description. Variable j is the number of steps performed since the start of the
derivation.

BufferStack

wi    wi+1    wi+2   ...  

...

s0s1s2s3

BufferSet

wi    wi+1    wi+2   ...  s0s1sn sf

Focus

...

Figure 2: In a stack-based system like shift-reduce-
swap (upper part), the parser extracts features from a
local region of the configuration (orange part), to pre-
dict the next action such as: construct a new tree with
label X and children s0 and s1 (REDUCE-X). In our
proposed set-based system (lower part), we consider
every item in the set to be combined bottom-up with
the focus item sf and score independently each possi-
ble transition.

as is usual in shift-reduce systems, but by an un-
ordered random-access set. The parser considers
every constituent in the current memory to con-
struct a new constituent in a bottom-up fashion,
and thus instantly models interactions between
parsing items that are not adjacent. As such, we
describe a left-to-right parsing model that deviates
from the standard stack-buffer setting, a legacy
from pushdown automata and classical parsing al-
gorithms for context-free grammars.

Our contributions are summarized as follows:

• We design a novel transition system for dis-
continuous constituency parsing, based on a
memory represented by a set of items, and

that derives any tree in exactly 4n − 2 steps
for a sentence of length n;
• we introduce the first dynamic oracle for dis-

continuous constituency parsing;
• we present an empirical evaluation of the

transition system and dynamic oracle on two
German and one English discontinuous tree-
banks.

The code of our parser is released as an open-
source project at https://gitlab.com/
mcoavoux/discoparset.

2 Set-based Transition System

System overview We propose to represent the
memory of the parser by (i) a set of parsing items
and (ii) a single focus item. Figure 2 (lower part)
illustrates a configuration in our system. The
parser constructs a tree with two main actions:
shift the next token to make it the new focus item
(SHIFT), or combine any item in the set with the
focus item to make a new constituent bottom-up
(COMBINE action).

Since the memory is not an ordered data struc-
ture, the parser considers equally every pending
parsing item, and thus constructs a discontinuous
constituent in a single step, thereby making it able
to construct any discontinuous tree in O(n) tran-
sitions.

The use of an unordered random-access data
structure to represent the memory of the parser
also leads to a major change for the scoring system
(Figure 2). Stack-based systems use a local view
of a parsing configuration to extract features and
score actions: features only rely on the few top-
most elements on the stack and buffer. The score
of each transition depends on the totality of this
local view. In constrast, we consider equally ev-
ery item in the set, and therefore rely on a global

https://gitlab.com/mcoavoux/discoparset
https://gitlab.com/mcoavoux/discoparset


206

Even action Set (S) Focus (sf ) Buffer Odd action

{} none So what ’s a parent to do ?
⇒SH⇒ {} {So} what ’s a parent to do ? ⇒NO-LABEL
⇒SH⇒ {{So}0} {what} ’s a parent to do ? ⇒LABEL-WHNP
⇒SH⇒ {{So}0, {what}1} {’s} a parent to do ? ⇒NO-LABEL
⇒SH⇒ {{So}0, {what}1, {’s}2} {a} parent to do ? ⇒NO-LABEL
⇒SH⇒ {{So}0, {what}1, {’s}2, {a}3} {parent} to do ? ⇒NO-LABEL

⇒COMB-3⇒ {{So}0, {what}1, {’s}2} {a parent} to do ? ⇒LABEL-NP
⇒COMB-2⇒ {{So}0, {what}1} {’s a parent} to do ? ⇒NO-LABEL

⇒SH⇒ {{So}0, {what}1, {’s a parent}2} {to} do ? ⇒NO-LABEL
⇒SH⇒ {{So}0, {what}1, {’s a parent}2, {to}5} {do} ? ⇒NO-LABEL

⇒COMB-1⇒ {{So}0, {’s a parent}2, {to}5} {what do} ? ⇒LABEL-VP
⇒COMB-5⇒ {{So}0, {’s a parent}2} {what to do} ? ⇒LABEL-VP
⇒COMB-2⇒ {{So}0} {what ’s a parent to do} ? ⇒LABEL-SQ
⇒COMB-0⇒ {} {so what ’s a parent to do} ? ⇒NO-LABEL

⇒SH⇒ {{So what ’s a parent to do}0} {?} ⇒NO-LABEL
⇒COMB-0⇒ {} {So what ’s a parent to do ?} ⇒LABEL-SBARQ

Table 2: Full derivation for the sentence in Figure 1. As a convention, we index elements in the set with their
left-index and use COMB-i to denote COMB-si. We also use tokens instead of their indexes for better legibility.

view of the memory (Section 3). However, we
score each possible combinations independently:
the score of a single combination only depends on
the two constituents that are combined, regardless
of the rest of the set.

2.1 System Description

Definitions We first define an instantiated (dis-
continuous) constituent (X, s) as a nonterminal la-
bel X associated with a set of token indexes s.
We call min(s) the left-index of c and max(s) its
right-index. For example in Figure 1, the two VPs
are respectively represented by (VP, {1, 6}) and
(VP, {1, 5, 6}), and they have the same right index
(6) and left index (1).

A parsing configuration is a quadruple
(S, sf , i, C) where:

• S is a set of sets of indexes and represents the
memory of the parser;
• sf is a set of indexes called the focus item,

and satisfies max(sf ) = i− 1;
• i is the index of the next token in the buffer;
• C is a set of instantiated constituents.

Each new constituent is constructed bottom-up
from the focus item and another item in the set S.

Transition set Our proposed transition system is
based on the following types of actions:

• SHIFT constructs a singleton containing the
next token in the buffer and assigns it as the
new focus item. The former focus item is
added to S.

• COMBINE-s computes the union between the
focus item sf and another item s from the set
S, to form the new focus item s ∪ sf .
• LABEL-X instantiates a new constituent
(X, sf ) whose yield is the set of indexes in
the focus item sf .
• NO-LABEL has no effect; its semantics is that

the current focus set is not a constituent.

Following Cross and Huang (2016b), transitions
are divided into structural actions (SHIFT, COM-
BINE-s) and labelling actions (LABEL-X, NO-
LABEL). The parser may only perform a structural
action on an even step and a labelling action on an
odd step. For our system, this distinction has the
crucial advantage of keeping the number of possi-
ble actions low at each parsing step, compared to a
system that would perform a COMBINE action and
a labelling action in a single REDUCE-s-X action.1

Table 1 presents each action as a deduction rule
associated with preconditions. In Table 2, we de-
scribe how to derive the tree from Figure 1.

2.2 Oracles

Training a transition-based parser requires an ora-
cle, i.e. a function that determines what the best
action is in a specific parsing configuration to
serve as a training signal. We first describe a static
oracle that provides a canonical derivation for a
given gold tree. We then introduce a dynamic or-
acle that determines what the best action is in any
parsing configuration.

1In such a case, we would need to score |S| × |N | + 1
actions, where N is the set of nonterminals, instead of |S|+1
actions for our system.



207

2.2.1 Static Oracle

Our transition system exhibits a fair amount of
spurious ambiguity, the ambiguity exhibited by
the existence of many possible derivations for a
single tree. Indeed, since we use an unordered
memory, an n-ary constituent (and more generally
a tree) can be constructed by many different tran-
sition sequences. For example, the set {0, 1, 2}
might be constructed by combining

• {0} and {1} first, and the result with {2}; or
• {1} and {2} first, and the result with {0}; or
• {0} and {2} first, and the result with {1}.

Following Cohen et al. (2012), we elimi-
nate spurious ambiguity by selecting a canonical
derivation for a gold tree. In particular, we design
the static oracle (i) to apply COMBINE as soon as
possible in order to minimize the size of the mem-
ory (ii) to combine preferably with the most recent
set in the memory when several combinations are
possible. The first choice is motivated by proper-
ties of our system: when the memory is smaller,
there are fewer choices, therefore decisions are
simpler and less expensive to score.

2.2.2 Dynamic Oracle

Parsers are usually trained to predict the gold se-
quence of actions, using a static oracle. The lim-
itation of this method is that the parser only sees
a tiny portion of the search space at train time and
only trains on gold input (i.e. configurations ob-
tained after performing gold actions). At test time,
it is in a different situation due to error propaga-
tion: it must predict what the best actions are in
configurations from which the gold tree is proba-
bly no longer reachable.

To alleviate this limitation, Goldberg and Nivre
(2012) proposed to train a parser with a dynamic
oracle, an oracle that is defined for any parsing
configuration and outputs the set of best actions to
perform. In contrast, a static oracle is determinis-
tic and is only defined for gold configurations.

Dynamic oracles were proposed for a wide
range of dependency parsing transition systems
(Goldberg and Nivre, 2013; Gómez-Rodrı́guez
et al., 2014; Gómez-Rodrı́guez and Fernández-
González, 2015), and later adapted to constituency
parsing (Coavoux and Crabbé, 2016; Cross and
Huang, 2016b; Fernández-González and Gómez-
Rodrı́guez, 2018b,a).

In the remainder of this section, we introduce
a dynamic oracle for our proposed transition sys-
tem. It can be seen as an extension of the oracle of
Cross and Huang (2016b) to the case of discontin-
uous parsing.

Preliminary definitions For a parsing configu-
ration c, the relation c ` c′ holds iff c′ can be
derived from c by a single transition. We note
`∗ the reflexive and transitive closure of `. An
instantiated constituent (X, s) is reachable from
a configuration c = (S, sf , i, C) iff there exists
c′ = (S′, s′f , i

′, C ′) such that (X, s) ∈ C ′ and
c `∗ c′. Similarly, a set of constituents t (possibly
a full discontinuous constituency tree) is reachable
iff there exists a configuration c′ = (S′, s′f , i

′, C ′)
such that t ⊆ C ′ and c `∗ c′. We note reach(c, t∗)
the set of constituents that are (i) in the gold set of
constituents t∗ (ii) reachable from c.

We define a total order � on index sets:

s � s′ ⇔


max(s) < max(s′),
or
max(s) = max(s′)
and s ⊆ s′.

This order naturally extends to the constituents of
a tree: (X, s) � (X ′, s′) iff s � s′. If (X, s)
precedes (X ′, s′), then (X, s) must be constructed
before (X ′, s′). Indeed, since the right-index of
the focus item is non-decreasing during a deriva-
tion (as per the transition definitions), constituents
are constructed in the order of their right-index
(first condition). Moreover, since the algorithm is
bottom-up, a constituent must be constructed be-
fore its parent (second condition).

From a configuration c = (S, sf , i, C) at an odd
step, a constituent (X, sg) /∈ C is reachable iff
both the following properties hold:

1. max(sf ) ≤ max(sg);
2. ∀s ∈ S ∪ {sf}, (s ⊆ sg) or (s ∩ sg = ∅).

Condition 1 is necessary because the parser can
only construct new constituents (X, s) such that
sf � s. Condition 2 makes sure that sg can be
constructed from a union of elements from S ∪
{sf}, potentially augmented with terminals from
the bufffer: {i, i+ 1, . . . ,max(sg)}.

Following Cross and Huang (2016b), we de-
fine next(c, t∗) as the smallest reachable gold con-
stituent from a configuration c. Formally:

next(c, t∗) = argmin
�

reach(c, t∗).



208

Oracle algorithm We first define the oracle
o for the odd step of a configuration c =
(S, sf , i, C):

oodd(c, t
∗) =

{
{LABEL-X} if ∃(X, sf ) ∈ t∗,
{NO-LABEL} otherwise.

For even steps, assuming next(c, t∗) = (X, sg),
we define the oracle as follows:

oeven(c, t
∗) =


{COMB-s|(sf ∪ s) ⊆ sg}

if max(sg) = max(sf ),
{COMB-s|(sf ∪ s) ⊆ sg} ∪ {SH}

if max(sg) > max(sf ).

We provide a proof of the correctness of the oracle
in Appendix A.

3 A Neural Network based on
Constituent Boundaries

We first present an encoder that computes context-
aware representations of tokens (Section 3.1). We
then discuss how to compute the representation of
a set of tokens (Section 3.2). We describe the ac-
tion scorer (Section 3.3), the POS tagging compo-
nent (Section 3.4), and the objective function (Sec-
tion 3.5).

3.1 Token Representations

As in recent proposals in dependency and con-
stituency parsing (Cross and Huang, 2016a; Kiper-
wasser and Goldberg, 2016), our scoring system
is based on a sentence transducer that constructs a
context-aware representation for each token.

Given a sequence of tokens xn1 = (x1, . . . , xn),
we first run a single-layer character bi-LSTM en-
coder c to obtain a character-aware embedding
c(xi) for each token. We represent a token xi
as the concatenation of a standard word embed-
ding e(xi) and the character-aware embedding:
wxi = [c(xi); e(xi)].

Then, we run a 2-layer bi-LSTM transducer
over the sequence of token representations:

(h
(1)
1 , . . . ,h

(1)
n ) = bi-LSTM(wx1 , . . . ,wxn),

(h
(2)
1 , . . . ,h

(2)
n ) = bi-LSTM(h

(1)
1 , . . . ,h

(1)
n ).

The parser uses the context-aware token represen-
tations h(2)i to construct vector representations of
sets or constituents.

3.2 Set Representations
An open issue in neural discontinuous parsing is
the representation of discontinuous constituents.
In projective constituency parsing, it has be-
come standard to use the boundaries of con-
stituents (Hall et al., 2014; Crabbé, 2015; Dur-
rett and Klein, 2015), an approach that proved
very successful with bi-LSTM token representa-
tions (Cross and Huang, 2016b; Stern et al., 2017).

Although constituent boundary features im-
proves discontinuous parsing (Coavoux and
Crabbé, 2017a), relying only on the left-index and
the right-index of a constituent has the limitation
of ignoring gaps inside a constituent. For exam-
ple, since the two VPs in Figure 1 have the same
right-index and left-index, they would have the
same representations. It may also happen that con-
stituents with identical right-index and left-index
do not have the same labels.

We represent a (possibly partial) constituent
with the yield s, by computing 4 indexes from s:
(min(s),max(s),min(s),max(s)). The set s rep-
resents the gap in s, i.e. the tokens between min(s)
and max(s) that are not in the yield of s:

s = {i|min(s) < i < max(s) and i /∈ s}.

Finally, we extract the corresponding token repre-
sentations of the 4 indexes and concatenate them
to form the vector representation r(s) of s:

r(s) = [h
(2)
min(s);h

(2)
max(s);h

(2)
min(s);h

(2)
max(s)].

For an index set that does not contain a gap, we
have s = ∅. To handle this case, we use a param-
eter vector hnil, randomly initialized and learned
jointly with the network, to embed max(∅) =
min(∅) = nil.

For example, the constituents (VP, {1, 6}) and
(VP, {1, 5, 6}) will be respectively vectorized as:

r({1, 6}) = [h(2)1 ;h
(2)
6 ;h

(2)
2 ;h

(2)
5 ],

r({1, 5, 6}) = [h(2)1 ;h
(2)
6 ;h

(2)
2 ;h

(2)
4 ].

This representation method makes sure that two
distinct index sets have distinct representations, as
long as they have at most one gap each. This prop-
erty no longer holds if one index sets has more
than one gap.

3.3 Action Scorer
For each type of action –structural or labelling– we
use a feedforward network with two hidden layers.



209

Structural actions At structural steps, for a
configuration c = (S, sf , i, C), we need to com-
pute the score of |S| COMBINE actions and pos-
sibly a SHIFT action. In our approach, the score
of a combine-s action only depends on s and sf
and is independent of the rest of the configuration
(i.e. other items in the set). We first construct input
matrix M as follows:

M =

(
r(s1) · · · r(sn) r({i})
r(sf ) · · · r(sf ) r(sf )

)
.

Each of the first n columns of matrix M represents
the input for a COMBINE action, whereas the last
column is the input for the SHIFT action. We then
compute the score of each structural action:

P (·|c) = Softmax(FFs(M)),

where FFs is a feedforward network with two hid-
den layers, a tanh activation and a single output
unit. In other words, it outputs a single scalar for
each column vector of matrix M . This part of the
network can be seen as an attention mechanism,
where the focus item is the query, and the context
is formed by the items in the set and the first ele-
ment in the buffer.

Labelling actions We compute the probabilities
of labelling actions as follows:

P (·|sf ) = Softmax(FFl(r(sf ))),

where FFl is a feedforward network with two hid-
den layers activated with the tanh function, and
|N |+1 output units, where N is the set of nonter-
minals.

3.4 POS Tagger

Following Coavoux and Crabbé (2017b), we use
the first layer of the bi-LSTM transducer as input
to a Part-of-Speech (POS) tagger that is learned
jointly with the parser. For a sentence xn1 , we
compute the probability of a sequence of POS tags
tn1 = (t1, . . . , tn) as follows:

P (tn1 |xn1 ) =
n∏

i=1

Softmax(W(t) · h(1)i + b
(t))ti ,

where W(t) and b(t) are parameters.

3.5 Objective Function

In the static oracle setting, for a single sen-
tence xn1 , we optimize the sum of the log-
likelihood of gold POS-tags tn1 and the log-
likelihood of gold parsing actions an1 :

L = Lt + Lp,

Lt = −
n∑

i=1

logP (ti|xn1 ),

Lp = −
4n−2∑
i=1

logP (ai|ai−11 , x
n
1 ).

We optimize this objective by alternating a
stochastic step for the tagging objective and a
stochastic step for the parsing objective, as is stan-
dard in multitask learning (Caruana, 1997).

In the dynamic oracle setting, instead of opti-
mizing the likelihood of the gold actions (assum-
ing all previous actions were gold), we optimize
the likelihood of the best actions, as computed by
the dynamic oracle, from a configuration sampled
from the space of all possible configurations. In
practice, before each epoch, we sample each sen-
tence from the training corpus with probability p
and we use the current (non-averaged) parameters
to parse the sentence and generate a sequence of
configurations. Instead of selecting the highest-
scoring action at each parsing step, as in a normal
inference step, we sample an action using the soft-
max distribution computed by the parser, as done
by Ballesteros et al. (2016). Then, we use the
dynamic oracle to calculate the best action from
each of these configurations. In case there are
several best actions, we deterministically choose
a single action by favoring a COMBINE over a
SHIFT (to bias the model towards a small mem-
ory), and to COMBINE with the item with the high-
est right-index (to avoid spurious discontinuity in
partial constituents). We train the parser on these
sequences of potentially non-gold configuration-
action pairs.

4 Experiments

We carried out experiments to assess the adequacy
of our system and the effect of training with the
dynamic oracle. We present the three discontin-
uous constituency treebanks that we used (Sec-
tion 4.1), our experimental protocol (Section 4.2),
then we discuss the results (Section 4.3) and the
efficiency of the parser (Section 4.4).



210

DPTB Tiger Negra

F1 Disc. F1 POS F1 Disc. F1 POS F1 Disc. F1 POS

static 91.1 68.2 97.2 87.4 61.7 98.3 83.6 51.3 97.9
dynamic 91.4 70.9 97.2 87.6 62.5 98.4 84.0 54.0 98.0

Table 3: Results on development corpora. F1 is the Fscore on all constituents, Disc. F1 is an Fscore computed only
on discontinuous constituents, POS is the accuracy on part-of-speech tags. Detailed results (including precision
and recall) are given in Table 7 of Appendix C.

English (DPTB) German (Tiger) German (Negra)

Model F Disc. F F Disc. F F Disc. F

Predicted POS tags or own tagging

This work, dynamic oracle 90.9 67.3 82.5 55.9 83.2 56.3

Coavoux et al. (2019),∗ GAP, bi-LSTM 91.0 71.3 82.7 55.9 83.2 54.6
Stanojević and Garrido Alhama (2017),∗ SWAP, stack/tree-LSTM 77.0
Coavoux and Crabbé (2017a), SR-GAP, perceptron 79.3
Versley (2016), pseudo-projective, chart-based 79.5
Corro et al. (2017),∗ bi-LSTM, Maximum Spanning Arborescence 89.2
van Cranenburgh et al. (2016), DOP, ≤ 40 87.0 74.8
Fernández-González and Martins (2015), dependency-based 77.3
Gebhardt (2018), LCFRS with latent annotations 75.1

Gold POS tags

Stanojević and Garrido Alhama (2017),∗ SWAP, stack/tree-LSTM 81.6 82.9
Coavoux and Crabbé (2017a), SR-GAP, perceptron 81.6 49.2 82.2 50.0
Maier (2015), SWAP, perceptron 74.7 18.8 77.0 19.8
Corro et al. (2017),∗ bi-LSTM, Maximum Spanning Arborescence 90.1 81.6
Evang and Kallmeyer (2011), PLCFRS, < 25 79†

Table 4: Discontinuous parsing results on the test sets. ∗Neural scoring system. †Does not discount root symbols
and punctuation.

4.1 Datasets

We perform experiments on three discontinuous
constituency corpora. The discontinuous Penn
Treebank was introduced by Evang and Kallmeyer
(2011) who converted the long distance depen-
dencies encoded by indexed traces in the original
Penn treebank (Marcus et al., 1993) to discontinu-
ous constituents. We used the standard split (sec-
tions 2-21 for training, 22 for development and
23 for test). The Tiger corpus (Brants et al., 2004)
and the Negra corpus (Skut et al., 1997) are both
German treebanks natively annotated with discon-
tinuous constituents. We used the SPMRL split for
the Tiger corpus (Seddah et al., 2013), and the split
of Dubey and Keller (2003) for the Negra corpus.

4.2 Implementation and Protocol

We implemented our parser in Python using the
Pytorch library (Paszke et al., 2017). We trained
each model with the ASGD algorithm (Polyak and

Juditsky, 1992) for 100 epochs. Training a single
model takes approximately a week with a GPU.
We evaluate a model every 4 epochs on the val-
idation set and select the best performing model
according to the validation F-score. We refer the
reader to Table 5 of Appendix B for the full list of
hyperparameters.

We evaluate models with the dedicated mod-
ule of discodop2 (van Cranenburgh et al.,
2016). We use the standard evaluation parame-
ters (proper.prm), that ignore punctuations and
root symbols. We report two evaluation metrics: a
standard Fscore (F) and an Fscore computed only
on discontinuous constituents (Disc. F), which
provides a more qualitative evaluation of the abil-
ity of the parser to recover long distance depen-
dencies.

2https://github.com/andreasvc/
disco-dop

https://github.com/andreasvc/disco-dop
https://github.com/andreasvc/disco-dop


211

4.3 Results

Effect of Dynamic Oracle We present parsing
results on the development sets of each corpus in
Table 3. The effect of the oracle is in line with
other published results in projective constituency
parsing (Coavoux and Crabbé, 2016; Cross and
Huang, 2016b) and dependency parsing (Goldberg
and Nivre, 2012; Gómez-Rodrı́guez et al., 2014):
the dynamic oracle improves the generalization
capability of the parser.

External comparisons In Table 4, we com-
pare our parser to other transition-based parsers
(Maier, 2015; Coavoux and Crabbé, 2017a; Stano-
jević and Garrido Alhama, 2017; Coavoux et al.,
2019), the pseudo-projective parser of Versley
(2016), grammar-based chart parsers (Evang and
Kallmeyer, 2011; van Cranenburgh et al., 2016;
Gebhardt, 2018) and parsers based on dependency
parsing (Fernández-González and Martins, 2015;
Corro et al., 2017). Note that some of them only
report results in a gold POS tag setting (the parser
has access to gold POS tags and use them as fea-
tures), a setting that is much easier than ours.

Our parser matches the state of the art of
Coavoux et al. (2019). This promising result
shows that it is feasible to design accurate tran-
sition systems without an ordered memory.

4.4 Efficiency

Our transition system derives a tree for a sentence
of n words in exactly 4n − 2 transitions. Indeed,
there must be n SHIFT actions, and n−1 COMBINE
actions. Each of these 2n − 1 transitions must be
followed by a single labelling action.

The statistical model responsible for choosing
which action to perform at each parsing step needs
to score |S| + 1 actions for a structural step and
|N |+1 actions for a labelling step (where N is the
set of possible nonterminals). Since in the worst
case, |S| contains n− 1 singletons, the parser has
an O(n(|N |+ n)) time complexity.

In practice, the memory of the parser S remains
relatively small on average. We report in Figure 3
the distribution of the size of S across configura-
tions when parsing the development sets of three
corpora. For the German treebanks, the memory
contains 7 or fewer elements for more than 99 per-
cents of configurations. For the Penn treebank, the
memory is slighlty larger, with 98 percents of con-
figuration with 11 or fewer items.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
Size of the memory (S)

101

102

103

104

Nu
m

be
r o

f c
on

fig
ur

at
io

ns
 (l

og
 sc

al
e)

11.7%
16.9%

14.1%12.8%11.3%
9.2%

7.1%
5.2%

3.8%
2.7%

1.9%
1.2%

0.8%
0.5%

0.3%

0.2%

0.1%

0.1%

0.0%

0.0%

0.0%0.0%0.0%

0.0%

DPTB

0 1 2 3 4 5 6 7 8 9 10 11 12 13
Size of the memory (S)

101

102

103

104

Nu
m

be
r o

f c
on

fig
ur

at
io

ns
 (l

og
 sc

al
e)

20.2%
30.9%

23.2%
14.0%

6.9%

3.0%

1.1%

0.4%

0.1%

0.0%

0.0%

0.0%

0.0%

0.0%

Tiger

0 1 2 3 4 5 6 7 8 9 10 11 12
Size of the memory (S)

100

101

102

103

104

Nu
m

be
r o

f c
on

fig
ur

at
io

ns
 (l

og
 sc

al
e)

18.5%
28.3%

22.1%
15.0%

8.6%

4.3%

2.0%

0.8%

0.3%

0.1%

0.0%

0.0%

0.0%

Negra

Figure 3: Distribution of the size of the memory of the
parser S across configurations derived when parsing
the development set of the three corpora. In practice,
we observe that the memory remains small.

We report empirical runtimes in Table 6 of
Appendix C. Our parser compares decently with
other transition-based parsers, despite being writ-
ten in Python.

5 Related Work

Existing transition systems for discontinuous con-
stituency parsing rely on three main strategies for
constructing discontinuous constituents: a swap-



212

based strategy, a split-stack strategy, and the use
of non-local transitions.

Swap-based systems Swap-based transition
systems are based on the idea that any discon-
tinuous constituency tree can be transformed
into a projective tree by reordering terminals.
They reorder terminals by swapping them with
a dedicated action (SWAP), commonly used in
dependency parsing (Nivre, 2009). The first
proposals in transition-based discontinuous
constituency parsing used the SWAP action on
top of an easy-first parser (Versley, 2014a,b).
Subsequent proposals relied on a shift-reduce
system (Maier, 2015; Maier and Lichte, 2016)
or a shift-promote-adjoin system (Stanojević and
Garrido Alhama, 2017).

The main limitation of swap-based system is
that they tend to require a large number of tran-
sitions to derive certain trees. The choice of
an oracle that minimizes derivation lengths has
a substantially positive effect on parsing (Maier
and Lichte, 2016; Stanojević and Garrido Alhama,
2017).

Split-stack systems The second parsing strat-
egy constructs discontinuous constituents by al-
lowing the parser to reduce pairs of items that are
not adjacent in the stack. In practice, Coavoux
and Crabbé (2017a) split the usual stack of shift-
reduce parsers into two data structures (a stack and
a double-ended queue), in order to give the parser
access to two focus items: the respective tops of
the stack and the dequeue, that may or may not be
adjacent. A dedicated action, GAP, pushes the top
of the stack onto the bottom of the queue to make
the next item in the stack available for a reduction.

The split stack associated with the GAP action
can be interpreted as a linear-access memory: it is
possible to access the ith element in the stack, but
it requires i operations.

Non-local transitions Non-local transitions
generalize standard parsing actions to non-
adjacent elements in the parsing configurations.
Maier and Lichte (2016) introduced a non-local
transition SKIPSHIFT-i which applies SHIFT to
the ith element in the buffer. Non-local transitions
are also widely used in non-projective dependency
parsing (Attardi, 2006; Qi and Manning, 2017;
Fernández-González and Gómez-Rodrı́guez,
2018).

The key difference between these systems and
ours is that we use an unordered memory. As a
result, the semantics of the COMBINE-s action we
introduce in Section 2 is independent from a spe-
cific position in the stack or the buffer. A sys-
tem with an action such as SKIPSHIFT-i needs to
learn parameters with every possible i, and will
only learn parameters with the SKIPSHIFT-i ac-
tions that are required to derive the training set. In
contrast, we use the same parameters to score each
possible COMBINE-s action.

6 Conclusion

We have presented a novel transition system that
dispenses with the use of a stack, i.e. a mem-
ory with linear sequential access. Instead, the
memory of the parser is represented by an un-
ordered data structure with random-access: a set.
We have designed a dynamic oracle for the re-
sulting system and shown their empirical potential
with state-of-the-art results on discontinuous con-
stituency parsing of one English and two German
treebanks. Finally, we plan to adapt our system to
non-projective dependency parsing and semantic
graph parsing.

Acknowledgments

We thank Caio Corro, Giorgio Satta, Marco Da-
monte, as well as NAACL anonymous reviewers
for feedback and suggestions. We gratefully ac-
knowledge the support of Huawei Technologies.

References

Giuseppe Attardi. 2006. Experiments with a multilan-
guage non-projective dependency parser. In Pro-
ceedings of the Tenth Conference on Computational
Natural Language Learning (CoNLL-X), pages 166–
170. Association for Computational Linguistics.

Miguel Ballesteros, Yoav Goldberg, Chris Dyer, and
Noah A. Smith. 2016. Training with exploration im-
proves a greedy stack lstm parser. In Proceedings of
the 2016 Conference on Empirical Methods in Natu-
ral Language Processing, pages 2005–2010, Austin,
Texas. Association for Computational Linguistics.

Léon Bottou. 2010. Large-scale machine learning
with stochastic gradient descent. In Proceedings
of the 19th International Conference on Compu-
tational Statistics (COMPSTAT’2010), pages 177–
187, Paris, France. Springer.

http://www.aclweb.org/anthology/W06-2922
http://www.aclweb.org/anthology/W06-2922
https://doi.org/10.18653/v1/D16-1211
https://doi.org/10.18653/v1/D16-1211
http://leon.bottou.org/papers/bottou-2010
http://leon.bottou.org/papers/bottou-2010


213

Sabine Brants, Stefanie Dipper, Peter Eisenberg, Sil-
via Hansen-Schirra, Esther König, Wolfgang Lezius,
Christian Rohrer, George Smith, and Hans Uszkor-
eit. 2004. Tiger: Linguistic interpretation of a ger-
man corpus. Research on Language and Computa-
tion, 2(4):597–620.

Rich Caruana. 1997. Multitask learning. Machine
Learning, 28(1):41–75.

Maximin Coavoux and Benoit Crabbé. 2016. Neural
greedy constituent parsing with dynamic oracles. In
Proceedings of the 54th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 172–182, Berlin, Germany. As-
sociation for Computational Linguistics.

Maximin Coavoux and Benoit Crabbé. 2017a. Incre-
mental discontinuous phrase structure parsing with
the gap transition. In Proceedings of the 15th Con-
ference of the European Chapter of the Association
for Computational Linguistics: Volume 1, Long Pa-
pers, pages 1259–1270, Valencia, Spain. Associa-
tion for Computational Linguistics.

Maximin Coavoux and Benoit Crabbé. 2017b. Multi-
lingual lexicalized constituency parsing with word-
level auxiliary tasks. In Proceedings of the 15th
Conference of the European Chapter of the Associa-
tion for Computational Linguistics: Volume 2, Short
Papers, pages 331–336, Valencia, Spain. Associa-
tion for Computational Linguistics.

Maximin Coavoux, Benoı̂t Crabbé, and Shay B. Cohen.
2019. Unlexicalized transition-based discontinuous
constituency parsing. CoRR, abs/1902.08912v1.

Shay B. Cohen, Carlos Gómez-Rodrı́guez, and Gior-
gio Satta. 2012. Elimination of spurious ambigu-
ity in transition-based dependency parsing. CoRR,
abs/1206.6735.

Caio Corro, Joseph Le Roux, and Mathieu Lacroix.
2017. Efficient discontinuous phrase-structure pars-
ing via the generalized maximum spanning arbores-
cence. In Proceedings of the 2017 Conference on
Empirical Methods in Natural Language Process-
ing, pages 1645–1655, Copenhagen, Denmark. As-
sociation for Computational Linguistics.

Benoit Crabbé. 2015. Multilingual discriminative lex-
icalized phrase structure parsing. In Proceedings of
the 2015 Conference on Empirical Methods in Nat-
ural Language Processing, pages 1847–1856, Lis-
bon, Portugal. Association for Computational Lin-
guistics.

Andreas van Cranenburgh, Remko Scha, and Rens
Bod. 2016. Data-oriented parsing with discontinu-
ous constituents and function tags. Journal of Lan-
guage Modelling, 4(1):57–111.

James Cross and Liang Huang. 2016a. Incremental
parsing with minimal features using bi-directional
LSTM. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers), pages 32–37, Berlin, Ger-
many. Association for Computational Linguistics.

James Cross and Liang Huang. 2016b. Span-based
constituency parsing with a structure-label system
and provably optimal dynamic oracles. In Proceed-
ings of the 2016 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1–11,
Austin, Texas. Association for Computational Lin-
guistics.

Amit Dubey and Frank Keller. 2003. Probabilistic
parsing for german using sister-head dependencies.
In Proceedings of the 41st Annual Meeting of the As-
sociation for Computational Linguistics, pages 96–
103, Sapporo, Japan. Association for Computational
Linguistics.

Greg Durrett and Dan Klein. 2015. Neural CRF pars-
ing. In Proceedings of the 53rd Annual Meet-
ing of the Association for Computational Linguis-
tics and the 7th International Joint Conference on
Natural Language Processing (Volume 1: Long Pa-
pers), pages 302–312, Beijing, China. Association
for Computational Linguistics.

Kilian Evang and Laura Kallmeyer. 2011. PLCFRS
parsing of english discontinuous constituents. In
Proceedings of the 12th International Conference on
Parsing Technologies, pages 104–116, Dublin, Ire-
land. Association for Computational Linguistics.

Daniel Fernández-González and Carlos Gómez-
Rodrı́guez. 2018. Non-projective dependency
parsing with non-local transitions. In Proceedings
of the 2018 Conference of the North American
Chapter of the Association for Computational Lin-
guistics: Human Language Technologies, Volume
2 (Short Papers), pages 693–700. Association for
Computational Linguistics.

Daniel Fernández-González and Carlos Gómez-
Rodrı́guez. 2018a. Dynamic oracles for top-down
and in-order shift-reduce constituent parsing. In
Proceedings of the 2018 Conference on Empirical
Methods in Natural Language Processing, pages
1303–1313, Brussels, Belgium. Association for
Computational Linguistics.

Daniel Fernández-González and Carlos Gómez-
Rodrı́guez. 2018b. Faster shift-reduce constituent
parsing with a non-binary, bottom-up strategy.
CoRR, abs/1804.07961.

Daniel Fernández-González and André F. T. Martins.
2015. Parsing as reduction. In Proceedings of the
53rd Annual Meeting of the Association for Compu-
tational Linguistics and the 7th International Joint
Conference on Natural Language Processing (Vol-
ume 1: Long Papers), pages 1523–1533, Beijing,
China. Association for Computational Linguistics.

https://doi.org/10.1007/s11168-004-7431-3
https://doi.org/10.1007/s11168-004-7431-3
https://doi.org/10.1023/A:1007379606734
http://www.aclweb.org/anthology/P16-1017
http://www.aclweb.org/anthology/P16-1017
http://www.aclweb.org/anthology/E17-1118
http://www.aclweb.org/anthology/E17-1118
http://www.aclweb.org/anthology/E17-1118
http://www.aclweb.org/anthology/E17-2053
http://www.aclweb.org/anthology/E17-2053
http://www.aclweb.org/anthology/E17-2053
http://arxiv.org/abs/arXiv:1902.08912v1
http://arxiv.org/abs/arXiv:1902.08912v1
http://arxiv.org/abs/1206.6735
http://arxiv.org/abs/1206.6735
https://www.aclweb.org/anthology/D17-1172
https://www.aclweb.org/anthology/D17-1172
https://www.aclweb.org/anthology/D17-1172
http://aclweb.org/anthology/D15-1212
http://aclweb.org/anthology/D15-1212
http://dx.doi.org/10.15398/jlm.v4i1.100
http://dx.doi.org/10.15398/jlm.v4i1.100
http://anthology.aclweb.org/P16-2006
http://anthology.aclweb.org/P16-2006
http://anthology.aclweb.org/P16-2006
https://aclweb.org/anthology/D16-1001
https://aclweb.org/anthology/D16-1001
https://aclweb.org/anthology/D16-1001
https://doi.org/10.3115/1075096.1075109
https://doi.org/10.3115/1075096.1075109
http://www.aclweb.org/anthology/P15-1030
http://www.aclweb.org/anthology/P15-1030
http://www.aclweb.org/anthology/W11-2913
http://www.aclweb.org/anthology/W11-2913
https://doi.org/10.18653/v1/N18-2109
https://doi.org/10.18653/v1/N18-2109
http://www.aclweb.org/anthology/D18-1161
http://www.aclweb.org/anthology/D18-1161
http://arxiv.org/abs/1804.07961
http://arxiv.org/abs/1804.07961
http://www.aclweb.org/anthology/P15-1147


214

Kilian Gebhardt. 2018. Generic refinement of expres-
sive grammar formalisms with an application to dis-
continuous constituent parsing. In Proceedings of
the 27th International Conference on Computational
Linguistics, pages 3049–3063, Santa Fe, New Mex-
ico, USA. Association for Computational Linguis-
tics.

Xavier Glorot and Yoshua Bengio. 2010. Understand-
ing the difficulty of training deep feedforward neu-
ral networks. In In Proceedings of the International
Conference on Artificial Intelligence and Statistics
(AISTATS10). Society for Artificial Intelligence and
Statistics.

Yoav Goldberg and Joakim Nivre. 2012. A dynamic or-
acle for arc-eager dependency parsing. In Proceed-
ings of COLING 2012, pages 959–976, Mumbai, In-
dia. The COLING 2012 Organizing Committee.

Yoav Goldberg and Joakim Nivre. 2013. Training de-
terministic parsers with non-deterministic oracles.
Transactions of the Association for Computational
Linguistics, 1:403–414.

Carlos Gómez-Rodrı́guez and Daniel Fernández-
González. 2015. An efficient dynamic oracle for
unrestricted non-projective parsing. In Proceedings
of the 53rd Annual Meeting of the Association for
Computational Linguistics and the 7th International
Joint Conference on Natural Language Processing
(Volume 2: Short Papers), pages 256–261, Beijing,
China. Association for Computational Linguistics.

Carlos Gómez-Rodrı́guez, Francesco Sartorio, and
Giorgio Satta. 2014. A polynomial-time dy-
namic oracle for non-projective dependency pars-
ing. In Proceedings of the 2014 Conference on
Empirical Methods in Natural Language Processing
(EMNLP), pages 917–927, Doha, Qatar. Association
for Computational Linguistics.

David Hall, Greg Durrett, and Dan Klein. 2014. Less
grammar, more features. In Proceedings of the
52nd Annual Meeting of the Association for Com-
putational Linguistics (Volume 1: Long Papers),
pages 228–237, Baltimore, Maryland. Association
for Computational Linguistics.

Laura Kallmeyer. 2010. Parsing Beyond Context-Free
Grammars, 1st edition. Springer Publishing Com-
pany, Incorporated.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional LSTM feature representations. Transactions
of the Association for Computational Linguistics,
4:313–327.

Wolfgang Maier. 2015. Discontinuous incremental
shift-reduce parsing. In Proceedings of the 53rd An-
nual Meeting of the Association for Computational
Linguistics and the 7th International Joint Confer-
ence on Natural Language Processing (Volume 1:
Long Papers), pages 1202–1212, Beijing, China.
Association for Computational Linguistics.

Wolfgang Maier and Timm Lichte. 2016. Discontinu-
ous parsing with continuous trees. In Proceedings of
the Workshop on Discontinuous Structures in Natu-
ral Language Processing, pages 47–57, San Diego,
California. Association for Computational Linguis-
tics.

Mitchell Marcus, Beatrice Santorini, and Mary
Ann Marcinkiewicz. 1993. Building a large anno-
tated corpus of english: The penn treebank. Com-
putational Linguistics, Volume 19, Number 2, June
1993, Special Issue on Using Large Corpora: II.

Arvind Neelakantan, Luke Vilnis, Quoc V. Le, Ilya
Sutskever, Lukasz Kaiser, Karol Kurach, and
James Martens. 2015. Adding gradient noise im-
proves learning for very deep networks. CoRR,
abs/1511.06807.

Joakim Nivre. 2009. Non-projective dependency pars-
ing in expected linear time. In Proceedings of the
Joint Conference of the 47th Annual Meeting of the
ACL and the 4th International Joint Conference on
Natural Language Processing of the AFNLP, pages
351–359, Suntec, Singapore. Association for Com-
putational Linguistics.

Adam Paszke, Sam Gross, Soumith Chintala, Gre-
gory Chanan, Edward Yang, Zachary DeVito, Zem-
ing Lin, Alban Desmaison, Luca Antiga, and Adam
Lerer. 2017. Automatic differentiation in pytorch.
In NIPS-W.

Boris T. Polyak and Anatoli B. Juditsky. 1992. Ac-
celeration of stochastic approximation by averag-
ing. SIAM Journal on Control and Optimization,
30(4):838–855.

Peng Qi and Christopher D. Manning. 2017. Arc-swift:
A novel transition system for dependency parsing.
In Proceedings of the 55th Annual Meeting of the
Association for Computational Linguistics (Volume
2: Short Papers), pages 110–117. Association for
Computational Linguistics.

Djamé Seddah, Reut Tsarfaty, Sandra Kübler, Marie
Candito, Jinho D. Choi, Richárd Farkas, Jen-
nifer Foster, Iakes Goenaga, Koldo Gojenola Gal-
letebeitia, Yoav Goldberg, Spence Green, Nizar
Habash, Marco Kuhlmann, Wolfgang Maier, Joakim
Nivre, Adam Przepiórkowski, Ryan Roth, Wolfgang
Seeker, Yannick Versley, Veronika Vincze, Marcin
Woliński, Alina Wróblewska, and Eric Villemonte
de la Clergerie. 2013. Overview of the SPMRL 2013
shared task: A cross-framework evaluation of pars-
ing morphologically rich languages. In Proceed-
ings of the Fourth Workshop on Statistical Parsing of
Morphologically-Rich Languages, pages 146–182,
Seattle, Washington, USA. Association for Compu-
tational Linguistics.

http://www.aclweb.org/anthology/C18-1258
http://www.aclweb.org/anthology/C18-1258
http://www.aclweb.org/anthology/C18-1258
http://www.aclweb.org/anthology/C12-1059
http://www.aclweb.org/anthology/C12-1059
http://aclweb.org/anthology/Q13-1033
http://aclweb.org/anthology/Q13-1033
http://www.aclweb.org/anthology/P15-2042
http://www.aclweb.org/anthology/P15-2042
http://www.aclweb.org/anthology/D14-1099
http://www.aclweb.org/anthology/D14-1099
http://www.aclweb.org/anthology/D14-1099
http://www.aclweb.org/anthology/P14-1022
http://www.aclweb.org/anthology/P14-1022
https://transacl.org/ojs/index.php/tacl/article/view/885
https://transacl.org/ojs/index.php/tacl/article/view/885
https://transacl.org/ojs/index.php/tacl/article/view/885
http://www.aclweb.org/anthology/P15-1116
http://www.aclweb.org/anthology/P15-1116
http://www.aclweb.org/anthology/W16-0906
http://www.aclweb.org/anthology/W16-0906
http://aclweb.org/anthology/J93-2004
http://aclweb.org/anthology/J93-2004
http://arxiv.org/abs/1511.06807
http://arxiv.org/abs/1511.06807
http://www.aclweb.org/anthology/P/P09/P09-1040
http://www.aclweb.org/anthology/P/P09/P09-1040
https://doi.org/10.1137/0330046
https://doi.org/10.1137/0330046
https://doi.org/10.1137/0330046
https://doi.org/10.18653/v1/P17-2018
https://doi.org/10.18653/v1/P17-2018
http://www.aclweb.org/anthology/W13-4917
http://www.aclweb.org/anthology/W13-4917
http://www.aclweb.org/anthology/W13-4917


215

Wojciech Skut, Brigitte Krenn, Thorsten Brants, and
Hans Uszkoreit. 1997. An annotation scheme for
free word order languages. In Proceedings of the
Fifth Conference on Applied Natural Language Pro-
cessing, pages 88–95, Washington, DC, USA. Asso-
ciation for Computational Linguistics.

Miloš Stanojević and Raquel Garrido Alhama. 2017.
Neural discontinuous constituency parsing. In Pro-
ceedings of the 2017 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1667–
1677, Copenhagen, Denmark. Association for Com-
putational Linguistics.

Mitchell Stern, Jacob Andreas, and Dan Klein. 2017. A
minimal span-based neural constituency parser. In
Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 818–827, Vancouver, Canada.
Association for Computational Linguistics.

Yannick Versley. 2014a. Experiments with easy-first
nonprojective constituent parsing. In Proceedings
of the First Joint Workshop on Statistical Parsing
of Morphologically Rich Languages and Syntactic
Analysis of Non-Canonical Languages, pages 39–
53, Dublin, Ireland. Dublin City University.

Yannick Versley. 2014b. Incorporating semi-
supervised features into discontinuous easy-first
constituent parsing. CoRR, abs/1409.3813.

Yannick Versley. 2016. Discontinuity reˆ2-visited: A
minimalist approach to pseudoprojective constituent
parsing. In Proceedings of the Workshop on Discon-
tinuous Structures in Natural Language Processing,
pages 58–69, San Diego, California. Association for
Computational Linguistics.

K. Vijay-Shanker, David J. Weir, and Aravind K. Joshi.
1987. Characterizing structural descriptions pro-
duced by various grammatical formalisms. In 25th
Annual Meeting of the Association for Computa-
tional Linguistics.

A Oracle Correctness

The oracle o leads to the reachable tree with the
highest F-score with respect to the gold tree. The
F-score of a predicted tree t̂ (represented as a set
of instantiated constituents) with respect to a gold
tree t∗ is defined as:

precision(t̂, t∗) = p =
|t̂ ∩ t∗|
|t̂|

,

recall(t̂, t∗) = r =
|t̂ ∩ t∗|
|t∗|

,

F1(t̂, t
∗) =

2pr

p+ r
.

By definition, oodd is optimal for precision be-
cause it constructs a constituent only if it is gold,
and optimal for recall because it will construct a
gold constituent if it is possible to do so.

Moreover, oeven is optimal for recall because
any gold constituent reachable from c will still
be reachable after any transition in oeven(c, t∗).
Assuming a configuration c = (S, sf , i, C) and
next(c, t∗) = sg, we consider separately the SHIFT
case and the COMBINE-s case:

• SHIFT case (max(sg) > max(sf )): con-
stituents (X, s) reachable from c and not
reachable from SHIFT(c) satisfy max(s) = i.
If a gold constituent satisfies this property, we
have s � sg, which contradicts the assump-
tion that sg = next(c, t∗) (see definition of
oracle in Section 2.2.2).
• COMBINE-s case: Let (X, s′) be a reachable

gold constituent. Since it is compatible with
sg, there are three possible cases:

– if (X, s′) is an ascendant of sg, then (s∪
sf ) ⊆ sg ⊂ s′, therefore (X, s′) is still
reachable from COMBINE-s(c).

– if (X, s′) is a descendant of sg then s′ �
sg, which contradicts the definition of
sg.

– if s′ and sg are completely disjoint, we
have s′ ∩ s = s′ ∩ sf = ∅, therefore
s′∩(s∪sf ) = ∅, and s′ is still reachable
from COMBINE-s(c).

Finally, since oeven does not construct new con-
stituents (it is the role of labelling actions), it is
optimal for precision.

B Hyperparameters

The list of hyperparameters is presented in Ta-
ble 5.

• We use learning rate warm-up (linear in-
crease from 0 to t1000 during the first 1000
steps).
• Before the tth update, we add Gaussian

noise to the gradient of every parameter with

mean 0 and variance
0.01

(1 + t)0.55
(Neelakan-

tan et al., 2015).
• All experiments use greedy search decoding

(we did not experiment with beam search).

https://doi.org/10.3115/974557.974571
https://doi.org/10.3115/974557.974571
https://www.aclweb.org/anthology/D17-1174
http://aclweb.org/anthology/P17-1076
http://aclweb.org/anthology/P17-1076
http://www.aclweb.org/anthology/W14-6104
http://www.aclweb.org/anthology/W14-6104
http://arxiv.org/abs/1409.3813
http://arxiv.org/abs/1409.3813
http://arxiv.org/abs/1409.3813
http://www.aclweb.org/anthology/W16-0907
http://www.aclweb.org/anthology/W16-0907
http://www.aclweb.org/anthology/W16-0907
http://aclanthology.coli.uni-saarland.de/pdf/P/P87/P87-1015.pdf
http://aclanthology.coli.uni-saarland.de/pdf/P/P87/P87-1015.pdf


216

Architecture hyperparameters

Dimension of word embeddings 32
Dimension of character embeddings 100
Dimension of character bi-LSTM state 50 for each direction
Dimension of sentence-level bi-LSTM 200 for each direction
Dimension of hidden layers for the action scorer 200
Activation functions tanh for all hidden layers

Optimization hyperparameters

Initial learning rate l0 = 0.01

Learning rate decay lt =
l0

1 + t · 10−7
for step number t

Dropout for tagger input 0.5
Dropout for parser input 0.2
Training epochs 100
Batch size 1 sentence
Optimization algorithm Averaged SGD (Polyak and Juditsky, 1992; Bottou, 2010)
Word and character embedding initialization U([−0.1, 0.1])
Other parameters initialization (including LSTMs) Xavier (Glorot and Bengio, 2010)
Gradient clipping (norm) 100
Dynamic oracle p 0.15

Table 5: Hyperparameters of the model.

Parser Setting Tiger DPTB

tok/s sent/s tok/s sent/s

This work Python, neural, greedy, CPU 978 64 910 38

MTG (Coavoux et al., 2019) C++, neural, greedy, CPU 1934 126 1887 80
MTG (Coavoux and Crabbé, 2017a) C++, perceptron, beam=4, CPU 4700 260
rparse (Maier, 2015) Java, perceptron, beam=8, CPU 80
rparse (Maier, 2015) Java, perceptron, beam=1, CPU 640
Corro et al. (2017) C++, neural, CPU ≈ 7.3

Table 6: Parsing times on development sets in tokens per second (tok/s) and sentences per second (sent/s). The
parsing times are presented as reported by authors, they are not comparable across parsers (since the experiments
were run on different hardware). Our parser is run on a single core of an Intel i7 CPU.

• Before each training step, we replace a word
embedding by an ‘UNK’ pseudo-word em-
bedding with probability 0.3. We only do this
replacement for the least frequent word-types
(23 least frequent word-types). The ‘UNK’
embedding is then used to represent unknown
words.
• We apply dropout at the input of the tagger

and the input of action scorers: each single
prediction has its own dropout mask.

C Detailed Results

We report indicative parsing times in Table 6. De-
tailed parsing results —including precision, recall,
F-score and part-of-speech tag accuracy— are pre-
sented in Table 7.



217

All const. Disc. const. POS
Development sets F P R F P R Acc.

English (DPTB) static 91.1 91.1 91.2 68.2 75.3 62.3 97.2
dynamic 91.4 91.5 91.3 70.9 76.1 66.4 97.2

German (Tiger) static 87.4 87.8 87.0 61.7 64.4 59.2 98.3
dynamic 87.6 88.2 87.0 62.5 68.6 57.3 98.4

German (Negra) static 83.6 83.8 83.4 51.3 53.3 49.5 97.9
dynamic 84.0 84.7 83.4 54.0 58.1 50.5 98.0

Test sets F P R F P R Acc.

English (DPTB) dynamic 90.9 91.3 90.6 67.3 73.3 62.1 97.6
German (Tiger) dynamic 82.5 83.5 81.5 55.9 62.4 50.6 98.0
German (Negra) dynamic 83.2 83.8 82.6 56.3 64.9 49.8 98.0

Table 7: Detailed results. Overall, the positive effect of the dynamic oracle on F-score is explained by its effect on
precision.


