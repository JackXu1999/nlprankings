



















































Universal Dependency Parsing for Hindi-English Code-Switching


Proceedings of NAACL-HLT 2018, pages 987–998
New Orleans, Louisiana, June 1 - 6, 2018. c©2018 Association for Computational Linguistics

Universal Dependency Parsing for Hindi-English Code-switching

Irshad Ahmad Bhat
LTRC, IIIT-H,

Hyderabad, India
irshad.bhat@iiit.ac.in

Riyaz Ahmad Bhat
Interaction Labs,
Bangalore, India

rbhat@interactions.com

Manish Shrivastava
LTRC, IIIT-H,

Hyderabad, India
m.shrivastava@iiit.ac.in

Dipti Misra Sharma
LTRC, IIIT-H,

Hyderabad, India
dipti@iiit.ac.in

Abstract
Code-switching is a phenomenon of mixing
grammatical structures of two or more lan-
guages under varied social constraints. The
code-switching data differ so radically from
the benchmark corpora used in NLP com-
munity that the application of standard tech-
nologies to these data degrades their perfor-
mance sharply. Unlike standard corpora, these
data often need to go through additional pro-
cesses such as language identification, nor-
malization and/or back-transliteration for their
efficient processing. In this paper, we in-
vestigate these indispensable processes and
other problems associated with syntactic pars-
ing of code-switching data and propose meth-
ods to mitigate their effects. In particular, we
study dependency parsing of code-switching
data of Hindi and English multilingual speak-
ers from Twitter. We present a treebank
of Hindi-English code-switching tweets under
Universal Dependencies scheme and propose
a neural stacking model for parsing that effi-
ciently leverages part-of-speech tag and syn-
tactic tree annotations in the code-switching
treebank and the preexisting Hindi and En-
glish treebanks. We also present normaliza-
tion and back-transliteration models with a
decoding process tailored for code-switching
data. Results show that our neural stacking
parser is 1.5% LAS points better than the aug-
mented parsing model and our decoding pro-
cess improves results by 3.8% LAS points
over the first-best normalization and/or back-
transliteration.

1 Introduction

Code-switching1 (henceforth CS) is the juxtaposi-
tion, within the same speech utterance, of gram-
matical units such as words, phrases, and clauses

1Code-mixing is another term in the linguistics literature
used interchangeably with code-switching. Both terms are of-
ten used to refer to the same or similar phenomenon of mixed
language use.

belonging to two or more different languages
(Gumperz, 1982). The phenomenon is prevalent in
multilingual societies where speakers share more
than one language and is often prompted by mul-
tiple social factors (Myers-Scotton, 1995). More-
over, code-switching is mostly prominent in col-
loquial language use in daily conversations, both
online and offline.

Most of the benchmark corpora used in NLP for
training and evaluation are based on edited mono-
lingual texts which strictly adhere to the norms of
a language related, for example, to orthography,
morphology, and syntax. Social media data in gen-
eral and CS data, in particular, deviate from these
norms implicitly set forth by the choice of corpora
used in the community. This is the reason why the
current technologies often perform miserably on
social media data, be it monolingual or mixed lan-
guage data (Solorio and Liu, 2008b; Vyas et al.,
2014; Çetinoğlu et al., 2016; Gimpel et al., 2011;
Owoputi et al., 2013; Kong et al., 2014). CS data
offers additional challenges over the monolingual
social media data as the phenomenon of code-
switching transforms the data in many ways, for
example, by creating new lexical forms and syn-
tactic structures by mixing morphology and syn-
tax of two languages making it much more diverse
than any monolingual corpora (Çetinoğlu et al.,
2016). As the current computational models fail
to cater to the complexities of CS data, there is of-
ten a need for dedicated techniques tailored to its
specific characteristics.

Given the peculiar nature of CS data, it has been
widely studied in linguistics literature (Poplack,
1980; Gumperz, 1982; Myers-Scotton, 1995), and
more recently, there has been a surge in studies
concerning CS data in NLP as well (Solorio and
Liu, 2008a,a; Vyas et al., 2014; Sharma et al.,
2016; Rudra et al., 2016; Joshi et al., 2016; Bhat
et al., 2017; Chandu et al., 2017; Rijhwani et al.,

987



2017; Guzmán et al., 2017, and others). Be-
sides the individual computational works, a series
of shared-tasks and workshops on preprocessing
and shallow syntactic analysis of CS data have
also been conducted at multiple venues such as
Empirical Methods in NLP (EMNLP 2014 and
2016), International Conference on NLP (ICON
2015 and 2016) and Forum for Information Re-
trieval Evaluation (FIRE 2015 and 2016). Most
of these works have attempted to address pre-
liminary tasks such as language identification,
normalization and/or back-transliteration as these
data often need to go through these additional
processes for their efficient processing. In this
paper, we investigate these indispensable pro-
cesses and other problems associated with syn-
tactic parsing of code-switching data and pro-
pose methods to mitigate their effects. In par-
ticular, we study dependency parsing of Hindi-
English code-switching data of multilingual In-
dian speakers from Twitter. Hindi-English code-
switching presents an interesting scenario for the
parsing community. Mixing among typologically
diverse languages will intensify structural varia-
tions which will make parsing more challenging.
For example, there will be many sentences con-
taining: (1) both SOV and SVO word orders2,
(2) both head-initial and head-final genitives, (3)
both prepositional and postpositional phrases, etc.
More importantly, none among the Hindi and En-
glish treebanks would provide any training in-
stance for these mixed structures within individual
sentences. In this paper, we present the first code-
switching treebank that provides syntactic anno-
tations required for parsing mixed-grammar syn-
tactic structures. Moreover, we present a parsing
pipeline designed explicitly for Hindi-English CS
data. The pipeline comprises of several modules
such as a language identification system, a back-
transliteration system, and a dependency parser.
The gist of these modules and our overall research
contributions are listed as follows:

• back-transliteration and normalization mod-
els based on encoder-decoder frameworks
with sentence decoding tailored for code-
switching data;

• a dependency treebank of Hindi-English
code-switching tweets under Universal De-
pendencies scheme; and

2Order of Subject, Object and Verb in transitive sentences.

• a neural parsing model which learns POS tag-
ging and parsing jointly and also incorporates
knowledge from the monolingual treebanks
using neural stacking.

2 Preliminary Tasks

As preliminary steps before parsing of CS data, we
need to identify the language of tokens and nor-
malize and/or back-transliterate them to enhance
the parsing performance. These steps are indis-
pensable for processing CS data and without them
the performance drops drastically as we will see
in Results Section. We need normalization of
non-standard word forms and back-transliteration
of Romanized Hindi words for addressing out-of-
vocabulary problem, and lexical and syntactic am-
biguity introduced due to contracted word forms.
As we will train separate normalization and back-
transliteration models for Hindi and English, we
need language identification for selecting which
model to use for inference for each word form sep-
arately. Moreover, we also need language infor-
mation for decoding best word sequences.

2.1 Language Identification

For language identification task, we train a mul-
tilayer perceptron (MLP) stacked on top of a re-
current bidirectional LSTM (Bi-LSTM) network
as shown in Figure 1.

x 2x 1 x n

…

…

ℎ11

ℎ11

ℎ12

ℎ12

ℎ1�

ℎ1
�

 Hidden Hidden Hidden

t1 t2 tn … 

Feature 
layer

…

Output 
layer

Softmax

…

ℎ 1 1

ℎ 1 1

ℎ 1 2

ℎ 1 2

ℎ 1 

ℎ 1
 �

…

…

ℎ 1 1

ℎ 1 1

ℎ 1 2

ℎ 1 2

ℎ 1 �

ℎ 1 �

…

…

ℎ 1 1

ℎ 1 1

ℎ 1 2

ℎ 1 2

ℎ 1 �

ℎ 1 �

…

x T 2x T 1 x T n

x F 2x F 1 x F n

Input
layer

x2x1

…
xn

Char-RNN

Eng-Embd

Hin-Embd

Flag-Embd

…

Linear Linear Linear…

Figure 1: Language identification network
We represent each token by a concatenated vec-
tor of its English embedding, back-transliterated
Hindi embedding, character Bi-LSTM embedding
and flag embedding (English dictionary flag and
word length flag with length bins of 0-3, 4-6, 7-10,
and 10-all). These concatenated vectors are passed
to a Bi-LSTM network to generate a sequence of

988



hidden representations which encode the contex-
tual information spread across the sentence. Fi-
nally, output layer uses the feed-forward neural
network with a softmax function for a probabil-
ity distribution over the language tags. We train
the network on our CS training set concatenated
with the data set provided in ICON 20153 shared
task (728 Facebook comments) on language iden-
tification and evaluate it on the datasets from Bhat
et al. (2017). We achieved the state-of-the-art per-
formance on both development and test sets (Bhat
et al., 2017). The results are shown in Table 1.

Label Precision Recall F1-Score count
hi 97.76 98.09 97.92 1465
en 96.87 98.83 97.84 1283
ne 94.33 79.17 86.08 168

acro 92.00 76.67 83.64 30
univ 99.71 1.00 99.86 349

average 97.39 97.42 97.36 3295
(Bhat et al., 2017) - 96.10 - -

Table 1: Language Identification results on CS test set.

2.2 Normalization and Back-transliteration

We learn two separate but similar character-level
models for normalization-cum-transliteration of
noisy Romanized Hindi words and normaliza-
tion of noisy English words. We treat both nor-
malization and back-transliteration problems as
a general sequence to sequence learning prob-
lem. In general, our goal is to learn a mapping
for non-standard English and Romanized Hindi
word forms to standard forms in their respective
scripts. In case of Hindi, we address the problem
of normalization and back-transliteration of Ro-
manized Hindi words using a single model. We
use the attention-based encoder-decoder model
of Luong (Luong et al., 2015) with global at-
tention for learning. For Hindi, we train the
model on the transliteration pairs (87,520) from
the Libindic transliteration project4 and Brahmi-
Net (Kunchukuttan et al., 2015) which are fur-
ther augmented with noisy transliteration pairs
(1,75,668) for normalization. Similarly, for nor-
malization of noisy English words, we train the
model on noisy word forms (4,29,715) syntheti-
cally generated from the English vocabulary. We
use simple rules such as dropping non-initial vow-
els and replacing consonants based on their phono-
logical proximity to generate synthetic data for

3http://ltrc.iiit.ac.in/icon2015/
4https://github.com/libindic/indic-trans

normalization. Figure 2 shows some of the noisy
forms generated from standard word forms using
simple and finite rules which include vowel elision
(please → pls), interchanging similar conso-
nants and vowels (cousin→ couzin), replac-
ing consonant or vowel clusters with a single let-
ter (Twitter → Twiter), etc. From here on-
wards, we will refer to both normalization and
back-transliteration as normalization.

pls1

blk10

agresive21

agrsv21

ppl5

nd7

plz1

becauze17

bcz17abt
4

r2

b3

srry8

sry8

sereis6

tel24
rockin19

blak11

twiter23

twtr23

boyz15

tuk9

couzin16

czn16

desert20

dezert20

dzrt20

riting21

ritin14

rong14

kiking12

kikin11

smac13

rkn19

rokin19

mesages18

msgs18

busines22

thier10
nvr7

hv7

msgz18

please1

are2

be3

about4

people5

series6

and7

sorry8

took9

their10

black11

kicking12

smack13

wrong14

boys15

cousin16

because17

messages18

rocking19

dessert20

aggressive21

business22

twitter23

tell24

   1    2   1

   3

Figure 2: Synthetic normalization pairs generated
for a sample of English words using hand crafted
rules.

At inference time, our normalization models
will predict the most likely word form for each in-
put word. However, the single-best output from
the model may not always be the best option con-
sidering an overall sentential context. Contracted
word forms in social media content are quite of-
ten ambiguous and can represent different stan-
dard word forms. For example, noisy form ‘pt’
can expand to different standard word forms such
as ‘put’, ‘pit’, ‘pat’, ‘pot’ and ‘pet’. The
choice of word selection will solely depend on
the sentential context. To select contextually rel-
evant forms, we use exact search over n-best nor-
malizations from the respective models extracted
using beam-search decoding. The best word se-
quence is selected using the Viterbi decoding over
bn word sequences scored by a trigram language
model. b is the size of beam-width and n is the
sentence length. The language models are trained
on the monolingual data of Hindi and English us-
ing KenLM toolkit (Heafield et al., 2013). For
each word, we extract five best normalizations
(b=5). Decoding the best word sequence is a non-
trivial problem for CS data due to lack of normal-
ized and back-transliterated CS data for training a
language model. One obvious solution is to apply
decoding on individual language fragments in a
CS sentence (Dutta et al., 2015). One major prob-

989



buddy
-
-
-
-
of
-
-
droplet
one
and
iam
-

Yar
cn
anyone
tel
me
k
twitr
acount
bnd
ksy
krty
hn
plz

year
can
anyones
tell  
mae
ok   
twitt
account
band   
casey  
courty
hon 
please

yarn
con
anyone
teal
moe
kk
twirt
count
bind
cosy
karity
nh
poles

yard
cano
anyone
tele
men
coo
twitre
adcount
bound
sky
curity
han
plus

friend
-
-
-
-
from
-
-
drop
certain
do
am
-

buddy
can
anyone
tell
me
of
twitt
account
drop
one
and
am
please

ययर
छछन
अनययनय
ततल
मम
कक
टट ववटर
अकयउउट
बबबद
ककसस
करतक
हह ह
पलछज

यर
कयन
अनययनस
टकल
मम
कक
ट्वसटर
एकछउबट
बउद
ककै सक
कक त्य
हम
पलछज

यछरर
कब
अनययनस
टसल
मम
कस
कत्वतरर
अकछउनट
बछबड
कसत
करतस
हब ब
पलतज

-
ककै न
कयईभस
बतछनछ
म मझकय
-
-
खछतछ
-
-
-
-
कक पयय

-
सकनछ
वकसमकक
कहनछ
ममझ
-
-
लतखछ
-
-
-
-
कक पयछ

ययर
कछन
ककससकय
टतल
मस
कक
कट्वटर
अकछउबट
बउद
ककै सक
करतक
हकै उ
कक पयछ

hi
en
en
en
en
hi
ne
en
hi
hi
hi
hi
en

ययर
can
anyone
tell
me
कक
twitt
account
बउद
ककै सक
करतक
हकै उ
please

Raw
Tweet Top 3

Normalizations
Top 2

Dictionary Equivalents
Top 3

Transliterations
Top 2

Dictionary Equivalents

English Decoding Hindi Decoding
Lang.
Tag

Final
BestBest Best 

Figure 3: The figure shows a 3-step decoding process for the sentence “Yar cn anyone tel me k twitr account bnd
ksy krty hn plz” (Friend can anyone tell me how to close twitter account please).

lem with this approach is that the language models
used for scoring are trained on complete sentences
but are applied on sentence fragments. Scoring in-
dividual CS fragments might often lead to wrong
word selection due to incomplete context, particu-
larly at fragment peripheries. We solve this prob-
lem by using a 3-step decoding process that works
on two separate versions of a CS sentence, one
in Hindi, and one in English. In the first step,
we replace first-best back-transliterated forms of
Hindi words by their translation equivalents us-
ing a Hindi-English bilingual lexicon.5 An exact
search is used over the top ‘5’ normalizations of
English words, the translation equivalents of Hindi
words and the actual word itself. In the second
step, we decode best word sequence over Hindi
version of the sentence by replacing best English
word forms decoded from the first step by their
translation equivalents. An exact search is used
over the top ‘5’ normalizations of Hindi words, the
dictionary equivalents of decoded English words
and the original words. In the final step, English
and Hindi words are selected from their respective
decoded sequences using the predicted language
tags from the language identification system. Note
that the bilingual mappings are only used to aid
the decoding process by making the CS sentences
lexically monolingual so that the monolingual lan-
guage models could be used for scoring. They are
not used in the final decoded output. The overall
decoding process is shown in Figure 3.

Both of our normalization and back-
transliteration systems are evaluated on the

5An off-the-shelf MT system would have been appropri-
ate for this task, however, we would first need to adapt it to
CS data which in itself is a non-trivial task.

evaluation set of Bhat et al. (2017). Results
of our systems are reported in Table 3 with a
comparison of accuracies based on the nature
of decoding used. The results clearly show the
significance of our 3-step decoding over first-best
and fragment-wise decoding.

Data-set
Hindi English

Tokens FB FW 3-step Tokens FB FW 3-step
Dev 1549 82.82 87.28 90.01 34 82.35 88.23 88.23
Test 1465 83.54 88.19 90.64 28 71.42 75.21 81.71

Table 2: Normalization accuracy based on the number
of noisy tokens in the evaluation set. FB = First Best,
and FW = Fragment Wise

3 Universal Dependencies for
Hindi-English

Recently Bhat et al. (2017) provided a CS dataset
for the evaluation of their parsing models which
they trained on the Hindi and English Univer-
sal Dependency (UD) treebanks. We extend this
dataset by annotating 1,448 more sentences. Fol-
lowing Bhat et al. (2017) we first sampled CS
data from a large set of tweets of Indian lan-
guage users that we crawled from Twitter using
Tweepy6–a Twitter API wrapper. We then used
a language identification system trained on ICON
dataset (see Section 2) to filter Hindi-English CS
tweets from the crawled Twitter data. Only those
tweets were selected that satisfied a minimum ra-
tio of 30:70(%) code-switching. From this dataset,
we manually selected 1,448 tweets for annotation.
The selected tweets are thoroughly checked for
code-switching ratio. For POS tagging and depen-
dency annotation, we used Version 2 of Universal
dependency guidelines (De Marneffe et al., 2014),

6http://www.tweepy.org/

990



while language tags are assigned based on the tag
set defined in (Solorio et al., 2014; Jamatia et al.,
2015). The dataset was annotated by two expert
annotators who have been associated with anno-
tation projects involving syntactic annotations for
around 10 years. Nonetheless, we also ensured the
quality of the manual annotations by carrying an
inter-annotator agreement analysis. We randomly
selected a dataset of 150 tweets which were anno-
tated by both annotators for both POS tagging and
dependency structures. The inter-annotator agree-
ment has a 96.20% accuracy for POS tagging and
a 95.94% UAS and a 92.65% LAS for dependency
parsing.

We use our dataset for training while the devel-
opment and evaluation sets from Bhat et al. (2017)
are used for tuning and evaluation of our models.
Since the annotations in these datasets follow ver-
sion 1.4 of the UD guidelines, we converted them
to version 2 by using carefully designed rules. The
statistics about the data are given in Table 3.

Data-set Sentences Tokens Hi En Ne Univ Acro
Train 1,448 20,203 8,363 8,270 698 2,730 142
Dev 225 3,411 1,549 1,300 151 379 32
Test 225 3,295 1,465 1,283 168 349 30

Table 3: Data Statistics. Dev set is used for tuning
model parameters, while Test set is used for evaluation.

4 Dependency Parsing

We adapt Kiperwasser and Goldberg (2016)
transition-based parser as our base model and in-
corporate POS tag and monolingual parse tree in-
formation into the model using neural stacking, as
shown in Figures 4 and 6.

4.1 Parsing Algorithm
Our parsing models are based on an arc-eager
transition system (Nivre, 2003). The arc-eager
system defines a set of configurations for a sen-
tence w1,...,wn, where each configuration C =
(S, B, A) consists of a stack S, a buffer B, and
a set of dependency arcs A. For each sentence, the
parser starts with an initial configuration where S
= [ROOT], B = [w1,...,wn] and A = ∅ and ter-
minates with a configuration C if the buffer is
empty and the stack contains the ROOT. The parse
trees derived from transition sequences are given
by A. To derive the parse tree, the arc-eager sys-
tem defines four types of transitions (t): Shift,
Left-Arc, Right-Arc, and Reduce.

We use the training by exploration method of
Goldberg and Nivre (2012) for decoding a tran-

sition sequence which helps in mitigating error
propagation at evaluation time. We also use
pseudo-projective transformations of Nivre and
Nilsson (2005) to handle a higher percentage of
non-projective arcs in the CS data (∼2%). We use
the most informative scheme of head+path to
store the transformation information.

Input
layerx2x1

…
xn

…

…

ℎ11

ℎ11

ℎ12

ℎ12

ℎ1�

ℎ1
�

…

…

ℎ21

ℎ21

ℎ22

ℎ22

ℎ2
�

ℎ2
�

Hidden Hidden Hidden

t1 t2 tn … 

Hidden Hidden Hidden

ℎ11
ℎ11

ℎ12
ℎ12

ℎ1�
ℎ1�

…

…

ℎ31

ℎ31

ℎ32

ℎ32

ℎ3
�

h3
�

Feature Template (s0, b0)

           (ScoreLeftArc, ScoreRightArc, ScoreShift, ScoreReduce)

POS
feature 
layer

Parser
feature 
layer

Hidden Hidden Hidden

Softmax

…

…

…

…
…

POS
output 
layer

Parser
input 
layer

Parser
output 
layer

Softmax

Linear Linear Linear…

Linear Linear Linear…

Figure 4: POS tagging and parsing network based
on stack-propagation model proposed in (Zhang and
Weiss, 2016).

4.2 Base Models
Our base model is a stack of a tagger network and
a parser network inspired by stack-propagation
model of Zhang and Weiss (2016). The param-
eters of the tagger network are shared and act
as a regularization on the parsing model. The
model is trained by minimizing a joint negative
log-likelihood loss for both tasks. Unlike Zhang
and Weiss (2016), we compute the gradients of the
log-loss function simultaneously for each train-
ing instance. While the parser network is updated
given the parsing loss only, the tagger network is
updated with respect to both tagging and parsing
losses. Both tagger and parser networks comprise
of an input layer, a feature layer, and an output
layer as shown in Figure 4. Following Zhang and
Weiss (2016), we refer to this model as stack-prop.

991



Tagger network: The input layer of the tagger
encodes each input word in a sentence by concate-
nating a pre-trained word embedding with its char-
acter embedding given by a character Bi-LSTM.
In the feature layer, the concatenated word and
character representations are passed through two
stacked Bi-LSTMs to generate a sequence of hid-
den representations which encode the contextual
information spread across the sentence. The first
Bi-LSTM is shared with the parser network while
the other is specific to the tagger. Finally, output
layer uses the feed-forward neural network with
a softmax function for a probability distribution
over the Universal POS tags. We only use the for-
ward and backward hidden representations of the
focus word for classification.

Parser Network: Similar to the tagger network,
the input layer encodes the input sentence using
word and character embeddings which are then
passed to the shared Bi-LSTM. The hidden rep-
resentations from the shared Bi-LSTM are then
concatenated with the dense representations from
the feed-forward network of the tagger and passed
through the Bi-LSTM specific to the parser. This
ensures that the tagging network is penalized for
the parsing error caused by error propagation by
back-propagating the gradients to the shared tag-
ger parameters (Zhang and Weiss, 2016). Finally,
we use a non-linear feed-forward network to pre-
dict the labeled transitions for the parser config-
urations. From each parser configuration, we ex-
tract the top node in the stack and the first node
in the buffer and use their hidden representations
from the parser specific Bi-LSTM for classifica-
tion.

dis rat ki barish alwayz scares me .
This night of rain always scares me .

Mixed grammar Mixed grammar

Hindi grammar English grammar

Figure 5: Code-switching tweet showing grammatical
fragments from Hindi and English.

4.3 Stacking Models
It seems reasonable that limited CS data would
complement large monolingual data in parsing CS
data and a parsing model which leverages both
data would significantly improve parsing perfor-
mance. While a parsing model trained on our
limited CS data might not be enough to accu-
rately parse the individual grammatical fragments
of Hindi and English, the preexisting Hindi and

English treebanks are large enough to provide suf-
ficient annotations to capture their structure. Sim-
ilarly, parsing model(s) trained on the Hindi and
English data may not be able to properly connect
the divergent fragments of the two languages as
the model lacks evidence for such mixed struc-
tures in the monolingual data. This will happen
quite often as Hindi and English are typologicalls
very diverse (see Figure 5).

POS
Input
layer

…
…

ℎ11 ℎ12 ℎ1

Hidden Hidden Hidden

t1 t2 tn 

Hidden Hidden Hidden

…
…

ℎ31
ℎ31

ℎ32
ℎ32

ℎ3�
h3�

  (ScoreLeftArc, ScoreRightArc, ScoreShift, ScoreReduce)

POS
feature 
layer

Parser
feature 
layer

Hidden Hidden Hidden

Softmax

…

                    Hin-Eng POS hidden layer

x2
Hidden

x1
Hidden

xn
Hidden

    Hin-Eng Base Model

x2x1 xn…

POS
output 
layer

Parser
input 
layer

Parser
output
layer

…

…

…

…

…

…

Hidden Hidden Hidden…

n

ℎ11 ℎ12 ℎ1n

ℎ21 ℎ22 ℎ2n
ℎ21 ℎ22 ℎ2n…

…

x1 x2 xn

x1 x2 xn
    Hin-Eng Base Model

Feature Template (s0, b0)

                           Hin-Eng Parser Bi-LSTM

Softmax
Linear Linear Linear…

Linear Linear Linear…

Figure 6: Neural Stacking-based parsing architecture
for incorporating monolingual syntactic knowledge.

As we discussed above, we adapted feature-
level neural stacking (Zhang and Weiss, 2016;
Chen et al., 2016) for joint learning of POS tag-
ging and parsing. Similarly, we also adapt this
stacking approach for incorporating the monolin-
gual syntactic knowledge into the base CS model.
Recently, Wang et al. (2017) used neural stacking
for injecting syntactic knowledge of English into a
graph-based Singlish parser which lead to signif-
icant improvements in parsing performance. Un-
like Wang et al. (2017), our base stacked models
will allow us to transfer the POS tagging knowl-
edge as well along the parse tree knowledge.

As shown in Figure 6, we transfer both POS
tagging and parsing information from the source

992



model trained on augmented Hindi and English
data. For tagging, we augment the input layer of
the CS tagger with the MLP layer of the source
tagger. For transferring parsing knowledge, hid-
den representations from the parser specific Bi-
LSTM of the source parser are augmented with
the input layer of the CS parser which already in-
cludes the hidden layer of the CS tagger, word and
character embeddings. In addition, we also add the
MLP layer of the source parser to the MLP layer
of the CS parser. The MLP layers of the source
parser are generated using raw features from CS
parser configurations. Apart from the addition
of these learned representations from the source
model, the overall CS model remains similar to the
base model shown in Figure 4. The tagging and
parsing losses are back-propagated by traversing
back the forward paths to all trainable parameters
in the entire network for training and the whole
network is used collectively for inference.

5 Experiments

We train all of our POS tagging and parsing mod-
els on training sets of the Hindi and English UD-
v2 treebanks and our Hindi-English CS treebank.
For tuning and evaluation, we use the develop-
ment and evaluation sets from Bhat et al. (2017).
We conduct multiple experiments in gold and pre-
dicted settings to measure the effectiveness of the
sub-modules of our parsing pipeline. In predicted
settings, we use the POS taggers separately trained
on the Hindi, English and CS training sets. All
of our models use word embeddings from trans-
formed Hindi and English embedding spaces to
address the problem of lexical differences preva-
lent in CS sentences.

5.1 Hyperparameters

Word Representations For language identifica-
tion, POS tagging and parsing models, we include
the lexical features in the input layer of our neu-
ral networks using 64-dimension pre-trained word
embeddings, while we use randomly initialized
embeddings within a range of [−0.1, +0.1] for
non-lexical units such as POS tags and dictionary
flags. We use 32-dimensional character embed-
dings for all the three models and 32-dimensional
POS tag embeddings for pipelined parsing mod-
els. The distributed representation of Hindi and
English vocabulary are learned separately from
the Hindi and English monolingual corpora. The

English monolingual data contains around 280M
sentences, while the Hindi data is comparatively
smaller and contains around 40M sentences. The
word representations are learned using Skip-gram
model with negative sampling which is imple-
mented in word2vec toolkit (Mikolov et al.,
2013). We use the projection algorithm of Artetxe
et al. (2016) to transform the Hindi and En-
glish monolingual embeddings into same semantic
space using a bilingual lexicon (∼63,000 entries).
The bilingual lexicon is extracted from ILCI and
Bojar Hindi-English parallel corpora (Jha, 2010;
Bojar et al., 2014). For normalization models,
we use 32-dimensional character embeddings uni-
formly initialized within a range of [−0.1,+0.1].
Hidden dimensions The POS tagger specific
Bi-LSTMs have 128 cells while the parser spe-
cific Bi-LSTMs have 256 cells. The Bi-LSTM
in the language identification model has 64 cells.
The character Bi-LSTMs have 32 cells for all three
models. The hidden layer of MLP has 64 nodes for
the language identification network, 128 nodes for
the POS tagger and 256 nodes for the parser. We
use hyperbolic tangent as an activation function in
all tasks. In the normalization models, we use sin-
gle layered Bi-LSTMs with 512 cells for both en-
coding and decoding of character sequences.

Learning For language identification, POS tag-
ging and parsing networks, we use momentum
SGD for learning with a minibatch size of 1. The
LSTM weights are initialized with random or-
thonormal matrices as described in (Saxe et al.,
2013). We set the dropout rate to 30% for POS tag-
ger and parser Bi-LSTM and MLP hidden states
while for language identification network we set
the dropout to 50%. All three models are trained
for up to 100 epochs, with early stopping based on
the development set.

In case of normalization, we train our encoder-
decoder models for 25 epochs using vanilla SGD.
We start with a learning rate of 1.0 and after 8
epochs reduce it to half for every epoch. We use a
mini-batch size of 128, and the normalized gradi-
ent is rescaled whenever its norm exceeds 5. We
use a dropout rate of 30% for the Bi-LSTM.

Language identification, POS tagging and
parsing code is implemented in DyNet (Neubig
et al., 2017) and for normalization without
decoding, we use Open-NMT toolkit for neural
machine translation (Klein et al., 2017). All

993



the code is available at https://github.
com/irshadbhat/nsdp-cs and the data
is available at https://github.com/
CodeMixedUniversalDependencies/
UD_Hindi_English.

6 Results

In Table 4, we present the results of our main
model that uses neural stacking for learning POS
tagging and parsing and also for knowledge trans-
fer from the Bilingual model. Transferring POS
tagging and syntactic knowledge using neural
stacking gives 1.5% LAS7 improvement over a
naive approach of data augmentation. The Bilin-
gual model which is trained on the union of Hindi
and English data sets is least accurate of all our
parsing models. However, it achieves better or
near state-of-the-art results on the Hindi and En-
glish evaluation sets (see Table 5). As compared
to the best system in CoNLL 2017 Shared Task
on Universal Dependencies (Zeman et al., 2017;
Dozat et al., 2017), our results for English are
around 3% better in LAS, while for Hindi only
0.5% LAS points worse. The CS model trained
only on the CS training data is slightly more accu-
rate than the Bilingual model. Augmenting the CS
data to Hindi-English data complements their syn-
tactic structures relevant for parsing mixed gram-
mar structures which are otherwise missing in the
individual datasets. The average improvements of
around ∼5% LAS clearly show their complemen-
tary nature.

Model
Gold (LID+TRN) Auto (LID+TRN)
UAS LAS UAS LAS

Bilingual 75.26 65.41 73.29 63.18
CS 76.69 66.90 75.84 64.94

Augmented 80.39 71.27 78.95 69.51
Neural Stacking 81.50 72.44 80.23 71.03

(Bhat et al., 2017) 74.16 64.11 66.18 54.40

Table 4: Accuracy of different parsing models on the
evaluation set. POS tags are jointly predicted with
parsing. LID = Language tag, TRN = Translitera-
tion/normalization.

Table 6 summarizes the POS tagging results on
the CS evaluation set. The tagger trained on the CS
training data is 2.5% better than the Bilingual tag-
ger. Adding CS training data to Hindi and English
train sets further improves the accuracy by 1%.
However, our stack-prop tagger achieves the high-

7The improvements discussed in the running text are for
the models that are evaluated in auto settings.

est accuracy of 90.53% by leveraging POS infor-
mation from Bilingual tagger using neural stack-
ing.

Pipeline
Stack-prop

Data-set Gold POS Auto POS
UAS LAS POS UAS LAS POS UAS LAS

Hindi 95.66 93.08 97.52 94.08 90.69 97.65 94.36 91.02
English 89.95 87.96 95.75 87.71 84.59 95.80 88.30 85.30

Table 5: POS and parsing results for Hindi and En-
glish monolingual test sets using pipeline and stack-
prop models.

Model
Gold (LID+TRN) Auto (LID+TRN)
Pipeline SP Pipeline SP

Bilingual 88.36 88.12 86.71 86.27
CS 90.32 90.38 89.12 89.19

Augmented 91.20 91.50 90.02 90.20
Neural Stacking 91.76 91.90 90.36 90.53

(Bhat et al., 2017) 86.00 85.30

Table 6: POS tagging accuracies of different models on
CS evaluation set. SP = stack-prop.

Pipeline vs Stack-prop Table 7 summarizes the
parsing results of our pipeline models which use
predicted POS tags as input features. As compared
to our stack-prop models (Table 4), pipeline mod-
els are less accurate (average 1% LAS improve-
ment across models) which clearly emphasizes the
significance of back-propagating the parsing loss
to tagging parameters as well.

Model
Gold (LID+TRN+POS) Auto (LID+TRN+POS)
UAS LAS UAS LAS

Bilingual 82.29 73.79 72.09 61.18
CS 82.73 73.38 75.20 64.64

Augmented 85.66 77.75 77.98 69.16
Neural Stacking 86.87 78.57 78.90 69.45

Table 7: Accuracy of different parsing mod-
els on the test set using predicted language tags,
normalized/back-transliterated words and predicted
POS tags. POS tags are predicted separately be-
fore parsing. In Neural Stacking model, only parsing
knowledge from the Bilingual model is transferred.

Significance of normalization We also con-
ducted experiments to evaluate the impact of nor-
malization on both POS tagging and parsing. The
results are shown in Table 8. As expected, tagging
and parsing models that use normalization with-
out decoding achieve an average of 1% improve-
ment over the models that do not use normaliza-
tion at all. However, our 3-step decoding leads to
higher gains in tagging as well as parsing accura-
cies. We achieved around 2.8% improvements in
tagging and around 4.6% in parsing over the mod-
els that use first-best word forms from the normal-
ization models. More importantly, there is a mod-

994



erate drop in accuracy (1.4% LAS points) caused
due to normalization errors (see results in Table 4
for gold vs auto normalization).

System POS UAS LAS
No Normalization 86.98 76.25 66.02

First Best 87.74 78.26 67.22
3-step Decoding 90.53 80.23 71.03

Table 8: Impact of normalization and back-
transliteration on POS tagging and parsing models.

Monolingual vs Cross-lingual Embeddings
We also conducted experiments with monolingual
and cross-lingual embeddings to evaluate the need
for transforming the monolingual embeddings into
a same semantic space for processing of CS data.
Results are shown in Table 9. Cross-lingual em-
beddings have brought around ∼0.5% improve-
ments in both tagging and parsing. Cross-lingual
embeddings are essential for removing lexical dif-
ferences which is one of the problems encountered
in CS data. Addressing the lexical differences will
help in better learning by exposing syntactic simi-
larities between languages.

Embedding POS UAS LAS
Monolingual 90.07 79.46 70.53
Crosslingual 90.53 80.23 71.03

Table 9: Impact of monolingual and cross-lingual em-
beddings on stacking model performance.

7 Conclusion

In this paper, we have presented a dependency
parser designed explicitly for Hindi-English CS
data. The parser uses neural stacking architecture
of Zhang and Weiss (2016) and Chen et al. (2016)
for learning POS tagging and parsing and for
knowledge transfer from Bilingual models trained
on Hindi and English UD treebanks. We have also
presented normalization and back-transliteration
models with a decoding process tailored for CS
data. Our neural stacking parser is 1.5% LAS
points better than the augmented parsing model
and 3.8% LAS points better than the one which
uses first-best normalizations.

References
Mikel Artetxe, Gorka Labaka, and Eneko Agirre. 2016.

Learning principled bilingual mappings of word em-
beddings while preserving monolingual invariance.

In Proceedings of the 2016 Conference on Empiri-
cal Methods in Natural Language Processing. pages
2289–2294.

Irshad Bhat, Riyaz A. Bhat, Manish Shrivastava, and
Dipti Sharma. 2017. Joining hands: Exploiting
monolingual treebanks for parsing of code-mixing
data. In Proceedings of the 15th Conference of the
European Chapter of the Association for Computa-
tional Linguistics: Volume 2, Short Papers. Associa-
tion for Computational Linguistics, Valencia, Spain,
pages 324–330.

Ondřej Bojar, Vojtěch Diatka, Pavel Rychlý, Pavel
Straňák, Vı́t Suchomel, Aleš Tamchyna, and Daniel
Zeman. 2014. HindEnCorp - Hindi-English and
Hindi-only Corpus for Machine Translation. In
Nicoletta Calzolari (Conference Chair), Khalid
Choukri, Thierry Declerck, Hrafn Loftsson, Bente
Maegaard, Joseph Mariani, Asuncion Moreno, Jan
Odijk, and Stelios Piperidis, editors, Proceedings of
the Ninth International Conference on Language Re-
sources and Evaluation (LREC’14). European Lan-
guage Resources Association (ELRA), Reykjavik,
Iceland.

Özlem Çetinoğlu, Sarah Schulz, and Ngoc Thang
Vu. 2016. Challenges of computational processing
of code-switching. In Proceedings of the Second
Workshop on Computational Approaches to Code
Switching. Association for Computational Linguis-
tics, Austin, Texas, pages 1–11.

Khyathi Raghavi Chandu, Manoj Chinnakotla, Alan W
Black, and Manish Shrivastava. 2017. Webshodh:
A code mixed factoid question answering system
for web. In International Conference of the Cross-
Language Evaluation Forum for European Lan-
guages. Springer, pages 104–111.

Hongshen Chen, Yue Zhang, and Qun Liu. 2016. Neu-
ral network for heterogeneous annotations. In Pro-
ceedings of the 2016 Conference on Empirical Meth-
ods in Natural Language Processing. Association
for Computational Linguistics, Austin, Texas, pages
731–741.

Marie-Catherine De Marneffe, Timothy Dozat, Na-
talia Silveira, Katri Haverinen, Filip Ginter, Joakim
Nivre, and Christopher D Manning. 2014. Universal
stanford dependencies: A cross-linguistic typology.
In Proceedings of the Ninth International Confer-
ence on Language Resources and Evaluation. vol-
ume 14, pages 4585–92.

Timothy Dozat, Peng Qi, and Christopher D Manning.
2017. Stanford’s graph-based neural dependency
parser at the conll 2017 shared task. Proceedings
of the CoNLL 2017 Shared Task: Multilingual Pars-
ing from Raw Text to Universal Dependencies pages
20–30.

Sukanya Dutta, Tista Saha, Somnath Banerjee, and
Sudip Kumar Naskar. 2015. Text normalization in
code-mixed social media text. In Proceedings of the

995



2nd International Conference on Recent Trends in
Information Systems (ReTIS).

Kevin Gimpel, Nathan Schneider, Brendan O’Connor,
Dipanjan Das, Daniel Mills, Jacob Eisenstein,
Michael Heilman, Dani Yogatama, Jeffrey Flanigan,
and Noah A Smith. 2011. Part-of-speech tagging
for twitter: Annotation, features, and experiments.
In Proceedings of the 49th Annual Meeting of the
Association for Computational Linguistics: Human
Language Technologies: short papers-Volume 2. As-
sociation for Computational Linguistics, pages 42–
47.

Yoav Goldberg and Joakim Nivre. 2012. A dynamic or-
acle for arc-eager dependency parsing. In Proceed-
ings of the 24th International Conference on Com-
putational Linguistics. pages 959–976.

John J Gumperz. 1982. Discourse strategies, volume 1.
Cambridge University Press.

Gualberto Guzmán, Joseph Ricard, Jacqueline Serigos,
Barbara E Bullock, and Almeida Jacqueline Toribio.
2017. Metrics for modeling code-switching across
corpora. Proceedings of Interspeech 2017 pages 67–
71.

Kenneth Heafield, Ivan Pouzyrevsky, Jonathan H
Clark, and Philipp Koehn. 2013. Scalable modified
kneser-ney language model estimation. In ACL (2).
pages 690–696.

Anupam Jamatia, Björn Gambäck, and Amitava Das.
2015. Part-of-speech tagging for code-mixed
english-hindi twitter and facebook chat messages.
page 239.

Girish Nath Jha. 2010. The TDIL program and the
Indian language corpora initiative (ILCI). In Pro-
ceedings of the Seventh Conference on International
Language Resources and Evaluation (LREC 2010).
European Language Resources Association (ELRA).

Aditya Joshi, Ameya Prabhu, Manish Shrivastava, and
Vasudeva Varma. 2016. Towards sub-word level
compositions for sentiment analysis of hindi-english
code mixed text. In Proceedings of COLING 2016,
the 26th International Conference on Computational
Linguistics: Technical Papers. The COLING 2016
Organizing Committee, Osaka, Japan, pages 2482–
2491.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and accurate dependency parsing using bidirec-
tional lstm feature representations. Transactions
of the Association for Computational Linguistics
4:313–327.

Guillaume Klein, Yoon Kim, Yuntian Deng, Jean
Senellart, and Alexander M. Rush. 2017. Opennmt:
Open-source toolkit for neural machine translation.
In Proc. ACL. https://doi.org/10.18653/
v1/P17-4012.

Lingpeng Kong, Nathan Schneider, Swabha
Swayamdipta, Archna Bhatia, and Chris Dyer.
2014. A dependency parser for tweets. In Pro-
ceedings of Conference on Empirical Methods In
Natural Language Processing (EMNLP). volume
1001, page 1012.

Anoop Kunchukuttan, Ratish Puduppully, and Pushpak
Bhattacharyya. 2015. Brahmi-net: A transliteration
and script conversion system for languages of the in-
dian subcontinent.

Minh-Thang Luong, Hieu Pham, and Christopher D
Manning. 2015. Effective approaches to attention-
based neural machine translation. arXiv preprint
arXiv:1508.04025 .

Tomas Mikolov, Kai Chen, Greg Corrado, and Jef-
frey Dean. 2013. Efficient estimation of word
representations in vector space. arXiv preprint
arXiv:1301.3781 .

Carol Myers-Scotton. 1995. Social motivations for
codeswitching: Evidence from Africa. Oxford Uni-
versity Press.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv preprint
arXiv:1701.03980 .

Joakim Nivre. 2003. An efficient algorithm for pro-
jective dependency parsing. In Proceedings of the
8th International Workshop on Parsing Technologies
(IWPT).

Joakim Nivre and Jens Nilsson. 2005. Pseudo-
projective dependency parsing. In Proceedings of
the 43rd Annual Meeting on Association for Com-
putational Linguistics.

Olutobi Owoputi, Brendan OConnor, Chris Dyer,
Kevin Gimpel, Nathan Schneider, and Noah A
Smith. 2013. Improved part-of-speech tagging for
online conversational text with word clusters. In
Proceedings of NAACL-HLT . pages 380–390.

Shana Poplack. 1980. Sometimes ill start a sentence in
spanish y termino en español: toward a typology of
code-switching1. Linguistics 18(7-8):581–618.

Shruti Rijhwani, Royal Sequiera, Monojit Choud-
hury, Kalika Bali, and Chandra Shekhar Maddila.
2017. Estimating code-switching on twitter with
a novel generalized word-level language detection
technique. In Proceedings of the 55th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers). volume 1, pages 1971–
1982.

Koustav Rudra, Shruti Rijhwani, Rafiya Begum, Ka-
lika Bali, Monojit Choudhury, and Niloy Ganguly.

996



2016. Understanding language preference for ex-
pression of opinion and sentiment: What do hindi-
english speakers do on twitter? In Proceedings of
the 2016 Conference on Empirical Methods in Nat-
ural Language Processing. Association for Com-
putational Linguistics, Austin, Texas, pages 1131–
1141. https://aclweb.org/anthology/
D16-1121.

Andrew M Saxe, James L McClelland, and Surya Gan-
guli. 2013. Exact solutions to the nonlinear dynam-
ics of learning in deep linear neural networks. arXiv
preprint arXiv:1312.6120 .

Arnav Sharma, Sakshi Gupta, Raveesh Motlani, Piyush
Bansal, Manish Shrivastava, Radhika Mamidi, and
Dipti M. Sharma. 2016. Shallow parsing pipeline -
hindi-english code-mixed social media text. In Pro-
ceedings of the 2016 Conference of the North Amer-
ican Chapter of the Association for Computational
Linguistics: Human Language Technologies. Asso-
ciation for Computational Linguistics, San Diego,
California, pages 1340–1345.

Thamar Solorio, Elizabeth Blair, Suraj Maharjan, Steve
Bethard, Mona Diab, Mahmoud Gonheim, Abdelati
Hawwari, Fahad AlGhamdi, Julia Hirshberg, Alison
Chang, and Pascale Fung. 2014. Overview for the
first shared task on language identification in code-
switched data. In Proceedings of the First Workshop
on Computational Approaches to Code-Switching.
EMNLP 2014, Conference on Empirical Methods in
Natural Language Processing, Octobe, 2014, Doha,
Qatar.

Thamar Solorio and Yang Liu. 2008a. Learning to pre-
dict code-switching points. In Proceedings of the
Conference on Empirical Methods in Natural Lan-
guage Processing. Association for Computational
Linguistics, pages 973–981.

Thamar Solorio and Yang Liu. 2008b. Part-of-speech
tagging for english-spanish code-switched text. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing. Association
for Computational Linguistics, pages 1051–1060.

Yogarshi Vyas, Spandana Gella, Jatin Sharma, Ka-
lika Bali, and Monojit Choudhury. 2014. Pos tag-
ging of english-hindi code-mixed social media con-
tent. In Proceedings of the 2014 Conference on
Empirical Methods in Natural Language Processing
(EMNLP). volume 14, pages 974–979.

Hongmin Wang, Yue Zhang, GuangYong Leonard
Chan, Jie Yang, and Hai Leong Chieu. 2017. Uni-
versal dependencies parsing for colloquial singa-
porean english. In Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers). Association
for Computational Linguistics, Vancouver, Canada,
pages 1732–1744.

Daniel Zeman, Martin Popel, Milan Straka, Jan Ha-
jic, Joakim Nivre, Filip Ginter, Juhani Luotolahti,

Sampo Pyysalo, Slav Petrov, Martin Potthast, Fran-
cis Tyers, Elena Badmaeva, Memduh Gokirmak,
Anna Nedoluzhko, Silvie Cinkova, Jan Hajic jr.,
Jaroslava Hlavacova, Václava Kettnerová, Zdenka
Uresova, Jenna Kanerva, Stina Ojala, Anna Mis-
silä, Christopher D. Manning, Sebastian Schuster,
Siva Reddy, Dima Taji, Nizar Habash, Herman Le-
ung, Marie-Catherine de Marneffe, Manuela San-
guinetti, Maria Simi, Hiroshi Kanayama, Valeria de-
Paiva, Kira Droganova, Héctor Martı́nez Alonso,
Çağr Çöltekin, Umut Sulubacak, Hans Uszkor-
eit, Vivien Macketanz, Aljoscha Burchardt, Kim
Harris, Katrin Marheinecke, Georg Rehm, Tolga
Kayadelen, Mohammed Attia, Ali Elkahky, Zhuoran
Yu, Emily Pitler, Saran Lertpradit, Michael Mandl,
Jesse Kirchner, Hector Fernandez Alcalde, Jana Str-
nadová, Esha Banerjee, Ruli Manurung, Antonio
Stella, Atsuko Shimada, Sookyoung Kwak, Gustavo
Mendonca, Tatiana Lando, Rattima Nitisaroj, and
Josie Li. 2017. Conll 2017 shared task: Multilingual
parsing from raw text to universal dependencies. In
Proceedings of the CoNLL 2017 Shared Task: Mul-
tilingual Parsing from Raw Text to Universal Depen-
dencies. Association for Computational Linguistics,
Vancouver, Canada, pages 1–19.

Yuan Zhang and David Weiss. 2016. Stack-
propagation: Improved representation learning for
syntax. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers). Association for Compu-
tational Linguistics, Berlin, Germany, pages 1557–
1566.

997



A Supplemental Material

A.1 Example Annotations from our CS
Treebank

i thought mosam different hoga bas fog hy

ROOT

nsubj nsubj

ccomp

cop advmod

advcl

cop

Thand bhi odd even formula follow Kr rhi h ;-)

ROOT
nsubj

advmod

amod

compound

obj

compound aux

aux

discourse

Tum kitne fake account banaogy

ROOTnsubj

det

amod obj

Ram Kapoor reminds me of boondi ke laddu

ROOT

nsubj

flat obj

case

nmod

case

obl

Has someone told Gabbar cal kya hai ?

ROOT

aux

nsubj iobj nmod

ccomp

cop

punct

Enjoying Dilli ki sardi after a long time .

ROOT

nmod

case

obj case

det

amod

obl

punct

Biggboss dekhne wali awaam can unfollow me .

ROOT

obj

amod

mark

nsubj

aux iobj

punct

Kaafi depressing situation hai yar

ROOT

advmod amod cop

vocative

Some people are double standards ki dukaan

ROOT

det

nsubj

cop

amod

nmod

case

There is no seperate emoji for khushi ke aansu .

ROOT

expl

cop

advmod

amod

case

nmod

case

obl

punct

998


