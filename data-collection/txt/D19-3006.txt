



















































CFO: A Framework for Building Production NLP Systems


Proceedings of the 2019 EMNLP and the 9th IJCNLP (System Demonstrations), pages 31–36
Hong Kong, China, November 3 – 7, 2019. c©2019 Association for Computational Linguistics

31

CFO: A Framework for Building Production NLP Systems

Rishav Chakravarti1 Cezar Pendus2 Andrzej Sakrajda2 Anthony Ferritto1
Lin Pan1 Michael Glass2 Vittorio Castelli2 J. William Murdock1

Radu Florian2 Salim Roukos2 Avirup Sil2∗

1IBM Watson, 2IBM Research AI

{rchakravarti, cpendus, ansa, panl, mrglass, vittorio, murdockj, raduf, roukos, avi}@us.ibm.com
aferritto@ibm.com

Abstract
This paper introduces a novel orchestra-
tion framework, called CFO (COMPUTATION
FLOW ORCHESTRATOR), for building, ex-
perimenting with, and deploying interactive
NLP (Natural Language Processing) and IR
(Information Retrieval) systems to produc-
tion environments. We then demonstrate a
question answering system built using this
framework which incorporates state-of-the-art
BERT based MRC (Machine Reading Com-
prehension) with IR components to enable
end-to-end answer retrieval. Results from the
demo system are shown to be high quality in
both academic and industry domain specific
settings. Finally, we discuss best practices
when (pre-)training BERT based MRC mod-
els for production systems.

1 Introduction

Production NLP (Natural Language Processing)
and IR (information retrieval) applications often
rely on a system flow consisting of multiple com-
ponents that need to be woven together to build an
end-to-end system (A. Ferrucci et al., 2010; Yang
et al., 2019). This paper presents a novel approach
for defining flow graphs and a toolkit for compil-
ing those definitions into deploy-able production
grade systems1.

Though the framework, which we refer to as
CFO (COMPUTATION FLOW ORCHESTRATOR),
is well suited to a variety of use cases, we demon-
strate it by creating an interactive QA (Ques-
tion Answering) system that can be used both for
academic benchmarking as well as industry spe-
cific use cases. The interactive system integrates
SOTA (state-of-the-art) BERT-based MRC (Ma-
chine Reading Comprehension), an Elasticsearch

∗ Corresponding author.
1We are actively seeking to open source the toolkit and

flow definition language. If successful, we will be releasing
the code to http://ibm.biz/cfo_framework

based document retrieval component, and a de-
duplication & sorting component to provide end-
to-end answer retrieval. We will refer to this
demonstration system as GAAMA (Go Ahead,
Ask Me Anything). The key contributions of this
work, therefore, are to (1) introduce a novel frame-
work for stitching together deployable NLP com-
ponents, (2) demonstrate the framework with an
end-to-end QA system, and (3) discuss the training
steps necessary for adapting a SOTA MRC model
to a data set before plugging it into the QA system.

Section 2 provides the motivations and de-
tails of the CFO framework, section 3 discusses
the specific model components integrated into
GAAMA, section 4 discusses experimentation to
adapt the BERT-based MRC component to this
system, section 5 discusses related work, and, fi-
nally, section 6 provides a conclusion and discus-
sion of future work.

In addition, a (private) screencast video demon-
stration of GAAMA has been uploaded at http:
//ibm.biz/gaama_demo (along with a sup-
plementary presentation of the CFO framework at
http://ibm.biz/gaama_cfo_demo).

2 CFO Architecture

The CFO framework relies on two sets of sys-
tem specifications to define the computation flow
graph. First, each node within the graph defines
its service name, input message data fields, and
output message data fields using Google’s Proto-
col Buffer Interface Definition Language2. Sec-
ond, the orchestrator is described using a custom
specification format allowing the user to declare:

1. The set of nodes (provided as containerized
gRPC3 microservices). Each node will have

2https://developers.google.com/
protocol-buffers/

3https://grpc.io/

http://ibm.biz/cfo_framework
http://ibm.biz/gaama_demo
http://ibm.biz/gaama_demo
http://ibm.biz/gaama_cfo_demo
https://developers.google.com/protocol-buffers/
https://developers.google.com/protocol-buffers/
https://grpc.io/


32

implemented a microservice according to the
node’s declared interface specification.

2. The set of nodes to treat as entry points to the
flow graph.

3. A mapping within the flow for each data el-
ement comprising the input and output mes-
sage interfaces for nodes.

4. For ease of deployment, the specification
also provides the ability to describe deploy-
ment specific configuration settings like ser-
vice ports, docker registry location etc.

Given these specification files, CFO provides
a compiler to auto-generate an orchestrator node
which implements the computation flow graph, a
(dockerized) launch script, and a simple REST in-
terface / GUI which provide access to the defined
entry points and debug information.

The resulting design allows data flows and de-
pendencies to be described both concisely and
transparently. The flow specification allows for
easy debugging and modification of how data
fields enter the computation flow, get transformed,
and finally outputted. This is a significant depar-
ture from traditional orchestration systems which
would require parsing through source code to de-
termine and change the route taken by data fields
through the computation flow. Furthermore, the
use of Protocol Buffers to describe these data
fields ensures a language and platform agnostic
representation that does not compromise the sys-
tem’s speed or ability to ensure data type cor-
rectness at compile time (as opposed to tradi-
tional JSON/XML representations which need to
encode/decode from strings at run time).

Another benefit of the CFO toolkit is to auto-
generate the serialization and connectivity code
for each node as well as exposing the entry points
via REST interfaces. Relinquishing this respon-
sibility to the CFO toolkit frees the developer
up from writing a significant amount of boiler-
plate code and worrying about distributed system
best practices such as enforcing time outs, error
propagation, latency logging, and parallelization
through asynchronous calls. As an illustrative ex-
ample, the auto-generated code for the GAAMA
demo consists of 2,800 lines of C++ orchestration
code.

Finally, the CFO toolkit generates a set of shell
scripts, docker images, and config files for de-
ploying and running the flow graph using either

Elastic 
Server

Pre-Ingest 
Document Corpus

1. Ask a 
Question

GAAMA (built on CFO)

2. Retrieve 
Candidate

Documents

BERT 
for QA

3. Extract 
Answer Spans

5. Receive 
Answer 

Snippets in 
Context

Combiner 

4. De-duplicate 
& Sort

Figure 1: GAAMA System Architecture

docker-compose4 or kubernetes5. This allows the
generated project to be deployed both locally for
debugging as well as on modern cloud infrastruc-
ture.

3 GAAMA Architecture

As a simple case study for CFO, we create
a demonstration QA system consisting of four
nodes: (1) an Elasticsearch6 based IR node (2)
a BERT based MRC node (3) an answer “de-
duplication” node and (4) a final answer combiner
node. See fig. 1 for an overview of the QA system.

As described in section 2, each component
starts by declaring an interface specification allow-
ing the underlying implementation to be swapped
out without the need to modify the rest of the
QA system. Next, a gRPC server is implemented
with the core business logic. Auto-generated
gRPC code stubs provide the core communica-
tion/serialization logic for the service layer of the
server. We describe the IR and MRC nodes in fur-
ther detail in the following two sections.

3.1 IR with Elasticsearch
The core business logic of the IR node uses Elas-
ticsearch APIs to retrieve the top k documents
from the appropriate corpus based on BM25, a
popular variant of term frequency overlap between
the query and document text (Robertson et al.,
1976). Two document corpora are ingested us-
ing the standard English analyzer. The first cor-
pus consists of Wikipedia paragraphs used for aca-
demic benchmarking and the second corpus con-
sists of an industry dataset made up of IBM Tech-
nical Support Documentation. The user interface
allows us to choose either corpus when asking

4https://docs.docker.com/compose/
5https://kubernetes.io/
6https://www.elastic.co/products/

elasticsearch

https://docs.docker.com/compose/
https://kubernetes.io/
https://www.elastic.co/products/elasticsearch
https://www.elastic.co/products/elasticsearch


33

questions to evaluate the system. We use “para-
graphs” as the base unit of ingestion in line with
(Yang et al., 2019) which shows this as an optimal
pre-processing step for consumption by a MRC
component.

The node’s input interface, therefore, accepts
query text, a hyperparameter k, and a target corpus
identifier. Its output interface produces a list of
document texts accompanied by retrieval scores.
As discussed earlier, these interfaces are defined
using protocol buffer definitions, so we follow
standard steps7 for auto-generating a gRPC server
with placeholders for the custom business logic of
retrieving documents. Similarly, with the server
logic in place, we follow standard steps8 to cre-
ate a docker image that CFO will need to launch
the gRPC server. Though we are wrapping Elas-
ticsearch’s index based retrieval implementation
here, we can swap our implementation for more
recent Neural IR based techniques (Craswell et al.,
2017) without changing the exposed interface or
the orchestration code.

3.2 MRC with BERT

The MRC node similarly wraps a BERT-for-QA
model in a dockerized gRPC server which accepts
a single query-document pair as its input and pro-
duces a span from the document along with a pre-
diction score as its output. Note that CFO’s or-
chestrator automatically realizes that the IR node
produces a list of documents, while the MRC node
accepts a single document at a time. So CFO will
take care of calling the MRC node for each of the k
retrieved documents (using asynchronous calls to
parallelize requests if a configuration flag is set).

The underlying BERT-for-QA model is based
on (Alberti et al., 2019). BERT (Devlin et al.,
2018) is one of a series of pre-trained neural mod-
els that can be fine tuned to provide state-of-the-
art results in NLP (Peters et al., 2018; Howard
and Ruder, 2018; Radford et al., 2019) including
on the SQuAD (Rajpurkar et al., 2018) and NQ
(Kwiatkowski et al., 2019) tasks that align with
our MRC based QA.

We use the Huggingface PyTorch implementa-
tion of BERT 9 which supports starting from a
Base (a 12 layer, 768 hidden dimension, 12 atten-

7https://grpc.io/docs/tutorials/
8https://github.com/grpc/

grpc-docker-library/
9https://github.com/huggingface/

pytorch-transformers

Answerability Prediction Start / End Position Predictions

…

…

E[CLS] E1 EN E[SEP] E’1 E’M……

C T1 TN T[SEP] T’1 T’M……

[CLS] Question [SEP] Candidate Paragraph

BERT

Figure 2: BERT for QA (Devlin et al., 2018)

tion head, 110M parameter transformer network)
or a Large (a 24 layer, 1024 hidden dimension, 16
attention head, 340M parameter transformer net-
work) model. An output feed forward layer is
added on top of this to produce 3 sets of scores:
(1) scores at each token offset marking the like-
lihood of an answer chunk starting at this offset
(2) scores at each token offset marking the likeli-
hood of an answer chunk ending at this offset (3)
a score for the entire sequence marking the like-
lihood of the question being answerable given the
current context.

The parameters of the entire network are fine
tuned using a set of question and document pairs
where annotators provide the correct start and end
offsets or have marked the question-document pair
as having no correct answer. Refer to fig. 2 for a
visual depiction of the model and to (Alberti et al.,
2019) for additional details about model architec-
ture and implementation.

Section 4 includes practical pre-training, fine
tuning, and hyperparameter optimization steps
for building the final model deployed as part of
GAAMA. At the time of writing, our BERT-based
MRC model10 was the best performing submis-
sion (dated 7/31/2019), outperforming the next
best system by 1% on F1 on the Natural Questions
public leaderboard11.

4 Experiments

Prior to integration of the MRC node into
GAAMA, we first experiment with data prepa-
ration and training of the BERT MRC model as
a standalone component using dev sets provided
with the NQ and SQuAD data sets (see 5 for more
on these data sets). NQ is preferred for evaluat-

10The best performing submission to the leaderboard
uses an ensemble of models using different hyperparameters
rather than a single model

11https://ai.google.com/research/
NaturalQuestions/leaderboard

https://grpc.io/docs/tutorials/
https://github.com/grpc/grpc-docker-library/
https://github.com/grpc/grpc-docker-library/
https://github.com/huggingface/pytorch-transformers
https://github.com/huggingface/pytorch-transformers
https://ai.google.com/research/NaturalQuestions/leaderboard
https://ai.google.com/research/NaturalQuestions/leaderboard


34

F1
Prior Work
DecAtt + Doc Reader (Parikh et al., 2016) 31.4
BERT (Devlin et al., 2018) 50.2
BERT w/ SQuAD 1.1 (Alberti et al., 2019) 52.7
This Work
BERT w/ U-MRC 53.6
BERT w/ U-MRC & SQuAD 1.1 54.2
BERT w/ U-MRC & SQuAD 1.1
+ SQuAD 2.0 Data Aug 54.5

Table 1: Dev Set Performance on NQ with different
pre-training & data augmentation techniques. We also
report some baselines from (Alberti et al., 2019) for
context

ing production systems since the questions were
“naturally” generated and does not suffer from
the observational bias inherent in SQuAD’s data
collection approach (Kwiatkowski et al., 2019).
When reporting results with the SQuAD dataset,
we use the methodology (and evaluation script)
made available with (Rajpurkar et al., 2018). Sim-
ilarly, when reporting results with the NQ dataset,
we use the methodology (and evaluation script)
made available with (Kwiatkowski et al., 2019).
Once we are satisfied with the performance of this
model, we integrate into GAAMA and evaluate
manually using an internal corpus.

We use the F-score at an “optimal” threshold
for the dev set12 as the headline metric for assess-
ing the system. Latency measurements are car-
ried out using a random sample of examples on
a system with an Intel R© Xeon R© E5-2690 16-core
CPU, 2 Nvidia R© Tesla R© P100 GPUs, and 128GB
of RAM.13 We then examine the feasibility of de-
ploying base and large models in a production en-
vironment on GPUs and CPUs.

4.1 Pre-Training & Data Augmentation

We explore two types of pre-training. The first fol-
lows (Alberti et al., 2019) by leveraging a similar
task for which supervised labels are available and
pre-training the model on it before moving onto
fine tuning on the target dataset. Specifically, we
use SQuAD 1.1 (Rajpurkar et al., 2016). Table 1
shows that this strategy can provide an absolute
improvement of 2.5% over a model that starts with
just the default BERT language model.

12See http://www.ibm.biz/confidence_
thresholding for more on choosing business specific
thresholds

13We only use 1 P100 GPU or 8 CPU threads in latency
experiments

Pre-Training EM F1
BERT (Devlin et al., 2018) 78.7 81.9
BERT w/ U-MRC 82.2 85
BERT w/ U-MRC & NQ 82.6 85.4

Table 2: Dev Set Performance on SQuAD 2 with dif-
ferent pre-training strategies.

We also employ (Glass et al., 2019)’s approach
to using an unsupervised auxilary task that is bet-
ter aligned to our final task (i.e. MRC) than the
default Masked Language Model and Next Sen-
tence Prediction used in (Devlin et al., 2018) to
pre-train the BERT models. Using the Wikipedia
corpus, we create cloze style queries by masking
out terms (named entities or noun phrases) in a
sentence. Then we identify an answer bearing pas-
sage from the Wikipedia corpus that is relevant to
the query (as identified by BM25 IR). This allows
us to pre-train all layers of the BERT model in-
cluding the answer extraction weights by training
the model to extract the answer term from the se-
lected passage. Like the Masked Language Model,
this task relies on predicting a masked component
of an input sequence, but the prediction is gener-
ated by extraction rather than generation. Table 1
labels these results as “BERT w/ U-MRC” and
shows that this additional training on a MRC spe-
cific unsupervised task improves the model’s final
fine-tuned performance on the NQ task by 1.5%.
Table 2 similarly shows the benefits of these pre-
training strategies on the SQuAD 2.0 dataset.

In addition, as noted by the authors of the orig-
inal BERT-for-QA submission to SQuAD (Devlin
et al., 2018), there can be a benefit to fine tuning
the entire network with labelled examples from
multiple datasets. The last row of table 1 shows an
incremental gain of 0.3% by introducing SQuAD
2.0 during the fine-tuning phase. For now, the ad-
ditional data is simply shuffled into the first 80%
of mini batches during the fine-tuning phase.

4.2 BERT Models & Latency

Most model settings are taken from (Alberti et al.,
2019) with the exception of batch size and learn-
ing rate which are tuned using the approach from
(Smith, 2018). In addition, we experiment with
models trained on BERT base and BERT large to
understand trade-offs between latency and accu-
racy. Using the hardware described in section 4,
we evaluate F1 and latency on a subset of the NQ

http://www.ibm.biz/confidence_thresholding
http://www.ibm.biz/confidence_thresholding


35

Model F1 TG50 T
G
95 T

C
50 T

C
95

Base 42.5 0.05 0.49 0.53 2.32
Large 50.8 0.10 0.66 1.51 6.00

Table 3: F1 and latencies for BERT base and large
models running on GPU and CPU for a subset of the
NQ dev set. TDK is the K-th percentile query latency in
seconds when running on device D (GPU or CPU).

dev set14. In order to decrease latency, we sim-
ulate passage retrieval to send GAAMA the most
relevant passage by selecting the first correct top
level candidate if there is one and the first (in-
correct) top level candidate if there is not. We
find in table 3 that switching from base to large
yields an 8.3% absolute increase in F1 in exchange
for 1.3x to 2.8x increases in latency. When run-
ning GAAMA on a GPU these result in manage-
able 95th percentile query latencies of less than a
second; whereas on the CPU the 95th percentile
times are in excess of two and five seconds for
base and large respectively. For large, even the
median latency is greater than one and a half sec-
onds, effectively cementing GPUs as a require-
ment for deploying to production environments. In
future work we intend to explore network pruning
or knowledge distillation techniques for potential
speedups with the large model.

5 Related Work

Recently (Yang et al., 2019) proposed BERT-
Serini, an end-to-end QA pipeline demo that lever-
ages the Anserini IR toolkit (Yang et al., 2017) to
look for relevant documents for a question, then
uses BERT-based techniques (Devlin et al., 2018)
to extract the correct answer. However, their re-
liance on a Lucene based IR toolkit means that
constructing a NLP pipeline would either require
pipeline components to be written as Lucene based
plugins (which comes with a variety of constraints
on programming language and structure) or writ-
ing custom orchestration code to connect compo-
nents outside of the toolkit. Similar constraints are
imposed by other popular NLP pipeline toolkits
such as StanfordNLP (Qi et al., 2018) and Spacy15

(both of which require development in Python
with limited flexibility in training neural models
with other frameworks such as Tensorflow16).

In contrast, CFO’s inherent programming lan-

14Used 500 random examples from dev set for experiments
15https://spacy.io/
16https://www.tensorflow.org/

guage and platform agnostic microservice archi-
tecture encourages flexibility and robustness in be-
ing able to switch out individual components with-
out re-doing boilerplate code. In addition, CFO’s
out-of-the-box support for containerization pro-
vides flexibility in the compute infrastructure that
can be leveraged for rapid deployment to both lo-
cal and cloud environments.

This flexibility is important in a domain such as
Machine Reading Comprehension (MRC) where
recent advances in language-modeling based pre-
trained embeddings like ELMO (Peters et al.,
2018) and BERT (Devlin et al., 2018) along with
large scale open data sets like the Stanford Ques-
tion Answering Dataset (SQuAD) 1.1 (Rajpurkar
et al., 2016) and its successor SQuAD 2.0 (Ra-
jpurkar et al., 2018) have spurred a diverse array of
model architecture improvements in a short time
span. Recent work has even produced systems
that surpass human-level exact match accuracy on
the SQuAD datasets, causing us to focus on the
challenging new Natural Questions (NQ) dataset
(Kwiatkowski et al., 2019) where the questions do
not have any observational bias as they were not
artificially created. To the best of our knowledge,
there is no current software framework paper that
shows its analysis on the NQ dataset and displays
strong empirical performance.

UIMA (Ferrucci and Lally, 2004) is an inte-
gration framework that provides defined APIs for
analyzing unstructured information and a shared
data structure for storing the results of that anal-
ysis. When paired with the UIMA Asynchronous
Scaleout layer (Apache UIMA Community, 2018)
and the Distributed UIMA Cluster Computing tool
(DUCC Team, 2013), this technology stack pro-
vides many of the same core capabilities that CFO
does: pipeline orchestration, microservice deploy-
ment and management, data serialization and con-
nectivity, etc. However, CFO is designed for
modern cloud environments and includes built-
in integration with docker-compose and kuber-
netes; the UIMA stack can be used with these
technologies but facilities for doing so are not
built-in to the stack so more development effort
is needed in those contexts. Also, UIMA and
CFO both require that each component expresses
its data model (including input and output speci-
fications) declaratively, but UIMA then unifies the
data model of all components into a global type hi-
erarchy, which requires some level of compatibil-

https://spacy.io/
https://www.tensorflow.org/


36

ity across type definitions. In contrast, CFO only
requires consistency in the data model for compo-
nents that directly connect to each other, and the
names of corresponding types and fields do not
need to match. These differences make CFO eas-
ier to use in cases where components were devel-
oped by different developers and integrated by a
third party.

6 Conclusion

This paper introduces CFO, a novel methodology
and toolkit for rapid development of production
grade systems for use cases which can be repre-
sented as computation flow graphs. We demon-
strate the use of this framework to build an end-
to-end QA system composed of a SOTA MRC
model that is adapted to answering “natural lan-
guage questions”. We also show experimentation
using the NQ dataset to illustrate training tech-
niques that can be used to build SOTA systems on
top of existing pre-trained language models like
BERT.

We are actively seeking to open source the CFO
framework and hope that, once available, the com-
munity will be able to quickly build and deploy
their own SOTA NLP components as interactive
multi-component systems. We also intend on ex-
panding GAAMA to incorporate additional QA
components to improve its performance through
approaches like query expansion for improved re-
call and network pruning for improved latency.

References
David A. Ferrucci, Eric Brown, Jennifer Chu-Carroll,

James Fan, David Gondek, Aditya Kalyanpur, Adam
Lally, J William Murdock, Eric Nyberg, John Prager,
Nico Schlaefer, and Christopher Welty. 2010. Build-
ing Watson: An overview of the DeepQA project. AI
Magazine, 31:59–79.

Chris Alberti, Kenton Lee, and Michael Collins. 2019.
A bert baseline for the natural questions.

Apache UIMA Community. 2018. UIMA Asyn-
chronous Scaleout: Version 2.10.3.

Nick Craswell, W Croft, Maarten de Rijke, Jiafeng
Guo, and Bhaskar Mitra. 2017. Sigir 2017 work-
shop on neural information retrieval (neu-ir’17).

Jacob Devlin, Ming-Wei Chang, Kenton Lee, and
Kristina Toutanova. 2018. Bert: Pre-training of deep
bidirectional transformers for language understand-
ing. In NAACL-HLT.

DUCC Team. 2013. Distributed UIMA cluster com-
puting.

David Ferrucci and Adam Lally. 2004. UIMA: an
architectural approach to unstructured information
processing in the corporate research environment.
Natural Language Engineering, 10(3-4):327348.

Michael Glass, Alfio Gliozzo, Rishav Chakravarti, An-
thony Ferritto, Lin Pan, Bhargav GP Shrivatsa, Di-
nesh Garg, and Avirup Sil. 2019. Span selection pre-
training for question answering.

Jeremy Howard and Sebastian Ruder. 2018. Universal
language model fine-tuning for text classification.

Tom Kwiatkowski, Jennimaria Palomaki, Olivia Red-
field, Michael Collins, Ankur Parikh, Chris Alberti,
Danielle Epstein, Illia Polosukhin, Matthew Kelcey,
Jacob Devlin, Kenton Lee, Kristina N. Toutanova,
Llion Jones, Ming-Wei Chang, Andrew Dai, Jakob
Uszkoreit, Quoc Le, and Slav Petrov. 2019. Natu-
ral questions: a benchmark for question answering
research. TACL.

Ankur Parikh, Oscar Tckstrm, Dipanjan Das, and
Jakob Uszkoreit. 2016. A decomposable attention
model for natural language inference. EMNLP.

Matthew Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. NAACL.

Peng Qi, Timothy Dozat, Yuhao Zhang, and Christo-
pher D. Manning. 2018. Universal dependency pars-
ing from scratch. CoNLL. ACL.

Alec Radford, Karthik Narasimhan, Tim Salimans, and
Ilya Sutskever. 2019. Improving language under-
standing by generative pre-training.

Pranav Rajpurkar, Robin Jia, and Percy Liang. 2018.
Know what you don’t know: Unanswerable ques-
tions for squad. arXiv preprint arXiv:1806.03822.

Pranav Rajpurkar, Jian Zhang, Konstantin Lopyrev, and
Percy Liang. 2016. Squad: 100,000+ questions for
machine comprehension of text. EMNLP.

C S. Robertson, H. Zaragoza, Stephen Robertson, and
Hugo Zaragoza. 1976. The probabilistic relevance
framework: Bm25 and beyond.

Leslie N. Smith. 2018. A disciplined approach to neu-
ral network hyper-parameters: Part 1 – learning rate,
batch size, momentum, and weight decay.

Peilin Yang, Hui Fang, and Jimmy Lin. 2017. Anserini:
Enabling the use of lucene for information retrieval
research. SIGIR. ACM.

Wei Yang, Yuqing Xie, Aileen Lin, Xingyu Li, Luchen
Tan, Kun Xiong, Ming Li, and Jimmy Lin. 2019.
End-to-end open-domain question answering with
bertserini.

http://arxiv.org/abs/1901.08634
https://uima.apache.org/d/uima-as-2.10.3/uima_async_scaleout.pdf
https://uima.apache.org/d/uima-as-2.10.3/uima_async_scaleout.pdf
https://doi.org/10.1145/3077136.3084373
https://doi.org/10.1145/3077136.3084373
https://cwiki.apache.org/confluence/download/attachments/30751207/duccbook-0.8.0.pdf
https://cwiki.apache.org/confluence/download/attachments/30751207/duccbook-0.8.0.pdf
https://doi.org/10.1017/S1351324904003523
https://doi.org/10.1017/S1351324904003523
https://doi.org/10.1017/S1351324904003523
http://ibm.biz/sspt_for_qa
http://ibm.biz/sspt_for_qa
http://arxiv.org/abs/1801.06146
http://arxiv.org/abs/1801.06146
https://tomkwiat.users.x20web.corp.google.com/papers/natural-questions/main-1455-kwiatkowski.pdf
https://tomkwiat.users.x20web.corp.google.com/papers/natural-questions/main-1455-kwiatkowski.pdf
https://tomkwiat.users.x20web.corp.google.com/papers/natural-questions/main-1455-kwiatkowski.pdf
https://doi.org/10.18653/v1/d16-1244
https://doi.org/10.18653/v1/d16-1244
https://doi.org/10.18653/v1/n18-1202
https://doi.org/10.18653/v1/n18-1202
https://nlp.stanford.edu/pubs/qi2018universal.pdf
https://nlp.stanford.edu/pubs/qi2018universal.pdf
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://doi.org/10.18653/v1/d16-1264
https://doi.org/10.18653/v1/d16-1264
http://arxiv.org/abs/1803.09820
http://arxiv.org/abs/1803.09820
http://arxiv.org/abs/1803.09820
https://doi.org/10.1145/3077136.3080721
https://doi.org/10.1145/3077136.3080721
https://doi.org/10.1145/3077136.3080721
http://arxiv.org/abs/1902.01718
http://arxiv.org/abs/1902.01718

