



















































Semantic Parsing with Dual Learning


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 51–64
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

51

Semantic Parsing with Dual Learning

Ruisheng Cao∗, Su Zhu∗, Chen Liu, Jieyu Li and Kai Yu †
MoE Key Lab of Artificial Intelligence

SpeechLab, Department of Computer Science and Engineering
Shanghai Jiao Tong University, Shanghai, China

{211314,paul2204,chris-chen,oracion,kai.yu}@sjtu.edu.cn

Abstract

Semantic parsing converts natural language
queries into structured logical forms. The
paucity of annotated training samples is a
fundamental challenge in this field. In this
work, we develop a semantic parsing frame-
work with the dual learning algorithm, which
enables a semantic parser to make full use
of data (labeled and even unlabeled) through
a dual-learning game. This game between a
primal model (semantic parsing) and a dual
model (logical form to query) forces them to
regularize each other, and can achieve feed-
back signals from some prior-knowledge. By
utilizing the prior-knowledge of logical form
structures, we propose a novel reward signal
at the surface and semantic levels which tends
to generate complete and reasonable logical
forms. Experimental results show that our
approach achieves new state-of-the-art perfor-
mance on ATIS dataset and gets competitive
performance on OVERNIGHT dataset.

1 Introduction

Semantic parsing is the task of mapping a natu-
ral language query into a logical form (Zelle and
Mooney, 1996; Wong and Mooney, 2007; Zettle-
moyer and Collins, 2007; Lu et al., 2008; Zettle-
moyer and Collins, 2005). A logical form is
one type of meaning representation understood by
computers, which usually can be executed by an
executor to obtain the answers.

The successful application of recurrent neu-
ral networks (RNN) in a variety of NLP tasks
(Bahdanau et al., 2014; Sutskever et al., 2014;
Vinyals et al., 2015) has provided strong impe-
tus to treat semantic parsing as a sequence-to-
sequence (Seq2seq) problem (Jia and Liang, 2016;
Dong and Lapata, 2016). This approach generates

∗Ruisheng Cao and Su Zhu are co-first authors and con-
tribute equally to this work.

†The corresponding author is Kai Yu.

a logical form based on the input query in an end-
to-end manner but still leaves two main issues: (1)
lack of labeled data and (2) constrained decoding.

Firstly, semantic parsing relies on sufficient la-
beled data. However, data annotation of semantic
parsing is a labor-intensive and time-consuming
task. Especially, the logical form is unfriendly for
human annotation.

Secondly, unlike natural language sentences, a
logical form is strictly structured. For example,
the lambda expression of “show flight from ci0
to ci1” is ( lambda $0 e ( and ( from
$0 ci0 ) ( to $0 ci1 ) ( flight
$0 ) ) ). If we make no constraint on decod-
ing, the generated logical form may be invalid or
incomplete at surface and semantic levels.

Surface The generated sequence should be struc-
tured as a complete logical form. For ex-
ample, left and right parentheses should be
matched to force the generated sequence to
be a valid tree.

Semantic Although the generated sequence is a
legal logical form at surface level, it may
be meaningless or semantically ill-formed.
For example, the predefined binary predicate
from takes no more than two arguments.
The first argument must represent a flight
and the second argument should be a city.

To avoid producing incomplete or semantically ill-
formed logical forms, the output space must be
constrained.

In this paper, we introduce a semantic parsing
framework (see Figure 1) by incorporating dual
learning (He et al., 2016) to tackle the problems
mentioned above. In this framework, we have a
primal task (query to logical form) and a dual task
(logical form to query). They can form a closed
loop, and generate informative feedback signals to



52

train the primal and dual models even without su-
pervision. In this loop, the primal and dual mod-
els restrict or regularize each other by generating
intermediate output in one model and then check-
ing it in the other. Actually, it can be viewed as a
method of data augmentation. Thus it can lever-
age unlabeled data (queries or synthesized logical
forms) in a more effective way which helps allevi-
ate the problem of lack of annotated data.

In the dual learning framework, the primal and
dual models are represented as two agents and they
teach each other through a reinforcement learning
process. To force the generated logical form com-
plete and well-formed, we newly propose a valid-
ity reward by checking the output of the primal
model at the surface and semantic levels.

We evaluate our approach on two standard
datasets: ATIS and OVERNIGHT. The results
show that our method can obtain significant im-
provements over strong baselines on both datasets
with fully labeled data, and even outperforms
state-of-the-art results on ATIS. With additional
logical forms synthesized from rules or tem-
plates, our method is competitive with state-of-
the-art systems on OVERNIGHT. Furthermore,
our method is compatible with various semantic
parsing models. We also conduct extensive ex-
periments to further investigate our framework in
semi-supervised settings, trying to figure out why
it works.

The main contributions of this paper are sum-
marized as follows:

• An innovative semantic parsing framework
based on dual learning is introduced, which
can fully exploit data (labeled or unlabeled)
and incorporate various prior-knowledge as
feedback signals. We are the first to intro-
duce dual learning in semantic parsing to the
best of our knowledge.

• We further propose a novel validity reward
focusing on the surface and semantics of log-
ical forms, which is a feedback signal indi-
cating whether the generated logical form is
well-formed. It involves the prior-knowledge
about structures of logical forms predefined
in a domain.

• We conduct extensive experiments on ATIS
and OVERNIGHT benchmarks. The results
show that our method achieves new state-
of-the-art performance (test accuracy 89.1%)

on ATIS dataset and gets competitive perfor-
mance on OVERNIGHT dataset.

2 Primal and Dual Tasks of Semantic
Parsing

Before discussing the dual learning algorithm
for semantic parsing, we first present the pri-
mal and dual tasks (as mentioned before) in de-
tail. The primal and dual tasks are modeled
on the attention-based Encoder-Decoder architec-
tures (i.e. Seq2seq) which have been successfully
applied in neural semantic parsing (Jia and Liang,
2016; Dong and Lapata, 2016). We also include
copy mechanism (Gulcehre et al., 2016; See et al.,
2017) to tackle unknown tokens.

2.1 Primal Task
The primal task is semantic parsing which con-
verts queries into logical forms (Q2LF ). Let x =
x1 · · ·x|x| denote the query, and y = y1 · · · y|y|
denote the logical form. An encoder is exploited
to encode the query x into vector representations,
and a decoder learns to generate logical form y
depending on the encoding vectors.
Encoder Each word xi is mapped to a fixed-
dimensional vector by a word embedding func-
tion ψ(·) and then fed into a bidirectional LSTM
(Hochreiter and Schmidhuber, 1997). The hidden
vectors are recursively computed at the i-th time
step via:

−→
hi =fLSTM(ψ(xi),

−→
h i−1), i = 1, · · · , |x| (1)

←−
hi =fLSTM(ψ(xi),

←−
h i+1), i = |x|, · · · , 1 (2)

hi =[
−→
h i;
←−
h i] (3)

where [·; ·] denotes vector concatenation, hi ∈
R2n, n is the number of hidden cells and fLSTM
is the LSTM function.
Decoder Decoder is an unidirectional LSTM
with the attention mechanism (Luong et al., 2015).
The hidden vector at the t-th time step is computed
by st = fLSTM(φ(yt−1), st−1), where φ(·) is the
token embedding function for logical forms and
st ∈ Rn. The hidden vector of the first time step
is initialized as s0 =

←−
h 1. The attention weight for

the current step t of the decoder, with the i-th step
in the encoder is ati =

exp(uti)∑|x|
j=1 exp(u

t
j)

and

uti =v
T tanh(W1hi + W2st + ba) (4)



53

Figure 1: An overview of dual semantic parsing framework. The primal model (Q2LF ) and dual model (LF2Q)
can form a closed cycle. But there are two different directed loops, depending on whether they start from a query
or logical form. Validity reward is used to estimate the quality of the middle generation output, and reconstruction
reward is exploited to avoid information loss. The primal and dual models can be pre-trained and fine-tuned with
labeled data to keep the models effective.

where v,ba ∈ Rn, and W1 ∈ Rn×2n,W2 ∈ Rn×n
are parameters. Then we compute the vocabulary
distribution Pgen(yt|y<t, x) by

ct =
|x|∑
i=1

atihi (5)

Pgen(yt|y<t, x) =softmax(Wo[st; ct] + bo) (6)

where Wo ∈ R|Vy |×3n, bo ∈ R|Vy | and |Vy| is the
output vocabulary size. Generation ends once an
end-of-sequence token “EOS” is emitted.
Copy Mechanism We also include copy mech-
anism to improve model generalization following
the implementation of See et al. (2017), a hybrid
between Nallapati et al. (2016) and pointer net-
work (Gulcehre et al., 2016). The predicted token
is from either a fixed output vocabulary Vy or raw
input words x. We use sigmoid gate function σ to
make a soft decision between generation and copy
at each step t.

gt =σ(vTg [st; ct;φ(yt−1)] + bg) (7)
P (yt|y<t, x) =gtPgen(yt|y<t, x)

+ (1− gt)Pcopy(yt|y<t, x)
(8)

where gt ∈ [0, 1] is the balance score, vg is a
weight vector and bg is a scalar bias. Distribution
Pcopy(yt|y<t, x) will be described as follows.
Entity Mapping Although the copy mechanism
can deal with unknown words, many raw words
can not be directly copied to be part of a log-
ical form. For example, kobe bryant is
represented as en.player.kobe_bryant in
OVERNIGHT (Wang et al., 2015). It is common
that entities are identified by Uniform Resource
Identifier (URI, Klyne and Carroll, 2006) in a

knowledge base. Thus, a mapping from raw words
to URI is included after copying. Mathematically,
Pcopy in Eq.8 is calculated by:

Pcopy(yt = w|y<t, x) =
∑

i,j: KB(xi:j)=w

j∑
k=i

atk

where i < j, atk is the attention weight of posi-
tion k at decoding step t, KB(·) is a dictionary-
like function mapping a specific noun phrase to
the corresponding entity token in the vocabulary
of logical forms.

2.2 Dual Model
The dual task (LF2Q) is an inverse of the primal
task, which aims to generate a natural language
query given a logical form. We can also exploit
the attention-based Encoder-Decoder architecture
(with copy mechanism or not) to build the dual
model.
Reverse Entity Mapping Different with the pri-
mal task, we reversely map every possible KB
entity yt of a logical form to the corresponding
noun phrase before query generation,KB−1(yt)1.
Since each KB entity may have multiple aliases in
the real world, e.g. kobe bryant has a nick-
name the black mamba, we make different
selections in two cases:

• For paired data, we select the noun phrase
from KB−1(yt), which exists in the query.

• For unpaired data, we randomly select one
from KB−1(yt).

1KB−1(·) is the inverse operation of KB(·), which re-
turns the set of all corresponding noun phrases given a KB
entity.



54

3 Dual learning for Semantic Parsing

In this section, we present a semantic parsing
framework with dual learning. We use one agent
to represent the model of the primal task (Q2LF )
and another agent to represent the model of the
dual task (LF2Q), then design a two-agent game
in a closed loop which can provide quality feed-
back to the primal and dual models even if only
queries or logical forms are available. As the feed-
back reward may be non-differentiable, reinforce-
ment learning algorithm (Sutton and Barto, 2018)
based on policy gradient (Sutton et al., 2000) is
applied for optimization.

Two agents, Q2LF and LF2Q, participate
in the collaborative game with two directed
loops as illustrated in Figure 1. One loop
query->logical_form->query starts
from a query, generates possible logical forms
by agent Q2LF and tries to reconstruct the
original query by LF2Q. The other loop
logical_form->query->logical_form
starts from the opposite side. Each agent will
obtain quality feedback depending on reward
functions defined in the directed loops.

3.1 Learning algorithm

Suppose we have fully labeled dataset T =
{〈x, y〉}, unlabeled dataset Q with only queries
if available, and unlabeled dataset LF with only
logical forms if available. We firstly pre-train the
primal model Q2LF and the dual model LF2Q
on T by maximum likelihood estimation (MLE).
Let ΘQ2LF and ΘLF2Q denote all the parameters
of Q2LF and LF2Q respectively. Our learning
algorithm in each iteration consists of three parts:

3.1.1 Loop starts from a query
As shown in Figure 1 (a), we sample a query
x from Q ∪ T randomly. Given x, Q2LF
model could generate k possible logical forms
y1, y2, · · · , yk via beam search (k is beam size).
For each yi, we can obtain a validity reward
Rvalq (yi) (a scalar) computed by a specific reward
function which will be discussed in Section 3.2.1.
After feeding yi into LF2Q, we finally get a re-
construction reward Rrecq (x, yi) which forces the
generated query as similar to x as possible and will
be discussed in Section 3.2.2.

A hyper-parameter α is exploited to balance
these two rewards in rqi = αR

val
q (yi) + (1 −

α)Rrecq (x, yi), where α ∈ [0, 1].

By utilizing policy gradient (Sutton et al.,
2000), the stochastic gradients of ΘQ2LF and
ΘLF2Q are computed as:

∇ΘQ2LF Ê[r] =
1

k

k∑
i=1

rqi∇ΘQ2LF logP (yi|x; ΘQ2LF )

∇ΘLF2QÊ[r] =
1− α
k

k∑
i=1

∇ΘLF2Q logP (x|yi; ΘLF2Q)

3.1.2 Loop starts from a logical form
As shown in Figure 1 (b), we sample a logical
form y from LF ∪ T randomly. Given y, LF2Q
model generates k possible queries x1, x2, · · · , xk
via beam search. For each xi, we can obtain a va-
lidity reward Rvallf (xi) (a scalar) which will also
be discussed in Section 3.2.1. After feeding xi
into Q2LF , we can also get a reconstruction re-
ward Rreclf (y, xi), which forces the generated log-
ical form as similar to y as possible and will be
discussed in Section 3.2.2.

A hyper-parameter β is also exploited to bal-
ance these two rewards by rlfi = βR

val
lf (xi)+(1−

β)Rreclf (y, xi), where β ∈ [0, 1].
By utilizing policy gradient, the stochastic gra-

dients of ΘQ2LF and ΘLF2Q are computed as:

∇ΘLF2QÊ[r] =
1

k

k∑
i=1

rlfi ∇ΘLF2Q logP (xi|y; ΘLF2Q)

∇ΘQ2LF Ê[r] =
1− β
k

k∑
i=1

∇ΘQ2LF logP (y|xi; ΘQ2LF )

3.1.3 Supervisor guidance
The previous two stages are unsupervised learning
processes, which need no labeled data. If there is
no supervision for the primal and dual models af-
ter pre-training, these two models would be rotten
especially when T is limited.

To keep the learning process stable and pre-
vent the models from crashes, we randomly se-
lect samples from T to fine-tune the primal and
dual models by maximum likelihood estimation
(MLE). Details about the dual learning algorithm
for semantic parsing are provided in Appendix A.

3.2 Reward design

As mentioned in Section 3.1, there are two types
of reward functions in each loop: validity reward
(Rvalq , R

val
lf ) and reconstruction reward (R

rec
q ,

Rreclf ). But each type of reward function may be
different in different loops.



55

3.2.1 Validity reward
Validity reward is used to evaluate the quality of
intermediate outputs in a loop (see Figure 1). In
the loop starts from a query, it indicates whether
the generated logical forms are well-formed at the
surface and semantic levels. While in the loop
starts from a logical form, it indicates how natu-
ral and fluent the intermediate queries are.
Loop starts from a query: We estimate the qual-
ity of the generated logical forms at two levels, i.e.
surface and semantics. Firstly, we check whether
the logical form is a complete tree without paren-
theses mismatching. As for semantics, we check
whether the logical form is understandable with-
out errors like type inconsistency. It can be formu-
lated as

Rvalq (y) = grammar_error_indicator(y) (9)

which returns 1 when y has no error at the surface
and semantic levels, and returns 0 otherwise.

If there exists an executing program
or search engine for logical form y, e.g.
dataset OVERNIGHT (Wang et al., 2015),
grammar_error_indicator(·) has been included.

Otherwise, we should construct a grammar er-
ror indicator based on the ontology of the corre-
sponding dataset. For example, a specification of
ATIS can be extracted by clarifying all (1) entities
paired with corresponding types, (2) unary/binary
predicates with argument constraints (see Table 1).
Accordingly, Algorithm 1 abstracts the procedure
of checking the surface and semantics for a logical
form candidate y based on the specification.

category type instances

entity
me lunch:me, snack:me
al delta:al, usair:al
pd morning:pd, late:pd

category instances args0

unary
_city ci

_airport ap
_oneway flight

category instances args0 args1

binary
_from flight ci

_services al ci
_during_day flight pd

Table 1: A truncated specification for ATIS.

Loop starts from a logical form: A language
model (LM) is exploited to evaluate the quality of
intermediate queries (Mikolov et al., 2010). We

Algorithm 1 Grammar error indicator on ATIS
Input: Logical form string y; specification D
Output: 1/0, whether y is valid

1: if to_lisp_tree(y) succeed then
2: lispTree← to_lisp_tree(y)

. using Depth-First-Search for lispTree
3: if type_consistent(lispTree,D) then
4: return 1
5: end if
6: end if
7: return 0

apply length-normalization (Wu et al., 2016) to
make a fair competition between short and long
queries.

Rvallf (x) = logLMq(x)/Length(x), (10)

where LMq(·) is a language model pre-trained on
all the queries of Q∪ T (referred in Section 3.1).

3.2.2 Reconstruction reward
Reconstruction reward is used to estimate how
similar the output of one loop is compared with
the input. We take log likelihood as reconstruction
rewards for the loop starts from a query and the
loop starts from a logical form. Thus,

Rrecq (x, yi) = logP (x|yi; ΘLF2Q)
Rreclf (y, xi) = logP (y|xi; ΘQ2LF )

where yi and xi are intermediate outputs.

4 Experiment

In this section, we evaluate our framework on the
ATIS and OVERNIGHT datasets.

4.1 Dataset

ATIS We use the preprocessed version provided
by Dong and Lapata (2018), where natural lan-
guage queries are lowercased and stemmed with
NLTK (Loper and Bird, 2002), and entity men-
tions are replaced by numbered markers. We
also leverage an external lexicon that maps word
phrases (e.g., first class) to entities (e.g.,
first:cl) like what Jia and Liang (2016) did.
OVERNIGHT It contains natural language para-
phrases paired with logical forms across eight
domains. We follow the traditional 80%/20%
train/valid splits as Wang et al. (2015) to choose
the best model during training.



56

ATIS and OVERNIGHT never provide unlabeled
queries. To test our method in semi-supervised
learning, we keep a part of the training set as fully
labeled data and leave the rest as unpaired queries
and logical forms which simulate unlabeled data.

4.2 Synthesis of logical forms

Although there is no unlabeled query provided in
most semantic parsing benchmarks, it should be
easy to synthesize logical forms. Since a logi-
cal form is strictly structured and can be modi-
fied from the existing one or created from simple
grammars, it is much cheaper than query collec-
tion. Our synthesized logical forms are public 2.

4.2.1 Modification based on ontology
On ATIS, we randomly sample a logical form from
the training set, and select one entity or predicate
for replacement according to the specification in
Table 1. If the new logical form after replacement
is valid and never seen, it is added to the unsuper-
vised set. 4592 new logical forms are created for
ATIS. An example is shown in Figure 2.

Figure 2: Synthesis of logical forms by replacement.

4.2.2 Generation based on grammar
Wang et al. (2015) proposed an underlying gram-
mar to generate logical forms along with their cor-
responding canonical utterances on OVERNIGHT,
which can be found in SEMPRE 3. We reorder
the entity instances (e.g., ENTITYNP) of one type
(e.g., TYPENP) in grammar files to generate new
logical forms. We could include new entity in-
stances if we want more unseen logical forms, but
we didn’t do that actually. Finally, we get about

2https://github.com/RhythmCao/
Synthesized-Logical-Forms

3https://github.com/percyliang/sempre

500 new logical forms for each domain on aver-
age. More examples can be found in Appendix B.

4.3 Experimental settings

4.3.1 Base models
We use 200 hidden units and 100-dimensional
word vectors for all encoders and decoders of
Q2LF and LF2Q models. The LSTMs used
are in single-layer. Word embeddings on query
side are initialized by Glove6B (Pennington et al.,
2014). Out-of-vocabulary words are replaced with
a special token 〈unk〉. Other parameters are ini-
tialized by uniformly sampling within the interval
[−0.2, 0.2]. The language model we used is also
a single-layer LSTM with 200 hidden units and
100-dim word embedding layer.

4.3.2 Training and decoding
We individually pre-train Q2LF /LF2Q models
using only labeled data and language model LMq
using both labeled and unlabeled queries. The lan-
guage model is fixed for calculating reward. The
hyper-parameters α and β are selected according
to validation set (0.5 is used), and beam size k is
selected from {3, 5}. The batch size is selected
from {10, 20}. We use optimizer Adam (Kingma
and Ba, 2014) with learning rate 0.001 for all ex-
periments. Finally, we evaluate the primal model
(Q2LF , semantic parsing) and report test accu-
racy on each dataset.

4.4 Results and analysis

We perform a PSEUDO baseline following the
setup in Sennrich et al. (2016) and Guo et al.
(2018). The pre-trained LF2Q or Q2LF model
is used to generate pseudo 〈query, logical form〉
pairs from unlabeled logical forms or unlabeled
queries, which extends the training set. The
pseudo-labeled data is used carefully with a dis-
count factor (0.5) in loss function (Lee, 2013),
when we train Q2LF by supervised training.

4.4.1 Main results
The results are illustrated in Table 2 and 3. ATT
and ATTPTR represent that the primal/dual models
are attention-based Seq2seq and attention-based
Seq2seq with copy mechanism respectively. We
train models with the dual learning algorithm if
DUAL is included, otherwise we only train the pri-
mal model by supervised training. LF refers to
the synthesized logical forms. PSEUDO uses the

https://github.com/RhythmCao/Synthesized-Logical-Forms
https://github.com/RhythmCao/Synthesized-Logical-Forms


57

Method Bas. Blo. Cal. Hou. Pub. Rec. Res. Soc. Avg.
SPO (Wang et al., 2015) 46.3 41.9 74.4 54.0 59.0 70.8 75.9 48.2 58.8
DSP-C (Xiao et al., 2016) 80.5 55.6 75.0 61.9 75.8 _ 80.1 80.0 72.7
NO RECOMBINATION (Jia and Liang, 2016) 85.2 58.1 78.0 71.4 76.4 79.6 76.2 81.4 75.8
DATARECOMB (Jia and Liang, 2016)*(+data) 87.5 60.2 81.0 72.5 78.3 81.0 79.5 79.6 77.5
CROSSDOMAIN (Su and Yan, 2017) 88.2 62.2 82.1 78.8 80.1 86.1 83.7 83.1 80.6
DOMAINENCODING (Herzig and Berant, 2017) 86.2 62.7 82.1 78.3 80.7 82.9 82.2 81.7 79.6
SEQ2ACTION (Chen et al., 2018a) 88.2 61.4 81.5 74.1 80.7 82.9 80.7 82.1 79.0
ATT 86.2 61.4 76.4 68.8 75.2 76.9 78.9 82.2 75.7
ATT + PSEUDO(LF) 87.2 60.9 73.2 71.4 75.8 80.1 79.2 82.0 76.2
ATT + DUAL 87.5 63.7 79.8 73.0 81.4 81.5 81.6 83.0 78.9
ATT + DUAL + LF 88.0 65.2 80.7 76.7 80.7 82.4 84.0 83.8 80.2
ATTPTR 86.7 63.2 74.4 69.3 75.8 77.8 78.3 82.2 76.0
ATTPTR + PSEUDO(LF) 85.7 63.4 74.4 69.8 78.3 78.7 79.8 82.1 76.5
ATTPTR + DUAL 87.7 63.4 77.4 74.1 80.1 80.1 82.5 83.4 78.6
ATTPTR + DUAL + LF 87.0 66.2 79.8 75.1 80.7 83.3 83.4 83.8 79.9

Table 2: Test accuracies on OVERNIGHT compared with previous systems.

Method ATIS
ZC07 (Zettlemoyer and Collins, 2007) 84.6
FUBL (Kwiatkowski et al., 2011) 82.8
GUSP++ (Poon, 2013) 83.5
TISP (Zhao and Huang, 2015) 84.2
SEQ2TREE (Dong and Lapata, 2016) 84.6
ASN+SUPATT (Rabinovich et al., 2017) 85.9
TRANX (Yin and Neubig, 2018) 86.2
COARSE2FINE (Dong and Lapata, 2018) 87.7
ATT 84.4
ATT + PSEUDO(LF) 83.3
ATT + DUAL 86.4
ATT + DUAL + LF 87.1
ATTPTR 85.7
ATTPTR + PSEUDO(LF) 86.2
ATTPTR + DUAL 88.6
ATTPTR + DUAL + LF 89.1

Table 3: Test accuracies on ATIS compared with previ-
ous systems.

LF2Q model and LF to generate pseudo-labeled
data. From the overall results, we can see that:

1) Even without the additional logical forms
by synthesizing, the dual learning based seman-
tic parser can outperform our baselines with su-
pervised training, e.g., “ATT + DUAL” gets much
better performances than “ATT + PSEUDO(LF)”
in Table 2 and 3. We think the Q2LF and LF2Q
models can teach each other in dual learning: one
model sends informative signals to help regularize
the other model. Actually, it can also be explained
as a data augmentation procedure, e.g., Q2LF
can generate samples utilized by LF2Q and vice
versa. While the PSEUDO greatly depends on the
quality of pseudo-samples even if a discount factor
is considered.

2) By involving the synthesized logical forms
LF in the dual learning for each domain respec-
tively, the performances are improved further. We

achieve state-of-the-art performance (89.1%)4 on
ATIS as shown in Table 3. On OVERNIGHT
dataset, we achieve a competitive performance on
average (80.2%). The best average accuracy is
from Su and Yan (2017), which benefits from
cross-domain training. We believe our method
could get more improvements with stronger pri-
mal models (e.g. with domain adaptation). Our
method would be compatible with various models.

3) Copy mechanism can remarkably improve
accuracy on ATIS, while not on OVERNIGHT. The
average accuracy even decreases from 80.2% to
79.9% when using the copy mechanism. We ar-
gue that OVERNIGHT dataset contains a very small
number of distinct entities that copy is not es-
sential, and it contains less training samples than
ATIS. This phenomenon also exists in Jia and
Liang (2016).

4.4.2 Ablation study
Semi-supervised learning We keep a part of the
training set as labeled data T randomly and leave
the rest as unpaired queries (Q) and logical forms
(LF) to validate our method in a semi-supervised
setting. The ratio of labeled data is 50%. PSEUDO
here uses the Q2LF model and Q to generate
pseudo-labeled data, as well as LF2Q model and
LF . From Table 4, we can see that the dual
learning method outperforms the PSEUDO base-
line in two datasets dramatically. The dual learn-
ing method is more efficient to exploit unlabeled
data. In general, both unpaired queries and logi-

4Although there is another published result that achieved
better performance by using word class information from
Wiktionary (Wang et al., 2014), it is unfair to compare it
with our results and other previous systems which only ex-
ploit data resources of ATIS.



58

Method Bas. Blo. Cal. Hou. Pub. Rec. Res. Soc. Avg. ATIS
ATT 80.1 55.4 61.9 53.4 60.2 64.4 71.1 76.8 65.4 78.6
ATT+PSEUDO(Q) 80.1 59.4 60.1 52.9 59.6 66.2 73.8 79.0 66.4 78.8
ATT+PSEUDO(LF) 83.9 60.4 64.3 54.5 58.4 69.0 70.5 77.3 67.3 77.9
ATT+PSEUDO(LF+Q) 80.6 59.1 61.9 57.1 62.7 65.3 73.2 79.8 67.5 78.3
ATT+DUAL 82.6 60.2 72.0 58.7 66.5 73.6 74.1 79.3 70.9 79.5
ATT+DUAL+Q 83.9 60.7 70.2 60.8 69.6 71.3 76.2 79.8 71.6 79.7
ATT+DUAL+LF 83.4 61.4 71.4 59.3 70.2 73.1 75.3 78.6 71.6 80.4
ATT+DUAL+LF+Q 85.4 62.9 73.2 59.3 72.0 75.5 75.6 79.5 72.9 81.7
ATTPTR 81.1 58.1 63.1 48.7 55.3 69.4 68.4 77.4 65.2 84.8
ATTPTR+PSEUDO(Q) 82.1 59.6 61.3 47.6 57.1 72.2 69.9 78.4 66.0 85.0
ATTPTR+PSEUDO(LF) 82.4 59.1 62.5 54.5 63.4 71.3 69.6 77.6 67.5 86.2
ATTPTR+PSEUDO(LF+Q) 81.3 59.4 65.5 49.2 58.4 72.7 72.0 78.6 67.1 85.0
ATTPTR+DUAL 81.8 60.2 68.5 57.1 65.2 72.2 74.1 79.0 69.8 86.2
ATTPTR+DUAL+Q 81.6 60.7 69.6 61.4 68.9 74.1 79.8 80.1 72.0 86.6
ATTPTR+DUAL+LF 82.6 62.2 68.5 62.4 69.6 73.1 77.4 79.4 71.9 87.3
ATTPTR+DUAL+LF+Q 83.6 62.2 72.6 61.9 71.4 75.0 76.5 80.4 73.0 86.8

Table 4: Semi-supervised learning experiments. We keep 50% of the training set as labeled data randomly, and
leave the rest as unpaired queries(Q) and logical forms(LF) to simulate unsupervised dataset.

Figure 3: Test accuracies on ATIS. It varies the ratio of
labeled data, and keeps the rest as unlabeled data.

cal forms could boost the performance of semantic
parsers with dual learning.

Different ratios To investigate the efficiency of
our method in semi-supervised learning, we vary
the ratio of labeled data kept on ATIS from 1% to
90%. In Figure 3, we can see that dual learning
strategy enhances semantic parsing over all pro-
portions. The prominent gap happens when the
ratio is between 0.2 and 0.4. Generally, the more
unlabeled data we have, the more remarkable the
leap is. However, if the labeled data is really lim-
ited, less supervision can be exploited to keep the
primal and dual models reasonable. For example,
when the ratio of labeled data is from only 1% to
10%, the improvement is not that obvious.
Does more unlabeled data give better result?
We also fix the ratio of labeled data as 30%, and
change the ratio of unlabeled samples to the rest
data on ATIS, as illustrated in Figure 4. Even

Figure 4: Test accuracies on ATIS. It fixes the ratio of
labeled data as 30%, and varies the ratio of unlabeled
samples to the rest data.

without unlabeled data (i.e. the ratio of unlabeled
data is zero), the dual learning based semantic
parser can outperform our baselines. However, the
performance of our method doesn’t improve con-
stantly, when the amount of unlabeled data is in-
creased. We think the power of the primal and dual
models is constrained by the limited amount of la-
beled data. When some complex queries or logi-
cal forms come, the two models may converge to
an equilibrium where the intermediate value loses
some implicit semantic information, but the re-
wards are high.

Choice for validity reward We conduct another
experiment by changing validity reward in Eq.9
with length-normalized LM score (i.e. language
model of logical forms) like Eq.10. Results (Ta-
ble 5) show that “hard” surface/semantic check
is more suitable than “soft” probability of logical



59

Method Validity ATIS OVERNIGHT
ATT LMlf 80.6 71.5

+ DUAL grammar check 81.7 72.9
ATTPTR LMlf 86.2 71.4

+ DUAL grammar check 86.8 73.0

Table 5: Test accuracies on ATIS and OVERNIGHT in
semi-supervised learning setting (the ratio of labeled
data is 50%). On OVERNIGHT, we average across
all eight domains. LMlf means using a logical form
language model for validity reward, while “grammar
check” means using the surface and semantic check.

form LM. We think that simple language models
may suffer from long-dependency and data imbal-
ance issues, and it is hard to capture inner struc-
tures of logical forms from a sequential model.

5 Related Work

Lack of data A semantic parser can be trained
from labeled logical forms or weakly supervised
samples (Krishnamurthy and Mitchell, 2012; Be-
rant et al., 2013; Liang et al., 2017; Goldman et al.,
2018). Yih et al. (2016) demonstrate logical forms
can be collected efficiently and more useful than
merely answers to queries. Wang et al. (2015)
construct a semantic parsing dataset starting from
grammar rules to crowdsourcing paraphrase. Jia
and Liang (2016) induces synchronous context-
free grammar (SCFG) and creates new “recombi-
nant” examples accordingly. Su and Yan (2017)
use multiple source domains to reduce the cost
of collecting data for the target domain. Guo
et al. (2018) pre-train a question generation model
to produce pseudo-labeled data as a supplement.
In this paper, we introduce the dual learning to
make full use of data (both labeled and unla-
beled). Yin et al. (2018) introduce a variational
auto-encoding model for semi-supervised seman-
tic parsing. Beyond semantic parsing, the semi-
supervised and adaptive learnings are also typi-
cal in natural language understanding (Tur et al.,
2005; Bapna et al., 2017; Zhu et al., 2014, 2018;
Zhu and Yu, 2018).
Constrained decoding To avoid invalid parses,
additional restrictions must be considered in the
decoding. Dong and Lapata (2016) propose
SEQ2TREE method to ensure the matching of
parentheses, which can generate syntactically
valid output. Cheng et al. (2017) and Dong and
Lapata (2018) both try to decode in two steps,
from a coarse rough sketch to a finer structure hi-
erarchically. Krishnamurthy et al. (2017) define a

grammar of production rules such that only well-
typed logical forms can be generated. Yin and
Neubig (2017) and Chen et al. (2018a) both trans-
form the generation of logical forms into query
graph construction. Zhao et al. (2019) propose a
hierarchical parsing model following the structure
of semantic representations, which is predefined
by domain developers. We introduce a validity re-
ward at the surface and semantic levels in the dual
learning algorithm as a constraint signal.
Dual learning Dual learning framework is first
proposed to improve neural machine translation
(NMT) (He et al., 2016). Actually, the primal
and dual tasks are symmetric in NMT, while not
in semantic parsing. The idea of dual learn-
ing has been applied in various tasks (Xia et al.,
2017), such as Question Answering/Generation
(Tang et al., 2017, 2018), Image-to-Image Trans-
lation (Yi et al., 2017) and Open-domain Informa-
tion Extraction/Narration (Sun et al., 2018). We
are the first to introduce dual learning in semantic
parsing to the best of our knowledge.

6 Conclusions and Future Work

In this paper, we develop a semantic parsing
framework based on dual learning algorithm,
which enables a semantic parser to fully utilize
labeled and even unlabeled data through a dual-
learning game between the primal and dual mod-
els. We also propose a novel reward function at
the surface and semantic levels by utilizing the
prior-knowledge of logical form structures. Thus,
the primal model tends to generate complete and
reasonable semantic representation. Experimental
results show that semantic parsing based on dual
learning improves performance across datasets.

In the future, we want to incorporate this frame-
work with much refined primal and dual mod-
els, and design more informative reward signals
to make the training more efficient. It would be
appealing to apply graph neural networks (Chen
et al., 2018b, 2019) to model structured logical
forms.

Acknowledgments

This work has been supported by the Na-
tional Key Research and Development Program
of China (Grant No.2017YFB1002102) and the
China NSFC projects (No. 61573241).



60

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-

gio. 2014. Neural machine translation by jointly
learning to align and translate. arXiv preprint
arXiv:1409.0473.

Ankur Bapna, Gökhan Tür, Dilek Hakkani-Tür, and
Larry P. Heck. 2017. Towards zero-shot frame se-
mantic parsing for domain scaling. In Interspeech
2017, 18th Annual Conference of the International
Speech Communication Association, pages 2476–
2480.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1533–1544.

Bo Chen, Le Sun, and Xianpei Han. 2018a. Sequence-
to-action: End-to-end semantic graph generation for
semantic parsing. In Proceedings of the 56th Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers), pages 766–777.

Lu Chen, Zhi Chen, Bowen Tan, Sishan Long, Mil-
ica Gasic, and Kai Yu. 2019. Agentgraph: To-
wards universal dialogue management with struc-
tured deep reinforcement learning. arXiv preprint
arXiv:1905.11259.

Lu Chen, Bowen Tan, Sishan Long, and Kai Yu.
2018b. Structured dialogue policy with graph neu-
ral networks. In Proceedings of the 27th Inter-
national Conference on Computational Linguistics,
pages 1257–1268, Santa Fe, New Mexico, USA.

Jianpeng Cheng, Siva Reddy, Vijay Saraswat, and
Mirella Lapata. 2017. Learning structured natural
language representations for semantic parsing. In
Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 44–55.

Li Dong and Mirella Lapata. 2016. Language to logi-
cal form with neural attention. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
33–43.

Li Dong and Mirella Lapata. 2018. Coarse-to-fine de-
coding for neural semantic parsing. In Proceed-
ings of the 56th Annual Meeting of the Association
for Computational Linguistics (Volume 1: Long Pa-
pers), pages 731–742.

Omer Goldman, Veronica Latcinnik, Ehud Nave, Amir
Globerson, and Jonathan Berant. 2018. Weakly su-
pervised semantic parsing with abstract examples.
In Proceedings of the 56th Annual Meeting of the
Association for Computational Linguistics (Volume
1: Long Papers), pages 1809–1819.

Caglar Gulcehre, Sungjin Ahn, Ramesh Nallapati,
Bowen Zhou, and Yoshua Bengio. 2016. Pointing

the unknown words. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 140–
149.

Daya Guo, Yibo Sun, Duyu Tang, Nan Duan, Jian Yin,
Hong Chi, James Cao, Peng Chen, and Ming Zhou.
2018. Question generation from sql queries im-
proves neural semantic parsing. In Proceedings of
the 2018 Conference on Empirical Methods in Nat-
ural Language Processing, pages 1597–1607.

Di He, Yingce Xia, Tao Qin, Liwei Wang, Nenghai Yu,
Tie-Yan Liu, and Wei-Ying Ma. 2016. Dual learn-
ing for machine translation. In Advances in Neural
Information Processing Systems, pages 820–828.

Jonathan Herzig and Jonathan Berant. 2017. Neural
semantic parsing over multiple knowledge-bases. In
Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics (Volume 2:
Short Papers), pages 623–628.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Robin Jia and Percy Liang. 2016. Data recombination
for neural semantic parsing. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
12–22.

Diederik P Kingma and Jimmy Ba. 2014. Adam: A
method for stochastic optimization. arXiv preprint
arXiv:1412.6980.

Graham Klyne and Jeremy J Carroll. 2006. Resource
description framework (rdf): Concepts and abstract
syntax.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gard-
ner. 2017. Neural semantic parsing with type con-
straints for semi-structured tables. In Proceedings of
the 2017 Conference on Empirical Methods in Nat-
ural Language Processing, pages 1516–1526.

Jayant Krishnamurthy and Tom M Mitchell. 2012.
Weakly supervised training of semantic parsers. In
Proceedings of the 2012 Joint Conference on Empir-
ical Methods in Natural Language Processing and
Computational Natural Language Learning, pages
754–765.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2011. Lexical generaliza-
tion in ccg grammar induction for semantic pars-
ing. In Proceedings of the conference on empiri-
cal methods in natural language processing, pages
1512–1523.

Dong-Hyun Lee. 2013. Pseudo-label: The simple and
efficient semi-supervised learning method for deep
neural networks. In Workshop on Challenges in
Representation Learning, ICML.



61

Chen Liang, Jonathan Berant, Quoc Le, Kenneth D.
Forbus, and Ni Lao. 2017. Neural symbolic ma-
chines: Learning semantic parsers on freebase with
weak supervision. In Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 23–33.

Edward Loper and Steven Bird. 2002. NLTK: The nat-
ural language toolkit. In Proceedings of the ACL-02
Workshop on Effective Tools and Methodologies for
Teaching Natural Language Processing and Compu-
tational Linguistics.

Wei Lu, Hwee Tou Ng, Wee Sun Lee, and Luke S
Zettlemoyer. 2008. A generative model for pars-
ing natural language to meaning representations. In
Proceedings of the Conference on Empirical Meth-
ods in Natural Language Processing, pages 783–
792.

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-based
neural machine translation. In Proceedings of the
2015 Conference on Empirical Methods in Natural
Language Processing, pages 1412–1421.

Tomáš Mikolov, Martin Karafiát, Lukáš Burget, Jan
Černockỳ, and Sanjeev Khudanpur. 2010. Recurrent
neural network based language model. In Eleventh
annual conference of the international speech com-
munication association.

Ramesh Nallapati, Bowen Zhou, Cicero dos Santos,
Caglar Gulcehre, and Bing Xiang. 2016. Ab-
stractive text summarization using sequence-to-
sequence rnns and beyond. In Proceedings of The
20th SIGNLL Conference on Computational Natu-
ral Language Learning, pages 280–290.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. Glove: Global vectors for word
representation. In Proceedings of the 2014 confer-
ence on empirical methods in natural language pro-
cessing (EMNLP), pages 1532–1543.

Hoifung Poon. 2013. Grounded unsupervised seman-
tic parsing. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguistics
(Volume 1: Long Papers), volume 1, pages 933–943.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code genera-
tion and semantic parsing. In Proceedings of the
55th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
1139–1149.

Abigail See, Peter J. Liu, and Christopher D. Manning.
2017. Get to the point: Summarization with pointer-
generator networks. In Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 1073–
1083.

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Improving neural machine translation mod-
els with monolingual data. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
86–96.

Yu Su and Xifeng Yan. 2017. Cross-domain seman-
tic parsing via paraphrasing. In Proceedings of the
2017 Conference on Empirical Methods in Natural
Language Processing, pages 1235–1246.

Mingming Sun, Xu Li, and Ping Li. 2018. Logician
and orator: Learning from the duality between lan-
guage and knowledge in open domain. In Proceed-
ings of the 2018 Conference on Empirical Methods
in Natural Language Processing, pages 2119–2130.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In Advances in neural information process-
ing systems, pages 3104–3112.

Richard S Sutton and Andrew G Barto. 2018. Rein-
forcement learning: An introduction. MIT press.

Richard S Sutton, David A McAllester, Satinder P
Singh, and Yishay Mansour. 2000. Policy gradi-
ent methods for reinforcement learning with func-
tion approximation. In Advances in neural informa-
tion processing systems, pages 1057–1063.

Duyu Tang, Nan Duan, Tao Qin, Zhao Yan, and
Ming Zhou. 2017. Question answering and ques-
tion generation as dual tasks. arXiv preprint
arXiv:1706.02027.

Duyu Tang, Nan Duan, Zhao Yan, Zhirui Zhang, Yibo
Sun, Shujie Liu, Yuanhua Lv, and Ming Zhou. 2018.
Learning to collaborate for question answering and
asking. In Proceedings of the 2018 Conference
of the North American Chapter of the Association
for Computational Linguistics: Human Language
Technologies, Volume 1 (Long Papers), pages 1564–
1574.

Gokhan Tur, Dilek Hakkani-Tür, and Robert E.
Schapire. 2005. Combining active and semi-
supervised learning for spoken language under-
standing. Speech Communication, 45(2):171–186.

Oriol Vinyals, Łukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey Hinton. 2015. Gram-
mar as a foreign language. In Advances in neural
information processing systems, pages 2773–2781.

Adrienne Wang, Tom Kwiatkowski, and Luke Zettle-
moyer. 2014. Morpho-syntactic lexical generaliza-
tion for CCG semantic parsing. In Proceedings of
the 2014 Conference on Empirical Methods in Nat-
ural Language Processing (EMNLP), pages 1284–
1295, Doha, Qatar. Association for Computational
Linguistics.



62

Yushi Wang, Jonathan Berant, and Percy Liang. 2015.
Building a semantic parser overnight. In Proceed-
ings of the 53rd Annual Meeting of the Association
for Computational Linguistics and the 7th Interna-
tional Joint Conference on Natural Language Pro-
cessing (Volume 1: Long Papers), pages 1332–1342.

Yuk Wah Wong and Raymond Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Proceedings of the 45th
Annual Meeting of the Association of Computational
Linguistics, pages 960–967.

Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V
Le, Mohammad Norouzi, Wolfgang Macherey,
Maxim Krikun, Yuan Cao, Qin Gao, Klaus
Macherey, et al. 2016. Google’s neural ma-
chine translation system: Bridging the gap between
human and machine translation. arXiv preprint
arXiv:1609.08144.

Yingce Xia, Tao Qin, Wei Chen, Jiang Bian, Nenghai
Yu, and Tie-Yan Liu. 2017. Dual supervised learn-
ing. In Proceedings of the 34th International Con-
ference on Machine Learning, pages 3789–3798.

Chunyang Xiao, Marc Dymetman, and Claire Gardent.
2016. Sequence-based structured prediction for se-
mantic parsing. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 1341–
1350.

Zili Yi, Hao Zhang, Ping Tan, and Minglun Gong.
2017. Dualgan: Unsupervised dual learning for
image-to-image translation. In Proceedings of the
IEEE International Conference on Computer Vision,
pages 2849–2857.

Wen-tau Yih, Matthew Richardson, Chris Meek, Ming-
Wei Chang, and Jina Suh. 2016. The value of se-
mantic parse labeling for knowledge base question
answering. In Proceedings of the 54th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers), pages 201–206.

Pengcheng Yin and Graham Neubig. 2017. A syntactic
neural model for general-purpose code generation.
In Proceedings of the 55th Annual Meeting of the
Association for Computational Linguistics (Volume
1: Long Papers), pages 440–450.

Pengcheng Yin and Graham Neubig. 2018. Tranx: A
transition-based neural abstract syntax parser for se-
mantic parsing and code generation. In Proceedings
of the 2018 Conference on Empirical Methods in
Natural Language Processing: System Demonstra-
tions, pages 7–12.

Pengcheng Yin, Chunting Zhou, Junxian He, and Gra-
ham Neubig. 2018. StructVAE: Tree-structured la-
tent variable models for semi-supervised semantic
parsing. In Proceedings of the 56th Annual Meet-
ing of the Association for Computational Linguis-
tics (Volume 1: Long Papers), pages 754–765, Mel-
bourne, Australia. Association for Computational
Linguistics.

John M Zelle and Raymond J Mooney. 1996. Learn-
ing to parse database queries using inductive logic
programming. In Proceedings of the national con-
ference on artificial intelligence, pages 1050–1055.

Luke Zettlemoyer and Michael Collins. 2007. Online
learning of relaxed ccg grammars for parsing to log-
ical form. In Proceedings of the 2007 Joint Con-
ference on Empirical Methods in Natural Language
Processing and Computational Natural Language
Learning (EMNLP-CoNLL).

Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In UAI, pages 658–666.

Kai Zhao and Liang Huang. 2015. Type-driven in-
cremental semantic parsing with polymorphism. In
Proceedings of the 2015 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 1416–1421.

Zijian Zhao, Su Zhu, and Kai Yu. 2019. A hierar-
chical decoding model for spoken language under-
standing from unaligned data. In ICASSP 2019-
2019 IEEE International Conference on Acous-
tics, Speech and Signal Processing (ICASSP), pages
7305–7309. IEEE.

Su Zhu, Lu Chen, Kai Sun, Da Zheng, and Kai
Yu. 2014. Semantic parser enhancement for dia-
logue domain extension with little data. In Spoken
Language Technology Workshop (SLT), 2014 IEEE,
pages 336–341. IEEE.

Su Zhu, Ouyu Lan, and Kai Yu. 2018. Robust spoken
language understanding with unsupervised asr-error
adaptation. In IEEE International Conference on
Acoustics, Speech and Signal Processing (ICASSP)
2018, pages 6179–6183. IEEE.

Su Zhu and Kai Yu. 2018. Concept transfer learning for
adaptive language understanding. In Proceedings of
the 19th Annual SIGdial Meeting on Discourse and
Dialogue, pages 391–399. Association for Compu-
tational Linguistics.



63

A Detailed algorithm

Algorithm 2 Dual Learning Framework for Semantic Parsing
Input:

1: Supervised dataset T = {〈x, y〉}; Unsupervised dataset for queries Q and logical forms LF ;
2: Pre-trained models on T : Q2LF model P (y|x; ΘQ2LF ), LF2Q model P (x|y; ΘLF2Q);
3: Pre-trained model on Q and queries of T : Language Model for queries LMq;
4: Indicator performs surface and semantic check for a logical form: grammar_error_indicator(·);
5: Beam search size k, hyper parameters α and β, learning rate η1 for Q2LF and η2 for LF2Q;

Output: Parameters ΘQ2LF of Q2LF model
6: repeat
7: . Reinforcement learning process uses unlabeled data, also reuses labeled data

8: Sample a query x from Q∪ T ;
9: Q2LF model generates k logical forms
y1, y2, · · · , yk via beam search;

10: for each possible logical form yi do
11: Obtain validity reward for yi as

Rvalq (yi) = grammar_error_indicator(yi)

12: Get reconstruction reward for yi as

Rrecq (x, yi) = logP (x|yi; ΘLF2Q)

13: Compute total reward for yi as

rqi = αR
val
q (yi) + (1− α)Rrecq (x, yi)

14: end for
15: Compute stochastic gradient of ΘQ2LF :

∇ΘQ2LF Ê[r] =
1

k

k∑
i=1

rqi∇ΘQ2LF logP (yi|x; ΘQ2LF )

16: Compute stochastic gradient of ΘLF2Q:

∇ΘLF2QÊ[r] =
1− α
k

k∑
i=1

∇ΘLF2Q logP (x|yi; ΘLF2Q)

17: Model updates:

ΘQ2LF ←ΘQ2LF + η1 · ∇ΘQ2LF Ê[r]
ΘLF2Q ←ΘLF2Q + η2 · ∇ΘLF2QÊ[r]

18: Sample a logical form y from LF ∪ T ;
19: LF2Q model generates k queries

x1, x2, · · · , xk via beam search;
20: for each possible query xi do
21: Obtain validity reward for xi as

Rvallf (xi) = logLMq(xi)/Length(xi)

22: Get reconstruction reward for xi as

Rreclf (y, xi) = logP (y|xi; ΘQ2LF )

23: Compute total reward for xi as

rlfi = βR
val
lf (xi) + (1− β)Rreclf (y, xi)

24: end for
25: Compute stochastic gradient of ΘLF2Q:

∇ΘLF2QÊ[r] =
1

k

k∑
i=1

rlfi ∇ΘLF2Q logP (xi|y; ΘLF2Q)

26: Compute stochastic gradient of ΘQ2LF :

∇ΘQ2LF Ê[r] =
1− β
k

k∑
i=1

∇ΘQ2LF logP (y|xi; ΘQ2LF )

27: Model updates:

ΘLF2Q ←ΘLF2Q + η2 · ∇ΘLF2QÊ[r]
ΘQ2LF ←ΘQ2LF + η1 · ∇ΘQ2LF Ê[r]

. After reinforcement learning process, use labeled data to fine-tune models
28: Sample a 〈x, y〉 pair from T ;
29: Update ΘQ2LF by ΘQ2LF ← ΘQ2LF + η1 · ∇ΘQ2LF logP (y|x; ΘQ2LF )
30: Update ΘLF2Q by ΘLF2Q ← ΘLF2Q + η2 · ∇ΘLF2Q logP (x|y; ΘLF2Q)
31: until Q2LF model converges



64

B Examples of synthesized logical forms

Original After Modification
Entity Replacement

( lambda $0 e ( and ( flight $0 ) ( meal $0
lunch:me ) ( from $0 ci0 ) ( to $0 ci1 ) ) )

( lambda $0 e ( and ( flight $0 ) ( meal $0 din-
ner:me ) ( from $0 ci0 ) ( to $0 ci1 ) ) )

( = al0 ( abbrev delta:al ) ) ( = al0 ( abbrev usair:al ) )
( lambda $0 e ( and ( flight $0 ) ( class_type $0
thrift:cl ) ( from $0 ci1 ) ( to $0 ci0 ) ) )

( lambda $0 e ( and ( flight $0 ) ( class_type $0
business:cl ) ( from $0 ci1 ) ( to $0 ci0 ) ) )

Unary Replacement
( lambda $0 e ( exists $1 ( and ( round_trip $1 ) (
from $1 ci0 ) ( to $1 ci1 ) ( = ( fare $1 ) $0 ) ) ) )

( lambda $0 e ( exists $1 ( and ( oneway $1 ) (
from $1 ci0 ) ( to $1 ci1 ) ( = ( fare $1 ) $0 ) ) ) )

( lambda $0 e ( and ( ground_transport $0 ) (
to_city $0 ci0 ) ) )

( lambda $0 e ( and ( has_meal $0 ) ( to_city $0
ci0 ) ) )

( lambda $0 e ( and ( taxi $0 ) ( to_city $0 ci0 ) (
from_airport $0 ap0 ) ) )

( lambda $0 e ( and ( limousine $0 ) ( to_city $0
ci0 ) ( from_airport $0 ap0 ) ) )

Binary Replacement
( lambda $0 e ( and ( flight $0 ) ( airline $0 al0 ) (
approx_departure_time $0 ti0 ) ( from $0 ci0 ) (
to $0 ci1 ) ) )

( lambda $0 e ( and ( flight $0 ) ( airline $0 al0 ) (
approx_arrival_time $0 ti0 ) ( from $0 ci0 ) ( to
$0 ci1 ) ) )

( lambda $0 e ( and ( flight $0 ) ( from $0
ci0 ) ( to $0 ci1 ) ( day_return $0 da0 ) (
day_number_return $0 dn0 ) ( month_return
$0 mn0 ) ) )

( lambda $0 e ( and ( flight $0 ) ( from $0
ci0 ) ( to $0 ci1 ) ( day_arrival $0 da0 ) (
day_number_arrival $0 dn0 ) ( month_arrival
$0 mn0 ) ) )

( lambda $0 e ( and ( flight $0 ) ( airline $0 al0 ) (
stop $0 ci0 ) ) )

( lambda $0 e ( and ( flight $0 ) ( airline $0 al0 ) (
from $0 ci0 ) ) )

Table 6: Examples of synthesized logical forms on ATIS.

Domain Logical Forms

Bas. pre
( call SW.listValue ( call SW.getProperty ( ( lambda s ( call SW.filter ( var s ) ( string position ) ( string
! = ) en.position.point_guard ) ) ( call SW.domain ( string player ) ) ) ( string player ) ) )

new ( call SW.listValue ( call SW.getProperty ( ( lambda s ( call SW.filter ( var s ) ( string position ) ( string! = ) en.position.forward ) ) ( call SW.domain ( string player ) ) ) ( string player ) ) )

Blo. pre
( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.block ) ( string ! type
) ) ( string shape ) ( string = ) en.shape.pyramid ) )

new ( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.block ) ( string ! type) ) ( string shape ) ( string = ) en.shape.cube ) )

Cal. pre
( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.location ) ( string !
type ) ) ( call SW.reverse ( string location ) ) ( string = ) en.meeting.weekly_standup ) )

new ( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.location ) ( string !type ) ) ( call SW.reverse ( string location ) ) ( string = ) en.meeting.annual_review ) )

Hou. pre
( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.housing_unit ) ( string !
type ) ) ( string housing_type ) ( string = ) ( call SW.concat en.housing.apartment en.housing.condo
) ) )

new
( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.housing_unit ) ( string !
type ) ) ( string housing_type ) ( string = ) ( call SW.concat en.housing.condo en.housing.apartment
) ) )

Pub. pre
( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.article ) ( string ! type
) ) ( string author ) ( string = ) en.person.efron ) )

new ( call SW.listValue ( call SW.filter ( call SW.getProperty ( call SW.singleton en.article ) ( string ! type) ) ( string author ) ( string = ) en.person.lakoff ) )

Rec. pre ( call SW.listValue ( call SW.getProperty en.recipe.rice_pudding ( string cuisine ) ) )new ( call SW.listValue ( call SW.getProperty en.recipe.quiche ( string cuisine ) ) )

Res. pre ( call SW.listValue ( call SW.getProperty en.restaurant.thai_cafe ( string neighborhood ) ) )new ( call SW.listValue ( call SW.getProperty en.restaurant.pizzeria_juno ( string neighborhood ) ) )

Soc. pre
( call SW.listValue ( call SW.getProperty ( ( lambda s ( call SW.filter ( var s ) ( string field_of_study )
( string ! = ) en.field.computer_science ) ) ( call SW.domain ( string student ) ) ) ( string student ) ) )

new ( call SW.listValue ( call SW.getProperty ( ( lambda s ( call SW.filter ( var s ) ( string field_of_study )( string ! = ) en.field.history ) ) ( call SW.domain ( string student ) ) ) ( string student ) ) )

Table 7: Examples of synthesized logical forms on OVERNIGHT.


