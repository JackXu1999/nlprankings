
























































untitled


Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 731–742
Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics

731

Coarse-to-Fine Decoding for Neural Semantic Parsing

Li Dong and Mirella Lapata
Institute for Language, Cognition and Computation

School of Informatics, University of Edinburgh
10 Crichton Street, Edinburgh EH8 9AB

li.dong@ed.ac.uk mlap@inf.ed.ac.uk

Abstract

Semantic parsing aims at mapping natural
language utterances into structured mean-
ing representations. In this work, we pro-
pose a structure-aware neural architecture
which decomposes the semantic parsing
process into two stages. Given an input ut-
terance, we first generate a rough sketch of
its meaning, where low-level information
(such as variable names and arguments) is
glossed over. Then, we fill in missing de-
tails by taking into account the natural lan-
guage input and the sketch itself. Experi-
mental results on four datasets characteris-
tic of different domains and meaning rep-
resentations show that our approach con-
sistently improves performance, achieving
competitive results despite the use of rela-
tively simple decoders.

1 Introduction

Semantic parsing maps natural language utter-
ances onto machine interpretable meaning rep-
resentations (e.g., executable queries or logical
forms). The successful application of recurrent
neural networks to a variety of NLP tasks (Bah-
danau et al., 2015; Vinyals et al., 2015) has pro-
vided strong impetus to treat semantic parsing as
a sequence-to-sequence problem (Jia and Liang,
2016; Dong and Lapata, 2016; Ling et al., 2016).
The fact that meaning representations are typi-
cally structured objects has prompted efforts to
develop neural architectures which explicitly ac-
count for their structure. Examples include tree
decoders (Dong and Lapata, 2016; Alvarez-Melis
and Jaakkola, 2017), decoders constrained by a
grammar model (Xiao et al., 2016; Yin and Neu-
big, 2017; Krishnamurthy et al., 2017), or modular

decoders which use syntax to dynamically com-
pose various submodels (Rabinovich et al., 2017).

In this work, we propose to decompose the de-
coding process into two stages. The first decoder
focuses on predicting a rough sketch of the mean-
ing representation, which omits low-level details,
such as arguments and variable names. Example
sketches for various meaning representations are
shown in Table 1. Then, a second decoder fills
in missing details by conditioning on the natural
language input and the sketch itself. Specifically,
the sketch constrains the generation process and is
encoded into vectors to guide decoding.

We argue that there are at least three advantages
to the proposed approach. Firstly, the decompo-
sition disentangles high-level from low-level se-
mantic information, which enables the decoders
to model meaning at different levels of granular-
ity. As shown in Table 1, sketches are more com-
pact and as a result easier to generate compared to
decoding the entire meaning structure in one go.
Secondly, the model can explicitly share knowl-
edge of coarse structures for the examples that
have the same sketch (i.e., basic meaning), even
though their actual meaning representations are
different (e.g., due to different details). Thirdly,
after generating the sketch, the decoder knows
what the basic meaning of the utterance looks like,
and the model can use it as global context to im-
prove the prediction of the final details.

Our framework is flexible and not restricted to
specific tasks or any particular model. We con-
duct experiments on four datasets representative of
various semantic parsing tasks ranging from log-
ical form parsing, to code generation, and SQL
query generation. We adapt our architecture to
these tasks and present several ways to obtain
sketches from their respective meaning represen-
tations. Experimental results show that our frame-
work achieves competitive performance compared



732

Dataset Length Example

GEO
7.6
13.7
6.9

x : which state has the most rivers running through it?
y : (argmax $0 (state:t $0) (count $1 (and (river:t $1) (loc:t $1 $0))))
a : (argmax#1 state:t@1 (count#1 (and river:t@1 loc:t@2 ) ) )

ATIS
11.1
21.1
9.2

x : all flights from dallas before 10am
y : (lambda $0 e (and (flight $0) (from $0 dallas:ci) (< (departure time $0) 1000:ti)))
a : (lambda#2 (and flight@1 from@2 (< departure time@1 ? ) ) )

DJANGO
14.4
8.7
8.0

x : if length of bits is lesser than integer 3 or second element of bits is not equal to string ’as’ ,
y : if len(bits) < 3 or bits[1] != ’as’:
a : if len ( NAME ) < NUMBER or NAME [ NUMBER ] != STRING :

WIKISQL

17.9
13.3
13.0
2.7

Table schema: ‖Pianist‖Conductor‖Record Company‖Year of Recording‖Format‖
x : What record company did conductor Mikhail Snitko record for after 1996?
y : SELECT Record Company WHERE (Year of Recording > 1996) AND (Conductor = Mikhail Snitko)
a : WHERE > AND =

Table 1: Examples of natural language expressions x, their meaning representations y, and meaning
sketches a. The average number of tokens is shown in the second column.

with previous systems, despite employing rela-
tively simple sequence decoders.

2 Related Work

Various models have been proposed over the years
to learn semantic parsers from natural language
expressions paired with their meaning representa-
tions (Tang and Mooney, 2000; Ge and Mooney,
2005; Zettlemoyer and Collins, 2007; Wong and
Mooney, 2007; Lu et al., 2008; Kwiatkowski et al.,
2011; Andreas et al., 2013; Zhao and Huang,
2015). These systems typically learn lexicalized
mapping rules and scoring models to construct a
meaning representation for a given input.

More recently, neural sequence-to-sequence
models have been applied to semantic parsing with
promising results (Dong and Lapata, 2016; Jia and
Liang, 2016; Ling et al., 2016), eschewing the
need for extensive feature engineering. Several
ideas have been explored to enhance the perfor-
mance of these models such as data augmenta-
tion (Kočiský et al., 2016; Jia and Liang, 2016),
transfer learning (Fan et al., 2017), sharing param-
eters for multiple languages or meaning represen-
tations (Susanto and Lu, 2017; Herzig and Berant,
2017), and utilizing user feedback signals (Iyer
et al., 2017). There are also efforts to develop
structured decoders that make use of the syntax of
meaning representations. Dong and Lapata (2016)
and Alvarez-Melis and Jaakkola (2017) develop
models which generate tree structures in a top-
down fashion. Xiao et al. (2016) and Krishna-
murthy et al. (2017) employ the grammar to con-
strain the decoding process. Cheng et al. (2017)

use a transition system to generate variable-free
queries. Yin and Neubig (2017) design a gram-
mar model for the generation of abstract syntax
trees (Aho et al., 2007) in depth-first, left-to-right
order. Rabinovich et al. (2017) propose a modular
decoder whose submodels are dynamically com-
posed according to the generated tree structure.

Our own work also aims to model the structure
of meaning representations more faithfully. The
flexibility of our approach enables us to easily ap-
ply sketches to different types of meaning repre-
sentations, e.g., trees or other structured objects.
Coarse-to-fine methods have been popular in the
NLP literature, and are perhaps best known for
syntactic parsing (Charniak et al., 2006; Petrov,
2011). Artzi and Zettlemoyer (2013) and Zhang
et al. (2017) use coarse lexical entries or macro
grammars to reduce the search space of semantic
parsers. Compared with coarse-to-fine inference
for lexical induction, sketches in our case are ab-
stractions of the final meaning representation.

The idea of using sketches as intermediate rep-
resentations has also been explored in the field
of program synthesis (Solar-Lezama, 2008; Zhang
and Sun, 2013; Feng et al., 2017). Yaghmazadeh
et al. (2017) use SEMPRE (Berant et al., 2013) to
map a sentence into SQL sketches which are com-
pleted using program synthesis techniques and it-
eratively repaired if they are faulty.

3 Problem Formulation

Our goal is to learn semantic parsers from in-
stances of natural language expressions paired
with their structured meaning representations.



733

all flights before ti0

(and 

flight@1

flight@1

(<

(<

departure
_time@1

departure
_time@1

?

?

)

<s>

(lambda#2

(lambda#2 

(and

)

)

)

)

<s>

(lambda $0

)

</s>

(flight $0

$0

)

)

(<
(departure

_time $0

$0

)

)

ti0

ti0

) )

( | )

$0

e

e

(and ) </s>
Sketch-Guided

Output 
Decoding

Sketch 
Encoding

Sketch 
Decoding

Input 
Encoding

( | , )

Encoder units
Decoder units

Figure 1: We first generate the meaning sketch a for natural language input x. Then, a fine meaning
decoder fills in the missing details (shown in red) of meaning representation y. The coarse structure a is
used to guide and constrain the output decoding.

Let x = x1 · · ·x|x| denote a natural language ex-
pression, and y = y1 · · · y|y| its meaning repre-
sentation. We wish to estimate p (y|x), the con-
ditional probability of meaning representation y
given input x. We decompose p (y|x) into a two-
stage generation process:

p (y|x) = p (y|x, a) p (a|x) (1)
where a = a1 · · · a|a| is an abstract sketch rep-
resenting the meaning of y. We defer detailed
description of how sketches are extracted to Sec-
tion 4. Suffice it to say that the extraction amounts
to stripping off arguments and variable names
in logical forms, schema specific information in
SQL queries, and substituting tokens with types in
source code (see Table 1).

As shown in Figure 1, we first predict sketch a
for input x, and then fill in missing details to gen-
erate the final meaning representation y by condi-
tioning on both x and a. The sketch is encoded
into vectors which in turn guide and constrain the
decoding of y. We view the input expression x,
the meaning representation y, and its sketch a as
sequences. The generation probabilities are fac-
torized as:

p (a|x) =
|a|∏
t=1

p (at|a<t, x) (2)

p (y|x, a) =
|y|∏
t=1

p (yt|y<t, x, a) (3)

where a<t = a1 · · · at−1, and y<t = y1 · · · yt−1.
In the following, we will explain how p (a|x) and
p (y|x, a) are estimated.

3.1 Sketch Generation
An encoder is used to encode the natural language
input x into vector representations. Then, a de-
coder learns to compute p (a|x) and generate the
sketch a conditioned on the encoding vectors.

Input Encoder Every input word is mapped to
a vector via xt = Wxo (xt), where Wx ∈
R
n×|Vx| is an embedding matrix, |Vx| is the vo-

cabulary size, and o (xt) a one-hot vector. We use
a bi-directional recurrent neural network with long
short-term memory units (LSTM, Hochreiter and
Schmidhuber 1997) as the input encoder. The en-
coder recursively computes the hidden vectors at
the t-th time step via:

−→e t = fLSTM
(−→e t−1,xt) , t = 1, · · · , |x| (4)

←−e t = fLSTM
(←−e t+1,xt) , t = |x|, · · · , 1 (5)

et = [
−→e t,←−e t] (6)

where [·, ·] denotes vector concatenation, et ∈ Rn,
and fLSTM is the LSTM function.

Coarse Meaning Decoder The decoder’s hid-
den vector at the t-th time step is computed by
dt = fLSTM (dt−1,at−1), where at−1 ∈ Rn is
the embedding of the previously predicted token.
The hidden states of the first time step in the de-
coder are initialized by the concatenated encoding
vectors d0 = [−→e |x|,←−e 1]. Additionally, we use an
attention mechanism (Luong et al., 2015) to learn
soft alignments. We compute the attention score
for the current time step t of the decoder, with the
k-th hidden state in the encoder as:

st,k = exp{dt · ek}/Zt (7)



734

where Zt =
∑|x|

j=1 exp{dt · ej} is a normalization
term. Then we compute p (at|a<t, x) via:

edt =

|x|∑
k=1

st,kek (8)

dattt = tanh
(
W1dt +W2e

d
t

)
(9)

p (at|a<t, x) = softmaxat
(
Wod

att
t + bo

)
(10)

where W1,W2 ∈ Rn×n, Wo ∈ R|Va|×n, and
bo ∈ R|Va| are parameters. Generation terminates
once an end-of-sequence token “</s>” is emitted.

3.2 Meaning Representation Generation
Meaning representations are predicted by condi-
tioning on the input x and the generated sketch a.
The model uses the encoder-decoder architecture
to compute p (y|x, a), and decorates the sketch a
with details to generate the final output.

Sketch Encoder As shown in Figure 1, a bi-
directional LSTM encoder maps the sketch se-
quence a into vectors {vk}|a|k=1 as in Equation (6),
where vk denotes the vector of the k-th time step.

Fine Meaning Decoder The final decoder is
based on recurrent neural networks with an atten-
tion mechanism, and shares the input encoder de-
scribed in Section 3.1. The decoder’s hidden states
{ht}|y|t=1 are computed via:

it =

{
vk yt−1 is determined by ak
yt−1 otherwise

(11)

ht = fLSTM (ht−1, it)

where h0 = [−→e |x|,←−e 1], and yt−1 is the embed-
ding of the previously predicted token. Apart from
using the embeddings of previous tokens, the de-
coder is also fed with {vk}|a|k=1. If yt−1 is deter-
mined by ak in the sketch (i.e., there is a one-to-
one alignment between yt−1 and ak), we use the
corresponding token’s vector vk as input to the
next time step.

The sketch constrains the decoding output. If
the output token yt is already in the sketch, we
force yt to conform to the sketch. In some cases,
sketch tokens will indicate what information is
missing (e.g., in Figure 1, token “flight@1” in-
dicates that an argument is missing for the pred-
icate “flight”). In other cases, sketch tokens
will not reveal the number of missing tokens
(e.g., “STRING” in DJANGO) but the decoder’s

output will indicate whether missing details have
been generated (e.g., if the decoder emits a clos-
ing quote token for “STRING”). Moreover, type
information in sketches can be used to constrain
generation. In Table 1, sketch token “NUMBER”
specifies that a numeric token should be emitted.

For the missing details, we use the hidden vec-
tor ht to compute p (yt|y<t, x, a), analogously
to Equations (7)–(10).

3.3 Training and Inference
The model’s training objective is to maximize the
log likelihood of the generated meaning represen-
tations given natural language expressions:

max
∑

(x,a,y)∈D
log p (y|x, a) + log p (a|x)

where D represents training pairs.
At test time, the prediction for input x is ob-

tained via â = argmaxa′ p (a
′|x) and ŷ =

argmaxy′ p (y
′|x, â), where a′ and y′ represent

coarse- and fine-grained meaning candidates. Be-
cause probabilities p (a|x) and p (y|x, a) are fac-
torized as shown in Equations (2)–(3), we can ob-
tain best results approximately by using greedy
search to generate tokens one by one, rather than
iterating over all candidates.

4 Semantic Parsing Tasks

In order to show that our framework applies across
domains and meaning representations, we devel-
oped models for three tasks, namely parsing nat-
ural language to logical form, to Python source
code, and to SQL query. For each of these tasks
we describe the datasets we used, how sketches
were extracted, and specify model details over and
above the architecture presented in Section 3.

4.1 Natural Language to Logical Form
For our first task we used two benchmark datasets,
namely GEO (880 language queries to a database
of U.S. geography) and ATIS (5, 410 queries to
a flight booking system). Examples are shown
in Table 1 (see the first and second block). We
used standard splits for both datasets: 600 train-
ing and 280 test instances for GEO (Zettlemoyer
and Collins, 2005); 4, 480 training, 480 develop-
ment, and 450 test examples for ATIS. Mean-
ing representations in these datasets are based
on λ-calculus (Kwiatkowski et al., 2011). We
use brackets to linearize the hierarchical structure.



735

Algorithm 1 Sketch for GEO and ATIS
Input: t: Tree-structure λ-calculus expression

t.pred: Predicate name, or operator name
Output: a: Meaning sketch

� (count $0 (< (fare $0) 50:do))→(count#1 (< fare@1 ?))
function SKETCH(t)

if t is leaf then � No nonterminal in arguments
return “%s@%d” % (t.pred,len(t.args))

if t.pred is λ operator, or quantifier then � e.g., count
Omit variable information defined by t.pred
t.pred← “%s#%d” % (t.pred,len(variable))

for c ← argument in t.args do
if c is nonterminal then

c ← SKETCH(c)
else

c ← “?” � Placeholder for terminal
return t

The first element between a pair of brackets is an
operator or predicate name, and any remaining el-
ements are its arguments.

Algorithm 1 shows the pseudocode used to ex-
tract sketches from λ-calculus-based meaning rep-
resentations. We strip off arguments and variable
names in logical forms, while keeping predicates,
operators, and composition information. We use
the symbol “@” to denote the number of missing
arguments in a predicate. For example, we ex-
tract “from@2” from the expression “(from $0 dal-
las:ci)” which indicates that the predicate “from”
has two arguments. We use “?” as a placeholder
in cases where only partial argument information
can be omitted. We also omit variable informa-
tion defined by the lambda operator and quanti-
fiers (e.g., exists, count, and argmax). We use the
symbol “#” to denote the number of omitted to-
kens. For the example in Figure 1, “lambda $0 e”
is reduced to “lambda#2”.

The meaning representations of these two
datasets are highly compositional, which moti-
vates us to utilize the hierarchical structure of
λ-calculus. A similar idea is also explored in the
tree decoders proposed in Dong and Lapata (2016)
and Yin and Neubig (2017) where parent hidden
states are fed to the input gate of the LSTM units.
On the contrary, parent hidden states serve as input
to the softmax classifiers of both fine and coarse
meaning decoders.

Parent Feeding Taking the meaning sketch
“(and flight@1 from@2)” as an example, the par-
ent of “from@2” is “(and”. Let pt denote the par-
ent of the t-th time step in the decoder. Compared
with Equation (10), we use the vector dattt and the
hidden state of its parent dpt to compute the prob-

ability p (at|a<t, x) via:

p (at|a<t, x) = softmaxat
(
Wo[d

att
t ,dpt ] + bo

)
where [·, ·] denotes vector concatenation. The par-
ent feeding is used for both decoding stages.

4.2 Natural Language to Source Code

Our second semantic parsing task used DJANGO
(Oda et al., 2015), a dataset built upon the Python
code of the Django library. The dataset contains
lines of code paired with natural language expres-
sions (see the third block in Table 1) and exhibits
a variety of use cases, such as iteration, exception
handling, and string manipulation. The original
split has 16, 000 training, 1, 000 development, and
1, 805 test instances.

We used the built-in lexical scanner of Python1

to tokenize the code and obtain token types.
Sketches were extracted by substituting the origi-
nal tokens with their token types, except delimiters
(e.g., “[”, and “:”), operators (e.g., “+”, and “*”),
and built-in keywords (e.g., “True”, and “while”).
For instance, the expression “if s[:4].lower() ==
’http’:” becomes “if NAME [ : NUMBER ] . NAME (
) == STRING :”, with details about names, values,
and strings being omitted.

DJANGO is a diverse dataset, spanning various
real-world use cases and as a result models are
often faced with out-of-vocabulary (OOV) tokens
(e.g., variable names, and numbers) that are un-
seen during training. We handle OOV tokens with
a copying mechanism (Gu et al., 2016; Gulcehre
et al., 2016; Jia and Liang, 2016), which allows
the fine meaning decoder (Section 3.2) to directly
copy tokens from the natural language input.

Copying Mechanism Recall that we use a soft-
max classifier to predict the probability distribu-
tion p (yt|y<t, x, a) over the pre-defined vocabu-
lary. We also learn a copying gate gt ∈ [0, 1] to
decide whether yt should be copied from the input
or generated from the vocabulary. We compute the
modified output distribution via:

gt = sigmoid(wg · ht + bg)
p̃ (yt|y<t, x, a) = (1− gt)p (yt|y<t, x, a)

+ �[yt /∈Vy ]gt
∑

k:xk=yt

st,k

1https://docs.python.org/3/library/
tokenize



736

where wg ∈ Rn and bg ∈ R are parameters, and
the indicator function �[yt /∈Vy ] is 1 only if yt is
not in the target vocabulary Vy; the attention score
st,k (see Equation (7)) measures how likely it is to
copy yt from the input word xk.

4.3 Natural Language to SQL
The WIKISQL (Zhong et al., 2017) dataset con-
tains 80, 654 examples of questions and SQL
queries distributed across 24, 241 tables from
Wikipedia. The goal is to generate the correct SQL
query for a natural language question and table
schema (i.e., table column names), without using
the content values of tables (see the last block in
Table 1 for an example). The dataset is partitioned
into a training set (70%), a development set (10%),
and a test set (20%). Each table is present in one
split to ensure generalization to unseen tables.

WIKISQL queries follow the format “SELECT
agg op agg col WHERE (cond col cond op
cond) AND ...”, which is a subset of the SQL syn-
tax. SELECT identifies the column that is to be in-
cluded in the results after applying the aggregation
operator agg op2 to column agg col. WHERE
can have zero or multiple conditions, which means
that column cond col must satisfy the con-
straints expressed by the operator cond op3 and
the condition value cond. Sketches for SQL
queries are simply the (sorted) sequences of con-
dition operators cond op in WHERE clauses. For
example, in Table 1, sketch “WHERE > AND =”
has two condition operators, namely “>” and “=”.

The generation of SQL queries differs from our
previous semantic parsing tasks, in that the ta-
ble schema serves as input in addition to natu-
ral language. We therefore modify our input en-
coder in order to render it table-aware, so to speak.
Furthermore, due to the formulaic nature of the
SQL query, we only use our decoder to gener-
ate the WHERE clause (with the help of sketches).
The SELECT clause has a fixed number of slots
(i.e., aggregation operator agg op and column
agg col), which we straightforwardly predict
with softmax classifiers (conditioned on the in-
put). We briefly explain how these components
are modeled below.

Table-Aware Input Encoder Given a table
schema with M columns, we employ the spe-
cial token “‖” to concatenate its header names

2agg op ∈ {empty,COUNT,MIN,MAX,SUM,AVG}.
3cond op ∈ {=, <,>}.

|| of |||| college number presidents

Column 1 Column 2Input Question

Question-to-Table Attention

̃ ̃ ̃̃ LSTM units
Vectors
Attention

Figure 2: Table-aware input encoder (left) and ta-
ble column encoder (right) used for WIKISQL.

as “‖c1,1 · · · c1,|c1|‖· · · ‖cM,1 · · · cM,|cM |‖”, where
the k-th column (“ck,1 · · · ck,|ck|”) has |ck| words.
As shown in Figure 2, we use bi-directional
LSTMs to encode the whole sequence. Next, for
column ck, the LSTM hidden states at positions
ck,1 and ck,|ck| are concatenated. Finally, the con-
catenated vectors are used as the encoding vectors
{ck}Mk=1 for table columns.

As mentioned earlier, the meaning representa-
tions of questions are dependent on the tables. As
shown in Figure 2, we encode the input question x
into {et}|x|t=1 using LSTM units. At each time
step t, we use an attention mechanism towards ta-
ble column vectors {ck}Mk=1 to obtain the most rel-
evant columns for et. The attention score from et
to ck is computed via ut,k ∝ exp{α(et) · α(ck)},
where α(·) is a one-layer neural network, and∑M

k=1 ut,k = 1. Then we compute the con-
text vector cet =

∑M
k=1 ut,kck to summarize the

relevant columns for et. We feed the concate-
nated vectors {[et, cet ]}|x|t=1 into a bi-directional
LSTM encoder, and use the new encoding vectors
{ẽt}|x|t=1 to replace {et}|x|t=1 in other model com-
ponents. We define the vector representation of
input x as:

ẽ = [
−→̃
e |x|,

←−̃
e 1] (12)

analogously to Equations (4)–(6).

SELECT Clause We feed the question vector ẽ
into a softmax classifier to obtain the aggregation
operator agg op. If agg col is the k-th table
column, its probability is computed via:

σ(x) = w3 · tanh (W4x+ b4) (13)
p (agg col = k|x) ∝ exp{σ([ẽ, ck])} (14)

where
∑M

j=1 p (agg col = j|x) = 1, σ(·) is a
scoring network, and W4 ∈ R2n×m,w3,b4 ∈
R
m are parameters.



737

̃ WHERE  < AND  =

Column 4

ANDcond_colPointer
cond

Pointer

̃ ̃
…

…
Sketch-Guided

WHERE
Decoding

Sketch 
Encoding

Sketch 
Classification

Figure 3: Fine meaning decoder of the WHERE
clause used for WIKISQL.

WHERE Clause We first generate sketches
whose details are subsequently decorated by the
fine meaning decoder described in Section 3.2.
As the number of sketches in the training set is
small (35 in total), we model sketch generation as
a classification problem. We treat each sketch a
as a category, and use a softmax classifier to com-
pute p (a|x):

p (a|x) = softmaxa (Waẽ+ ba)
where Wa ∈ R|Va|×n,ba ∈ R|Va| are parame-
ters, and ẽ is the table-aware input representation
defined in Equation (12).

Once the sketch is predicted, we know the con-
dition operators and number of conditions in the
WHERE clause which follows the format “WHERE
(cond op cond col cond) AND ...”. As shown
in Figure 3, our generation task now amounts
to populating the sketch with condition columns
cond col and their values cond.

Let {ht}|y|t=1 denote the LSTM hidden states
of the fine meaning decoder, and {hattt }|y|t=1
the vectors obtained by the attention mecha-
nism as in Equation (9). The condition column
cond colyt is selected from the table’s head-
ers. For the k-th column in the table, we com-
pute p (cond colyt = k|y<t, x, a) as in Equa-
tion (14), but use different parameters and com-
pute the score via σ([hattt , ck]). If the k-th table
column is selected, we use ck for the input of the
next LSTM unit in the decoder.

Condition values are typically mentioned in the
input questions. These values are often phrases
with multiple tokens (e.g., Mikhail Snitko in Ta-
ble 1). We therefore propose to select a text span
from input x for each condition value condyt
rather than copying tokens one by one. Let
xl · · ·xr denote the text span from which condyt

is copied. We factorize its probability as:

p (condyt = xl · · ·xr|y<t, x, a)
= p

(
�l�Lyt |y<t, x, a

)
p
(
�r�Ryt |y<t, x, a, �l�Lyt

)
p
(
�l�Lyt |y<t, x, a

) ∝ exp{σ([hattt , ẽl])}
p
(
�r�Ryt |y<t, x, a, �l�Lyt

) ∝ exp{σ([hattt , ẽl, ẽr])}
where �l�Lyt/�r�

R
yt represents the first/last copying

index of condyt is l/r, the probabilities are nor-
malized to 1, and σ(·) is the scoring network de-
fined in Equation (13). Notice that we use dif-
ferent parameters for the scoring networks σ(·).
The copied span is represented by the concate-
nated vector [ẽl, ẽr], which is fed into a one-layer
neural network and then used as the input to the
next LSTM unit in the decoder.

5 Experiments

We present results on the three semantic parsing
tasks discussed in Section 4. Our implementation
and pretrained models are available at https://
github.com/donglixp/coarse2fine.

5.1 Experimental Setup

Preprocessing For GEO and ATIS, we used the
preprocessed versions provided by Dong and La-
pata (2016), where natural language expressions
are lowercased and stemmed with NLTK (Bird
et al., 2009), and entity mentions are replaced by
numbered markers. We combined predicates and
left brackets that indicate hierarchical structures to
make meaning representations compact. We em-
ployed the preprocessed DJANGO data provided
by Yin and Neubig (2017), where input expres-
sions are tokenized by NLTK, and quoted strings
in the input are replaced with place holders. WIK-
ISQL was preprocessed by the script provided
by Zhong et al. (2017), where inputs were lower-
cased and tokenized by Stanford CoreNLP (Man-
ning et al., 2014).

Configuration Model hyperparameters were
cross-validated on the training set for GEO, and
were validated on the development split for the
other datasets. Dimensions of hidden vectors and
word embeddings were selected from {250, 300}
and {150, 200, 250, 300}, respectively. The
dropout rate was selected from {0.3, 0.5}. Label
smoothing (Szegedy et al., 2016) was employed
for GEO and ATIS. The smoothing parameter was
set to 0.1. For WIKISQL, the hidden size of σ(·)



738

Method GEO ATIS

ZC07 (Zettlemoyer and Collins, 2007) 86.1 84.6
UBL (Kwiatkowksi et al., 2010) 87.9 71.4
FUBL (Kwiatkowski et al., 2011) 88.6 82.8
GUSP++ (Poon, 2013) — 83.5
KCAZ13 (Kwiatkowski et al., 2013) 89.0 —
DCS+L (Liang et al., 2013) 87.9 —
TISP (Zhao and Huang, 2015) 88.9 84.2

SEQ2SEQ (Dong and Lapata, 2016) 84.6 84.2
SEQ2TREE (Dong and Lapata, 2016) 87.1 84.6
ASN (Rabinovich et al., 2017) 85.7 85.3
ASN+SUPATT (Rabinovich et al., 2017) 87.1 85.9

ONESTAGE 85.0 85.3
COARSE2FINE 88.2 87.7
− sketch encoder 87.1 86.9
+ oracle sketch 93.9 95.1

Table 2: Accuracies on GEO and ATIS.

and α(·) in Equation (13) was set to 64. Word
embeddings were initialized by GloVe (Penning-
ton et al., 2014), and were shared by table encoder
and input encoder in Section 4.3. We appended
10-dimensional part-of-speech tag vectors to em-
beddings of the question words in WIKISQL. The
part-of-speech tags were obtained by the spaCy
toolkit. We used the RMSProp optimizer (Tiele-
man and Hinton, 2012) to train the models. The
learning rate was selected from {0.002, 0.005}.
The batch size was 200 for WIKISQL, and was
64 for other datasets. Early stopping was used to
determine the number of epochs.

Evaluation We use accuracy as the evaluation
metric, i.e., the percentage of the examples that
are correctly parsed to their gold standard meaning
representations. For WIKISQL, we also execute
generated SQL queries on their corresponding ta-
bles, and report the execution accuracy which is
defined as the proportion of correct answers.

5.2 Results and Analysis

We compare our model (COARSE2FINE) against
several previously published systems as well as
various baselines. Specifically, we report results
with a model which decodes meaning representa-
tions in one stage (ONESTAGE) without leverag-
ing sketches. We also report the results of several
ablation models, i.e., without a sketch encoder and
without a table-aware input encoder.

Table 2 presents our results on GEO and ATIS.
Overall, we observe that COARSE2FINE outper-
forms ONESTAGE, which suggests that disentan-
gling high-level from low-level information dur-

Method Accuracy

Retrieval System 14.7
Phrasal SMT 31.5
Hierarchical SMT 9.5

SEQ2SEQ+UNK replacement 45.1
SEQ2TREE+UNK replacement 39.4
LPN+COPY (Ling et al., 2016) 62.3
SNM+COPY (Yin and Neubig, 2017) 71.6

ONESTAGE 69.5
COARSE2FINE 74.1
− sketch encoder 72.1
+ oracle sketch 83.0

Table 3: DJANGO results. Accuracies in the first
and second block are taken from Ling et al. (2016)
and Yin and Neubig (2017).

ing decoding is beneficial. The results also show
that removing the sketch encoder harms perfor-
mance since the decoder loses access to additional
contextual information. Compared with previous
neural models that utilize syntax or grammatical
information (SEQ2TREE, ASN; the second block
in Table 2), our method performs competitively
despite the use of relatively simple decoders. As
an upper bound, we report model accuracy when
gold meaning sketches are given to the fine mean-
ing decoder (+oracle sketch). As can be seen, pre-
dicting the sketch correctly boosts performance.
The oracle results also indicate the accuracy of the
fine meaning decoder.

Table 3 reports results on DJANGO where we
observe similar tendencies. COARSE2FINE out-
performs ONESTAGE by a wide margin. It is also
superior to the best reported result in the literature
(SNM+COPY; see the second block in the table).
Again we observe that the sketch encoder is ben-
eficial and that there is an 8.9 point difference in
accuracy between COARSE2FINE and the oracle.

Results on WIKISQL are shown in Table 4. Our
model is superior to ONESTAGE as well as to pre-
vious best performing systems. COARSE2FINE’s
accuracies on aggregation agg op and agg col
are 90.2% and 92.0%, respectively, which is com-
parable to SQLNET (Xu et al., 2017). So the
most gain is obtained by the improved decoder
of the WHERE clause. We also find that a table-
aware input encoder is critical for doing well
on this task, since the same question might lead
to different SQL queries depending on the table
schemas. Consider the question “how many pres-
idents are graduated from A”. The SQL query
over table “‖President‖College‖” is “SELECT



739

Method Accuracy ExecutionAccuracy

SEQ2SEQ 23.4 35.9
Aug Ptr Network 43.3 53.3
SEQ2SQL (Zhong et al., 2017) 48.3 59.4
SQLNET (Xu et al., 2017) 61.3 68.0

ONESTAGE 68.8 75.9
COARSE2FINE 71.7 78.5
− sketch encoder 70.8 77.7
− table-aware input encoder 68.6 75.6
+ oracle sketch 73.0 79.6

Table 4: Evaluation results on WIKISQL. Accu-
racies in the first block are taken from Zhong et al.
(2017) and Xu et al. (2017).

Method GEO ATIS DJANGO WIKISQL

ONESTAGE 85.4 85.9 73.2 95.4
COARSE2FINE 89.3 88.0 77.4 95.9

Table 5: Sketch accuracy. For ONESTAGE,
sketches are extracted from the meaning represen-
tations it generates.

COUNT(President) WHERE (College = A)”, but
the query over table “‖College‖Number of Presi-
dents‖” would be “SELECT Number of Presidents
WHERE (College = A)”.

We also examine the predicted sketches them-
selves in Table 5. We compare sketches generated
by COARSE2FINE against ONESTAGE. The latter
model generates meaning representations without
an intermediate sketch generation stage. Never-
theless, we can extract sketches from the output of
ONESTAGE following the procedures described in
Section 4. Sketches produced by COARSE2FINE
are more accurate across the board. This is not
surprising because our model is trained explicitly
to generate compact meaning sketches. Taken to-
gether (Tables 2–4), our results show that better
sketches bring accuracy gains on GEO, ATIS, and
DJANGO. On WIKISQL, the sketches predicted
by COARSE2FINE are marginally better compared
with ONESTAGE. Performance improvements on
this task are mainly due to the fine meaning de-
coder. We conjecture that by decomposing de-
coding into two stages, COARSE2FINE can better
match table columns and extract condition values
without interference from the prediction of condi-
tion operators. Moreover, the sketch provides a
canonical order of condition operators, which is
beneficial for the decoding process (Vinyals et al.,
2016; Xu et al., 2017).

6 Conclusions

In this paper we presented a coarse-to-fine de-
coding framework for neural semantic parsing.
We first generate meaning sketches which abstract
away from low-level information such as argu-
ments and variable names and then predict miss-
ing details in order to obtain full meaning repre-
sentations. The proposed framework can be easily
adapted to different domains and meaning repre-
sentations. Experimental results show that coarse-
to-fine decoding improves performance across
tasks. In the future, we would like to apply the
framework in a weakly supervised setting, i.e., to
learn semantic parsers from question-answer pairs
and to explore alternative ways of defining mean-
ing sketches.

Acknowledgments We would like to thank
Pengcheng Yin for sharing with us the prepro-
cessed version of the DJANGO dataset. We grate-
fully acknowledge the financial support of the Eu-
ropean Research Council (award number 681760;
Dong, Lapata) and the AdeptMind Scholar Fel-
lowship program (Dong).

References
Alfred V Aho, Ravi Sethi, and Jeffrey D Ullman. 2007.

Compilers: principles, techniques, and tools, vol-
ume 2. Addison-wesley Reading.

David Alvarez-Melis and Tommi S Jaakkola. 2017.
Tree-structured decoding with doubly-recurrent
neural networks. In Proceedings of the 5th Inter-
national Conference on Learning Representations,
Toulon, France.

Jacob Andreas, Andreas Vlachos, and Stephen Clark.
2013. Semantic parsing as machine translation. In
Proceedings of the 51st Annual Meeting of the Asso-
ciation for Computational Linguistics, pages 47–52,
Sofia, Bulgaria.

Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-
pervised learning of semantic parsers for mapping
instructions to actions. Transactions of the Associa-
tion of Computational Linguistics, 1:49–62.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proceedings of
the 3rd International Conference on Learning Rep-
resentations, San Diego, California.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on Freebase from
question-answer pairs. In Proceedings of the 2013



740

Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1533–1544, Seattle, Wash-
ington. Association for Computational Linguistics.

Steven Bird, Ewan Klein, and Edward Loper.
2009. Natural Language Processing with Python.
O’Reilly Media.

Eugene Charniak, Mark Johnson, Micha Elsner, Joseph
Austerweil, David Ellis, Isaac Haxton, Catherine
Hill, R. Shrivaths, Jeremy Moore, Michael Pozar,
and Theresa Vu. 2006. Multilevel coarse-to-fine
PCFG parsing. In Proceedings of the Human Lan-
guage Technology Conference of the NAACL, pages
168–175, New York, NY.

Jianpeng Cheng, Siva Reddy, Vijay Saraswat, and
Mirella Lapata. 2017. Learning structured natural
language representations for semantic parsing. In
Proceedings of the 55th Annual Meeting of the Asso-
ciation for Computational Linguistics, pages 44–55.
Association for Computational Linguistics.

Li Dong and Mirella Lapata. 2016. Language to logi-
cal form with neural attention. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics, pages 33–43, Berlin, Germany.

Xing Fan, Emilio Monti, Lambert Mathias, and Markus
Dreyer. 2017. Transfer learning for neural seman-
tic parsing. In Proceedings of the 2nd Workshop
on Representation Learning for NLP, pages 48–56,
Vancouver, Canada.

Yu Feng, Ruben Martins, Yuepeng Wang, Isil Dillig,
and Thomas Reps. 2017. Component-based synthe-
sis for complex apis. In Proceedings of the 44th
ACM SIGPLAN Symposium on Principles of Pro-
gramming Languages, POPL 2017, pages 599–612,
New York, NY.

Ruifang Ge and Raymond J. Mooney. 2005. A statis-
tical semantic parser that integrates syntax and se-
mantics. In Proceedings of the Ninth Conference on
Computational Natural Language Learning, pages
9–16, Ann Arbor, Michigan.

Jiatao Gu, Zhengdong Lu, Hang Li, and Victor O.K.
Li. 2016. Incorporating copying mechanism in
sequence-to-sequence learning. In Proceedings of
the 54th Annual Meeting of the Association for Com-
putational Linguistics, pages 1631–1640, Berlin,
Germany.

Caglar Gulcehre, Sungjin Ahn, Ramesh Nallapati,
Bowen Zhou, and Yoshua Bengio. 2016. Pointing
the unknown words. In Proceedings of the 54th An-
nual Meeting of the Association for Computational
Linguistics, pages 140–149, Berlin, Germany. Asso-
ciation for Computational Linguistics.

Jonathan Herzig and Jonathan Berant. 2017. Neural
semantic parsing over multiple knowledge-bases. In
Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics, pages 623–
628, Vancouver, Canada.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Computation, 9:1735–
1780.

Srinivasan Iyer, Ioannis Konstas, Alvin Cheung,
Jayant Krishnamurthy, and Luke Zettlemoyer. 2017.
Learning a neural semantic parser from user feed-
back. In Proceedings of the 55th Annual Meeting
of the Association for Computational Linguistics,
pages 963–973, Vancouver, Canada.

Robin Jia and Percy Liang. 2016. Data recombination
for neural semantic parsing. In Proceedings of the
54th Annual Meeting of the Association for Compu-
tational Linguistics, pages 12–22, Berlin, Germany.

Tomáš Kočiský, Gábor Melis, Edward Grefenstette,
Chris Dyer, Wang Ling, Phil Blunsom, and
Karl Moritz Hermann. 2016. Semantic parsing with
semi-supervised sequential autoencoders. In Pro-
ceedings of the 2016 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1078–
1087, Austin, Texas.

Jayant Krishnamurthy, Pradeep Dasigi, and Matt Gard-
ner. 2017. Neural semantic parsing with type con-
straints for semi-structured tables. In Proceedings of
the 2017 Conference on Empirical Methods in Natu-
ral Language Processing, pages 1517–1527, Copen-
hagen, Denmark.

Tom Kwiatkowksi, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing probabilis-
tic CCG grammars from logical form with higher-
order unification. In Proceedings of the 2010 Con-
ference on Empirical Methods in Natural Language
Processing, pages 1223–1233, Cambridge, MA.

Tom Kwiatkowski, Eunsol Choi, Yoav Artzi, and Luke
Zettlemoyer. 2013. Scaling semantic parsers with
on-the-fly ontology matching. In Proceedings of
the 2013 Conference on Empirical Methods in Natu-
ral Language Processing, pages 1545–1556, Seattle,
Washington.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2011. Lexical generaliza-
tion in CCG grammar induction for semantic pars-
ing. In Proceedings of the 2011 Conference on Em-
pirical Methods in Natural Language Processing,
pages 1512–1523, Edinburgh, Scotland.

Percy Liang, Michael I. Jordan, and Dan Klein. 2013.
Learning dependency-based compositional seman-
tics. Computational Linguistics, 39(2).

Wang Ling, Phil Blunsom, Edward Grefenstette,
Karl Moritz Hermann, Tomáš Kočiský, Fumin
Wang, and Andrew Senior. 2016. Latent predictor
networks for code generation. In Proceedings of the
54th Annual Meeting of the Association for Com-
putational Linguistics, pages 599–609, Berlin, Ger-
many.



741

Wei Lu, Hwee Tou Ng, Wee Sun Lee, and Luke Zettle-
moyer. 2008. A generative model for parsing natural
language to meaning representations. In Proceed-
ings of the 2008 Conference on Empirical Methods
in Natural Language Processing, pages 783–792,
Honolulu, Hawaii.

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-based
neural machine translation. In Proceedings of the
2015 Conference on Empirical Methods in Natu-
ral Language Processing, pages 1412–1421, Lisbon,
Portugal.

Christopher D. Manning, Mihai Surdeanu, John Bauer,
Jenny Finkel, Steven J. Bethard, and David Mc-
Closky. 2014. The Stanford CoreNLP natural lan-
guage processing toolkit. In Association for Compu-
tational Linguistics System Demonstrations, pages
55–60, Baltimore, Maryland.

Yusuke Oda, Hiroyuki Fudaba, Graham Neubig,
Hideaki Hata, Sakriani Sakti, Tomoki Toda, and
Satoshi Nakamura. 2015. Learning to generate
pseudo-code from source code using statistical ma-
chine translation. In Proceedings of the 2015 30th
IEEE/ACM International Conference on Automated
Software Engineering, pages 574–584, Washington,
DC.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. GloVe: Global vectors for word
representation. In Proceedings of the 2014 Con-
ference on Empirical Methods in Natural Language
Processing, pages 1532–1543, Doha, Qatar.

Slav Petrov. 2011. Coarse-to-fine natural language
processing. Springer Science & Business Media.

Hoifung Poon. 2013. Grounded unsupervised seman-
tic parsing. In Proceedings of the 51st Annual Meet-
ing of the Association for Computational Linguis-
tics, pages 933–943, Sofia, Bulgaria.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code genera-
tion and semantic parsing. In Proceedings of the
55th Annual Meeting of the Association for Compu-
tational Linguistics, pages 1139–1149, Vancouver,
Canada.

Armando Solar-Lezama. 2008. Program Synthesis by
Sketching. Ph.D. thesis, University of California at
Berkeley, Berkeley, CA.

Raymond Hendy Susanto and Wei Lu. 2017. Neural
architectures for multilingual semantic parsing. In
Proceedings of the 55th Annual Meeting of the Asso-
ciation for Computational Linguistics, pages 38–44,
Vancouver, Canada.

Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe,
Jon Shlens, and Zbigniew Wojna. 2016. Rethinking
the inception architecture for computer vision. In
Proceedings of the IEEE Conference on Computer
Vision and Pattern Recognition, pages 2818–2826.

Lappoon R. Tang and Raymond J. Mooney. 2000. Au-
tomated construction of database interfaces: Inter-
grating statistical and relational learning for seman-
tic parsing. In 2000 Joint SIGDAT Conference on
Empirical Methods in Natural Language Process-
ing and Very Large Corpora, pages 133–141, Hong
Kong, China.

T. Tieleman and G. Hinton. 2012. Lecture 6.5—
RMSProp: Divide the gradient by a running average
of its recent magnitude. Technical report.

Oriol Vinyals, Samy Bengio, and Manjunath Kudlur.
2016. Order matters: Sequence to sequence for
sets. In Proceedings of the 4th International Confer-
ence on Learning Representations, San Juan, Puerto
Rico.

Oriol Vinyals, Lukasz Kaiser, Terry Koo, Slav Petrov,
Ilya Sutskever, and Geoffrey Hinton. 2015. Gram-
mar as a foreign language. In Proceedings of the
28th International Conference on Neural Informa-
tion Processing Systems, pages 2773–2781, Mon-
treal, Canada.

Yuk Wah Wong and Raymond Mooney. 2007. Learn-
ing synchronous grammars for semantic parsing
with lambda calculus. In Proceedings of the 45th
Annual Meeting of the Association of Computational
Linguistics, pages 960–967, Prague, Czech Repub-
lic.

Chunyang Xiao, Marc Dymetman, and Claire Gardent.
2016. Sequence-based structured prediction for se-
mantic parsing. In Proceedings of the 54th Annual
Meeting of the Association for Computational Lin-
guistics, pages 1341–1350, Berlin, Germany.

Xiaojun Xu, Chang Liu, and Dawn Song. 2017. SQL-
Net: Generating structured queries from natural
language without reinforcement learning. arXiv
preprint arXiv:1711.04436.

Navid Yaghmazadeh, Yuepeng Wang, Isil Dillig, and
Thomas Dillig. 2017. SQLizer: Query synthesis
from natural language. Proceedings of the ACM on
Programming Languages, 1:63:1–63:26.

Pengcheng Yin and Graham Neubig. 2017. A syntactic
neural model for general-purpose code generation.
In Proceedings of the 55th Annual Meeting of the As-
sociation for Computational Linguistics, pages 440–
450, Vancouver, Canada.

Luke Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classification with probabilistic categorial gram-
mars. In Proceedings of the 21st Conference on Un-
certainty in Artificial Intelligence, pages 658–666,
Edinburgh, Scotland.

Luke Zettlemoyer and Michael Collins. 2007. Online
learning of relaxed CCG grammars for parsing to
logical form. In Proceedings of the 2007 Joint Con-
ference on Empirical Methods in Natural Language
Processing and Computational Natural Language
Learning, pages 678–687, Prague, Czech Republic.



742

Sai Zhang and Yuyin Sun. 2013. Automatically syn-
thesizing SQL queries from input-output examples.
In Proceedings of the 28th IEEE/ACM International
Conference on Automated Software Engineering,
pages 224–234, Piscataway, NJ.

Yuchen Zhang, Panupong Pasupat, and Percy Liang.
2017. Macro grammars and holistic triggering for
efficient semantic parsing. In Proceedings of the
2017 Conference on Empirical Methods in Natural
Language Processing, pages 1214–1223. Associa-
tion for Computational Linguistics.

Kai Zhao and Liang Huang. 2015. Type-driven in-
cremental semantic parsing with polymorphism. In
Proceedings of the 2015 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 1416–1421, Denver, Colorado.

Victor Zhong, Caiming Xiong, and Richard Socher.
2017. Seq2SQL: Generating structured queries
from natural language using reinforcement learning.
arXiv preprint arXiv:1709.00103.
















<<
  /ASCII85EncodePages false
  /AllowTransparency false
  /AutoPositionEPSFiles false
  /AutoRotatePages /None
  /Binding /Left
  /CalGrayProfile (Gray Gamma 2.2)
  /CalRGBProfile (sRGB IEC61966-2.1)
  /CalCMYKProfile (U.S. Web Coated \050SWOP\051 v2)
  /sRGBProfile (sRGB IEC61966-2.1)
  /CannotEmbedFontPolicy /Warning
  /CompatibilityLevel 1.7
  /CompressObjects /Off
  /CompressPages true
  /ConvertImagesToIndexed true
  /PassThroughJPEGImages true
  /CreateJobTicket false
  /DefaultRenderingIntent /Default
  /DetectBlends true
  /DetectCurves 0.0000
  /ColorConversionStrategy /LeaveColorUnchanged
  /DoThumbnails false
  /EmbedAllFonts true
  /EmbedOpenType false
  /ParseICCProfilesInComments true
  /EmbedJobOptions true
  /DSCReportingLevel 0
  /EmitDSCWarnings false
  /EndPage -1
  /ImageMemory 1048576
  /LockDistillerParams true
  /MaxSubsetPct 100
  /Optimize true
  /OPM 0
  /ParseDSCComments false
  /ParseDSCCommentsForDocInfo false
  /PreserveCopyPage true
  /PreserveDICMYKValues true
  /PreserveEPSInfo false
  /PreserveFlatness true
  /PreserveHalftoneInfo true
  /PreserveOPIComments false
  /PreserveOverprintSettings true
  /StartPage 1
  /SubsetFonts true
  /TransferFunctionInfo /Remove
  /UCRandBGInfo /Preserve
  /UsePrologue false
  /ColorSettingsFile ()
  /AlwaysEmbed [ true
  ]
  /NeverEmbed [ true
  ]
  /AntiAliasColorImages false
  /CropColorImages true
  /ColorImageMinResolution 200
  /ColorImageMinResolutionPolicy /OK
  /DownsampleColorImages true
  /ColorImageDownsampleType /Bicubic
  /ColorImageResolution 300
  /ColorImageDepth -1
  /ColorImageMinDownsampleDepth 1
  /ColorImageDownsampleThreshold 1.50000
  /EncodeColorImages true
  /ColorImageFilter /DCTEncode
  /AutoFilterColorImages false
  /ColorImageAutoFilterStrategy /JPEG
  /ColorACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /ColorImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /JPEG2000ColorACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000ColorImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasGrayImages false
  /CropGrayImages true
  /GrayImageMinResolution 200
  /GrayImageMinResolutionPolicy /OK
  /DownsampleGrayImages true
  /GrayImageDownsampleType /Bicubic
  /GrayImageResolution 300
  /GrayImageDepth -1
  /GrayImageMinDownsampleDepth 2
  /GrayImageDownsampleThreshold 1.50000
  /EncodeGrayImages true
  /GrayImageFilter /DCTEncode
  /AutoFilterGrayImages false
  /GrayImageAutoFilterStrategy /JPEG
  /GrayACSImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /GrayImageDict <<
    /QFactor 0.76
    /HSamples [2 1 1 2] /VSamples [2 1 1 2]
  >>
  /JPEG2000GrayACSImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /JPEG2000GrayImageDict <<
    /TileWidth 256
    /TileHeight 256
    /Quality 15
  >>
  /AntiAliasMonoImages false
  /CropMonoImages true
  /MonoImageMinResolution 400
  /MonoImageMinResolutionPolicy /OK
  /DownsampleMonoImages true
  /MonoImageDownsampleType /Bicubic
  /MonoImageResolution 600
  /MonoImageDepth -1
  /MonoImageDownsampleThreshold 1.50000
  /EncodeMonoImages true
  /MonoImageFilter /CCITTFaxEncode
  /MonoImageDict <<
    /K -1
  >>
  /AllowPSXObjects false
  /CheckCompliance [
    /None
  ]
  /PDFX1aCheck false
  /PDFX3Check false
  /PDFXCompliantPDFOnly false
  /PDFXNoTrimBoxError true
  /PDFXTrimBoxToMediaBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXSetBleedBoxToMediaBox true
  /PDFXBleedBoxToTrimBoxOffset [
    0.00000
    0.00000
    0.00000
    0.00000
  ]
  /PDFXOutputIntentProfile (None)
  /PDFXOutputConditionIdentifier ()
  /PDFXOutputCondition ()
  /PDFXRegistryName ()
  /PDFXTrapped /False

  /CreateJDFFile false
  /Description <<
    /CHT <FEFF4f7f752890194e9b8a2d7f6e5efa7acb7684002000410064006f006200650020005000440046002065874ef69069752865bc666e901a554652d965874ef6768467e5770b548c52175370300260a853ef4ee54f7f75280020004100630072006f0062006100740020548c002000410064006f00620065002000520065006100640065007200200035002e003000204ee553ca66f49ad87248672c4f86958b555f5df25efa7acb76840020005000440046002065874ef63002>
    /DAN <FEFF004200720075006700200069006e0064007300740069006c006c0069006e006700650072006e0065002000740069006c0020006100740020006f007000720065007400740065002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e007400650072002c0020006400650072002000650067006e006500720020007300690067002000740069006c00200064006500740061006c006a006500720065007400200073006b00e60072006d007600690073006e0069006e00670020006f00670020007500640073006b007200690076006e0069006e006700200061006600200066006f0072007200650074006e0069006e006700730064006f006b0075006d0065006e007400650072002e0020004400650020006f007000720065007400740065006400650020005000440046002d0064006f006b0075006d0065006e0074006500720020006b0061006e002000e50062006e00650073002000690020004100630072006f00620061007400200065006c006c006500720020004100630072006f006200610074002000520065006100640065007200200035002e00300020006f00670020006e0079006500720065002e>
    /DEU <FEFF00560065007200770065006e00640065006e0020005300690065002000640069006500730065002000450069006e007300740065006c006c0075006e00670065006e0020007a0075006d002000450072007300740065006c006c0065006e00200076006f006e002000410064006f006200650020005000440046002d0044006f006b0075006d0065006e00740065006e002c00200075006d002000650069006e00650020007a0075007600650072006c00e40073007300690067006500200041006e007a006500690067006500200075006e00640020004100750073006700610062006500200076006f006e00200047006500730063006800e40066007400730064006f006b0075006d0065006e00740065006e0020007a0075002000650072007a00690065006c0065006e002e00200044006900650020005000440046002d0044006f006b0075006d0065006e007400650020006b00f6006e006e0065006e0020006d006900740020004100630072006f00620061007400200075006e0064002000520065006100640065007200200035002e003000200075006e00640020006800f600680065007200200067006500f600660066006e00650074002000770065007200640065006e002e>
    /ESP <FEFF005500740069006c0069006300650020006500730074006100200063006f006e0066006900670075007200610063006900f3006e0020007000610072006100200063007200650061007200200064006f00630075006d0065006e0074006f0073002000640065002000410064006f00620065002000500044004600200061006400650063007500610064006f007300200070006100720061002000760069007300750061006c0069007a00610063006900f3006e0020006500200069006d0070007200650073006900f3006e00200064006500200063006f006e006600690061006e007a006100200064006500200064006f00630075006d0065006e0074006f007300200063006f006d00650072006300690061006c00650073002e002000530065002000700075006500640065006e00200061006200720069007200200064006f00630075006d0065006e0074006f00730020005000440046002000630072006500610064006f007300200063006f006e0020004100630072006f006200610074002c002000410064006f00620065002000520065006100640065007200200035002e003000200079002000760065007200730069006f006e0065007300200070006f00730074006500720069006f007200650073002e>
    /FRA <FEFF005500740069006c006900730065007a00200063006500730020006f007000740069006f006e00730020006100660069006e00200064006500200063007200e900650072002000640065007300200064006f00630075006d0065006e00740073002000410064006f006200650020005000440046002000700072006f00660065007300730069006f006e006e0065006c007300200066006900610062006c0065007300200070006f007500720020006c0061002000760069007300750061006c00690073006100740069006f006e0020006500740020006c00270069006d007000720065007300730069006f006e002e0020004c0065007300200064006f00630075006d0065006e00740073002000500044004600200063007200e900e90073002000700065007500760065006e0074002000ea0074007200650020006f007500760065007200740073002000640061006e00730020004100630072006f006200610074002c002000610069006e00730069002000710075002700410064006f00620065002000520065006100640065007200200035002e0030002000650074002000760065007200730069006f006e007300200075006c007400e90072006900650075007200650073002e>
    /ITA (Utilizzare queste impostazioni per creare documenti Adobe PDF adatti per visualizzare e stampare documenti aziendali in modo affidabile. I documenti PDF creati possono essere aperti con Acrobat e Adobe Reader 5.0 e versioni successive.)
    /JPN <FEFF30d330b830cd30b9658766f8306e8868793a304a3088307353705237306b90693057305f002000410064006f0062006500200050004400460020658766f8306e4f5c6210306b4f7f75283057307e305930023053306e8a2d5b9a30674f5c62103055308c305f0020005000440046002030d530a130a430eb306f3001004100630072006f0062006100740020304a30883073002000410064006f00620065002000520065006100640065007200200035002e003000204ee5964d3067958b304f30533068304c3067304d307e305930023053306e8a2d5b9a3067306f30d530a930f330c8306e57cb30818fbc307f3092884c3044307e30593002>
    /KOR <FEFFc7740020c124c815c7440020c0acc6a9d558c5ec0020be44c988b2c8c2a40020bb38c11cb97c0020c548c815c801c73cb85c0020bcf4ace00020c778c1c4d558b2940020b3700020ac00c7a50020c801d569d55c002000410064006f0062006500200050004400460020bb38c11cb97c0020c791c131d569b2c8b2e4002e0020c774b807ac8c0020c791c131b41c00200050004400460020bb38c11cb2940020004100630072006f0062006100740020bc0f002000410064006f00620065002000520065006100640065007200200035002e00300020c774c0c1c5d0c11c0020c5f40020c2180020c788c2b5b2c8b2e4002e>
    /NLD (Gebruik deze instellingen om Adobe PDF-documenten te maken waarmee zakelijke documenten betrouwbaar kunnen worden weergegeven en afgedrukt. De gemaakte PDF-documenten kunnen worden geopend met Acrobat en Adobe Reader 5.0 en hoger.)
    /NOR <FEFF004200720075006b00200064006900730073006500200069006e006e007300740069006c006c0069006e00670065006e0065002000740069006c002000e50020006f0070007000720065007400740065002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e00740065007200200073006f006d002000650072002000650067006e0065007400200066006f00720020007000e5006c006900740065006c006900670020007600690073006e0069006e00670020006f00670020007500740073006b007200690066007400200061007600200066006f0072007200650074006e0069006e006700730064006f006b0075006d0065006e007400650072002e0020005000440046002d0064006f006b0075006d0065006e00740065006e00650020006b0061006e002000e50070006e00650073002000690020004100630072006f00620061007400200065006c006c00650072002000410064006f00620065002000520065006100640065007200200035002e003000200065006c006c00650072002e>
    /PTB <FEFF005500740069006c0069007a006500200065007300730061007300200063006f006e00660069006700750072006100e700f50065007300200064006500200066006f0072006d00610020006100200063007200690061007200200064006f00630075006d0065006e0074006f0073002000410064006f00620065002000500044004600200061006400650071007500610064006f00730020007000610072006100200061002000760069007300750061006c0069007a006100e700e3006f002000650020006100200069006d0070007200650073007300e3006f00200063006f006e0066006900e1007600650069007300200064006500200064006f00630075006d0065006e0074006f007300200063006f006d0065007200630069006100690073002e0020004f007300200064006f00630075006d0065006e0074006f00730020005000440046002000630072006900610064006f007300200070006f00640065006d0020007300650072002000610062006500720074006f007300200063006f006d0020006f0020004100630072006f006200610074002000650020006f002000410064006f00620065002000520065006100640065007200200035002e0030002000650020007600650072007300f50065007300200070006f00730074006500720069006f007200650073002e>
    /SUO <FEFF004b00e40079007400e40020006e00e40069007400e4002000610073006500740075006b007300690061002c0020006b0075006e0020006c0075006f0074002000410064006f0062006500200050004400460020002d0064006f006b0075006d0065006e007400740065006a0061002c0020006a006f0074006b006100200073006f0070006900760061007400200079007200690074007900730061007300690061006b00690072006a006f006a0065006e0020006c0075006f00740065007400740061007600610061006e0020006e00e400790074007400e4006d0069007300650065006e0020006a0061002000740075006c006f007300740061006d0069007300650065006e002e0020004c0075006f0064007500740020005000440046002d0064006f006b0075006d0065006e00740069007400200076006f0069006400610061006e0020006100760061007400610020004100630072006f0062006100740069006c006c00610020006a0061002000410064006f00620065002000520065006100640065007200200035002e0030003a006c006c00610020006a006100200075007500640065006d006d0069006c006c0061002e>
    /SVE <FEFF0041006e007600e4006e00640020006400650020006800e4007200200069006e0073007400e4006c006c006e0069006e006700610072006e00610020006f006d002000640075002000760069006c006c00200073006b006100700061002000410064006f006200650020005000440046002d0064006f006b0075006d0065006e007400200073006f006d00200070006100730073006100720020006600f60072002000740069006c006c006600f60072006c00690074006c006900670020007600690073006e0069006e00670020006f006300680020007500740073006b007200690066007400650072002000610076002000610066006600e4007200730064006f006b0075006d0065006e0074002e002000200053006b006100700061006400650020005000440046002d0064006f006b0075006d0065006e00740020006b0061006e002000f600700070006e00610073002000690020004100630072006f0062006100740020006f00630068002000410064006f00620065002000520065006100640065007200200035002e00300020006f00630068002000730065006e006100720065002e>
    /ENU (Use these settings to create PDFs that match the "Required"  settings for PDF Specification 4.01)
    /CHS <FEFF4f7f75288fd94e9b8bbe5b9a521b5efa7684002000410064006f006200650020005000440046002065876863900275284e8e55464e1a65876863768467e5770b548c62535370300260a853ef4ee54f7f75280020004100630072006f0062006100740020548c002000410064006f00620065002000520065006100640065007200200035002e003000204ee553ca66f49ad87248672c676562535f00521b5efa768400200050004400460020658768633002>
  >>
>> setdistillerparams
<<
  /HWResolution [600 600]
  /PageSize [612.000 792.000]
>> setpagedevice

