

















































Quantifier-free Least Fixed Point Functions for Phonology

Jane Chandlee
Haverford College

Haverford, PA, USA
jchandlee@haverford.edu

Adam Jardine
Rutgers University

New Brunswick, NJ, USA
adam.jardine@rutgers.edu

Abstract

In this paper we define quantifier-free least
fixed point functions (QFLFP) and argue that
they are an appropriate and valuable ap-
proach to modeling phonological processes
(construed as input-output maps). These func-
tions, characterized in terms of first order logic
interpretations over graphs, provide a close fit
to the observed typology, capturing both local
and long-distance phenomena, but are also re-
strictive in desirable ways. Namely, QFLFP
logical functions approximate the computation
of deterministic finite-state transducers, which
have been argued to form a restrictive hypoth-
esis for phonological processes.

1 Introduction

A lot of recent work in computational phonol-
ogy has taken the approach of representing phono-
logical processes as maps or functions from
input strings/underlying representations to out-
put strings/surface representations (Chandlee and
Heinz, 2012; Heinz and Lai, 2013; Chandlee,
2014; Luo, 2017; Payne, 2017). The question of
interest underlying such work is how computa-
tionally powerful or expressive the functions in-
volved in phonology need to be. In particular,
these authors have argued that various proper sub-
sets of the regular relations (i.e., subregular func-
tions) are sufficient to model the attested range of
phonological phenomena. Special attention has
been given to one such subclass, the subsequen-
tial functions, which are restrictive in being deter-
ministic but still sufficiently expressive to capture
the needed range of segmental phonological pro-
cesses, both local and long-distance.

While this work has largely proceeded using
the finite-state formalism, a related line of work
has aimed to address similar questions using logi-
cal characterizations (Jardine, 2016; Chandlee and
Jardine, 2019), one advantage of logic being that it

offers a unified approach to modeling both linear
(i.e., string-based) and non-linear (i.e., autoseg-
mental representations, metrical structure) phe-
nomena. However, a restrictive logic that is still
sufficiently expressive to cover a wide range of
phonological phenomena has yet to be established.
Recent work has studied the relationships between
classes of automata and logical transductions (En-
gelfriet and Hoogeboom, 2001; Filiot, 2015; Fil-
iot and Reynier, 2016), but no work has studied a
logical characterization of the subsequential func-
tions.

This paper thus aims to fill this gap by propos-
ing a type of logic that approximates the sub-
sequential class of functions in an important
way. This logic is quantifier-free least fixed point
(QFLFP), which is first order logic without quan-
tifiers but with a (monadic) least fixed point oper-
ator. We will define this type of logic and demon-
strate how it can be used to model a range of
phonological processes in a recursive and output-
oriented way. We will also show that the functions
can be defined with this type of logic are in fact a
proper subset of the subsequential functions. This
is interesting both because it shows how logical
transductions can be related to subsequential func-
tions, and also because it closely fits the attested
typology of phonological processes.

The paper is organized as follows. In §2 we pro-
vide the needed preliminaries, and in §3 we give
an overview of the hierarchy of function classes
in the finite-state formalism. In §4 we provide
relevant background on logical characterizations
of functions, quantifier-free logic, and least fixed
point operators, before defining QFLFP functions.
In §5 we demonstrate the application of QFLFP
functions to phonology by giving example anal-
yses of phonological processes. In §6 we estab-
lish certain properties of QFLFP, and in §7 we dis-
cuss the implications of our findings and highlight



a few areas for future work. §8 concludes.

2 Preliminaries

Given a finite alphabet Σ, with Σ∗ we designate
the set of all possible finite strings of symbols from
Σ and with Σ≤n we designate the set of all possible
finite strings of length ≤ n. The length of a string
w is ∣w∣. The unique empty string is λ, so ∣λ∣ = 0.

Let P(X) denote the powerset of a set X .
For a set of strings

L,pref(L) = {u ∣∃v such that uv ∈
L},suff(L) = {v ∣∃u such that uv ∈
L}, and for a string w,pref(w) = {u ∣w =
uv for some string v},

prefn(w) = w if ∣w∣ ≤ n; otherwise
w1, where w = w1w2, ∣w1∣ = n,

suffn(w) = w if ∣w∣ ≤ n; otherwise
w2, where w = w1w2, ∣w2∣ = n.

For a stringw = σ1...σi...σn, letw(i) denote σi.
For a set of strings L ⊆ Σ∗ and two strings

w, v ∈ Σ∗, we write w ≡L v iff ∀z ∈ Σ∗, wz ∈
L ↔ vz ∈ L. This is an equivalence relation on
Σ∗ inducing a partition PL on Σ∗. A set L is
regular if and only if PL is finite. Note that if
w, v ∈ A for some A ∈ PL, then for any z ∈ Σ∗
then wz ∈ A′ ↔ vz ∈ A′ for some other A′ ∈ P .

We can define a similar notion for functions on
Σ∗. For a set of strings L, the longest common
prefix is the longest shared prefix of all the strings
in L. Formally,

lcp(L) = u ∈ ⋂w∈L pref(w), ∣u∣ ≥ ∣u′∣
for all u′ ∈ ⋂w∈L pref(w).

For a function f ∶ Σ∗ → Γ∗, and a string w ∈ Σ∗,
the tails of w with respect to f are defined as fol-
lows:

tailsf(w) = {(z, z′) ∣ f(wz) = uz′,
u = lcp(f(wΣ∗))}.

Two strings w, v ∈ Σ∗ are tail-equivalent, writ-
ten w ≡f v iff tailsf(w) = tailsf(v). Note
that ≡f is an equivalence relation on Σ∗; let Pf
be the partition it induces on Σ∗. A function f is
subsequential (SUBSEQ) iff Pf is finite (Oncina
et al., 1993).

We will make use of the following operation
that takes the pairwise intersection of the blocks
of two partitions P1 and P2 on some set X .

P1 ⊗ P2 def= {A ∩B ≠ ∅ ∣ A ∈ P1,B ∈ P2}

It is elementary to show that P1 ⊗ P2 is also a
partition on X , and that the operation is associa-
tive and commutative.

3 Transducers and function classes

It will be helpful to first define some impor-
tant function classes and illustrate them with au-
tomata. The SUBSEQ class is exactly described
by subsequetial finite-state transducers (SFSTs),
or determinstic finite state machines that output
a string for each input symbol and upon ending
on a state (Schützenberger, 1977; Mohri, 1997).
Note that this makes SUBSEQ a strict sublcass
of the regular (or rational) functions, or ex-
actly those describable with an FST (determinis-
tic or otherwise). Formally, a SFST is a tuple
⟨Q, q0,Qf ,Σ,Γ, δ, ω⟩ where Q is the set of states,
q0 ∈ Q is the single initial state, Qf ⊆ Q is the set
of final states, Σ and Γ are the input and output
alphabets, respectively, δ ∶ (Q × Σ) → (Γ∗ × Q)
is a transition function, and ω ∶ Qf → Γ∗ is the
output function. Note that because δ takes pairs
in (Q × Σ) (that is, it does not have transitions
on an input λ), and because it is a function, the
machine is deterministic. We define the transitive
closure δ∗ of δ recursively in the usual way; i.e.
δ∗(q, λ) = (λ, q) and if δ∗(q,w) = (v1, q1) and
δ(q1, σ) = (v2, q2) then δ∗(q,wσ) = (v1v2, q2).

A transducer T = ⟨Q, q0,Qf ,Σ,Γ, δ, ω⟩ de-
scribes a function fT ∶ Σ∗ → Γ∗ defined as
fT (w) = uv where δ∗(q0,w) = (u, qf) for some
qf ∈ Qf , and v = ω(qf). As an example, the
SFST in Fig 1 models the function described by
the rewrite rule in (1) (‘change an a that follows
a b to b’). (In all SFSTs in this paper, the initial
state is indicated with a small unlabeled incom-
ing arrow, all states are assumed to be final, and
the output function is represented in the state label
with the string to the right of the colon.)

(1) a → b / b (simultaneous)

As stated above, SUBSEQ is exactly the class
of functions with a finite set of tail-equivalence
classes. In the minimal SFST for a subsequen-
tial function, each state corresponds to a tail-
equivalence class.

Restrictions on the nature of these tail-
equivalence classes offer subclasses of
SUBSEQ that have been argued to be rele-
vant to phonology. One such class is the input
strictly local (ISL) functions, a subsequential



0 ∶ λ 1 ∶ λ

a ∶ a b ∶ b

b ∶ b

a ∶ b

Figure 1: A SFST implementing the rule a → b / b ,
applied simultaneously, for Σ = Γ = {a, b}. This func-
tion is ISL2.

class defined by Chandlee (2014), which Chan-
dlee and Heinz (2018) argue can model any local
phonological rule that applies simultaneously.
Formally, the ISL class is defined as below.

Definition 1 (ISL; Chandlee 2014) A function f
is ISLk iff for all strings w, v, suffk−1(w) =
suffk−1(v) implies tailsf(w) = tailsf(v).

Intuitively, the ISL class is exactly those func-
tions for which, for any symbol in the string, its
output is entirely decided by the preceding k − 1
symbols in the input. This means that any ISLk
function can be described by a SFST whose states
correspond to the k − 1 suffixes of Σ∗. Fig. 1 is
exactly one such SFST: its states represent the pre-
vious 1 symbol in the input—state 0 represents a
preceding a in the input, and state 1 a preceding b.
The function is thus ISL2.

Another notion of local string functions is those
for which the output of a string is based on the
preceding k − 1 symbols in the output; this is the
output strictly local (OSL) class. A definition for
this class is given below.

Definition 2 (OSL; Chandlee 2014)
A function f is OSLk iff for all
strings w, v, suffk−1(f(w)) =
suffk−1(f(v)) implies tailsf(w) =
tailsf(v).

(Note: this is an incomplete definition, but for
the purposes of this paper it is sufficient. For the
complete definition see Chandlee et al. 2015.) The
definition for OSL is parallel to that for ISL, ex-
cept it refers to the output of the function. An ex-
ample is given in Fig. 2 for the rule in (2), applied
iteratively.

(2) a → b / b (iterative)

By “applied iteratively,” we mean that an a be-
comes a b after a b which may have been present
in the input (and so remained a b in the output) or

0 ∶ λ 1 ∶ λ

a ∶ a a ∶ b, b ∶ b

b ∶ b

Figure 2: A SFST implementing the rule a → b / b ,
applied iteratively, for Σ = Γ = {a, b}. This function is
OSL2.

may have been an a in the input (and so was it-
self turned into a b in the output). This is OSL2,
because (either way) whether or not an input a is
output as b depends on the immediately preceding
output symbol.

The way in which ISL and OSL correspond
to the difference between simultaneous and iter-
ative application of rules can be seen more clearly
when one compares the output strings for these
two FSTs for the input baabaa. The FST in Fig.
1 outputs bbabba for this input string, such that all
a’s that follow b’s in the input are changed to b.
In contrast, the FST in Fig. 2 outputs bbbbbb, such
that all a’s are changed to b. The structural differ-
ence in the FSTs that is responsible for this differ-
ence is that in Fig. 1 all transitions with the same
input symbol lead to the same state whereas in Fig.
2 all transitions with the same output string lead to
the same state.1

The ISL and OSL functions are strict subclasses
of SUBSEQ. That ISL ⊊ SUBSEQ is witnessed
by Fig. 3. The SFST in this figure represents a
function that changes a to b if it follows a b, where
any number of c’s can intervene. The strings ck

and bck clearly have the same suffix of length k −
1 (for any k), but (contra Definition 1) they have
different tails, as (a, a) is in the tails of ck while
(a, b) is in the tails of bck.

That OSL ⊊ SUBSEQ is also witnessed by Fig.
3. The strings f(ck) = ck and f(bck) = bck again
have the same suffix of length k − 1 (for any k),
but (contra Definition 2) they have different tails,
as (a, a) is in the tails of ck while (a, b) is in the
tails of bck.

The ISL and OSL classes are thus restrictive
classes of functions that have been posited as
strong hypotheses for the computational complex-
ity of phonological processes with local triggers
(Chandlee, 2014; Chandlee and Heinz, 2018). Ex-
amples of their connection to phonological pro-

1For more on how FSTs model modes of rule application
see Kaplan and Kay (1994) and Hulden (2009).



0 ∶ λ 1 ∶ λ

a ∶ a

c ∶ c

a ∶ b

b ∶ b

c ∶ c
b ∶ b

Figure 3: A SFST changing any a following a b in a
word, regardless of any number of intervening c’s, to a
b. This function is neither ISL or OSL.

cesses are given below. The purpose of this pa-
per is to investigate, through logical transduc-
tions, a class that generalizes the intuitions behind
these classes, and also captures non-ISL and non-
OSL functions, like Fig. 3, that are relevant to
phonology.

4 Logical transductions

We consider finite strings models over the signa-
ture I of strings in Σ with predecessor function p,
delimited by boundaries ⋊ and ⋉, and assume that
for a string of length n (including the boundaries)
the domain of its model is D = {1, ..., n}.

I = {p,⋊,⋉, Pσ∈Σ}

Figure 4 gives a model for a string over the al-
phabet Σ = {a, b} with D = {1,2,3,4,5,6,7}.
For each σ ∈ Σ ∪ {⋊,⋉}, Pσ ⊆ D includes those
members of D that are labeled with σ. For exam-
ple, in the figure Pb = {3,4,6}.

⋊1 a2 b3 b4 a5 b6 ⋉7

Figure 4: Model for the string abbab

The signature also includes a predecessor func-
tion p that gives the immediately proceeding po-
sition for each position—e.g., p(3) = 2, p(2) = 1,
etc.

We define a monadic second order (MSO) logic
LI over I in the usual way; that is, LI is a predi-
cate logic whose atomic formulae are of the form
σ(t), where σ(t) is true when the term t is inter-
preted as a member of Pσ. More formally, a term
is either some member x of a countably infinite
set of first-order variables (which range over the
domains of models) or the application p(t) of the
predecessor function to a term t. MSO is then a
logic defined recursively in which σ(t) for some t

and σ ∈ Σ is a well-formed formula (WFF); X(t)
for some term t and some variableX drawn from a
countably infinite set of set variables is a WFF; for
WFFs ϕ and ψ, ¬ϕ and ϕ ∨ ψ are WFFs; and for
WFFs ϕ(x) and ψ(X) with free first-order and
set variables x and X , respectively, (∃x)[ϕ(x)]
and (∃X)[ψ(X)] are WFFs. As shorthand, for
k ≥ 0, pk(x) denotes x when k = 0, p(pk−1(x))
otherwise. The semantics of LI are defined as
usual over string models with the first-order vari-
ables mapped to positions in a string and second-
order variables mapped to sets of positions in the
string. In particular we write S ⊧ ϕ(x)[x ↦ i]
for a string model S that satisfies ϕ(x) when x is
mapped to i ∈D.

For example, b(p(x)) is a WFF in LI , as is
b(x) ∧ b(p(x)). The string in Fig. 4 satisfies
b(p(x)) when x is mapped to positions 4, 5, or 7
(that is, the positions whose predecessor is labeled
b). The string in Fig. 4 satisfies b(x) ∧ b(p(x))
only when x is mapped to 4, as that is the only po-
sition that is both a b and is immediately preceded
by a b.

We can define functions logically through a log-
ical interpretation of an output signature O in the
logic LI of the input signature. Specifically, a
MSO transduction T to the output signature O
over strings in Γ

O = {<′, Pγ∈Γ}

is a finite ordered copy set C = {1, ..., n} and a
series of formulae γc(x) in LI with exactly one
free variable x and for each γ ∈ Γ and c ∈ C. The
copy set allows us to create up to n output copies
of each input element.2 See below for an exam-
ple demonstrating the use of multiple copies of an
input element.

We define the semantics of T following Engel-
friet and Hoogeboom (2001). For an input string
model S over the signature I with domain D, its
output T (S) is a string S ′ over the signature O
with domain D′ and unary relations Pγ∈Γ built
in the following way. For each d ∈ D, there
is a dc ∈ D′ that belongs to Pγ if and only if
S ⊧ γc(x)[x ↦ d] for exactly one γ ∈ Γ and ex-
actly one c ∈ C. If no such γ or c exists, then no
output position is constructed for d. We assume

2We can also consider a closed domain formula ϕdom
which specifies the domain of the function; as long as this
formula is in MSO or lower, this does not change any of the
below results, so we do not discuss it in detail here. For more
see Engelfriet and Hoogeboom (2001); Filiot (2015).



that the transduction is order-preserving; that is,
the output order <′ in O is such that for any d ∈ D
and i < j ∈ C, di <′ dj , and for any distinct d, e ∈D
and i, j ∈ C, for the copies di and ej in D′, di <′ ej
if and only if d < e.

Thus, a MSO transduction T thus defines a
function f(T ) from strings in ⋊Σ∗⋉ to strings in
Γ∗.

As an example, we logically define the func-
tion for ‘change a b following another b to a c’
rule given in (3), assuming Σ = {a, b} and Γ =
{a, b, c}.

(3) b→ c / b

Since this rule makes no mention of a’s, all po-
sitions in the input model that are labeled a can
likewise be labeled a in the output model. The
formula in (4-a) achieves this. As this is a ‘sub-
stitution’ rule that doesn’t extend the length of the
string, only a single copy of each input position
is needed. Therefore we simply mark the output
relations with a prime γ′ instead of a number.

(4) a. a′(x) def= a(x)
b. b′(x) def= b(x) ∧ ¬b(p(x))
c. c′(x) def= b(x) ∧ b(p(x))

Likewise, the formula in (4-b) declares which po-
sitions in the output model are labeled b: namely,
those positions that are labeled b in the input
model but whose predecessors are not also labeled
b (so excluding those b’s that are subject to the rule
in (3)). Lastly, the formula in (4-c) declares which
positions are labeled c in the output model: those
positions that are subject to the rule in (3). The
collective result is the output model shown in Fig-
ure 5.

⋊1 a2 b3 b4 a5 b6 ⋉7
↧

a2′ b3′ c4′ a5′ b6′

Figure 5: Transduction of abbab following (4).

The following example demonstrates the use of
a copy set with a size larger than 1. With the fol-
lowing formulas and a copy set C = {1,2} we de-
fine a function that inserts a c after every input b.

(5) a. a1(x) def= a(x)
b. a2(x) def= False

c. b1(x) def= b(x)
d. b2(x) def= False
e. c1(x) def= False
f. c2(x) def= b(x)

The formulas (5-a) and (5-c) create a first copy la-
beled a and b in the output, respectively, for each a
and b in the input. The formula (5-f), then, creates
a second copy labeled c for each b in the input. As
the other formula are set to False, no other copies
are produced in the output. Finally, following the
precedence relation defined above, each 1 copy b
precedes the 2 copy c. Thus, abbab is output as
abcbcabc.

Fig. 6 illustrates the transduction defined by
these formulas with the input string abbab.

⋊1 a2 b3 b4 a5 b6 ⋉7
↧

a21 b31 b41 a51 b61
c32 c42 c62

Figure 6: Transduction of abbab into abcbcabc follow-
ing (5)

We fix the precedence relations in the output
due to the following equivalence.

Theorem 1 (Filiot 2015) A function f is regular
iff there is an order-preserving monadic second or-
der transduction T such that f = f(T ).

Theorem 1 thus guarantees that any logic and
signature we use that is less than or equal to
monadic second order logic in expressivity will
give us (sub-)regular functions.

4.1 Quantifier-free logic
Note that none of the formulas used in the previous
example included quantifiers. Let quantifier-free
(QF) denote the restriction on LI to formula with
no quantifiers (and thus no set variables).

Chandlee and Lindell (in prep.) relate QF to
the ISL class, showing that any ISL function with
bounded deletion is QF-definable. However, their
definitions do not consider functions with the out-
put order as defined above. We show in §6.2 that,
given this order, QF = ISL exactly.

An example of a phonological rule that cannot
be modeled with this restricted logic is unbounded
iterative spreading of a feature, such as the spread-
ing of nasality from a nasal consonant to a follow-
ing sequence of vowels: nV V V ↦ nṼ Ṽ Ṽ . The



formula in (6) would achieve the nasalization of
the first vowel following the input nasal.

(6) Ṽ ′(x) def= n(p(x))

The problem with modeling this process using
only QF formula arises when trying to account for
the nasalization of the second and third vowels. Of
course we can add to (6) n(p2(x)) ∨ n(p3(x)),
which would accommodate the present example.
But then what about a form like /nVVVV/, for
which the nasalization of the final vowel would re-
quire a formula to identify the nasality of the pre-
decessor of its predecessor of its predecessor of its
predecessor (i.e., p4(x))? The issue now should
be clear: for an unbounded pattern such as this
one, the input nasal that triggers the nasalization
of a given vowel may be an unbounded number of
segments away. Without knowing in advance how
large of a bound that is, a formula in terms of the
predecessor function cannot be defined. Instead,
what is needed is a quantifier: nasalize a vowel if
there exists a nasal consonant at a prior position.

The traditional analysis of a feature spreading
process like this one is that after the first nasaliza-
tion of the vowel immediately following the nasal
consonant, the actual trigger of the next nasaliza-
tion is the most ‘recently’ nasalized vowel. But
capturing that intuition requires specifying some-
thing about the labels in the output model, not the
input model, which falls beyond the capabilities
of QF. In that sense the limitation here is not the
need for the quantifier, but the restriction on the
formula to referring to the input model only.

In the next section we will show how to model
such output-oriented processes using QF formula
with the addition of the least fixed point (lfp) op-
erator.

4.2 Least fixed point quantifier-free logic

Least fixed point logic allows us to add inductive
definitions to our logics. The following is based
on Libkin (2004, Ch. 10), but simplified for unary
predicates.

For a set U an operator on U is a function F ∶
P(U) → P(U). A set X ⊆ U is a fixed point
if F (X) = X . A set X is the least fixed point
lfp(F ) of F iff it is a fixed point of F and for
every other fixed point Y of F , X ⊆ Y . We write
lfp(F ) for the least fixed point of F .

An operator F is monotone if X ⊆ Y implies
F (X) ⊆ F (Y ). For every monotone operator F ,

lfp(F ) = ⋃iXi, where each Xi is from the se-
quence in (7).

(7) X0 = ∅,Xi+1 = F (Xi)

That is, lfp(F ) is the set that is converged to by
recursive applications of F . Given models with
finite domains, there is always such a (finite) set
for a monotone operator on the domain.

For a signature S and any modelM in the sig-
nature whose universe is M , we extend our logic
with an additional set predicate A not in S. A for-
mula ϕ(A,x) with a single free variable x and free
set variableA induces an operator Fϕ onM as fol-
lows.

Fϕ(X) = {m ∣M ⊧ ϕ(A,x)[A↦X,x↦m]}

We will work through an example to illustrate,
using the string model in Figure 7. Let ϕ(A,x) be
defined as in (8).

⋊1 a2 b3 a4 a5 a6 c7 a8 ⋉9

Figure 7: Model for the string abaaaca

(8) ϕ(A,x) = a(x) ∧ (b(p(x)) ∨A(p(x)))

First let X0 = ∅. We then have

Fϕ(∅) = {m ∣ D ⊧ ϕ(A,x)[A↦ ∅, x↦m]}.

No positionm ∈D satisfiesA(p(x)) sinceA = ∅,
but position 4 satisfies both a(x) and b(p(x)), and
so Fϕ(∅) = {4}.

Now X = {4}, so Fϕ({4}) = {m ∣ D ⊧
ϕ(A,x)[A ↦ {4}, x ↦ m]}. Now position 5 sat-
isfies the formula (because it is labeled a and its
predecessor is in A), so Fϕ({4}) = {4,5}.

Now with X = {4,5}, Fϕ({4,5}) = {4,5,6},
and then Fϕ({4,5,6}) = {4,5,6}, so {4,5,6} is
lfp(Fϕ), as no new elements are added.

Whether or not Fϕ is monotone (and thus,
whether lfp(Fϕ) can be determined via the se-
quence in (7)) is undecidable for an arbitrary FO
formula ϕ. So the least fixed point extension of
FO is defined with the following restriction on the
set variable A:

(9) A is positive in ϕ; that is, it is under the
scope of an even number of negations.

We then extend the usual definition of QF with
the following syntax:



Definition 3 (QFLFP syntax) Any formula in
QF is in QFLFP.

For a formula ϕ(A,y) in QF extended with the
predicate A(y) satisfying (9), [lfp ϕ(A,y)](x)
is a formula in QFLFP.

A formula [lfp ϕ(A,y)](x) is then true when
x is interpreted as an element in the least-fixed
point of the operator induced by ϕ(A,y).

Definition 4 (QFLFP semantics) For any for-
mula in QFLFP that is also in QF, satisfaction
is the same as in QF.

For a formula [lfp ϕ(A,y)](x) in QFLFP,

M ⊧ [lfp ϕ(A,y)](x)[x↦m] iff m ∈ lfp(Fϕ)

In the next section we will demonstrate such
transductions with phonological examples.

5 QFLFP functions in phonology

First we return to the example of unbounded iter-
ative spreading, discussed in the previous section
as a case that can’t be modeled as a QF transduc-
tion. For simplicity we will assume the alphabet
Σ = {a, b} and use the model in Figure 8.

⋊1 b2 a3 a4 a5 ⋉6

Figure 8: Model for the string baaa

The rule is the same as in (2), repeated below in
(10).

(10) a→ b / b (iterative)

The expected output string is then bbbb. The for-
mula in (11) uses a lfp operator to declare which
output positions should be labeled b.

(11) b′(x) def= [lfp b(y) ∨A(p(y))](x) ∧ ¬ ⋉
(x)

At first only position 2 satisfies b(y) ∨ A(p(y)),
since initially A = ∅ and so no positions satisfy
A(p(y)). Now with A = {2}, position 3 satis-
fies b(x) ∨ A(p(y)), since its predecessor is in
A. Next 4 can be added, and then 5, and finally
6. After that no new positions will ever be added,
and so {2,3,4,5,6} is the lfp. The copies of the-
ses positions are all labeled b in the output—with
the exception of 6 due to ¬ ⋉ (x). Thus the map
baaa↦ bbbb is obtained.

We also consider a case of unbounded spread-
ing with blocking, in which the feature spreads un-
boundedly but only up to a particular type of seg-
ment, a blocker. This type of process is attested in
Johore Malay (Onn, 1980), where nasality spreads
from a nasal consonant through a following span
of vowels and glides but stops when it reaches an
obstruent:

(12) Johore Malay (Onn, 1980)
/p@Nawasan/ ↦ [p@Nãw̃ãsan], ‘supervi-
sion’

We will extend our analysis of unbounded spread-
ing to this case as well, using the alphabet Σ =
{a, b, c}, where c is a blocker.

⋊1 b2 a3 a4 c5 a6 b7 a8 ⋉9

Figure 9: Model for the string baacaba

As (13) shows, the change is minor: the condi-
tions under which a position is added to the set are
made more stringent by including ¬c(x).

(13) b′(x) def= [lfp(b(y) ∨ (A(p(y)) ∧
¬c(y)))](x) ∧ ¬ ⋉ (x)

The effect of this added restriction is that the set
will be built as follows:

∅
{2, 7}
{2, 3, 7, 8}
{2, 3, 4, 7, 8, 9}

This last set is the lfp, which picks out those
positions that will be labeled b in the output (again
except for 9), giving the string bbbcabb. The a that
follows the blocker cwill not receive the spreading
feature because it is never added to the set, because
its predecessor is prevented from joining the set by
being labeled c.

Lastly, we consider a case of unbounded agree-
ment, where a segment takes on a feature from a
triggering segment but (unlike in spreading) the in-
tervening segments are unaffected. An example is
in Kikongo, in which a liquid becomes nasal (un-
derlined below) following a nasal somewhere in a
root (Ao, 1991; Odden, 1994).

(14) Kikongo (Ao, 1991)



a. /ku-toot-ila/ ↦[ku-toot-ila]
‘to harvest for’

b. /ku-dumuk-ila/ ↦[ku-dumuk-ina
‘to jump for’

c. /ku-dumuk-is-ila/↦[ku-dumuk-is-ina]
‘to make jump for’

We can model this process schematically with the
function from Fig. 3, in which any a following a b
is output as a b, no matter how many c’s intervene.
We will use the string model in Figure 10, where
b is the trigger, a is the target, and c intervenes
(without blocking).

⋊1 c2 b3 c4 c5 c6 a7 ⋉8

Figure 10: Model for the string cbccca

This time the positions labeled b in the output
are identified by the formula in (15).

(15) b′(x) def= [lfp b(y) ∨ A(p(y))](x) ∧
¬c(x) ∧ ¬ ⋉ (x)

The set is built as follows:
∅
{3}
{3, 4}
{3, 4, 5}
{3, 4, 5, 6}
{3, 4, 5, 6, 7}
{3, 4, 5, 6, 7, 8}

Note that all positions after the trigger are in-
cluded in the set, but the formula for b′(x) spec-
ifies that to be labeled b in the output a position
has to both be in this set AND not be labeled c (or
again ⋉). So only the trigger and target are labeled
b, giving the output string cbcccb.

6 Properties of QFLFP

6.1 Relation of QFLFP to other classes of
functions

We now show some important properties
of QFLFP. In particular, the structure of
QFLFP concisely restricts its transductions
to subsequential functions. Specifically,
QFLFP transductions model the determinis-
tic computation of the output string reading the
input string left to right.

Remark 1 QFLFP ⊆ MSO.

Proof: It is sufficient to show a transla-
tion into MSO for formulas of the form

[lfp ϕ(A,y)](x). We can replace any such
formula for an equivalent MSO formula
(∃X∀y)[(ϕ(A/X,y) → X(y)) ∧ X(x)],
where ϕ(A/X,y) is ϕ(A,y) with each instance
of A(pn(y)) replaced with X(pn(y)). ◻

The following shows that satisfaction of a
QFLFP formula is closed under suffixation; that
is, if a position in a string satisfies a formula, it will
satisfy that formula regardless of how the string is
suffixed. This shows that QFLFP is strictly less
powerful than full MSO transductions.

Lemma 1 For any QFLFP formula
[lfp ϕ(A,y)](x), any w ∈ pref(⋊Σ∗⋉),
and any 1 ≤ n ≤ ∣w∣,

w ⊧ [lfp ϕ(A,y)](x)[x↦ n]
implies

wv ⊧ [lfp ϕ(A,y)](x)[x↦ n]

for all v ∈ suff(⋊Σ∗⋉).

Proof: Let lfpw(Fϕ) be the least fixed point with
respect to Fϕ for the domain Dw of (the model
of) w; likewise lfpwv(Fϕ) for wv. We show that
lfpw = (lfpwv ∩Dw); this means that n ∈ lfpw
if and only if n ∈ lfpwv for all 1 ≤ n ≤ ∣w∣.

Consider the series X0w = ∅, Xi+1w = Fϕ(Xiw)
from (7), relativized to the domain of w, and sim-
ilarly X0w = ∅, Xi+1wv = Fϕ(Xiwv) for wv. By defi-
nition X0w =X0wv = ∅.

It is then the case that X1w = (X1wv ∩Dw). For
any 1 ≤ j ≤ ∣w∣, w ⊧ ϕ(A,y)[A ↦ ∅, y ↦ j]
implies wv ⊧ ϕ(A,y)[A ↦ ∅, y ↦ j] because
they are equivalent with respect to the base cases:
for ϕ(A,y) = a(pm(y)), w ⊧ a(pm(y))[y ↦ j]
iff v ⊧ a(pm(y))[y ↦ j] because prefj(w) =
prefj(wv); w, v /⊧ A(pm(y))[A ↦ ∅, y ↦ j],
because this always evaluates to false. So j ∈ X1w
iff j ∈X1wv for 1 ≤ j ≤ ∣w∣.

We then consider Xiw and X
i
wv for an arbi-

trary i ≥ 2. By hypothesis, assume that Xiw =
(Xiwv ∩ Dwv). Then for any 1 ≤ j ≤ ∣w∣, be-
cause prefj(w) = prefj(wv),w ⊧ ϕ(A,y)[A↦
Xiw, y ↦ j] iff v ⊧ ϕ(A,y)[A ↦ Xiwv, y ↦ j].
So j ∈ Xi+1w iff j ∈ Xi+1wv , and thus Xi+1w =
(Xi+1wv ∩Dwv).

Because we have shown this also for i = 1,
it must then hold for any arbitrary i. Thus
lfpw = (lfpwv ∩Dw). ◻



Lemma 2 For any QFLFP formula ϕ(x), any
w ∈ pref(⋊Σ∗⋉), and any 1 ≤ n ≤ ∣w∣,

w ⊧ ϕ(x)[x↦ n] implies wv ⊧ ϕ(x)[x↦ n]

for all v ∈ suff(⋊Σ∗⋉).

Proof: By recursion on the structure of ϕ(x). If
ϕ(x) = a(pm(x)) for some a ∈ Σ ∪ {⋊,⋉}, then
w(n) = wv(n) = a. If ϕ(x) = [lfp ψ(A,y)](x)
and w ⊧ ϕ(x)[x ↦ n] then wv ⊧ ϕ(x)[x ↦ n]
by Lemma 1. The cases for ϕ(x) = ¬ψ(x) and
ϕ(x) = ψ1(x) ∨ ψ2(x) then follow. ◻

The above means that for a QFLFP trans-
duction T the output of a prefix w ∈ Σ∗ in
the input remains constant, regardless of how
we extend w. We formalize this output with
outT (w) = w′1w′2...w′`, where ` = ∣w∣ and each
w′i = γ1γ2...γn, such that w ⊧ γ11(x)[x ↦ i],
w ⊧ γ22(x)[x ↦ i], ..., w ⊧ γnn(x)[x ↦ i] for
γ11(x), γ22(x), ..., γnn(x) ∈ T .

The following is thus important in establishing
the tails of w.

Corollary 1 For any string w ∈ Σ∗, a QFLFP-
definable transduction T and its function f =
f(T ), out(w) is a prefix of lcp(f(wΣ∗)).

Proof: Let outT (w) = w′1w′2...w′` as above. The
corollary follows from Lemma 2, because at each
position i in w, i will satisfy the same formulas
no matter how w is extended, so w′i will be output
no matter how w is extended. Thus, at the least,
w′1w

′
2...w

′
` will be output. ◻

The following establishes the set of ‘reach
strings’ for ϕ(x) ∈ T ; that is, strings w such that
some wσ will satisfy ϕ(x). This simulates the set
of strings that will reach a particular state in a FST.

Definition 5 For ϕ(x) ∈ T , let

Lϕ
def= {w ∣ wσ ⊧ ϕ(x)[x↦ ∣wσ∣] for some σ ∈ Σ}

The following follows from the fact that
QFLFP ⊆ MSO.
Remark 2 Lϕ is regular.

For ϕ(x) ∈ T , let Pϕ be the finite partition
on Σ∗ induced by the equivalence relation of Lϕ.
Then for T = {ϕ1(x), ..., ϕn(x)}, let

PT
def= Pϕ1 ⊗ Pϕ2 ⊗ ...⊗ Pϕn

This is the partition of Σ∗ into sets of strings
belonging to the same equivalence class for every
Lϕi . As each Lϕi is regular, it follows that PT is
finite.

Lemma 3 For some QFLFP T =
{ϕ1(x), ..., ϕn(x)} and f = f(T ), for any
w, v ∈ Σ∗ and A ∈ PT ,

w, v ∈ A ↔ w ≡f v

Proof: (→) Recall (from §2) that for any ϕ(x) ∈
T and B ∈ Pϕ, w, v ∈ B iff for all z ∈ Σ∗, wz ∈ Lϕ
iff vz ∈ Lϕ. Because PT is the pairwise intersec-
tion of all such sets, for any A ∈ PT , w, v ∈ A if
and only if for all z ∈ Σ∗ and for all ϕ(x) ∈ T ,
wz ∈ Lϕ ↔ vz ∈ Lϕ.

Thus, for w, v ∈ A in PT if and only if for all
z ∈ Σ∗ and for all ϕ(x) ∈ T ,

wzσ ⊧ ϕ(x)[x↦ ∣wzσ∣] ↔
vzσ ⊧ ϕ(x)[x↦ ∣vzσ∣]

Consider then any w, v ∈ A for some A ∈ PT
and any u = σ1σ2...σm. It follows that for each
σi wσ1...σi ⊧ ϕ(x)[x ↦ (∣w∣ + i)] if and only if
vσ1...σi ⊧ ϕ(x)[x↦ (∣v∣ + i)].

Then consider u′ = u′1u′2...u′n where each u′i =
γ11γ

2
2 ...γ

k
k s.t. wσ1...σi ⊧ γ

j
j (x)[x↦ (∣w∣+ i)] for

γ11(x), ..., γkk(x) ∈ T . From Lemma 2 we know

f(wu) = outT (w)u′ and f(vu) = outT (v)u′.

From Corollary 1 it is also the case that
outT(w) is a prefix of lcp(f(wΣ∗)) and outT(v)
is a prefix of lcp(f(vΣ∗)). Let u′p be the portion
of u′ that is in lcp(f(wΣ∗)); that is, u′ = u′pu′s
where lcp(f(wΣ∗)) = outT(w)u′p. Because the
above establishes that w and v share the same out-
put suffixes, it is also the case that lcp(f(vΣ∗)) =
outT(v)u′p. Thus any (u,u′s) is in tailsf(w) if
and only if it is also in tailsf(v).

Thus w, v ∈ A implies that tailsf(w) =
tailsf(v).

(←) The reverse is clear by consid-
ering that (u,u′1u′2...u′n) ∈ tailsf(w)
if and only if for each ui = γ11γ22 ...γkk ,
wσ1...σi ⊧ γjj (x)[x ↦ (∣w∣ + i)] for each
γjj (x). If this is also the case for v then it must be
the case that w, v ∈ A for the same A ∈ PT . ◻

Theorem 2 QFLFP ⊆ SUBSEQ.



0 1 2

a ∶ λ a ∶ λ a ∶ λ

b ∶ λ
b ∶ b b ∶ b

Figure 11: An OSL3 function we conjecture not to be
QFLFP.

Proof: From Lemma 3 and the fact that PT is
finite. ◻

Lemma 4 QFLFP /⊆ OSL

Proof: This is witnessed by the function of the
SFST in Fig. 3 (which turns any a following a
b into an a, regardless of any intervening c’s),
which was shown not to be OSL, but was shown
in Sec. 5 to be QFLFP-definable. ◻

Conjecture 1 OSL,SUBSEQ /⊆ QFLFP
Consider the OSL function in Figure 11, which

deletes any a and all except for the first two b’s.3

This is OSL3, because whether or not we delete
a b depends on whether or not we have output 2
b’s previously. Now consider a formula b′(x) that
is true for exactly the first two b’s. For the first,
we can write b(x)∧¬[lfp(b(y)∨A(p(y)))](x),
the latter lfp disjunct identifying any elements
following a b. To identify exactly the second b,
we would have to include reference to the first
b in another lfp predicate, thus embedding one
lfp statement in another. We conjecture that this
embedding of one lfp formula in another is neces-
sary; that is, there is no QF formula ϕ(A,y) such
that [lfp ϕ(A,y)](x) can identify the second b.

6.2 Equivalence of QF and ISL

Finally, we show that the QF fragment of
QFLFP describes exactly the ISL functions. We
first show that QF formula can only distinguish
positions in a string based on the previous k − 1
symbols for some k.

Lemma 5 Let T be a QF transduction, and let k
be the value for which pk−1(x) appears in some
γc(x) in T and for any other pj(x) that appears
in some γc(x) in T , j < k. Consider two strings
w, v ∈ pref(⋊Σ∗⋉) such that suffk−1(w) =
suffk−1(v); let `w denote ∣w∣ and likewise `v for

3We thank Shiori Ikawa for this example.

SUBSEQ

OSL QFLFP

ISL = QF

Figure 12: Hierarchy of the relevant function classes

∣v∣. For any γc(x) in T ,

w ⊧ γc(x)[x↦ `w]
if and only if

v ⊧ γc(x)[x↦ `v]

Proof: Let u = suffk−1(w) = suffk−1(v)
and `u denote ∣u∣. If γc(x) = a(pj(x)) for
some a ∈ Σ ∪ {⋊,⋉}, then w ⊧ γc(x)[x ↦ `w]
iff w(`w − j) = a. Since j < k, this im-
plies that u(`u − j) = a and thus also that
v ⊧ γc(x)[x ↦ `v]. Clearly the reverse implica-
tion holds as well. Since w and v are equivalent
with respect to satisfaction of the atomic formulae
for QF, this then extends to the general case for
ϕ(x) based on induction on the structure of QF.◻

Theorem 3 QF = ISL

Proof: (→) From Lemma 3 we know that w and
v have the same set of tails; thus Lemma 5 shows
that suffk−1(w) = suffk−1(v) implies w ≡f v.
Thus QF ⊆ ISL.

(←) For ISL ⊆ QF, we construct a QF trans-
duction for the canonical transducer for an
ISL function. As stated in §3, each state in an
ISLk SFST represents a k − 1 suffix. So we
can construct an equivalent QF transduction T
as follows. For a string w = σ1σ2...σk we can
write ϕw(x) = σ1(pk−1(x)) ∧ σ2(pk−2(x)) ∧ ... ∧
σk−1(p(x)) ∧ σk(x). For each symbol γ ∈ Γ,
we set γi(x) = ϕw1(x) ∨ ϕw2(x) ∨ ... ∨ ϕwn(x),
where w1,w2, ...,wn is the exhaustive set
of strings wj = qjσj for which a transition
δ(qj , σj) = (vj , rj), exists where γ = vj(i).
So for any position in the input string that
exercises a transition δ(q, σ) = (v, r) in the
ISLk machine, it will also satisfy a sequence
γ11(x), γ22(x), ..., γmm(x) such that γ1γ2...γm = v.
◻

Fig. 12 summarizes the results discussed so far.



6.3 Left- and right-subsequential functions

We have so far abstracted away from the fact
that SUBSEQ can instead be characterized as
the left-subsequential functions, with the right-
subsequential functions being the reversal of some
left-subsequential function (Mohri, 1997). For-
mally, a function f is right-subsequential iff f =
{(wr, vr)∣f ′(w) = v}, where wr is the reverse of
string w, for some left-subsequential function f ′.
Equivalently, the right-subsequential functions are
those that can be described by a SFST reading and
writing strings right-to-left.

In terms of QFLFP, when the input signature
I contains the predecessor function p we obtain
left-subsequential functions. As is perhaps clear
from the above discussion, if we instead use an
identical signature with a successor function s, we
obtain the right-subsequential functions.

Crucially, inclusion of QFLFP in one of the
subsequential classes relies on using either s or p,
but not both. Consider the following transduction
defined with a signature including both s and p.4

(16) a. a′(x) def= a(x) ∧ ( ⋊ (p(x))→
[lfp b(y) ∨A(s(y))](x))

b. b′(x) def= b(x)∧
[lfp b(y) ∨A(p(y))](x)

c. c′(x)def= (a(x) ∧ ⋊(p(x))∧
¬[lfp b(y) ∨A(s(y))](x))

∨
(b(x)∧
¬[lfp b(y) ∨A(p(y))](x))

This transduction takes strings of a’s and b’s and
outputs as a c 1) the first a if and only if there
are no b’s in a string; or 2) the first b in the
string. The definition of c′(x) in (16-c) out-
puts a c for an input initial a that is not fol-
lowed by a b (the first disjunct; a(x) ∧ ⋊(p(x)) ∧
¬[lfp b(y) ∨ A(s(y))](x)) or an input b that is
not preceded by another b (the second disjunct;
b(x) ∧ ¬[lfp b(y) ∨ A(p(y))](x)). The defini-
tions in (16-a) and (16-b) output a’s and b’s, re-
spectively, for any a and b that does not meet the
conditions in (16-c) for outputting a c. A (nonde-
terministic) FST for this function is given in Fig.
13; examples of the mapping are given below in
(17).

4We thank Nate Koser for this example.

0

1

2 3

a ∶ a

a ∶ a b ∶ b

a ∶ c

a ∶ a b ∶ c

Figure 13: A properly regular function definable using
QFLFP with both successor s and predecessor p func-
tions.

(17) aaaaaa↦ caaaaa
aababa↦ aacaba

It can be shown that this function is not subse-
quential, and thus there is no equivalent SFST for
the FST in Fig 13. The reason is made clear by the
definition in (16): the transduction looks ahead to
the right to check if an initial a should be output
as a c, but looks behind to the left to check if a b is
the first b. These cannot both be accomplished by
a deterministic FST that reads either right-to-left
or left-to-right. Thus, restricting the signature to
either p or s is crucial to capturing the behavior of
subsequential FSTs.

7 Discussion

We have introduced a class of functions called
QFLFP that are defined as graph interpretations
using quantifier-free first order logic formulas aug-
mented with a least fixed point operator. In this
section we discuss some of the implications of us-
ing this class to model phonological processes and
highlight a few important areas of future work.

One of the main advantages of such logical
characterizations of phonological processes is that
they enable a unified approach to both linear and
non-linear representations. The graphs used to
represent strings in this approach can be extended
to represent additional structure used in phono-
logical theory such as autosegmental represen-
tations and feature geometry (Goldsmith, 1976;
Clements, 1985), syllable constituents (Selkirk,
1984), or metrical structure (Hayes, 1995). This
flexibility allows us to directly apply the notion
of subsequentiality to other types of representa-
tions, which in turn enables more direct com-
parison among types of phonological phenomena
and theories of phonological representation, as we
can change the models to accommodate the added



structure but maintain the restrictions on the log-
ical formalism (see Chandlee and Jardine, 2019,
for an example). This was not as straightforward
with finite-state automata.

We have argued that the QFLFP class provides
an attractive fit to the observed typology of phono-
logical functions, capturing both local and long-
distance phenomena, which the previously defined
ISL and OSL classes cannot do without introduc-
ing the mechanism of string markup. Compared to
the subsequential functions, QFLFP can describe
functions dependent on even/odd parity in a local
way—such as assigning iterative stress—but not
in an unbounded way (e.g., identify every other
vowel regardless of how many consonants inter-
vene). The subsequential functions can describe
such unbounded even/odd phenomena, which are
hypothesized to not exist in phonology. In this way
QFLFP appears to be a better fit to the typology
compared to the already restrictive subsequential
functions.

Future work will aim to identify the limits of
QFLFP and the kinds of phonological processes
and process interactions that it cannot describe.
Such cases will point to the ways the class of func-
tions can be extended and/or modified to provide
an even better fit to the range of attested phenom-
ena without including logically possible but unat-
tested patterns. For example, what is the expres-
sivity of QFLFP when two-place predicates (see
Koser et al., 2019) or embedded lfp operators are
allowed?

There are also several theoretical questions left
to be addressed. Are QFLFP functions closed
under composition? We conjecture that they are
not, as per the discussion of the OSL function in
Fig. 11 that we conjecture not to be QFLFP.
The reason is that functions in which lfp opera-
tors are embedded in other lfp operators appear
to be strictly more expressive than those which
are not. We also leave an abstract characteriza-
tion of the QFLFP functions to future work. Such
a characterization would lead to a definitive an-
swer to the conjecture that SUBSEQ is a proper
superset of QFLFP, as well as whether or not
QFLFP is closed under composition. Finally, this
paper has considered QFLFP defined over string
signatures with only a single ordering function p.
The same logic defined over string signatures de-
fined with both p and the successor function s
will almost certainly be more expressive, but how

much more expressive is an interesting question
for future work.

8 Conclusion

QFLFP graph interpretations combine the re-
strictiveness of quantifier-free first order logic
with an operator that can recursively reference
the output structure. This allows us to model
phenomena beyond the reach of the ISL func-
tions, including iterative spreading processes and
long-distance agreement. This class of functions
appears to cross-cut several subregular function
classes that have previously been applied to the
modeling of phonological processes. Because it
is still a subset of the subsequential functions,
however, it is learnable from positive data. This
combination of desirable properties incidates that
QFLFP is an important step toward the goal of
identifying and understanding the computational
nature of phonological processes.

References
Benjamin Ao. 1991. Kikongo nasal harmony and

context-sensitive underspecification. Linguistic In-
quiry, 22(2):193–196.

Jane Chandlee. 2014. Strictly Local Phonological Pro-
cesses. Ph.D. thesis, University of Delaware.

Jane Chandlee, Rémi Eyraud, and Jeffrey Heinz. 2015.
Output strictly local functions. In Proceedings of the
14th Meeting on the Mathematics of Language (MoL
2015), pages 112–125, Chicago, USA. Association
for Computational Linguistics.

Jane Chandlee and Jeffrey Heinz. 2012. Bounded
copying is subsequential: implications for metathe-
sis and reduplication. In Proceedings of SIGMOR-
PHON 12.

Jane Chandlee and Jeffrey Heinz. 2018. Strict locality
and phonological maps. LI, 49:23–60.

Jane Chandlee and Adam Jardine. 2019. Autosegmen-
tal strictly local functions. Transactions of the Asso-
ciation for Computational Linguistics, 7:157–168.

Jane Chandlee and Steven Lindell. in prep. A log-
ical characterization of strictly local functions. In
Jeffrey Heinz, editor, Doing Computational Phonol-
ogy. OUP.

G. N. Clements. 1985. The geometry of phonological
features. Phonology Yearbook, 2:225–252.

Joost Engelfriet and Hendrik Jan Hoogeboom. 2001.
MSO definable string transductions and two-way
finite-state transducers. ACM Transations on Com-
putational Logic, 2:216–254.



Emmanual Filiot. 2015. Logic-automata connections
for transformations. In Logic and Its Applications
(ICLA), pages 30–57. Springer.

Emmanuel Filiot and Pierre-Alain Reynier. 2016.
Transducers, logic, and algebra for functions of fi-
nite words. ACM SIGLOG News, 3(3):4–19.

John Goldsmith. 1976. Autosegmental Phonology.
Ph.D. thesis, Massachussets Institute of Technology.

Bruce Hayes. 1995. Metrical stress theory. Chicago:
The University of Chicago Press.

Jeffrey Heinz and Regine Lai. 2013. Vowel harmony
and subsequentiality. In Proceedings of the 13th
Meeting on the Mathematics of Language (MoL 13),
pages 52–63.

Mans Hulden. 2009. Finite-State Machine Construc-
tion Methods and Algorithms for Phonology and
Morphology. Ph.D. thesis, University of Arizona.

Adam Jardine. 2016. Locality and non-linear repre-
sentations in tonal phonology. Ph.D. thesis, Univer-
sity of Delaware.

R.M. Kaplan and M. Kay. 1994. Regular models of
phonological rule systems. Computational Linguis-
tics, (20):371–387.

Nathan Koser, Christopher Oakden, and Adam Jardine.
2019. Tone association and output locality in non-
linear structures. In Supplemental proceedings of
the 2018 Annual Meeting on Phonology. Linguistics
Society of America.

Leonid Libkin. 2004. Elements of Finite Model The-
ory. Berlin: Springer-Verlag.

Huan Luo. 2017. Long-distance consonant agreement
and subsequentiality. Glossa: A Journal of General
Linguistics, 2(1):52.

Mehryar Mohri. 1997. Finite-state transducers in lan-
guage and speech processing. Computational Lin-
guistics, 23(2):269–311.

David Odden. 1994. Adjacency parameters in phonol-
ogy. Language, 70(2):289–330.

J. Oncina, J. Garcı́a, and E. Vidal. 1993. Learning sub-
sequential transducers for pattern recognition inter-
pretation tasks. IEEE Transactions on Pattern Anal-
ysis and Machine Intelligence, (15:5):448–457.

Farid M. Onn. 1980. Aspects of Malay Phonology
and Morphology: A Generative Approach. Kuala
Lumpur: Universiti Kebangsaan Malaysia.

Amanda Payne. 2017. All dissimilation is compu-
tationally subsequential. Language: Phonological
Analysis, 93(4):e353–e371.

Marcel Paul Schützenberger. 1977. Sur une variante
des fonctions séquentielles. Theoretical Computer
Science, 4:47–57.

Elisabeth Selkirk. 1984. On the major class features
and syllable theory. In Morris Halle, Mark Aronoff,
and R.T. Oehrle, editors, Language sound struc-
ture: Studies in phonology. Cambridge, Mass.: MIT
Press.


