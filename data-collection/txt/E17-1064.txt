



















































Tackling Error Propagation through Reinforcement Learning: A Case of Greedy Dependency Parsing


Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics: Volume 1, Long Papers, pages 677–687,
Valencia, Spain, April 3-7, 2017. c©2017 Association for Computational Linguistics

Tackling Error Propagation through Reinforcement Learning:
A Case of Greedy Dependency Parsing

Minh Lê
CLTL

Vrije Universiteit Amsterdam
Amsterdam, The Netherlands

m.n.le@vu.nl

Antske Fokkens
CLTL

Vrije Universiteit Amsterdam
Amsterdam, The Netherlands
antske.fokkens@vu.nl

Abstract

Error propagation is a common problem
in NLP. Reinforcement learning explores
erroneous states during training and can
therefore be more robust when mistakes
are made early in a process. In this paper,
we apply reinforcement learning to greedy
dependency parsing which is known to
suffer from error propagation. Reinforce-
ment learning improves accuracy of both
labeled and unlabeled dependencies of
the Stanford Neural Dependency Parser,
a high performance greedy parser, while
maintaining its efficiency. We investigate
the portion of errors which are the result
of error propagation and confirm that rein-
forcement learning reduces the occurrence
of error propagation.

1 Introduction

Error propagation is a common problem for many
NLP tasks (Song et al., 2012; Quirk and Corston-
Oliver, 2006; Han et al., 2013; Gildea and Palmer,
2002; Yang and Cardie, 2013). It can occur when
NLP tools applied early on in a pipeline make
mistakes that have negative impact on higher-level
tasks further down the pipeline. It can also occur
within the application of a specific task, when se-
quential decisions are taken and errors made early
in the process affect decisions made later on.

When reinforcement learning is applied, a sys-
tem actively tries out different sequences of ac-
tions. Most of these sequences will contain some
errors. We hypothesize that a system trained in this
manner will be more robust and less susceptible to
error propagation.

We test our hypothesis by applying reinforce-
ment learning to greedy transition-based parsers
(Yamada and Matsumoto, 2003; Nivre, 2004),

which have been popular because of superior effi-
ciency and accuracy nearing state-of-the-art. They
are also known to suffer from error propagation.
Because they work by carrying out a sequence of
actions without reconsideration, an erroneous ac-
tion can exert a negative effect on all subsequent
decisions. By rendering correct parses unreach-
able or promoting incorrect features, the first error
induces the second error and so on. McDonald
and Nivre (2007) argue that the observed negative
correlation between parsing accuracy and sentence
length indicates error propagation is at work.

We compare reinforcement learning to super-
vised learning on Chen and Manning (2014)’s
parser. This high performance parser is available
as open source. It does not make use of alterna-
tive strategies for tackling error propagation and
thus provides a clean experimental setup to test
our hypothesis. Reinforcement learning increased
both unlabeled and labeled accuracy on the Penn
TreeBank and German part of SPMRL (Seddah
et al., 2014). This outcome shows that reinforce-
ment learning has a positive effect, but does not yet
prove that this is indeed the result of reduced er-
ror propagation. We therefore designed an exper-
iment which identified which errors are the result
of error propagation. We found that around 50%
of avoided errors were cases of error propagation
in our best arc-standard system. Considering that
27% of the original errors were caused by error
propagation, this result confirms our hypothesis.

This paper provides the following contributions:

1. We introduce Approximate Policy Gradient
(APG), a new algorithm that is suited for de-
pendency parsing and other structured pre-
diction problems.

2. We show that this algorithm improves the ac-
curacy of a high-performance greedy parser.

677



3. We design an experiment for analyzing error
propagation in parsing.

4. We confirm our hypothesis that reinforce-
ment learning reduces error propagation.

To our knowledge, this paper is the first to ex-
perimentally show that reinforcement learning can
reduce error propagation in NLP.

The rest of this paper is structured as follows.
We discuss related work in Section 2. This is fol-
lowed by a description of the parsers used in our
experiments in Section 3. Section 4 outlines our
experimental setup and presents our results. The
error propagation experiment and its outcome are
described in Section 5. Finally, we conclude and
discuss future research in Section 6.

2 Related Work

In this section, we address related work on depen-
dency parsing, including alternative approaches
for reducing error propagation, and reinforcement
learning.

2.1 Dependency Parsing

We use Chen and Manning (2014)’s parser as a
basis for our experiments. Their parser is open-
source and has served as a reference point for
many recent publications (Dyer et al., 2015; Weiss
et al., 2015; Alberti et al., 2015; Honnibal and
Johnson, 2015, among others). They provide an
efficient neural network that learns dense vec-
tor representations of words, PoS-tags and depen-
dency labels. This small set of features makes their
parser significantly more efficient than other popu-
lar parsers, such as the Malt (Nivre et al., 2007) or
MST (McDonald et al., 2005) parser while obtain-
ing higher accuracy. They acknowledge the error
propagation problem of greedy parsers, but leave
addressing this through (e.g.) beam search for fu-
ture work.

Dyer et al. (2015) introduce an approach that
uses Long Short-Term Memory (LSTM). Their
parser still works incrementally and the number of
required operations grows linearly with the length
of the sentence, but it uses the complete buffer,
stack and history of parsing decisions, giving the
model access to global information. Weiss et al.
(2015) introduce several improvements on Chen
and Manning (2014)’s parser. Most importantly,
they put a globally-trained perceptron layer in-
stead of a softmax output layer. Their model uses

smaller embeddings, rectified linear instead of cu-
bic activation function, and two hidden layers in-
stead of one. They furthermore apply an aver-
aged stochastic gradient descent (ASGD) learn-
ing scheme. In addition, they apply beam search
and increase training data by using unlabeled data
through the tri-training approach introduced by Li
et al. (2014), which leads to further improvements.

Kiperwasser and Goldberg (2016) introduce a
new way to represent features using a bidirectional
LSTM and improve the results of a greedy parser.
Andor et al. (2016) present a mathematical proof
that globally normalized models are more expres-
sive than locally normalized counterparts and pro-
pose to use global normalization with beam search
at both training and testing.

Our approach differs from all of the work men-
tioned above, in that it manages to improve results
of Chen and Manning (2014) without changing the
architecture of the model nor the input represen-
tation. The only substantial difference lies in the
way the model is trained. In this respect, our re-
search is most similar to training approaches us-
ing dynamic oracles (Goldberg and Nivre, 2012).
Traditional static oracles can generate only one se-
quence of actions per sentence. A dynamic ora-
cle gives all trajectories leading to the best pos-
sible result from every valid parse configuration.
They can therefore be used to generate more train-
ing sequences including those containing errors.
A drawback of this approach is that dynamic or-
acles have to be developed specifically for indi-
vidual transition systems (e.g. arc-standard, arc-
eager). Therefore, a large number of dynamic or-
acles have been developed in recent years (Gold-
berg and Nivre, 2012; Goldberg and Nivre, 2013;
Goldberg et al., 2014; Gomez-Rodriguez et al.,
2014; Björkelund and Nivre, 2015). In contrast,
the reinforcement learning approach proposed in
this paper is more general and can be applied to a
variety of systems.

Zhang and Chan (2009) present the only study
we are aware of that also uses reinforcement learn-
ing for dependency parsing. They compare their
results to Nivre et al. (2006b) using the same fea-
tures, but they also change the model and apply
beam search. It is thus unclear to what extend their
improvements are due to reinforcement learning.

Even though most approaches mentioned above
improve the results reported by Chen and Man-
ning (2014) and even more impressive results on

678



dependency parsing have been achieved since (no-
tably, Andor et al. (2016)), Chen and Manning’s
parser provides a better baseline for our purposes.
We aim at investigating the influence of reinforce-
ment learning on error propagation and want to
test this in a clean environment, where reinforce-
ment learning does not interfere with other meth-
ods that address the same problem.

2.2 Reinforcement Learning

Reinforcement learning has been applied to sev-
eral NLP tasks with success, e.g. agenda-based
parsing (Jiang et al., 2012), semantic parsing (Be-
rant and Liang, 2015) and simultaneous machine
translation (Grissom II et al., 2014). To our knowl-
edge, however, none of these studies investigated
the influence of reinforcement learning on error
propagation.

Learning to Search (L2S) is probably the most
prominent line of research that applies reinforce-
ment learning (more precisely, imitation learn-
ing) to NLP. Various algorithms, e.g. SEARN
(Daumé III et al., 2009) and DAgger (Ross et
al., 2011), have been developed sharing common
high-level steps: a roll-in policy is executed to
generate training states from which a roll-out pol-
icy is used to estimate the loss of certain actions.
The concrete instantiation differs from one algo-
rithm to another with choices including a referent
policy (static or dynamic oracle), learned policy,
or a mixture of the two. Early work in L2S fo-
cused on reducing reinforcement learning into bi-
nary classification (Daumé III et al., 2009), but
newer systems favored regressors for efficiency
(Chang et al., 2015, Supplementary material, Sec-
tion B). Our algorithm APG is simpler than L2S in
that it uses only one policy (pre-trained with stan-
dard supervised learning) and applies the existing
classifier directly without reduction (the only re-
quirement is that it is probabilistic). Nevertheless,
our results demonstrate its effectiveness.

APG belongs to the family of policy gradient al-
gorithms (Sutton et al., 1999), i.e. it maximizes the
expected reward directly by following its gradient
w.r.t. the parameters. The advantage of using a
policy gradient algorithm in NLP is that gradient-
based optimization is already widely used. REIN-
FORCE (Williams, 1992; Ranzato et al., 2016) is
a widely-used policy gradient algorithm but it is
also well-known for suffering from high variance
(Sutton et al., 1999).

We directly compare our approach to REIN-
FORCE, whereas we leave a direct comparison
to L2S for future work. Our experiments show
that our algorithm results in lower variance and
achieves better performance than REINFORCE.

Recent work addresses the approximation of re-
inforcement learning gradient in the context of
machine translation. Shen et al. (2016)’s algo-
rithm is roughly equivalent to the combination
of an oracle and random sampling. Their ap-
proach differs from ours, because it does not retain
memory across iteration as in our best-performing
model (see Section 3.4).

2.3 Reinforcement and error propagation

As mentioned above, previous work that applied
reinforcement learning to NLP has, to our knowl-
edge, not shown that it improved results by reduc-
ing error propagation.

Work on identifying the impact of error prop-
agation in parsing is rare, Ng and Curran (2015)
being a notable exception. They provide a detailed
error analysis for parsing and classify which kind
of parsing errors are involved with error propa-
gation. There are four main differences between
their approaches and ours. First, Ng and Curran
correct arcs in the tree and our algorithm corrects
decisions of the parsing algorithm. Second, our
approach distinguishes between cases where one
erroneous action deterministically leads to multi-
ple erroneous arcs and cases where an erroneous
action leads to conditions that indirectly result in
further errors (see Section 5.1 for a detailed expla-
nation). Third, Ng and Curran’s algorithm corrects
all erroneous arcs that are the same type of pars-
ing error and point out that they cannot examine
the interaction between multiple errors of the same
type in a sentence. Our algorithm corrects errors
incrementally and therefore avoids this issue. Fi-
nally, the classification and analysis presented in
Ng and Curran (2015) are more extensive and de-
tailed than ours. Our algorithm can, however, eas-
ily be extended to perform similar analysis. Over-
all, Ng and Curran’s approach for error analysis
and ours are complementary. Combining them and
applying them to various systems would form an
interesting direction for future work.

3 A Reinforced Greedy Parser

This section describes the systems used in our ex-
periments. We first describe the arc-standard al-

679



Step Transition Stack Buffer Arcs
0 <ROOT> waves hit ... Big Board ∅
1 SHIFT <ROOT> waves hit stocks ... Big Board ∅
2 SHIFT <ROOT> waves hit stocks themselves ... Big Board ∅
3 LEFTnsubj <ROOT> hit stocks themselves ... Big Board A1 = { hit

nsubj−−−→ waves}
4 SHIFT <ROOT> hit stocks themselves on the Big Board A1
5 SHIFT <ROOT> hit stocks themselves on the Big Board A1
6 RIGHTdep <ROOT> hit stocks on the Big Board A2 = A1∪

{ stock
dep−−→ themselves}

7 RIGHTdobj <ROOT> hit on the Big Board A3 = A2∪ { hit dobj−−−→ stock}

Table 1: Parsing oracle walk-through

gorithm, because familiarity with it helps to un-
derstand our error propagation analysis. Next, we
briefly point out the main differences between the
arc-standard algorithm and the alternative algo-
rithms we experimented with (arc-eager and swap-
standard). We then outline the traditional and our
novel machine learning approaches. The features
we used are identical to those described in Chen
and Manning (2014). We are not aware of research
identifying the best feature for a neural parser with
arc-eager or swap-standard so we use the same
features for all transition systems.

3.1 Transition-Based Dependency Parsing

In an arc-standard system (Nivre, 2004), a parsing
configuration consists of a triple 〈Σ, β, A〉, where
Σ is a stack, β is a buffer containing the remain-
ing input tokens and A are the dependency arcs
that are created during parsing process. At initi-
ation, the stack contains only the root symbol (Σ
= [ROOT]), the buffer contains the tokens of the
sentence (β = [w1, ..., wn]) and the set of arcs is
empty (A = ∅).

The arc-standard system supports three transi-
tions. When σ1 is the top element and σ2 the sec-
ond element on the stack, and β1 the first element
of the buffer:1

LEFTl adds an arc σ1
l−→ σ2 toA and removes σ2

from the stack.
RIGHTl adds an arc σ2

l−→ σ1 to A and removes
σ1 from the stack.

SHIFT moves β1 to the stack.

When the buffer is empty, the stack contains
only the root symbol and A contains a parse tree,
the configuration is completed. For a sentence of

1Naturally, the transitions LEFTl and RIGHTl can only
take place if the stack contains at least two elements and
SHIFT can only occur when there is at least one element on
the buffer.

<ROOT> waves hit stocks themselves on the Big Board

Figure 1: Correct dependencies for a simplified
example from Penn TreeBank

Nw tokens, a full parse takes 2Nw + 1 transitions
to complete (including the initiation). Figure 1
provides the gold parse tree for a (simplified) ex-
ample from the Penn Treebank. The steps taken
to create the dependencies between the sentence’s
head word hit and its subject and direct object are
provided in Table 1.

To demonstrate that reinforcement learning can
train different systems, we also carried out ex-
periments with arc-eager (Nivre, 2003) and swap-
standard (Nivre, 2009). Arc-eager is designed for
incremental parsing and included in the popular
MaltParser (Nivre et al., 2006a). Swap-standard is
a simple and effective solution to unprojective de-
pendency trees. Because arc-eager does not guar-
antee complete parse trees, we used a variation
that employs an action called UNSHIFT to re-
sume processing of tokens that would otherwise
not be attached to a head (Nivre and Fernández-
González, 2014).

3.2 Training with a Static Oracle

In transition-based dependency parsing, it is com-
mon to convert a dependency treebank D 3 (x, y)
into a collection of input features s ∈ S and cor-
responding gold-standard actions a ∈ A for train-
ing, using a static oracle O. In Chen and Man-
ning (2014), a neural network works as a function
mapping input features to probabilities of actions:
fNN : S × A → [0, 1]. The neural network is
trained to minimize negative log-likelihood loss

680



on the converted treebank:

L =
∑

(x,y)∈D

∑
(s,a)∈O(x,y)

− log fNN (s, a; θ) (1)

3.3 Reinforcement Learning

Following Maes et al. (2009), we view transition-
based dependency parsing as a deterministic
Markov Decision Process. The problem is sum-
marized by a tuple 〈S,A, T , r〉 where S is the set
of all possible states, A contains all possible ac-
tions, T is a mapping S×A → S called transition
function and r : S ×A → R is a reward function.

A state corresponds to a configuration and is
summarized into input features. Possible actions
are defined for each transition system described in
Section 3.1. We keep the training approach simple
by using only one reward r(ȳ) at the end of each
parse.

Given this framework, a stochastic policy
guides our parser by mapping each state to a prob-
abilistic distribution of actions. During training,
we use function fNN described in Section 3.2 as a
stochastic policy. At test time, actions are chosen
in a greedy fashion following existing literature.
We aim at finding the policy that maximizes the
expected reward (or, equivalently, minimizes the
expected loss) on the training dataset:

maximize η =
∑

(x,y)∈D

∑
a1:m∼f

r(ȳ)
m∏

i=1

fNN (si, ai; θ)

(2)
where a1:m is a sequence of actions obtained by
following policy fNN until termination and s1:m
are corresponding states (with sm+1 being the ter-
mination state).

3.4 Approximate Policy Gradient

Gradient ascent can be used to maximize the ex-
pected reward in Equation 2. The gradient of ex-
pected reward w.r.t. parameters is (note that dz =
zd(log z)):

∂η

∂θ
=

∑
(x,y)∈D

∑
a1:m∼fNN

r(ȳ)
m∏

i=1

fNN (si, ai)

m∑
i=1

∂

∂θ
log fNN (si, ai; θ)

(3)

Because of the exponential number of possible
trajectories, calculating the gradient exactly is not

possible. We propose to replace it by an approxi-
mation (hence the name Approximate Policy Gra-
dient) by summing over a small subset U of trajec-
tories. Following common practice, we also use a
baseline b(y) that only depends on the correct de-
pendency tree. The parameter is then updated by
following the approximate gradient:

∆θ ∝
∑

(x,y)∈D

∑
a1:m∈U

(r(ȳ)− b(y))
m∏

i=1

fNN (si, ai)

m∑
i=1

∂

∂θ
log fNN (si, ai; θ)

(4)

Instead of sampling one trajectory at a time as in
REINFORCE, Equation 4 has the advantage that
sampling over multiple trajectories could lead to
more stable training and higher performance. To
achieve that goal, the choice of U is critical. We
empirically evaluate three strategies:

RL-ORACLE: only includes the oracle transition
sequence.

RL-RANDOM: randomly samples k distinct tra-
jectories at each iteration. Every action is
sampled according to fNN , i.e. preferring tra-
jectories for which the current policy assigns
higher probability.

RL-MEMORY: samples randomly as the previ-
ous method but retains k trajectories with
highest rewards across iterations in a sepa-
rate memory. Trajectories are “forgotten” (re-
moved) randomly with probability ρ before
each iteration.2

Intuitively, trajectories that are more likely and
produce higher rewards are better training exam-
ples. It follows from Equation 3 that they also
bear bigger weight on the true gradient. This is the
rationale behind RL-RANDOM and RL-ORACLE.
For a suboptimal parser, however, these objec-
tives sometimes work against each other. RL-
MEMORY was designed to find the right balance
between them. It is furthermore important that the
parser is pretrained to ensure good samples. Algo-
rithm 1 illustrates the procedure of training a de-
pendency parser using the proposed algorithms.

2We assign a random number (drawn uniformly from
[0, 1]) to each trajectory in memory and remove those as-
signed a number less than ρ.

681



MemorySeqs← ∅;
foreach training batch b do

foreach sentence s ∈ b do
OracleSeq ← Oracle(s);
SystemSeqs← (sample k parsing
transition sequences for s);

if RL-Oracle then
ComputeGradients(OracleSeq);

else if RL-Random then
ComputeGradients(SystemSeqs);

else if RL-Memory then
m←MemorySeqs[s];
foreach q ∈ m do

if RandomNumber() < ρ then
Remove q from m;

end
end
foreach q ∈ SystemSeqs do

if |m| < k then
Insert q into m;

else
p← (sequence with
smallest reward in m);

if reward(q) > reward(p)
then

Replace p by q in m;
end

end
ComputeGradients(m);

end
Perform one gradient descent step;

end
Algorithm 1: Training a dependency parser with
approximate policy gradient.

4 Reinforcement Learning Experiments

We first train a parser using a supervised learning
procedure and then improve its performance using
APG. We empirically tested that training a second
time with supervised learning has little to no effect
on performance.

4.1 Experimental Setup

We use PENN Treebank 3 with standard split
(training, development and test set) for our exper-
iments with arg-standard and arg-eager. Because
the swap-standard parser is mainly suited for non-
projective structures, which are rare in the PENN
Treebank, we evaluate this parser on the German

Arc- Arc- Swap-
standard eager standard

UAS LAS UAS LAS UAS LAS
SL 91.3 89.4 88.3 85.8 84.3 81.3
RE 91.9 90.2 89.7 87.2 87.5 84.4
RL-O 91.8 90.2 88.9 86.5 86.8 83.9
RL-R 92.2 90.6 89.4 87.0 87.5 84.5
RL-M 92.2 90.6 89.8 87.4 87.6 84.6

Table 2: Comparing training methods on PENN
Treebank (arc-standard and arc-eager) and Ger-
man part of SPMRL-2014 (swap-standard).

section of the SPMRL dataset. For PENN Tree-
bank, we follow Chen and Manning’s preprocess-
ing steps. We also use their pretrained model3 for
arc-standard and train our own models in similar
settings for other transition systems.

For reinforcement learning, we use AdaGrad for
optimization. We do not use dropout because we
observed that it destablized the training process.
The reward r(ȳ) is the number of correct labeled
arcs (i.e. LAS multiplied by number of tokens).4

The baseline is fixed to half the number of tokens
(corresponding to a 0.5 LAS score). As train-
ing takes a lot of time, we tried only few values
of hyperparameters on the development set and
picked k = 8 and ρ = 0.01. 1,000 updates were
performed (except for REINFORCE which was
trained for 8,000 updates) with each training batch
contains 512 randomly selected sentences. The
Stanford dependency scorer5 was used for evalu-
ation.

4.2 Effectiveness of Reinforcement Learning
Table 2 displays the performance of different ap-
proaches to training dependency parsers. Al-
though we used Chen and Manning (2014)’s pre-
trained model and Stanford open-source software,
the results of our baseline are slightly worse than
what is reported in their paper. This could be due
to minor differences in settings and does not affect
our conclusions.

Across transition systems and two languages,
APG outperforms supervised learning, verifying
our hypothesis. Moreover, it is not simply be-
cause the learners are exposed to more examples
than their supervised counterparts. RL-ORACLE

3We use PTB_Stanford_params.txt.gz down-
loaded from http://nlp.stanford.edu/software/
nndep.shtml on December 30th, 2015.

4Punctuation is not taken into account, following Chen
and Manning (2014).

5Downloaded from http://nlp.stanford.edu/
software/lex-parser.shtml.

682



is trained on exactly the same examples as the
standard supervised learning system (SL), yet it
is consistently superior. This can only be ex-
plained by the superiority of the reinforcement
learning objective function compared to negative
log-likelihood.

The results support our hypothesis that APG is
better than REINFORCE (abbreviated as RE in
Table 2) as RL-MEMORY always outperforms the
classical algorithm and the other two heuristics do
in two out of three cases. The usefulness of train-
ing examples that contain errors is evident through
the better performance of RL-RANDOM and RL-
MEMORY in comparison to RL-ORACLE.

Table 3 shows the importance of samples for
RL-RANDOM. The algorithm hurts performance
when only one sample is used whereas training
with two or more samples improves the results.
The difference cannot be explained by the total
number of observed samples because one-sample
training is still worse after 8,000 iterations com-
pared to a sample size of 8 after 1,000 itera-
tions. The benefit of added samples is twofold: in-
creased performance and decreased variance. Be-
cause these benefits saturate quickly, we did not
test sample sizes beyond 32.

Dev Test Test std.
UAS LAS UAS LAS UAS LAS

SL 91.5 89.6 91.3 89.4 - -
RE 92.1∗ 90.4∗ 91.9∗ 90.2∗ 0.04 0.05
1 91.2∗ 89.1∗ 91.0∗ 88.9∗ 0.12 0.15
2 91.8∗ 90.0∗ 91.6∗ 89.9∗ 0.09 0.09
4 92.2∗ 90.5∗ 92.0∗ 90.4∗ 0.09 0.08
8 92.4∗ 90.8∗ 92.2∗ 90.6∗ 0.03 0.05

16 92.4 90.8 92.2 90.6 - -
32 92.4 90.8 92.3 90.6 - -

Table 3: Parsing accuracy of RL-RANDOM (arc-
standard) with different sample sizes compared to
supervised learning (SL) and REINFORCE (RE).
∗: significantly different from SL with p < 0.001

5 Error Propagation Experiment

We hypothesized that reinforcement learning
avoids error propagation. In this section, we de-
scribe our algorithm and the experiment that iden-
tifies error propagation in the arc-standard parsers.

5.1 Error Propagation

Section 3.1 explained that a transition-based
parser goes through the sentence incrementally
and must select a transition from [SHIFT, LEFTl,

<ROOT> waves hit stocks themselves on the Big Board

<ROOT> waves hit stocks themselves on the Big Board

(A)

(B)
<ROOT> waves hit stocks themselves on the Big Board

(C)

Figure 2: Three dependency graphs: gold (A), arc
errors caused by one decision error (B) and arc er-
rors caused by multiple decision errors (C).

RIGHTl] at each step. We use the term arc error
to refer to an erroneous arc in the resulting tree.
The term decision error refers to a transition that
leads to a loss in parsing accuracy. Decision er-
rors in the parsing process lead to one or more arc
errors in the resulting tree. There are two ways
in which a single decision error may lead to mul-
tiple arc errors. First, the decision can determin-
istically lead to more than one arc error, because
(e.g.) an erroneously formed arc also blocks other
correct arcs. Second, an erroneous parse decision
changes some of the features that the model uses
for future decisions and these changes can lead to
further (decision) errors down the road.

We illustrate both cases using two incorrect
derivations presented in Figure 2. The original
gold tree is repeated in (A). The dependency graph
in Figure 2 (B) contains three erroneous depen-
dency arcs (indicated by dashed arrows). The first
error must have occurred when the parser executed
RIGHTamod creating the arc Big → Board. After
this error, it is impossible to create the correct re-
lations on→ Board and Board→ the. The wrong
arcs Big→ the and on→ Big are thus all the result
of a single decision error.

Figure 2 (C) represents the dependency graph
that is actually produced by our parser.6 It contains
two erroneous arcs: hit → themselves and them-
selves→ on. Table 4 provides a possible sequence
of steps that led to this derivation, starting from
the moment stocks was added to the stack (Step
4). The first error is introduced in Step 5’, where
hit combines with stocks before stocks has picked
up its dependent themselves. At that point, them-
selves can no longer be combined with the right
head. The proposition on, on the other hand, can

6The example is a fragment of a more complex sentence
consisting of 33 tokens. The parser does provide the correct
output when is analyzes this sequence in isolation.

683



Step Transition Stack Buffer Arcs
4 SHIFT <ROOT> hit stocks themselves on the Big Board A1
5’ RIGHTdobj <ROOT> hit themselves on the Big Board A2 = A1∪

{hit
dobj−−−→ stock}

6’ SHIFT <ROOT> hit themselves on the Big Board A2
7’ SHIFT <ROOT> hit themselves on the Big Board A2
...
10’ SHIFT <ROOT> hit themselves on the Big Board A2
11’ LEFTnn <ROOT> hit themselves on the Board A3 = A2∪

{Board nn−→ Big}
12’ LEFTdet <ROOT> hit themselves on Board A4 = A3∪

{Board det−−→ the}
13’ RIGHTpobj <ROOT> hit themselves on A5 = A4∪

{on
pobj−−−→ Board}

14’ RIGHTdep <ROOT> hit themselves A6 = A5∪
{themselves

dep−−→on}

Table 4: Possible parsing walk-through with error

still be combined with the correct head. This error
is introduced in Step 7’, where the parser moves
on to the stack rather than creating an arc from hit
to themselves.7 There are thus two decision er-
rors that lead to the arc errors in Figure 2 (C). The
second decision error can, however, be caused in-
directly by the first error. If a decision error causes
additional decision errors later in the parsing pro-
cess, we talk of error propagation. This cannot be
known just by looking at the derivation.

5.2 Examining the impact of decision errors
We examine the impact of individual decision er-
rors on the overall parse results in our test set by
combining a dynamic oracle and a recursive func-
tion. We use a dynamic oracle based on Goldberg
et al. (2014) which gives us the overall loss at any
point during the derivation. The loss is equal to
the minimal number of arc errors that will have
been made once the parse is complete. We can
thus deduce how many arc errors are deterministi-
cally caused by a given decision error.

The propagation of decision errors cannot be
determined by simply examining the increase in
loss during the parsing process. We use a recur-
sive function to identify whether a particular parse
suffered from this. While parsing the sentence, we
register which decisions lead to an increase in loss.
We then recursively reparse the sentence correct-
ing one additional decision error during each run
until the parser produces the gold. If each erro-
neous decision has to be corrected in order to ar-
rive at the gold, we assume the decision errors are

7Note that technically, on can still become a dependent
of hit, but this can only happen if on becomes the head of
themselves which would also be an error.

SL RL-O RL-R RL-M
Total Loss 7069 6227 6042 6144
Dec. Errors 5177 4410 4345 4476
Err. Prop. 1399 1124 992 1035
New errors 411 432 403 400
Loss/error 1.37 1.41 1.39 1.37
Err. Prop. (%) 27.0 25.5 22.8 23.1

Table 5: Overview of average impact of decision
errors

independent of each other. If, on the other hand,
the correction of a specific decision also fixes other
decisions down the road, the original parse suffers
from error propagation.

The results are presented in Table 5. Total Loss
indicates the number of arc errors in the corpus,
Dec. Errors the number of decision errors and Err.
Prop. the number of decision errors that were the
result of error propagation. This number was ob-
tained by comparing the number of decision er-
rors in the original parse to the number of decision
errors that needed to be fixed to obtain the gold
parse. If less errors had to be fixed than originally
present, we counted the difference as error prop-
agation. Note that fixing errors sometimes leads
to new decision errors during the derivation. We
also counted the cases where more decision errors
needed to be fixed than were originally present and
report them in Table 5.8

8We ran an alternative analysis where we counted all cases
where fixing one decision error in the derivation reduced the
overall number of decision errors in the parse by more than
one. Under this alternative analysis, similar reductions in the
proportion of error propagation were observed for reinforce-
ment learning.

684



On average, decision errors deterministically
lead to more than one arc error in the resulting
parse tree. This remains stable across systems
(around 1.4 arc errors per decision error). We
furthermore observe that the proportion of deci-
sion errors that are the result of error propagation
has indeed reduced for all reinforcement learn-
ing models. Among the errors avoided by APG,
35.9% were propagated errors for RL-ORACLE,
48.9% for RL-RANDOM, and 51.9% for RL-
MEMORY. These percentages are all higher than
the proportion of propagated errors occurring in
the corpus parsed by SL (27%). This outcome
confirms our hypothesis that reinforcement learn-
ing is indeed more robust for making decisions in
imperfect environments and therefore reduces er-
ror propagation.

6 Conclusion

This paper introduced Approximate Policy Gra-
dient (APG), an efficient reinforcement learning
algorithm for NLP, and applied it to a high-
performance greedy dependency parser. We hy-
pothesized that reinforcement learning would be
more robust against error propagation and would
hence improve parsing accuracy.

To verify our hypothesis, we ran experiments
applying APG to three transition systems and two
languages. We furthermore introduced an exper-
iment to investigate which portion of errors were
the result of error propagation and compared the
output of standard supervised machine learning to
reinforcement learning. Our results showed that:
(a) reinforcement learning indeed improved pars-
ing accuracy and (b) propagated errors were over-
represented in the set of avoided errors, confirming
our hypothesis.

To our knowledge, this paper is the first to show
experimentally that reinforcement learning can re-
duce error propagation in an NLP task. This re-
sult was obtained by a straight-forward implemen-
tation of reinforcement learning. Furthermore, we
only applied reinforcement learning in the training
phase, leaving the original efficiency of the model
intact. Overall, we see the outcome of our exper-
iments as an important first step in exploring the
possibilities of reinforcement learning for tackling
error propagation.

Recent research on parsing has seen impressive
improvement during the last year achieving UAS
around 94% (Andor et al., 2016). This improve-

ment is partially due to other approaches that, at
least in theory, address error propagation, such as
beam search. Both the reinforcement learning al-
gorithm and the error propagation study we devel-
oped can be applied to other parsing approaches.
There are two (related) main questions to be ad-
dressed in future work in the domain of parsing.
The first addresses whether our method is comple-
mentary to alternative approaches and could also
improve the current state-of-the-art. The second
question would address the impact of various ap-
proaches on error propagation and the kind of er-
rors they manage to avoid (following Ng and Cur-
ran (2015)).

APG is general enough for other structured pre-
diction problems. We therefore plan to investigate
whether we can apply our approach to other NLP
tasks such as coreference resolution or semantic
role labeling and investigate if it can also reduce
error propagation for these tasks.

The source code of all experiments is pub-
licly available at https://bitbucket.org/
cltl/redep-java.

Acknowledgments

The research for this paper was supported by the
Netherlands Organisation for Scientific Research
(NWO) via the Spinoza-prize Vossen projects (SPI
30-673, 2014-2019) and the VENI project Read-
ing between the lines (VENI 275-89-029). Ex-
periments were carried out on the Dutch national
e-infrastructure with the support of SURF Co-
operative. We would like to thank our friends
and colleagues Piek Vossen, Roser Morante, Tom-
maso Caselli, Emiel van Miltenburg, and Ngoc Do
for many useful comments and discussions. We
would like to extend our thanks the anonymous
reviewers for their feedback which helped improv-
ing this paper. All remaining errors are our own.

References

Chris Alberti, David Weiss, Greg Coppola, and Slav
Petrov. 2015. Improved Transition-Based Parsing
and Tagging with Neural Networks. In EMNLP
2015, pages 1354–1359. ACL.

Daniel Andor, Chris Alberti, David Weiss, Aliak-
sei Severyn, Alessandro Presta, Kuzman Ganchev,
Slav Petrov, and Michael Collins. 2016. Glob-
ally Normalized Transition-Based Neural Networks.
arXiv.org, cs.CL.

685



Jonathan Berant and Percy Liang. 2015. Imitation
Learning of Agenda-based Semantic Parsers. TACL,
3:545–558.

Anders Björkelund and Joakim Nivre. 2015.
Non-Deterministic Oracles for Unrestricted Non-
Projective Transition-Based Dependency Parsing.
In IWPT 2015, pages 76–86. ACL.

Kai-Wei Chang, Akshay Krishnamurthy, Alekh Agar-
wal, Hal Daumé III, and John Langford. 2015.
Learning to search better than your teacher. In
ICML 2015.

Danqi Chen and Christopher Manning. 2014. A Fast
and Accurate Dependency Parser using Neural Net-
works. In EMNLP 2014, pages 740–750. ACL.

Hal Daumé III, John Langford, and Daniel Marcu.
2009. Search-based Structured Prediction. Machine
Learning, 75(3):297–325, 6.

Chris Dyer, Miguel Ballesteros, Wang Ling, Austin
Matthews, and Noah A Smith. 2015. Transition-
Based Dependency Parsing with Stack Long Short-
Term Memory. In ACL 2015, pages 334–343.

Daniel Gildea and Martha Palmer. 2002. The Neces-
sity of Parsing for Predicate Argument Recognition.
In ACL 2002, pages 239–246. ACL.

Yoav Goldberg and Joakim Nivre. 2012. A Dynamic
Oracle for Arc-Eager Dependency Parsing. In COL-
ING 2012, pages 959–976.

Yoav Goldberg and Joakim Nivre. 2013. Training De-
terministic Parsers with Non-Deterministic Oracles.
In TACL 2013, volume 1, pages 403–414.

Yoav Goldberg, Francesco Sartorio, and Giorgio Satta.
2014. A tabular method for dynamic oracles in
transition-based parsing. In TACL 2014, volume 2,
pages 119–130.

Carlos Gomez-Rodriguez, Francesco Sartorio, and
Giorgio Satta. 2014. A Polynomial-Time Dynamic
Oracle for Non-Projective Dependency Parsing. In
EMNLP 2014, pages 917–927. ACL.

Alvin C. Grissom II, Jordan Boyd-Graber, He He, John
Morgan, and Hal Daume III. 2014. Don’t Until
the Final Verb Wait: Reinforcement Learning for Si-
multaneous Machine Translation. In EMNLP 2014,
pages 1342–1352.

Dan Han, Pascual Martínez-Gómez, Yusuke Miyao,
Katsuhito Sudoh, and Masaaki Nagata. 2013. Ef-
fects of parsing errors on pre-reordering perfor-
mance for Chinese-to-Japanese SMT. PACLIC 27,
pages 267–276.

Matthew Honnibal and Mark Johnson. 2015. An Im-
proved Non-monotonic Transition System for De-
pendency Parsing. In EMNLP 2015, pages 1373–
1378. ACL.

Jiarong Jiang, Adam Teichert, Hal Daumé III, and Ja-
son Eisner. 2012. Learned Prioritization for Trading
Off Accuracy and Speed. ICML workshop on Infer-
ning: Interactions between Inference and Learning,
(0964681):1–9.

Eliyahu Kiperwasser and Yoav Goldberg. 2016. Sim-
ple and Accurate Dependency Parsing Using Bidi-
rectional LSTM Feature Representations. CoRR,
abs/1603.0.

Zhenghua Li, Min Zhang, and Wenliang Chen. 2014.
Ambiguity-aware Ensemble Training for Semi-
supervised Dependency Parsing. In ACL 2014,
pages 457–467.

Francis Maes, Ludovic Denoyer, and Patrick Galli-
nari. 2009. Structured prediction with reinforce-
ment learning. Machine Learning, (77):271–301.

Ryan McDonald and Joakim Nivre. 2007. Character-
izing the Errors of Data-Driven Dependency Parsing
Models. In EMNLP-CoNLL 2007.

Ryan McDonald, Fernando Pereira, Kiril Ribarov, and
Jan Hajič. 2005. Non-projective dependency pars-
ing using spanning tree algorithms. In HLT-EMNLP
2005, pages 523–530. Association for Computa-
tional Linguistics.

Dominick Ng and James R Curran. 2015. Identifying
Cascading Errors using Constraints in Dependency
Parsing. In ACL-IJCNLP, pages 1148–1158, Bei-
jing. ACL.

Joakim Nivre and Daniel Fernández-González. 2014.
Arc-eager Parsing with the Tree Constraint. Com-
putational Linguistics, 40(2):259–267, 6.

Joakim Nivre, Johan Hall, and Jens Nilsson. 2006a.
MaltParser: A data-driven parser-generator for de-
pendency parsing. In LREC 2006, volume 6, pages
2216–2219.

Joakim Nivre, Johan Hall, Jens Nilsson, Gülşen Ery-
iğit, and Svetoslav Marinov. 2006b. Labeled
pseudo-projective dependency parsing with support
vector machines. In CoNLL 2006, pages 221–225.
ACL.

Joakim Nivre, Johan Hall, Jens Nilsson, Atanas
Chanev, Eryiǧit Gülşen, Sandra Kübler, Svetoslav
Marinov, and Erwin Marsi. 2007. MaltParser:
A language-independent system for data-driven de-
pendency parsing. Natural Language Engineering,
13(02):95–135.

Joakim Nivre. 2003. An Efficient Algorithm for Pro-
jective Dependency Parsing. In IWPT 2003, pages
149–160.

Joakim Nivre. 2004. Incrementality in Deterministic
Dependency Parsing. In Proceedings of the Work-
shop on Incremental Parsing: Bringing Engineering
and Cognition Together.

686



Joakim Nivre. 2009. Non-projective Dependency
Parsing in Expected Linear Time. In ACL-IJCNLP
2009, pages 351–359, Stroudsburg, PA, USA. ACL.

Chris Quirk and Simon Corston-Oliver. 2006. The im-
pact of parse quality on syntactically-informed sta-
tistical machine translation. In EMNLP 2006, pages
62–69, Sydney, Australia. ACL.

Marc’Aurelio Ranzato, Sumit Chopra, Michael Auli,
and Wojciech Zaremba. 2016. Sequence Level
Training with Recurrent Neural Networks. ICLR,
pages 1–15.

Stephane Ross, Geoffrey J Gordon, and J Andrew Bag-
nell. 2011. A Reduction of Imitation Learning and
Structured Prediction to No-Regret Online Learning.
AISTATS, 15:627–635.

Djamé Seddah, Sandra Kübler, and Reut Tsarfaty.
2014. Introducing the SPMRL 2014 Shared Task
on Parsing Morphologically-Rich Languages. In
Proceedings of the First Joint Workshop on Statisti-
cal Parsing of Morphologically Rich Languages and
Syntactic Analysis of Non-Canonical Languages,
pages 103–109.

Shiqi Shen, Yong Cheng, Zhongjun He, Wei He, Hua
Wu, Maosong Sun, and Yang Liu. 2016. Mini-
mum Risk Training for Neural Machine Translation.
In ACL 2016, pages 1683–1692, Berlin, Germany.
ACL.

Hyun-Je Song, Jeong-Woo Son, Tae-Gil Noh, Seong-
Bae Park, and Sang-Jo Lee. 2012. A Cost Sensitive
Part-of-Speech Tagging: Differentiating Serious Er-
rors from Minor Errors. In ACL 2012, pages 1025–
1034. ACL.

Richard S. Sutton, David Mcallester, Satinder Singh,
and Yishay Mansour. 1999. Policy Gradient Meth-
ods for Reinforcement Learning with Function Ap-
proximation. In NIPS 1999, pages 1057–1063.

David Weiss, Chris Alberti, Michael Collins, and Slav
Petrov. 2015. Structured Training for Neural Net-
work Transition-Based Parsing. In ACL-IJCNLP
2015, pages 323–333. ACL.

Ronald J. Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine Learning, 8(3-4):229–256.

Hiroyasu Yamada and Yuji Matsumoto. 2003. Statis-
tical Dependency Analysis with Support Vector Ma-
chines. In Proceedings of IWPT, pages 195–206.

Bishan Yang and Claire Cardie. 2013. Joint Inference
for Fine-grained Opinion Extraction. In ACL 2013,
pages 1640–1649. ACL.

Lidan Zhang and Kwok Ping Chan. 2009. Dependency
Parsing with Energy-based Reinforcement Learning.
In IWPT 2009, pages 234–237. ACL.

687


