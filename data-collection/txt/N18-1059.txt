



















































The Web as a Knowledge-Base for Answering Complex Questions


Proceedings of NAACL-HLT 2018, pages 641–651
New Orleans, Louisiana, June 1 - 6, 2018. c©2018 Association for Computational Linguistics

The Web as a Knowledge-base for Answering Complex Questions

Alon Talmor
Tel-Aviv University

alontalmor@mail.tau.ac.il

Jonathan Berant
Tel-Aviv University

joberant@cs.tau.ac.il

Abstract

Answering complex questions is a time-
consuming activity for humans that requires
reasoning and integration of information. Re-
cent work on reading comprehension made
headway in answering simple questions, but
tackling complex questions is still an ongo-
ing research challenge. Conversely, seman-
tic parsers have been successful at handling
compositionality, but only when the informa-
tion resides in a target knowledge-base. In this
paper, we present a novel framework for an-
swering broad and complex questions, assum-
ing answering simple questions is possible us-
ing a search engine and a reading comprehen-
sion model. We propose to decompose com-
plex questions into a sequence of simple ques-
tions, and compute the final answer from the
sequence of answers. To illustrate the viabil-
ity of our approach, we create a new dataset
of complex questions, COMPLEXWEBQUES-
TIONS, and present a model that decomposes
questions and interacts with the web to com-
pute an answer. We empirically demonstrate
that question decomposition improves perfor-
mance from 20.8 precision@1 to 27.5 preci-
sion@1 on this new dataset.

1 Introduction

Humans often want to answer complex questions
that require reasoning over multiple pieces of ev-
idence, e.g., “From what country is the winner
of the Australian Open women’s singles 2008?”.
Answering such questions in broad domains can
be quite onerous for humans, because it requires
searching and integrating information from multi-
ple sources.

Recently, interest in question answering (QA)
has surged in the context of reading comprehen-
sion (RC), where an answer is sought for a ques-
tion given one or more documents (Hermann et al.,
2015; Joshi et al., 2017; Rajpurkar et al., 2016).

q :What city is the birthplace of the author of

‘Without end’, and hosted Euro 2012?

Decompose:

q1 : Author of ‘Without End’? {Ken Follett, Adam Zagajewski}
q2 : Birthplace of Ken Follett {Cardiff}
q3 : Birthplace of Adam Zagajewski {Lviv}
q4 : What cities hosted Euro 2012? {Warsaw, Kiev, Lviv, ...}
Recompose:

a :({Cardiff} ∪ {Lviv}) ∩ {Warsaw, Kiev, Lviv, ...}={Lviv}

Figure 1: Given a complex questions q, we decom-
pose the question to a sequence of simple questions
q1, q2, . . . , use a search engine and a QA model to an-
swer the simple questions, from which we compute the
final answer a.

Neural models trained over large datasets led to
great progress in RC, nearing human-level perfor-
mance (Wang et al., 2017). However, analysis of
models revealed (Jia and Liang, 2017; Chen et al.,
2016) that they mostly excel at matching questions
to local contexts, but struggle with questions that
require reasoning. Moreover, RC assumes docu-
ments with the information relevant for the answer
are available – but when questions are complex,
even retrieving the documents can be difficult.

Conversely, work on QA through semantic pars-
ing has focused primarily on compositionality:
questions are translated to compositional pro-
grams that encode a sequence of actions for find-
ing the answer in a knowledge-base (KB) (Zelle
and Mooney, 1996; Zettlemoyer and Collins,
2005; Artzi and Zettlemoyer, 2013; Krishna-
murthy and Mitchell, 2012; Kwiatkowski et al.,
2013; Liang et al., 2011). However, this reliance
on a manually-curated KB has limited the cover-
age and applicability of semantic parsers.

In this paper we present a framework for QA
that is broad, i.e., it does not assume information
is in a KB or in retrieved documents, and compo-
sitional, i.e., to compute an answer we must per-
form some computation or reasoning. Our thesis
is that answering simple questions can be achieved

641



by combining a search engine with a RC model.
Thus, answering complex questions can be ad-
dressed by decomposing the question into a se-
quence of simple questions, and computing the an-
swer from the corresponding answers. Figure 1
illustrates this idea. Our model decomposes the
question in the figure into a sequence of simple
questions, each is submitted to a search engine,
and then an answer is extracted from the search
result. Once all answers are gathered, a final an-
swer can be computed using symbolic operations
such as union and intersection.

To evaluate our framework we need a dataset
of complex questions that calls for reasoning
over multiple pieces of information. Because an
adequate dataset is missing, we created COM-
PLEXWEBQUESTIONS, a new dataset for com-
plex questions that builds on WEBQUESTION-
SSP, a dataset that includes pairs of simple ques-
tions and their corresponding SPARQL query. We
take SPARQL queries from WEBQUESTIONSSP
and automatically create more complex queries
that include phenomena such as function composi-
tion, conjunctions, superlatives and comparatives.
Then, we use Amazon Mechanical Turk (AMT) to
generate natural language questions, and obtain a
dataset of 34,689 question-answer pairs (and also
SPARQL queries that our model ignores). Data
analysis shows that examples are diverse and that
AMT workers perform substantial paraphrasing of
the original machine-generated question.

We propose a model for answering complex
questions through question decomposition. Our
model uses a sequence-to-sequence architecture
(Sutskever et al., 2014) to map utterances to short
programs that indicate how to decompose the
question and compose the retrieved answers. To
obtain supervision for our model, we perform
a noisy alignment from machine-generated ques-
tions to natural language questions and automati-
cally generate noisy supervision for training.1

We evaluate our model on COMPLEXWE-
BQUESTIONSand find that question decompo-
sition substantially improves precision@1 from
20.8 to 27.5. We find that humans are able to
reach 63.0 precision@1 under a limited time bud-
get, leaving ample room for improvement in future
work.

To summarize, our main contributions are:

1We differ training from question-answer pairs for future
work.

Conj {Lviv}

Comp {Cardiff, Lviv}

birthplace of VAR SimpQA {KF, AZ}

author of ‘Without End’

SimpQA {Warsaw, Lviv, ...}

what cities hosted Euro 2012

Figure 2: A computation tree for “What city is the
birthplace of the author of ‘Without end’, and hosted
Euro 2012?”. The leaves are strings, and inner nodes
are functions (red) applied to their children to produce
answers (blue).

1. A framework for answering complex ques-
tions through question decomposition.

2. A sequence-to-sequence model for question
decomposition that substantially improves
performance.

3. A dataset of 34,689 examples of complex and
broad questions, along with answers, web
snippets, and SPARQL queries.

Our dataset, COMPLEXWEBQUESTIONS, can
be downloaded from http://nlp.cs.tau.
ac.il/compwebq and our codebase can be
downloaded from https://github.com/
alontalmor/WebAsKB.

2 Problem Formulation

Our goal is to learn a model that given a ques-
tion q and a black box QA model for answering
simple questions, SIMPQA(·), produces a com-
putation tree t (defined below) that decomposes
the question and computes the answer. The model
is trained from a set of N question-computation
tree pairs {qi, ti}Ni=1 or question-answer pairs
{qi, ai}Ni=1.

A computation tree is a tree where leaves are
labeled with strings, and inner nodes are labeled
with functions. The arguments of a function are
its children sub-trees. To compute an answer, or
denotation, from a tree, we recursively apply the
function at the root to its children. More formally,
given a tree rooted at node t, labeled by the func-
tion f , that has children c1(t), . . . , ck(t), the de-
notation JtK = f(Jc1(t)K, . . . , Jck(t)K) is an ar-
bitrary function applied to the denotations of the
root’s children. Denotations are computed recur-
sively and the denotation of a string at the leaf is
the string itself, i.e., JlK = l. This is closely re-
lated to “semantic functions” in semantic parsing
(Berant and Liang, 2015), except that we do not in-

642



teract with a KB, but rather compute directly over
the breadth of the web through a search engine.

Figure 2 provides an example computation tree
for our running example. Notice that words at
the leaves are not necessarily in the original ques-
tion, e.g., “city” is paraphrased to “cities”. More
broadly, our framework allows paraphrasing ques-
tions in any way that is helpful for the function
SIMPQA(·). Paraphrasing for better interaction
with a QA model has been recently suggested by
Buck et al. (2017) and Nogueira and Cho (2016).

We defined the function SIMPQA(·) for an-
swering simple questions, but in fact it comprises
two components in this work. First, the question
is submitted to a search engine that retrieves a list
of web snippets. Next, a RC model extracts the
answer from the snippets. While it is possible to
train the RC model jointly with question decompo-
sition, in this work we pre-train it separately, and
later treat it as a black box.

The expressivity of our QA model is determined
by the functions used, which we turn to next.

3 Formal Language

Functions in our formal language take arguments
and return values that can be strings (when decom-
posing or re-phrasing the question), sets of strings,
or sets of numbers. Our set of functions includes:

1. SIMPQA(·): Model for answering simple
questions, which takes a string argument and
returns a set of strings or numbers as answer.

2. COMP(·, ·): This function takes a string con-
taining one unique variable VAR, and a set
of answers. E.g., in Figure 2 the first argu-
ment is “birthplace of VAR”, and the sec-
ond argument is “{KEN FOLLETT, ADAM
ZAGAJEWSKI}”. The function replaces the
variable with each answer string represen-
tation and returns their union. Formally,
COMP(q,A) = ∪a∈ASIMPQA(q/a), where
q/a denotes the string produced when re-
placing VAR in q with a. This is similar
to function composition in CCG (Steedman,
2000), or a join operation in λ-DCS (Liang,
2013), where the string is a function applied
to previously-computed values.

3. CONJ(·, ·): takes two sets and returns their
intersection. Other set operations can be de-
fined analogously. As syntactic sugar, we al-
low CONJ(·) to take strings as input, which
means that we run SIMPQA(·) to obtain a set

and then perform intersection. The root node
in Figure 2 illustrates an application of CONJ.

4. ADD(·, ·): takes two singleton sets of num-
bers and returns a set with their addition.
Similar functions can be defined analogously.
While we support mathematical operations,
they were not required in our dataset.

Other logical operations In semantic parsing
superlative and comparative questions like “What
is the highest European mountain?” or “What Eu-
ropean mountains are higher than Mont Blanc?”
are answered by joining the set of European moun-
tains with their elevation. While we could add
such functions to the formal language, answering
such questions from the web is cumbersome: we
would have to extract a list of entities and a numer-
ical value for each. Instead, we handle such con-
structions using SIMPQA directly, assuming they
are mentioned verbatim on some web document.

Similarly, negation questions (“What countries
are not in the OECD?”) are difficult to handle
when working against a search engine only, as this
is an open world setup and we do not hold a closed
set of countries over which we can perform set
subtraction.

In future work, we plan to interface with tables
(Pasupat and Liang, 2015) and KBs (Zhong et al.,
2017). This will allow us to perform set operations
over well-defined sets, and handle in a composi-
tional manner superlatives and comparatives.

4 Dataset

Evaluating our framework requires a dataset of
broad and complex questions that examine the im-
portance of question decomposition. While many
QA datasets have been developed recently (Yang
et al., 2015; Rajpurkar et al., 2016; Hewlett et al.,
2016; Nguyen et al., 2016; Onishi et al., 2016; Hill
et al., 2015; Welbl et al., 2017), they lack a focus
on the importance of question decomposition.

Most RC datasets contain simple questions that
can be answered from a short input document. Re-
cently, TRIVIAQA (Joshi et al., 2017) presented a
larger portion of complex questions, but still most
do not require reasoning. Moreover, the focus of
TRIVIAQA is on answer extraction from docu-
ments that are given. We, conversely, highlight
question decomposition for finding the relevant
documents. Put differently, RC is complemen-
tary to question decomposition and can be used
as part of the implementation of SIMPQA. In Sec-

643



1. Seed Question

2. SPARQL

3. Machine-generated

4. Natural language

What movies have robert pattinson starred in?
ns:rebert_pattinson ns:film.actor.film ?c .
?c ns:film.performance.film ?x .
?x ns:film.film.produced_by ns:erwin_stoff

What movies have robert pattinson starred in and that 
was produced by Erwin Stoff?

Which Robert Pattinson film was produced by Erwin Stoff?

Figure 3: Overview of data collection process.

tion 6 we demonstrate that question decomposi-
tion is useful for two different RC approaches.

4.1 Dataset collection

To generate complex questions we use the dataset
WEBQUESTIONSSP (Yih et al., 2016), which
contains 4,737 questions paired with SPARQL
queries for Freebase (Bollacker et al., 2008).
Questions are broad but simple. Thus, we sample
question-query pairs, automatically create more
complex SPARQL queries, generate automatically
questions that are understandable to AMT work-
ers, and then have them paraphrase those into nat-
ural language (similar to Wang et al. (2015)). We
compute answers by executing complex SPARQL
queries against Freebase, and obtain broad and
complex questions. Figure 3 provides an example
for this procedure, and we elaborate next.

Generating SPARQL queries Given a
SPARQL query r, we create four types of
more complex queries: conjunctions, superlatives,
comparatives, and compositions. Table 1 gives the
exact rules for generation. For conjunctions, su-
perlatives, and comparatives, we identify queries
in WEBQUESTIONSSP whose denotation is a set
A, |A| ≥ 2, and generate a new query r′ whose
denotation is a strict subset A′,A′ ⊂ A,A′ 6= φ.
For conjunctions this is done by traversing the
KB and looking for SPARQL triplets that can
be added and will yield a valid set A′. For
comparatives and superlatives we find a numerical
property common to all a ∈ A, and add a triplet
and restrictor to r accordingly. For compositions,
we find an entity e in r, and replace e with a
variable y and add to r a triplet such that the
denotation of that triplet is {e}.

Machine-generated (MG) questions To have
AMT workers paraphrase SPARQL queries into
natural language, we need to present them in an
understandable form. Therefore, we automatically
generate a question they can paraphrase. When
we generate new SPARQL queries, new predi-

cates are added to the query (Table 1). We man-
ually annotated 687 templates mapping KB pred-
icates to text for different compositionality types
(with 462 unique KB predicates), and use those
templates to modify the original WebQuestionsSP
question according to the meaning of the gener-
ated SPARQL query. E.g., the template for ?x
ns:book.author.works written obj is “the au-
thor who wrote OBJ”. For brevity, we provide the
details in the supplementary material.

Question Rephrasing We used AMT workers
to paraphrase MG questions into natural language
(NL). Each question was paraphrased by one
AMT worker and validated by 1-2 other workers.
To generate diversity, workers got a bonus if the
edit distance of a paraphrase was high compared to
the MG question. A total of 200 workers were in-
volved, and 34,689 examples were produced with
an average cost of 0.11$ per question. Table 1
gives an example for each compositionality type.

A drawback of our method for generating data
is that because queries are generated automatically
the question distribution is artificial from a se-
mantic perspective. Still, developing models that
are capable of reasoning is an important direc-
tion for natural language understanding and COM-
PLEXWEBQUESTIONS provides an opportunity to
develop and evaluate such models.

To summarize, each of our examples contains
a question, an answer, a SPARQL query (that our
models ignore), and all web snippets harvested by
our model when attempting to answer the ques-
tion. This renders COMPLEXWEBQUESTIONS
useful for both the RC and semantic parsing com-
munities.

4.2 Dataset analysis

COMPLEXWEBQUESTIONS builds on the WE-
BQUESTIONS (Berant et al., 2013). Questions in
WEBQUESTIONS are usually about properties of
entities (“What is the capital of France?”), of-
ten with some filter for the semantic type of the
answer (“Which director”, “What city”). WE-
BQUESTIONS also contains questions that refer to
events with multiple entities (“Who did Brad Pitt
play in Troy?”). COMPLEXWEBQUESTIONS con-
tains all these semantic phenomena, but we add
four compositionality types by generating compo-
sition questions (45% of the times), conjunctions
(45%), superlatives (5%) and comparatives (5%).

644



Composit. Complex SPARQL query r′ Example (natural language)

CONJ. r. ?x pred1 obj. or “What films star Taylor Lautner and have costume designs by Nina Proctor?”
r. ?x pred1 ?c. ?c pred2 obj.

SUPER. r. ?x pred1 ?n.ORDER BY DESC(?n) LIMIT 1 “Which school that Sir Ernest Rutherford attended has the latest founding date?”
COMPAR. r. ?x pred1?n. FILTER ?n < V “Which of the countries bordering Mexico have an army size of less than 1050?”
COMP. r[e/y]. ?y pred1obj. “Where is the end of the river that originates in Shannon Pot?”

Table 1: Rules for generating a complex query r′ from a query r (’.’ in SPARQL corresponds to logical and). The
query r returns the variable ?x, and contains an entity e. We denote by r[e/y] the replacement of the entity e with
a variable ?y. pred1 and pred2 are any KB predicates, obj is any KB entity, V is a numerical value, and ?c is a
variable of a CVT type in Freebase which refers to events. The last column provides an example for a NL question
for each type.

Figure 4: MG and NL questions similarity with nor-
malized edit-distance, and the DICE coefficient (bars
are stacked).

Paraphrasing To generate rich paraphrases, we
gave a bonus to workers that substantially modi-
fied MG questions. To check whether this worked,
we measured surface similarity between MG and
NL questions, and examined the similarity. Using
normalized edit-distance and the DICE coefficient,
we found that NL questions are different from MG
questions and that the similarity distribution has
wide support (Figure 4).

Figure 5: Heat map for similarity matrix between a
MG and NL question. The red line indicates a known
MG split point. The blue line is the approximated NL
split point.

We created a heuristic for approximating the
amount of word re-ordering performed by AMT
workers. For every question, we constructed a ma-
trix A, where Aij is the similarity between token
i in the MG question and token j in the NL ques-
tion. Similarity is 1 if lemmas match, or cosine
similarity according to GloVe embeddings (Pen-
nington et al., 2014), when above a threshold, and
0 otherwise. The matrix A allows us to estimate
whether parts of the MG question were re-ordered
when paraphrased to NL (details in supplementary
material). We find that in 44.7% of the conjunc-
tion questions and 13.2% of the composition ques-
tions, word re-ordering happened, illustrating that
substantial changes to the MG question have been
made. Figure 5 illustrates the matrix A for a pair
of questions with re-ordering.

Qualitative analysis We randomly sampled 100
examples from the development set and manually
identified prevalent phenomena in the data. We
present these types in Table 2 along with their fre-
quency. In 18% of the examples a conjunct in the
MG question becomes a modifier of a wh-word in
the NL question (WH-MODIFIER). In 22% sub-
stantial word re-ordering of the MG questions oc-
curred, and in 42% a minor word re-ordering oc-
curred (“number of building floors is 50” para-
phrased as “has 50 floors”). AMT workers used
a synonym in 54% of the examples, they omitted
words in 27% of the examples and they added new
lexical material in 29%.

To obtain intuition for operations that will be
useful in our model, we analyzed the 100 exam-
ples for the types of operations that should be ap-
plied to the NL question during question decom-
position. We found that splitting the NL question
is insufficient, and that in 53% of the cases a word
in the NL question needs to be copied to multiple
questions after decomposition (row 3 in Table 3).

645



Type MG question NL question %

WH-MODIFIER what movies does leo howard play in and that is 113.0 Which Leo Howard movie lasts 113 minutes? 18%
minutes long?

MAJOR REORD. Where did the actor that played in the film Hancock 2 What high school did the actor go to who was in the movie 22%
go to high school? Hancock 2?

MINOR REORD. what to do and see in vienna austria What building in Vienna, Austria has 50 floors? 42%
and the number of building floors is 50?

SYNONYM where does the body of water under Kineshma Where does the body of water under Kineshma Bridge originate? 54%
Bridge start?

SKIP WORD what movies did miley cyrus play in and involves What movie featured Miley Cyrus and involved Cirkus? 27%
organization Cirkus?

ADD WORD what to do if you have one day in bangkok and Which amusement park, that happens to be the one that opened 29%
the place is an amusement park that opened earliest? earliest, should you visit if you have only one day to spend

in Bangkok?

Table 2: Examples and frequency of prevalent phenomena in the NL questions for a manually analyzed subset (see
text).

Moreover, words that did not appear in the MG
question need to be added in 39% of the cases, and
words need to be deleted in 28% of the examples.

5 Model and Learning

We would like to develop a model that translates
questions into arbitrary computation trees with ar-
bitrary text at the tree leaves. However, this re-
quires training from denotations using methods
such as maximum marginal likelihood or rein-
forcement learning (Guu et al., 2017) that are dif-
ficult to optimize. Moreover, such approaches in-
volve issuing large amounts of queries to a search
engine at training time, incurring high costs and
slowing down training.

Instead, we develop a simple approach in this
paper. We consider a subset of all possible compu-
tation trees that allows us to automatically gener-
ate noisy full supervision. In what follows, we de-
scribe the subset of computation trees considered
and their representation, a method for automati-
cally generating noisy supervision, and a pointer
network model for decoding.

Representation We represent computation trees
as a sequence of tokens, and consider trees with
at most one compositional operation. We denote
a sequence of question tokens qi:j = (qi, . . . , qj),
and the decoded sequence by z. We consider the
following token sequences (see Table 3):

1. SimpQA: The function SIMPQA is applied
to the question q without paraphrasing. In
prefix notation this is the tree SIMPQA(q).

2. Comp i j: This sequence of tokens corre-
sponds to the following computation tree:
COMP(q1:i−1◦VAR◦qj+1:|q|, SIMPQA(qi:j)),
where ◦ is the concatenation operator. This is
used for questions where a substring is an-
swered by SIMPQA and the answers replace

a variable before computing a final answer.
3. Conj i j: This sequence of tokens

corresponds to the computation tree
CONJ(SIMPQA(q0:i−1), SIMPQA(qj ◦
qi:|q|)). The idea is that conjunction can
be answered by splitting the question in a
single point, where one token is copied to
the second part as well (“film” in Table 3). If
nothing needs to be copied, then j = −1.

This representation supports one compositional
operation, and a single copying operation is al-
lowed without any re-phrasing. In future work,
we plan to develop a more general representation,
which will require training from denotations.

Supervision Training from denotations is diffi-
cult as it involves querying a search engine fre-
quently, which is expensive. Therefore, we take
advantage of the the original SPARQL queries
and MG questions to generate noisy programs for
composition and conjunction questions. Note that
these noisy programs are only used as supervision
to avoid the costly process of manual annotation,
but the model itself does not assume SPARQL
queries in any way.

We generate noisy programs from SPARQL
queries in the following manner: First, we au-
tomatically identify composition and conjunction
questions. Because we generated the MG ques-
tion, we can exactly identify the split points (i, j in
composition questions and i in conjunction ques-
tions) in the MG question. Then, we use a rule-
based algorithm that takes the alignment matrix A
(Section 4), and approximates the split points in
the NL question and the index j to copy in con-
junction questions. The red line in Figure 5 corre-
sponds to the known split point in the MG ques-
tion, and the blue one is the approximated split
point in the NL question. The details of this rule-

646



Program Question Split
SimpQA “What building in Vienna, Austria has 50 floors” -
Comp 5 9 “Where is the birthplace of the writer of Standup Shakespeare” “Where is the birthplace of VAR”

“the writer of Standup Shakespeare”
Conj 5 1 “What film featured Taylor Swift and “What film featured Taylor Swift”

was directed by Deborah Aquila” “film and was directed by Deborah Aquila”

Table 3: Examples for the types of computation trees that can be decoded by our model.

based algorithm are in the supplementary material.
Thus, we obtain noisy supervision for all com-

position and conjunction questions and can train
a model that translates questions q to representa-
tions z = z1 z2 z3, where z1 ∈ {Comp,Conj}
and z2, z3 are integer indices.

Pointer network The representation z points to
indices in the input, and thus pointer networks
(Vinyals et al., 2015) are a sensible choice. Be-
cause we also need to decode the tokens COMP
and CONJ, we use “augmented pointer networks”,
(Zhong et al., 2017): For every question q, an aug-
mented question q̂ is created by appending the to-
kens “COMP CONJ” to q. This allows us to de-
code the representation z with one pointer network
that at each decoding step points to one token in
the augmented question. We encode q̂ with a one-
layer GRU (Cho et al., 2014), and decode z with a
one-layer GRU with attention as in Jia and Liang
(2016). The only difference is that we decode to-
kens from the augmented question q̂ rather than
from a fixed vocabulary.

We train the model with token-level cross-
entropy loss, minimizing

∑
j log pθ(zj |x, z1:j−1).

Parameters θ include the GRU encoder and de-
coder, and embeddings for unknown tokens (that
are not in pre-trained GloVe embeddings (Pen-
nington et al., 2014)).

The trained model decodes COMP and CONJ
representations, but sometimes using SIMPQA(q)
without decomposition is better. To handle such
cases we do the following: We assume that we al-
ways have access to a score for every answer, pro-
vided by the final invocation of SIMPQA (in CONJ
questions this score is the maximum of the scores
given by SIMPQA for the two conjuncts), and use
the following rule to decide if to use the decoded
representation z or SIMPQA(q). Given the scores
for answers given by z and the scores given by
SIMPQA(q), we return the single answer that has
the highest score. The intuition is that the confi-
dence provided by the scores of SIMPQA is corre-
lated with answer correctness. In future work we
will train directly from denotations and will han-

dle all logical functions in a uniform manner.

6 Experiments

In this section, we aim to examine whether ques-
tion decomposition can empirically improve per-
formance of QA models over complex questions.

Experimental setup We used 80% of the exam-
ples in COMPLEXWEBQUESTIONS for training,
10% for development, and 10% for test, training
the pointer network on 24,708 composition and
conjunction examples. The hidden state dimen-
sion of the pointer network is 512, and we used
Adagrad (Duchi et al., 2010) combined with L2
regularization and a dropout rate of 0.25. We
initialize 50-dimensional word embeddings using
GloVe and learn embeddings for missing words.

Simple QA model As our SIMPQA function,
we download the web-based QA model of Talmor
et al. (2017). This model sends the question to
Google’s search engine and extracts a distribution
over answers from the top-100 web snippets us-
ing manually-engineered features. We re-train the
model on our data with one new feature: for ev-
ery question q and candidate answer mention in a
snippet, we run RASOR, a RC model by lee et al.
(2016), and add the output logit score as a feature.
We found that combining the web-facing model of
Talmor et al. (2017) and RASOR, resulted in im-
proved performance.

Evaluation For evaluation, we measure preci-
sion@1 (p@1), i.e., whether the highest scoring
answer returned string-matches one of the correct
answers (while answers are sets, 70% of the ques-
tions have a single answer, and the average size of
the answer set is 2.3).

We evaluate the following models and oracles:
1. SIMPQA: running SIMPQA on the entire

question, i.e., without decomposition.
2. SPLITQA: Our main model that answers

complex questions by decomposition.
3. SPLITQAORACLE: An oracle model that

chooses whether to perform question decom-

647



System Dev. Test
SIMPQA 20.4 20.8
SPLITQA 29.0 27.5
SPLITQAORACLE 34.0 33.7
RCQA 18.7 18.6
SPLITRCQA 21.5 22.0
GOOGLEBOX 2.5 -
HUMAN 63.0 -

Table 4: precision@1 results on the development set
and test set for COMPLEXWEBQUESTIONS.

position or use SIMPQA in hindsight based
on what performs better.

4. RCQA: This is identical to SIMPQA, except
that we replace the RC model from Talmor
et al. (2017) with the the RC model DOCQA
(Clark and Gardner, 2017), whose perfor-
mance is comparable to state-of-the-art on
TRIVIAQA.

5. SPLITRCQA: This is identical to SPLITQA,
except that we replace the RC model from
Talmor et al. (2017) with DOCQA.

6. GOOGLEBOX: We sample 100 random de-
velopment set questions and check whether
Google returns a box that contains one of the
correct answers.

7. HUMAN: We sample 100 random develop-
ment set questions and manually answer the
questions with Google’s search engine, in-
cluding all available information. We limit
the amount of time allowed for answering to
4 minutes.

Table 4 presents the results on the development
and test sets. SIMPQA, which does not decom-
pose questions obtained 20.8 p@1, while by per-
forming question decomposition we substantially
improve performance to 27.5 p@1. An upper
bound with perfect knowledge on when to decom-
pose is given by SPLITQAORACLE at 33.7 p@1.

RCQA obtained lower performance SIMPQA,
as it was trained on data from a different distri-
bution. More importantly SPLITRCQA outper-
forms RCQA by 3.4 points, illustrating that this
RC model also benefits from question decomposi-
tion, despite the fact that it was not created with
question decomposition in mind. This shows the
importance of question decomposition for retriev-
ing documents from which an RC model can ex-
tract answers. GOOGLEBOX finds a correct an-
swer in 2.5% of the cases, showing that complex
questions are challenging for search engines.

To conclude, we demonstrated that question de-

composition substantially improves performance
on answering complex questions using two inde-
pendent RC models.

Analysis We estimate human performance
(HUMAN) at 63.0 p@1. We find that answering
complex questions takes roughly 1.3 minutes on
average. For questions we were unable to answer,
we found that in 27% the answer was correct but
exact string match with the gold answers failed;
in 23.1% the time required to compute the answer
was beyond our capabilities; for 15.4% we could
not find an answer on the web; 11.5% were of
ambiguous nature; 11.5% involved paraphrasing
errors of AMT workers; and an additional 11.5%
did not contain a correct gold answer.

SPLITQA decides if to decompose questions or
not based on the confidence of SIMPQA. In 61%
of the questions the model chooses to decompose
the question, and in the rest it sends the question
as-is to the search engine. If one of the strategies
(decomposition vs. no decomposition) works, our
model chooses that right one in 86% of the cases.
Moreover, in 71% of these answerable questions,
only one strategy yields a correct answer.

We evaluate the ability of the pointer network
to mimic our labeling heuristic on the develop-
ment set. We find that the model outputs the ex-
act correct output sequence 60.9% of the time, and
allowing errors of one word to the left and right
(this often does not change the final output) accu-
racy is at 77.1%. Token-level accuracy is 83.0%
and allowing one-word errors 89.7%. This shows
that SPLITQA learned to identify decomposition
points in the questions. We also observed that of-
ten SPLITQA produced decomposition points that
are better than the heuristic, e.g., for “What is the
place of birth for the lyricist of Roman Holiday”,
SPLITQA produced “the lyricist of Roman Hol-
iday”, but the heuristic produced “the place of
birth for the lyricist of Roman Holiday”. Addi-
tional examples of SPLITQA question decompo-
sitions are provided in Table 5.

ComplexQuestions To further examine the abil-
ity of web-based QA models, we run an experi-
ment against COMPLEXQUESTIONS (Bao et al.,
2016), a small dataset of question-answer pairs de-
signed for semantic parsing against Freebase.

We ran SIMPQA on this dataset (Table 6) and
obtained 38.6 F1 (the official metric), slightly
lower than COMPQ, the best system, which op-

648



Question Split-1 Split-2
“Find the actress who played Hailey Rogers, “the actress who played Hailey Rogers” “Find VAR , what label is she signed to”
what label is she signed to”
“What are the colors of the sports team whose “the sports team whose arena stadium “What are the colors of VAR”
arena stadium is the AT&T Stadium” is the AT&T Stadium”
“What amusement park is located in Madrid “What amusement park is located in “park includes the stunt fall ride”
Spain and includes the stunt fall ride” Madrid Spain and”
“Which university whose mascot is “Which university whose mascot is “university Derek Fisher attend”
The Trojan did Derek Fisher attend” The Trojan did”

Table 5: Examples for question decompositions from SPLITQA.

System Dev. F1 Test F1
SIMPQA 40.7 38.6
SPLITQARULE 43.1 39.7
SPLITQARULE++ 46.9 -
COMPQ - 40.9

Table 6: F1 results for COMPLEXQUESTIONS.

erates directly against Freebase. 2 By analyzing
the training data, we found that we can decom-
pose COMP questions with a rule that splits the
question when the words “when” or “during” ap-
pear, e.g., “Who was vice president when JFK was
president?”.3 We decomposed questions with this
rule and obtained 39.7 F1 (SPLITQARULE). An-
alyzing the development set errors, we found that
occasionally SPLITQARULE returns a correct an-
swer that fails to string-match with the gold an-
swer. By manually fixing these cases, our devel-
opment set F1 reaches 46.9 (SPLITQARULE++).
Note that COMPQ does not suffer from any string
matching issue, as it operates directly against the
Freebase KB and thus is guaranteed to output the
answer in the correct form. This short experiment
shows that a web-based QA model can rival a se-
mantic parser that works against a KB, and that
simple question decomposition is beneficial and
leads to results comparable to state-of-the-art.

7 Related work

This work is related to a body of work in seman-
tic parsing and RC, in particular to datasets that
focus on complex questions such as TRIVIAQA
(Joshi et al., 2017), WIKIHOP (Welbl et al., 2017)
and RACE (Lai et al., 2017). Our distinction is in
proposing a framework for complex QA that fo-
cuses on question decomposition.

Our work is related to Chen et al. (2017) and
Watanabe et al. (2017), who combined retrieval
and answer extraction on a large set of documents.
We work against the entire web, and propose ques-

2By adding the output logit from RASOR, we improved
test F1 from 32.6, as reported by Talmor et al. (2017), to 38.6.

3The data is too small to train our decomposition model.

tion decomposition for finding information.
This work is also closely related to Dunn et al.

(2017) and Buck et al. (2017): we start with ques-
tions directly and do not assume documents are
given. Buck et al. (2017) also learn to phrase ques-
tions given a black box QA model, but while they
focus on paraphrasing, we address decomposition.

Another important related research direction is
Iyyer et al. (2016), who answered complex ques-
tions by decomposing them. However, they used
crowdsourcing to obtain direct supervision for the
gold decomposition, while we do not assume such
supervision. Moreover, they work against web
tables, while we interact with a search engine
against the entire web.

8 Conclusion

In this paper we propose a new framework for
answering complex questions that is based on
question decomposition and interaction with the
web. We develop a model under this framework
and demonstrate it improves complex QA perfor-
mance on two datasets and using two RC mod-
els. We also release a new dataset, COMPLEXWE-
BQUESTIONS, including questions, SPARQL pro-
grams, answers, and web snippets harvested by
our model. We believe this dataset will serve the
QA and semantic parsing communities, drive re-
search on compositionality, and push the commu-
nity to work on holistic solutions for QA.

In future work, we plan to train our model di-
rectly from weak supervision, i.e., denotations,
and to extract information not only from the web,
but also from structured information sources such
as web tables and KBs.

Acknowledgements

We thank Jonatahn Herzig, Ni Lao, and the anony-
mous reviewers for their constructive feedback.
This work was supported by the Samsung runway
project and the Israel Science Foundation, grant
942/16.

649



References
Y. Artzi and L. Zettlemoyer. 2013. Weakly supervised

learning of semantic parsers for mapping instruc-
tions to actions. Transactions of the Association for
Computational Linguistics (TACL) 1:49–62.

J. Bao, N. Duan, Z. Yan, M. Zhou, and T. Zhao. 2016.
Constraint-based question answering with knowl-
edge graph. In International Conference on Com-
putational Linguistics (COLING).

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013. Se-
mantic parsing on Freebase from question-answer
pairs. In Empirical Methods in Natural Language
Processing (EMNLP).

J. Berant and P. Liang. 2015. Imitation learning of
agenda-based semantic parsers. Transactions of the
Association for Computational Linguistics (TACL)
3:545–558.

K. Bollacker, C. Evans, P. Paritosh, T. Sturge, and
J. Taylor. 2008. Freebase: a collaboratively created
graph database for structuring human knowledge. In
International Conference on Management of Data
(SIGMOD). pages 1247–1250.

C. Buck, J. Bulian, M. Ciaramita, A. Gesmundo,
N. Houlsby, W. Gajewski, and W. Wang. 2017.
Ask the right questions: Active question reformu-
lation with reinforcement learning. arXiv preprint
arXiv:1705.07830 .

D. Chen, J. Bolton, and C. D. Manning. 2016. A thor-
ough examination of the CNN / Daily Mail reading
comprehension task. In Association for Computa-
tional Linguistics (ACL).

D. Chen, A. Fisch, J. Weston, and A. Bordes. 2017.
Reading Wikipedia to answer open-domain ques-
tions. arXiv preprint arXiv:1704.00051 .

K. Cho, B. van Merriënboer, D. Bahdanau, and Y. Ben-
gio. 2014. On the properties of neural machine
translation: Encoder-decoder approaches. arXiv
preprint arXiv:1409.1259 .

C. Clark and M. Gardner. 2017. Simple and effec-
tive multi-paragraph reading comprehension. arXiv
preprint arXiv:1710.10723 .

J. Duchi, E. Hazan, and Y. Singer. 2010. Adaptive sub-
gradient methods for online learning and stochastic
optimization. In Conference on Learning Theory
(COLT).

M. Dunn, , L. Sagun, M. Higgins, U. Guney, V. Cirik,
and K. Cho. 2017. SearchQA: A new Q&A dataset
augmented with context from a search engine. arXiv
.

K. Guu, P. Pasupat, E. Z. Liu, and P. Liang. 2017.
From language to programs: Bridging reinforce-
ment learning and maximum marginal likelihood. In
Association for Computational Linguistics (ACL).

K. M. Hermann, T. Koisk, E. Grefenstette, L. Espe-
holt, W. Kay, M. Suleyman, and P. Blunsom. 2015.
Teaching machines to read and comprehend. In Ad-
vances in Neural Information Processing Systems
(NIPS).

D. Hewlett, A. Lacoste, L. Jones, I. Polosukhin,
A. Fandrianto, J. Han, M. Kelcey, and D. Berthelot.
2016. Wikireading: A novel large-scale language
understanding task over Wikipedia. In Association
for Computational Linguistics (ACL).

F. Hill, A. Bordes, S. Chopra, and J. Weston. 2015. The
goldilocks principle: Reading children’s books with
explicit memory representations. In International
Conference on Learning Representations (ICLR).

M. Iyyer, W. Yih, and M. Chang. 2016. Answering
complicated question intents expressed in decom-
posed question sequences. CoRR 0.

R. Jia and P. Liang. 2016. Data recombination for neu-
ral semantic parsing. In Association for Computa-
tional Linguistics (ACL).

R. Jia and P. Liang. 2017. Adversarial examples for
evaluating reading comprehension systems. In Em-
pirical Methods in Natural Language Processing
(EMNLP).

M. Joshi, E. Choi, D. Weld, and L. Zettlemoyer. 2017.
TriviaQA: A large scale distantly supervised chal-
lenge dataset for reading comprehension. In Associ-
ation for Computational Linguistics (ACL).

J. Krishnamurthy and T. Mitchell. 2012. Weakly
supervised training of semantic parsers. In Em-
pirical Methods in Natural Language Processing
and Computational Natural Language Learning
(EMNLP/CoNLL). pages 754–765.

T. Kwiatkowski, E. Choi, Y. Artzi, and L. Zettlemoyer.
2013. Scaling semantic parsers with on-the-fly on-
tology matching. In Empirical Methods in Natural
Language Processing (EMNLP).

G. Lai, Q. Xie, H. Liu, Y. Yang, and E. Hovy.
2017. Race: Large-scale reading comprehen-
sion dataset from examinations. arXiv preprint
arXiv:1704.04683 .

K. lee, M. Lewis, and L. Zettlemoyer. 2016. Global
neural CCG parsing with optimality guarantees. In
Empirical Methods in Natural Language Processing
(EMNLP).

P. Liang. 2013. Lambda dependency-based composi-
tional semantics. arXiv preprint arXiv:1309.4408 .

P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Association for Computational Linguistics (ACL).
pages 590–599.

650



T. Nguyen, M. Rosenberg, X. Song, J. Gao, S. Tiwary,
R. Majumder, and L. Deng. 2016. MS MARCO:
A human generated machine reading comprehension
dataset. In Workshop on Cognitive Computing at
NIPS.

R. Nogueira and K. Cho. 2016. End-to-end goal-driven
web navigation. In Advances in Neural Information
Processing Systems (NIPS).

T. Onishi, H. Wang, M. Bansal, K. Gimpel, and
D. McAllester. 2016. Who did what: A large-scale
person-centered cloze dataset. In Empirical Meth-
ods in Natural Language Processing (EMNLP).

P. Pasupat and P. Liang. 2015. Compositional semantic
parsing on semi-structured tables. In Association for
Computational Linguistics (ACL).

J. Pennington, R. Socher, and C. D. Manning. 2014.
Glove: Global vectors for word representation. In
Empirical Methods in Natural Language Processing
(EMNLP).

P. Rajpurkar, J. Zhang, K. Lopyrev, and P. Liang. 2016.
Squad: 100,000+ questions for machine comprehen-
sion of text. In Empirical Methods in Natural Lan-
guage Processing (EMNLP).

M. Steedman. 2000. The Syntactic Process. MIT
Press.

I. Sutskever, O. Vinyals, and Q. V. Le. 2014. Sequence
to sequence learning with neural networks. In Ad-
vances in Neural Information Processing Systems
(NIPS). pages 3104–3112.

A. Talmor, M. Geva, and J. Berant. 2017. Evaluating
semantic parsing against a simple web-based ques-
tion answering model. In *SEM.

O. Vinyals, M. Fortunato, and N. Jaitly. 2015. Pointer
networks. In Advances in Neural Information Pro-
cessing Systems (NIPS). pages 2674–2682.

W. Wang, N. Yang, F. Wei, B. Chang, and M. Zhou.
2017. Gated self-matching networks for reading
comprehension and question answering. In Associ-
ation for Computational Linguistics (ACL).

Y. Wang, J. Berant, and P. Liang. 2015. Building a
semantic parser overnight. In Association for Com-
putational Linguistics (ACL).

Y. Watanabe, B. Dhingra, and R. Salakhutdinov.
2017. Question answering from unstructured text
by retrieval and comprehension. arXiv preprint
arXiv:1703.08885 .

J. Welbl, P. Stenetorp, and S. Riedel. 2017. Construct-
ing datasets for multi-hop reading comprehension
across documents. arXiv preprint arXiv:1710.06481
.

Y. Yang, W. Yih, and C. Meek. 2015. WikiQA: A chal-
lenge dataset for open-domain question answering.
In Empirical Methods in Natural Language Process-
ing (EMNLP). pages 2013–2018.

W. Yih, M. Richardson, C. Meek, M. Chang, and
J. Suh. 2016. The value of semantic parse labeling
for knowledge base question answering. In Associ-
ation for Computational Linguistics (ACL).

M. Zelle and R. J. Mooney. 1996. Learning to parse
database queries using inductive logic program-
ming. In Association for the Advancement of Arti-
ficial Intelligence (AAAI). pages 1050–1055.

L. S. Zettlemoyer and M. Collins. 2005. Learning to
map sentences to logical form: Structured classifica-
tion with probabilistic categorial grammars. In Un-
certainty in Artificial Intelligence (UAI). pages 658–
666.

V. Zhong, C. Xiong, and R. Socher. 2017. Seq2sql:
Generating structured queries from natural lan-
guage using reinforcement learning. arXiv preprint
arXiv:1709.00103 .

651


