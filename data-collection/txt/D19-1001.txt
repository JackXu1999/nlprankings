



















































Attending to Future Tokens for Bidirectional Sequence Generation


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 1–10,

Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

1

Attending to Future Tokens for Bidirectional Sequence Generation

Carolin Lawrence and Bhushan Kotnis and Mathias Niepert
NEC Laboratories Europe

{carolin.lawrence, bhushan.kotnis, mathias.niepert}@neclab.eu

Abstract
Neural sequence generation is typically
performed token-by-token and left-to-right.
Whenever a token is generated only previously
produced tokens are taken into consideration.
In contrast, for problems such as sequence
classification, bidirectional attention, which
takes both past and future tokens into con-
sideration, has been shown to perform much
better. We propose to make the sequence
generation process bidirectional by employing
special placeholder tokens. Treated as a node
in a fully connected graph, a placeholder
token can take past and future tokens into
consideration when generating the actual
output token. We verify the effectiveness of
our approach experimentally on two conversa-
tional tasks where the proposed bidirectional
model outperforms competitive baselines by a
large margin.

1 Introduction

When generating an output sequence, neural net-
work models typically produce one token at a
time. At each generation step, only the already
produced sequence is taken into account. How-
ever, future and not-yet-produced tokens can also
be highly relevant when choosing the current to-
ken. The importance of attending to both past and
future tokens is apparent in self-attention archi-
tectures such as the Transformer (Vaswani et al.,
2017). The self-attention module of a Transformer
network treats a sequence bidrectionally as a fully
connected graph of tokens – when a token is pro-
duced all other tokens are taken into considera-
tion. However, this requires the entire sequence
to be known a priori and when a Transformer is
used for sequence generation, the self-attention
process only includes previously produced tokens
(Vaswani et al. (2017); Radford et al. (2019); in-
ter alia). But the bidirectional self-attention is a

crucial property of the highly successful language
model BERT (Devlin et al., 2018). During the pre-
training procedure of BERT, a fraction of input to-
kens is randomly masked out and the training ob-
jective is to predict these masked tokens correctly.
BERT can then be fine-tuned for various classifi-
cation tasks. Unfortunately, BERT cannot be di-
rectly used for sequence generation because the
bidirectional nature of the approach requires the
entire sequence to be known beforehand.

Inspired by BERT’s masking-based objective,
we propose to start out with a sequence of place-
holder tokens which are iteratively replaced by to-
kens from the output vocabulary to eventually gen-
erate the full output sequence. For an example see
Figure 1. With this novel model component, the
self-attention of a Transformer can take both past
and future tokens into consideration, leading to
Bidirectional Sequence generation (BISON). Fur-
thermore, it allows us to directly incorporate the
pre-trained language model BERT and, to the best
of our knowledge, for the first time directly fine-
tune it for sequence generation.

BISON makes two major contributions which
we investigate in turn. First, we explore differ-
ent stochastic placeholder replacement strategies
to determine, at training time, where to position
the placeholder tokens. This is crucial as we need
the BISON models to be exposed to a large number
of heterogeneous placeholder configurations. Sec-
ond, we explore several strategies for iteratively
generating, at inference time, a complete output
sequence from an initial sequence of placeholders.

We evaluate our bidirectional sequence gener-
ation approach on two conversational tasks. BI-
SON outperforms both competitive baselines and
state of the art neural network approaches on both
datasets by a significant margin.



2

1 p̄ p̄ p̄ p̄ p̄ p̄ p̄ p̄ p̄ p̄ p̄ p̄ p̄
2 p̄ you been p̄ or enrolled in an p̄ degree or program ?
3 Have you been accepted or enrolled in an accredited degree or program ?

Figure 1: Example generation, going from a sequence of the placeholder token p̄ (1), to an intermediate represen-
tation (2) and to the final output (3).

2 Sequence Generation with
Transformers

For sequence-to-sequence tasks, an input se-
quence x = x1, x2, . . . , x|x| is to be mapped to
an output sequence y = y1, y2, . . . , y|y| by some
model πθ with learnable parameters θ. For neu-
ral models, this is typically done by first encoding
the input sequence x and then calling a decoder
t times to produce a sequence y token-by-token,
from left-to-right.

A popular choice for both encoder and decoder
is the transformer (Vaswani et al., 2017). It takes a
sequence of embedded tokens s = s1, s2, . . . , s|s|
and treats it as a fully connected graph over which
a self-attention module is applied: for each to-
ken st in the sequence it assigns a probabilistic
attention score at to every other token in the sen-
tence. For the full mathematical details we refer
the reader to (Vaswani et al., 2017).

Typically a transformer encoder is employed to
encode x, whereas a transformer decoder is used
to produce y. In contrast to the encoder, the de-
coder at time step t only has access to previously
produced tokens s<t = s1, s2, . . . , st−1. Conse-
quently, the attention module cannot take possi-
ble future tokens into account when making its
decision at time t. Additionally, in this encoder-
decoder framework, there is a disconnect between
input x and output y because the self-attention
modules are applied to x and y in isolation before
they are combined.

The latter weakness has been overcome in re-
cent work (Radford et al., 2018; Wolf et al., 2019;
Radford et al., 2019) by feeding the concatenation
s = x ⊕ y to a transformer decoder. At training
time, given the current token st, the transformer
is trained to predict the next word st+1 via maxi-
mum likelihood estimation. At test time, the trans-
former is conditioned on x and then produces the
output y token-by-token. But because the model is
a transformer decoder, it is unable to take possible
future tokens into account.

3 Bidirectional Sequence Generation

During sequence generation, we want to take
both past and future tokens into account. More
formally, at time t, we want to attend to both
s1, . . . , st−1 as well as st+1, . . . , s|s|. To do this,
we give the sequence s = x ⊕ y, the concatena-
tion of the sequences x and y, to a Transformer
encoder, rather than a decoder. Of course, at in-
ference time y is unknown. Thus, we propose to
replace each token yj with a placeholder token p̄.
Since the model needs to be exposed to hetero-
geneous placeholder token configurations during
training time, we introduce a placeholder strat-
egy that replaces some tokens yj with placeholder
tokens p̄ at training time. Hence, during train-
ing, a sequence y is replaced by a sequence p =
p1, p2, . . . , p|y|, where a token pj is either the orig-
inal token yj or the placeholder token p̄. We intro-
duce two placeholder strategies in the following
section. At inference time, p contains only place-
holder tokens up to some pre-determined maxi-
mum sequence length.

With the placeholder strategy in place, a Trans-
former encoder is given the sequence s = x ⊕ p
as input. The self-attention module then computes
hidden representations rt of each token st by at-
tending to every other token in the sequence s.
Because the output sequence is already present in
the form of placeholder tokens both past tokens
as well as future, not-yet-produced, tokens can be
taken into consideration for every token st. Fol-
lowing the self-attention step, placeholder tokens
are converted into a token from the output vocab-
ulary with a language model (LM) classification
layer, where for each placeholder pt, its hidden
representation rt is mapped to a distribution dt
over the output vocabulary.

At training time, each output sequence token is
fed the gold label and updates to the model πθ are
performed using stochastic gradient descent with
a cross-entropy loss, i.e.



3

Lπθ = −
1

M

M∑
m=1

|y|∑
j=1

log πθ(pj = yj |s),

where M is the size of a minibatch.
At inference time, the placeholder tokens can be

replaced iteratively based on the probability dis-
tribution dt over the output vocabulary for each
placeholder pt. Different sequence generation
strategies are outlined in Section 3.2.

3.1 Placeholder Replacement Strategy
At inference time, the output sequence starts out
with a sequence of placeholder tokens. To intro-
duce this notion at training time, we require a strat-
egy that replaces some output sequence tokens yj
with the placeholder token p̄. The simplest ap-
proach would be to replace all output sequence to-
kens yj with the placeholder token p̄. However,
with this approach the model is never confronted
with a sequence containing a mix of output se-
quence tokens and placeholder tokens.

Due to the exponential number of possible
replacement configurations per given token se-
quence, we introduce probabilistic generative
models that we can use to draw diverse sequence
replacements. To this end, we model the decision
whether to use placeholder or input tokens with
probabilistic models, two of which we propose in
the following.

Bernoulli Random Variables (RV). We model
each position of the input sequence with a binary
random variable with a fixed mean. For every in-
put sequence and every position i in the sequence,
we draw from a Bernoulli variable with mean µ to
decide whether to use yi or p̄. The expected num-
ber of placeholder tokens in a sequence of length
|y| is |y|µ and the variance is σ2 = |y|µ(1 − µ).
The variance of this strategy is determined by the
mean and, therefore, the probabilistic model has
one tunable parameter µ.

Gaussian Random Variables. The number of
placeholder tokens of the input sequence p can
be seen as drawn from an unknown optimal Bino-
mial distribution. We can approximate this Bino-
mial with a normal distribution N (µ, σ2), where
µ is the mean and σ the standard deviation and
they are considered hyperparameters. More for-
mally, for every input sequence, we draw a value
P ∼ N (µ, σ2). Multiplied with the sequence

length |y|, the nearest integer value b(|y| · P )e is
used as the number of placeholder tokens for the
given sequence. The positions of the placeholder
tokens in the sequence are then determined at ran-
dom. The resulting probabilistic model’s two pa-
rameters (mean µ and standard deviation σ) are
treated as hyperparameters and are not updated
during training. Being able to tune the variance
parameter independently from the mean parame-
ter might provide an advantage over the parame-
terization with Bernoulli RVs.

3.2 Sequence Generation Strategies

Starting with a sequence of placeholder tokens at
inference time, it is possible to generate output
token sequences in arbitrary order. We experi-
ment with the following strategies. The distribu-
tion in all of these strategies are the distributions
dt (t = 1, ..., n) for the placeholders over the out-
put vocabulary. We use the term uncover to mean
that an output token is generated for a placeholder
token.

One-step greedy. In a single time step, all
placeholder tokens are uncovered simultaneously
by picking the most probable token from the out-
put vocabulary for each placeholder.

Highest probability. Placeholders are replaced
iteratively and the placeholder to be uncovered is
the placeholder that assigns the highest probability
to a token from the output vocabulary, indicating
the model is the most sure about this token.

Lowest entropy. Placeholders are replaced iter-
atively and the placeholder to be uncovered is the
placeholder that exhibits the lowest entropy over
its output vocabulary distribution and the most
likely token at this position is chosen. Intuitively,
the lowest entropy indicates the position where the
uncertainty of the model to decide between tokens
of the output vocabulary is the lowest.

Left-to-right. Placeholders are replaced itera-
tively, moving from left-to-right and thus mimick-
ing the typical writing style for English. Note that
this approach still differs from the Transformer de-
coders because future tokens are considered via
the placeholder representations.

No look ahead. To test whether future place-
holders hold useful information, we consider an
adversarial sequence generation strategy: Again
we iteratively uncover placeholders from left-to-
right, but we suppress all attention flows from fu-
ture placeholders. This imitates the behaviour of



4

a transformer decoder but follows the idea of pre-
dicting a token on a placeholder, rather than pre-
dicting the next word as is typically done in trans-
former decoders. If this performs worse than left-
to-right, there is indeed valuable information in fu-
ture placeholder tokens.

4 Experiments

We conduct a series of experiments to explore BI-
SON’s behavior. First, we want to compare two to-
ken replacement strategies for training as well as
the four generation strategies for inference. Sec-
ond, we want to compare BISON to state of the art
methods and investigate the impact of its ability to
attend to future tokens.

4.1 Datasets

We run experiments on the two following conver-
sational datasets.

Goal-oriented SHARC (Saeidi et al., 2018).
SHARC is a dialogue, text-based question-
answering dataset. Unlike many popular QA
datasets, answers cannot simply be extracted from
the text. Given a regulatory text, such as a text
from the UK government’s website, and a user
scenario with corresponding question, it is nec-
essary to interpret the text in the context of the
specific user’s needs. Before generating its final
answer, a system may generate clarification ques-
tions. Finally, the system decides if the answer to
the user’s original question is “Yes”, “No” or “Ir-
relevant” where the latter means the question can-
not be answered with the given text.

We perform the evaluation with the official
SHARC script. For a set of generated clarifica-
tion questions, it computes BLEU n-gram scores
for n = 1, 2, 3, 4 using a set of clarification ques-
tion in the set of gold responses. In each step of
the conversation, the model under evaluation gen-
erates an output token sequence. This output is
automatically assigned to the category “More” if
it is a clarification question, and to “Yes”, “No”,
and “Irrelevant” otherwise. Since this is a clas-
sification task we can compute micro and macro
accuracy for it. The final model is chosen using
the highest BLEU-4 score on the development set.

The SHARC dataset has a hidden test set and,
therefore, it is not feasible to evaluate our vari-
ous model variants. Hence, we take 30 unique
rule texts and their corresponding training exam-
ples from the training set. This leads to a new de-

velopment set of 2,465 instances and leaves the of-
ficial development set to be used as a test set here.
Finally we submitted our best model to be evalu-
ated on the hidden test set.

Free-form DAILY DIALOG (Li et al., 2017).
DAILY DIALOG is a dataset of written conversa-
tions occurring in daily life. Following the authors
of the corpus, we report BLEU n-gram scores for
n = 1, 2, 3, 4 for the generated output sequences
with respect to the given gold responses. We tok-
enize these responses equally to ensure a fair com-
parison.

4.2 BISON Settings

We implement BISON based on the BERT Pytorch
code1 and initialize with the pre-trained BERT
model BERT-BASE-UNCASED (Devlin et al.,
2018). Consequently we employ the same model
architecture and tokenisation as (Devlin et al.,
2018) resulting in a model with about 110M pa-
rameters. To remain compatible with the BERT
model, we prepend each sequence with a [CLS]
token and place a [SEP] token after the input con-
text. Similarly, producing a second [SEP] token
indicates the end of sequence generation. For in-
put context of SHARC, we follow Saeidi et al.
(2018) and use the concatenation of question, rule
text, scenario and history. The input context for
DAILY DIALOG is the concatenation of all previ-
ous utterances.

On the SHARC and DAILY DIALOG training
sets we train for 20 and 40 epochs, respectively,
which equates in each case to about 200k seen ex-
amples. As optimizer we used ADAM (Kingma
and Ba, 2015) with β1 = 0.9, β2 = 0.999, a L2
weight decay of 0.01 and a learning rate warm-up
over the first 10% of training steps. As learning
rates we consider both the pre-training learning
rate of BERT 1e-4 and the fine-tuning learning rate
3e-5. On preliminary experiments 3e-5 proved to
be best for SHARC, whereas it is 1e-4 for DAILY
DIALOG. We set the batch size to 15. Finally,
the maximum sequence generation length, is set
to 50 for SHARC and to 100 for DAILY DIALOG,
which was chosen based on values observed in the
training data. As the maximum sequence length
of the BERT model is 512, longer input sequences
are truncated accordingly. For the main results,
we employ the sequence generation strategy left-

1https://github.com/huggingface/
pytorch-pretrained-BERT

https://github.com/huggingface/pytorch-pretrained-BERT
https://github.com/huggingface/pytorch-pretrained-BERT


5

to-right, which we found to work best. Later on
we also report results for the other strategies.

For the Bernoulli RV approach, we test µ ∈
[0.2, 0.8] with increments of 0.1. For the Gaussian
RV approach, we test all possible combinations for
the following hyperparmeters µ = {0.4, 0.5, 0.6}
and σ = {0.3, 0.6, 0.9}. The best combination on
the SHARC dev set is µ = 0.5, σ = 0.6. It out-
performs the best Bernoulli approach (µ = 0.7)
by 3.4 point in BLEU-4 score. Some Bernoulli ex-
periments in fact only produced a very small num-
ber of clarification question, e.g. µ = 0.5 only
generated 9 clarification questions on the develop-
ment set, whereas in the ground truth responses
846 clarification questions occur. This suggests
that a high variance is important, as the Bernoulli
setups all have a variance of 0.25 or lower and
our best Gaussian approach has a variance of 0.6.
We directly employ the Gaussian distribution with
µ = 0.5, σ = 0.6 on the DAILY DIALOG task.

4.3 Baselines

To measure the success of our proposed approach,
we consider the following three baselines.

Encoder-Decoder Transformer (E&D). First,
we compare our bidirectional encoder to a stan-
dard encoder-decoder Transformer where the de-
coder only has access to tokens produced so far
to compute its self-attention. We use the imple-
mentation of OpenNMT (Klein et al., 2017) and
employ the parameters suggested by them, but ad-
just the learning rate to 0.1, which we found to
work better for both datasets. Additionally, we in-
creased the word and hidden dimension size to 768
and the number of attention heads to 12 to match
the capacity of our model. Training ran for 50
epochs. Needing both an encoder and a decoder,
this leads to a total of about 270M parameters.

Encoder-Decoder Transformer with BERT
(E&D+B). The power of our bidirectional decoder
stems from two advantages. First, we can initial-
ize our model with the pre-trained BERT-BASE-
UNCASED model. Second, the decoding process
is bidirectional. It would be possible to transfer
the first advantage to an encoder-decoder frame-
work by using BERT embeddings. This is how-
ever only possible for the input sequence, because
the bidirectionality of BERT requires the entire se-
quence to be available beforehand. Thus, we mod-
ify implementation of OpenNMT to use the BERT
model as the encoder. The weights are frozen

Model Micro
Acc.

Macro
Acc.

B-1 B-4

S
H

A
R

C E&D 31.9 38.9 17.1 1.9

E&D+B 54.7 60.4 24.3 4.3
GPT2 60.4 65.1 53.7 33.9
BISON 64.9 68.8 61.8 46.2

Table 1: Results on the SHARC test set, averaged over
3 independent runs for GPT2 and BISON, reporting mi-
cro accuracy and macro accuracy in terms of the clas-
sification task and BLEU-1 and BLEU-4 on instances
for which a clarification question was generated. E&D
uses no language model pre-training.

Model Micro
Acc.

Macro
Acc.

B-1 B-4

S
H

A
R

C E3 67.6 73.3 54.1 38.7
BISON 66.9 71.6 58.8 44.3

Table 2: Results on the official hidden SHARC test
set of our model compared to the best model on the
leaderboard, E3 (Zhong and Zettlemoyer, 2019).

when training the decoder, which produced bet-
ter results than allowing the gradients to also flow
through the BERT model. Again, with both an en-
coder and decoder, this leads to a total of about
270M parameters.

GPT2. Radford et al. (2019) present a trans-
former decoder, GPT2, trained as a language
model on large amounts of monolingual text. Rad-
ford et al. (2019) showed that it is possible to per-
form various tasks in a zero-shot setting by prim-
ing the language model with an input and letting
it generate further words greedily. This setup can
be transferred to a supervised setting, where the
model is fine-tuned to a dataset by using maximum
likelihood estimation to increase the probability
of the gold output sequence (Wolf et al., 2019).
As the starting point for the supervised learning,
we initialize the model with the pre-trained model
GPT-2-117M released by Radford et al. (2019)2

and then fine-tune. With 117M parameters, this
model is comparable to our model. Unlike base-
line 2, this setup can directly employ a pre-trained
model as our approach can, but it is not bidirec-
tional.

2https://github.com/openai/gpt-2

https://github.com/openai/gpt-2


6

4.4 Results

We report the results of our approach, the various
baselines, as well as the previous state-of-the-art
(SOTA) scores where applicable in Table 1 and 2
for SHARC and in Table 3 for DAILY DIALOG.

On the SHARC dataset, we observe very poor
BLEU-4 performance for the encoder-decoder
Transformer (E&D), which is consistent with re-
sults from Saeidi et al. (2018), who could not
get a LSTM-based network to work without an
additional classification head. Adding BERT
(E&D+B) slightly improves performance. By di-
rectly leveraging a pre-trained model, GPT2 out-
performs the previous models by a large margin,
reaching 33.9% on BLEU-4 and a micro accuracy
of 60.4%. BISON is able to take future tokens into
consideration and outperforms GPT2 by 12.3 per-
centage points in BLEU-4 and by 4.5 points in mi-
cro accuracy.

We submitted the best BISON model out of the
random three of Table 1 to be evaluated on the hid-
den test set and report results in comparison to the
best model on the leaderboard,3 E3 (Zhong and
Zettlemoyer, 2019) in Table 2. BISON outper-
forms E3 by 5.6 BLEU-4 points, while it is only
slightly worse than E3 in terms of accuracy.

On the DAILY DIALOG dataset the information
retrieval-based method (IR in Table 3) introduced
by Li et al. (2017) is very strong and outperforms
the best end-to-end model (E2E) (Luo et al., 2018)
by over 16 percentage points in BLEU-4. The best
end-to-end model is based on LSTMs and Luo
et al. (2018) report performance increases when
adding an attention module to their setup. The
encoder-decoder transformer (E&D) outperforms
this setup by over 2 percentage points in BLEU-
4 and we conjecture that this is due to the trans-
former making more effective use of the attention
principle. Adding BERT (E&D+B) does not help
much for this dataset. But again we observe a large
increase of performance when directly employing
pre-trained models. GPT2 performs on par with
the IR SOTA, achieving a BLEU-4 score of 19.4%.
Again, BISON can outperform GPT2, here with a
difference of 6.2 points in BLEU-4 and even larger
increases in the other scores.

Effect of bidirectionality. To investigate that
our model benefits from bidirectionality, we con-
sider a setup where BISON isn’t allowed to attend

3https://sharc-data.github.io/
leaderboard.html, 19 August 2019

Model B-1 B-2 B-3 B-4

D
A

IL
Y

D
IA

L
O

G IR - 25.8 20.4 19.4
E2E 14.2 5.7 3.8 2.8
E&D 22.3 6.8 5.7 5.2

E&D+B 26.1 7.3 6.0 5.5
GPT2 42.3 23.6 20.7 19.4
BISON 54.9 32.6 28.0 25.6

Table 3: BLEU n-gram scores for n = 1, 2, 3, 4 on the
DailyDialog test set, averaged over 3 independent runs
for GPT2 and BISON. Models before the line do not
make use of a pre-trained language model. IR (SOTA)
(Li et al., 2017) and E2E (SOTA) (Luo et al., 2018)
are, to the best of our knowledge, the best previously
published scores for information retrieval and end-to-
end approaches.

Model Micro
Acc.

Macro
Acc.

B-1 B-4
S

H
A

R
C BISON 64.9 68.8 61.8 46.2

past only 64.3 67.4 35.0 21.3

Model B-1 B-2 B-3 B-4

D
D BISON 54.9 32.6 28.0 25.6

past only 48.0 24.6 18.5 14.8

Table 4: Comparison of BISON to a setup where BI-
SON isn’t allowed to attend to future tokens, i.e. past
only, for SHARC and DAILY DIALOG (DD).

to future tokens during prediction (see Table 4).
It causes a drop in BLEU-4 performance of about
25 points on the SHARC dataset and a drop of 10
points on the DAILY DIALOG dataset. This show-
cases that BISON during training has learnt to rely
on the ability to attend to future tokens.

Effect of pre-trained model. We are curi-
ous how big the effect of the pre-trained model
is. Thus, instead of starting with the BERT-BASE-
UNCASED weights, we initialize BISON with ran-
dom weights drawn from a normal distribution
with mean 0.0 and standard deviation of 0.02. Re-
sults are presented in Table 5 for SHARC and
DAILY DIALOG. Even without a pre-trained lan-
guage model, our approach can outperform the
standard encoder-decoder transformer framework
(E&D) on both datasets, although we had to in-
crease the number of epochs for the SHARC
dataset to 40. On the DAILY DIALOG task, we are
even able to outperform GPT2. This demonstrates

https://sharc-data.github.io/leaderboard.html
https://sharc-data.github.io/leaderboard.html


7

Model Micro
Acc.

Macro
Acc.

B-1 B-4
S

H
A

R
C E&D 31.9 38.9 17.1 1.9

BISON 52.9 57.4 21.9 2.3

Model B-1 B-2 B-3 B-4

D
D E&D 22.3 6.8 5.7 5.2

BISON 46.3 27.0 23.6 22.4

Table 5: Best end-to-end models that do not use a
pre-trained language model in comparison with BISON
that uses randomly initialized weights for SHARC and
DAILY DIALOG (DD), averaged over 3 runs.

Strategy SHARC DAILY DIALOG

one step greedy 22.9 9.3
lowest entropy 40.3 16.8
highest probability 50.9 16.4
left-to-right 46.2 23.8

Table 6: BLEU-4 using various sequence generation
strategies for BISON on SHARC and DAILY DIALOG.

the effectiveness of our approach in itself, free of
any pre-trained language model.

Effect of sequence generation strategies. We
present the different sequence generation strate-
gies in Table 6. The best overall sequence genera-
tion strategy is to predict from left to right which
achieves good results on both datasets. On the
SHARC dataset the highest probability approach
performs better than left-to-right. However, on
DAILY DIALOG this approach is not as successful.
This suggests that it might be worth selecting the
best sequence generation strategy for each dataset
individually. However, we hypothesize that left-
to-right works consistently well due to the left-to-
right nature of the English language. A brief ex-
periment with a right-to-left strategy gave poor re-
sults.

5 Analysis

We believe that the placeholders capture sequen-
tial information present in the language model
learned during pre-training. After running a trans-
former encoder where each position can attend
to every other position, a placeholder token will
have a probability distribution over the output vo-
cabulary and this distribution is informed by all
other tokens in input and output. Thus, a place-

Dataset α1 α2 α3

SHARC 92.6±3.1 5.2±2.4 2.2±1.8
DD 97.0±2.5 2.3±2.3 0.7±0.4

ᾱ2 ᾱ3

SHARC - 71.7±13.7 28.3±13.7
DD - 70.2±14.5 29.8±14.5

Table 7: Average attention weights and standard de-
viation when predicting from left-to-right on both
SHARC and DAILY DIALOG (DD) for different parts
of the sequence, where α1 is for the input sequence
x, α2/ᾱ2 is for the already produced sequence y and
α3/ᾱ3 is for the sequence of remaining placeholder to-
kens p. αk are the normalized attention weights across
all three parts, whereas ᾱk normalizes over the second
and third part.

holder could be seen as a mixture of tokens with
varying probabilities. As placeholders are subse-
quently uncovered, the other placeholders can up-
date their distribution by taking the newly revealed
token into consideration.

For example, in Figure 2, for the sentence“is
the animal an endangered animal ?”, while gen-
erating “endangered”, the self-attention head pays
attention to the next placeholder token, which in
the next step is revealed to be “animal”. While
producing “endangered”, the distribution for the
next position already placed a high probability on
“animal”, thus the current token can take this into
consideration and produces “endangered”. Further
heat maps demonstrating this can be found in the
appendix.

The quantify this intuition, we measure the av-
erage attention score on various parts of the se-
quence. For this, we use the left-to-right predic-
tion strategy. Thus, at time t, we can decompose
our sequence into three parts: s = x⊕y⊕p, where
x is the input, y the already produced sequence
and p the remaining sequence of placeholder to-
kens. For each attention head, we can decompose
the attention probabilities into the three parts,

1. attention on the input text,

2. attention on the current word and already
generated words (left of the current word),

3. attention on words that are yet to be generated
(right of the current word).



8

Figure 2: Heat map (darker hues indicate higher atten-
tion) that shows an example of where an attention head
looks into the future while generating from left to right.
Each row shows the attention over the output sequence
for this row’s placeholder token at that point in time.
Word in previous rows have been produced already,
whereas words of later rows still hold placeholder to-
kens. Thus the upper triangle of the matrix shows the
attention that is paid to future tokens. The red square
shows that while generating the token “endangered”,
the attention head already takes the next placeholder
into account, which is revealed to be “animal” in the
next step. Best viewed in color.

This is mathematically expressed as

at = a0:|x| ⊕ a|x|+1:|x|+t ⊕ a|x|+t+1,|s|,

where |s| is the maximum possible sequence
length. For each part we can calculate an average
leading to three values, a1t , a

2
t and a

3
t .

Averaged over all T generation time steps and
all D data points, we can derive a score for each
part k, k = 1, 2, 3 and each attention head h:

αkh =
1

D

1

T

D∑
d=1

T∑
t=1

akd,t

Note that we use the attention heads in the final
BERT self-attention layer. Averaging over all H
attention heads, αk = 1H

∑H
h=1 α

k
h, leads to the

results reported in Table 7 for both datasets. Un-
surprisingly, we find that with scores of over 90%
for both datasets the majority of the attention is fo-
cused on the first part, i.e. the conditioning input
x (see α1 in Table 7). The remaining attention is
split between the already produced sequence (α2)
and the future tokens (α3).

To directly compare the relationship within the
sequence generation, we re-normalize over α2 and
α3, leading to new values ᾱ2 and ᾱ3 (see Table 7).
Here we can see that the past, already produced
tokens are about twice as important as the future,
not-yet-produced tokens. But with scores of just
under 30% on both datasets, we see that a sub-
stantial amount of attention is also focused on the
future, not-yet-produced tokens.

Interestingly, with a standard deviation of about
14%, the values of ᾱ2 and ᾱ3 vary strongly across
the different attention heads. For example on the
SHARC dataset, we find one attention head where
only about 9% is focused on the future and another
where it is about 64% and thus this attention head
pays more attention to the future than the past. A
graphical overview can be found in the appendix
for both datasets.

6 Related Work

Transformers (Vaswani et al., 2017) model se-
quences as fully connected graphs and apply a
bidirectional self-attention module where every
token can attend to every other token. Because
of this a Transformer is not restricted to sequen-
tial orderings. However, Vaswani et al. (2017); in-
ter alia still restrict themselves to producing to-
kens from left-to-right and only allow a Trans-
former decoder to attend to previously produced
tokens. Recently, several attempts have been made
to lift the left-to-right restriction in Transformer or
LSTM-based models (Gu et al., 2019; Stern et al.,
2019; Welleck et al., 2019; Zhou et al., 2019), but
in those approaches it is not possible to attend to
future, not-yet-produced tokens.

Concurrently to our work, (Ghazvininejad et al.,
2019) proposed a similar placeholder strategy ap-
proach for generating in the context of machine
translation. However, they employ an encoder-
decoder framework, whereas we only require an
encoder, which more closely links input and out-
put via a single shared attention module. Fur-
thermore, they only consider uniform sampling
of placeholders whereas we found that the higher
variance, which we can control with the Gaussian
random variable approach, leads to better results.

Bidirectionality is one of the crucial ingredients
in the success of the recently proposed unsuper-
vised language model BERT (Devlin et al., 2018).
For this, Devlin et al. (2018) propose a Trans-
former encoder to take full advantage of the bidi-



9

rectional nature of the Transformer. Their result-
ing model, BERT, can directly be applied to var-
ious classification tasks but not to sequence gen-
eration tasks. Our approach shows how a Trans-
former encoder can be used for sequence gener-
ation and this allows us to directly incorporate
BERT into our experiments.

GPT (Radford et al., 2018) and GPT2 (Radford
et al., 2019) are both pre-trained language mod-
els that use a Transformer decoder instead, which
can only attend to already produced tokens. For
dialogue, the GPT model has been fine-tuned for
the chit-chat dataset PersonaChat (Zhang et al.,
2018) by Wolf et al. (2019). While GPT and GPT2
can immediately be used as a sequence generators,
these models do not offer bidirectionality and they
cannot attend to not-yet-produced tokens. Our
bidirectional encoder for sequence generation can
combine the best of both worlds.

7 Conclusion

We introduced bidirectional sequence generation
by employing placeholders in the output sequence.
These placeholder tokens are subsequently re-
placed by tokens of the output vocabulary. Cru-
cially, this allows a transformer encoder to attend
to both past and future, not-yet-produced token.
Simply masking all placeholder tokens is not fea-
sible. Instead we investigated two placeholder
strategies, based on Bernoulli and Gaussian ran-
dom variables. At prediction time, our approach is
not restricted to produce the output sequence from
left to right. However, this strategy proved to pro-
duce most consistent results in our experiments.

Our approach outperforms previous end-to-end
approaches that do not make use of any pre-
trained language models. In conjunction with the
pre-trained language model BERT, our bidirec-
tional sequence generation approach allows us to
achieve new state-of-art results on both conversa-
tional tasks. In the future, we would like to apply
our approach to other sequence generation tasks.
Additionally, we wonder if a further performance
increase could be achieved if the pre-training of
BERT would employ our placeholder strategy.

References
Jacob Devlin, Ming-Wei Chang, Kenton Lee, and

Kristina Toutanova. 2018. BERT: pre-training of
deep bidirectional transformers for language under-
standing. ArXiv e-prints, 1810.04805.

Marjan Ghazvininejad, Omer Levy, Yinhan Liu, and
Luke Zettlemoyer. 2019. Constant-Time Machine
Translation with Conditional Masked Language
Models. arXiv:1904.09324 [cs, stat]. ArXiv:
1904.09324.

Jiatao Gu, Qi Liu, and Kyunghyun Cho. 2019.
Insertion-based decoding with automatically in-
ferred generation order. CoRR, abs/1902.01370.

Diederick P Kingma and Jimmy Ba. 2015. Adam:
A method for stochastic optimization. In Inter-
national Conference on Learning Representations
(ICLR), San Diego, CA, USA.

G. Klein, Y. Kim, Y. Deng, J. Senellart, and A. M.
Rush. 2017. OpenNMT: Open-Source Toolkit
for Neural Machine Translation. ArXiv e-prints,
1701.02810.

Yanran Li, Hui Su, Xiaoyu Shen, Wenjie Li, Ziqiang
Cao, and Shuzi Niu. 2017. Dailydialog: A manually
labelled multi-turn dialogue dataset. In Proceedings
of the Eighth International Joint Conference on Nat-
ural Language Processing (IJCNLP), Taipei, Tai-
wan.

Liangchen Luo, Jingjing Xu, Junyang Lin, Qi Zeng,
and Xu Sun. 2018. An auto-encoder matching
model for learning utterance-level semantic depen-
dency in dialogue generation. In Proceedings of the
2018 Conference on Empirical Methods in Natural
Language Processing (EMNLP).

Alec Radford, Karthik Narasimhan, Tim Salimans, and
Ilya Sutskever. 2018. Improving Language Under-
standing by Generative Pre-Training. Technical Re-
port Technical report, OpenAI.

Alec Radford, Jeffrey Wu, Rewon Child, David Luan,
and Dario Amodei. 2019. Language Models are
Unsupervised Multitask Learners. Technical report,
OpenAI.

Marzieh Saeidi, Max Bartolo, Patrick Lewis, Sameer
Singh, Tim Rocktäschel, Mike Sheldon, Guillaume
Bouchard, and Sebastian Riedel. 2018. Interpreta-
tion of natural language rules in conversational ma-
chine reading. In Proceedings of the 2018 Con-
ference on Empirical Methods in Natural Language
Processing (EMNLP).

Mitchell Stern, William Chan, Jamie Kiros, and Jakob
Uszkoreit. 2019. Insertion transformer: Flexible se-
quence generation via insertion operations. CoRR,
abs/1902.03249.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Ł ukasz
Kaiser, and Illia Polosukhin. 2017. Attention is All
you Need. In Advances in Neural Information Pro-
cessing Systems 30 (NIPS).

Sean Welleck, Kianté Brantley, Hal Daumé III, and
Kyunghyun Cho. 2019. Non-monotonic sequential
text generation. CoRR, abs/1902.02192.

http://arxiv.org/abs/1810.04805
http://arxiv.org/abs/1810.04805
http://arxiv.org/abs/1810.04805
http://arxiv.org/abs/1904.09324
http://arxiv.org/abs/1904.09324
http://arxiv.org/abs/1904.09324
http://arxiv.org/abs/1902.01370
http://arxiv.org/abs/1902.01370
https://arxiv.org/abs/1412.6980
https://arxiv.org/abs/1412.6980
https://arxiv.org/abs/1701.02810
https://arxiv.org/abs/1701.02810
http://aclweb.org/anthology/I17-1099
http://aclweb.org/anthology/I17-1099
http://aclweb.org/anthology/D18-1075
http://aclweb.org/anthology/D18-1075
http://aclweb.org/anthology/D18-1075
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf
https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf
https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf
http://aclweb.org/anthology/D18-1233
http://aclweb.org/anthology/D18-1233
http://aclweb.org/anthology/D18-1233
http://arxiv.org/abs/1902.03249
http://arxiv.org/abs/1902.03249
http://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf
http://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf
http://arxiv.org/abs/1902.02192
http://arxiv.org/abs/1902.02192


10

Thomas Wolf, Victor Sanh, Julien Chaumond, and
Clement Delangue. 2019. TransferTransfo: A
Transfer Learning Approach for Neural Network
Based Conversational Agents. ArXiv e-prints,
1901.08149.

Saizheng Zhang, Emily Dinan, Jack Urbanek, Arthur
Szlam, Douwe Kiela, and Jason Weston. 2018. Per-
sonalizing dialogue agents: I have a dog, do you
have pets too? In Proceedings of the 56th Annual
Meeting of the Association for Computational Lin-
guistics (ACL), Melbourne, Australia.

Victor Zhong and Luke Zettlemoyer. 2019. E3:
Entailment-driven extracting and editing for conver-
sational machine reading. In Proceedings of the
57th Annual Meeting of the Association for Compu-
tational Linguistics, Florence, Italy.

Long Zhou, Jiajun Zhang, and Chengqing Zong. 2019.
Synchronous bidirectional neural machine transla-
tion. Transactions of the Association for Compu-
tational Linguistics, 7:91–105.

http://arxiv.org/abs/1901.08149
http://arxiv.org/abs/1901.08149
http://arxiv.org/abs/1901.08149
https://www.aclweb.org/anthology/P18-1205
https://www.aclweb.org/anthology/P18-1205
https://www.aclweb.org/anthology/P18-1205
https://www.aclweb.org/anthology/P19-1223
https://www.aclweb.org/anthology/P19-1223
https://www.aclweb.org/anthology/P19-1223
https://doi.org/10.1162/tacl_a_00256
https://doi.org/10.1162/tacl_a_00256

