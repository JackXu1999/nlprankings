



















































Embedding Lexical Features via Low-Rank Tensors


Proceedings of NAACL-HLT 2016, pages 1019–1029,
San Diego, California, June 12-17, 2016. c©2016 Association for Computational Linguistics

Embedding Lexical Features via Low-Rank Tensors

Mo Yu∗
Harbin Institute of Technology

IBM Watson
yum@us.ibm.com

Mark Dredze
HLTCOE

Johns Hopkins University
mdredze@cs.jhu.edu

Raman Arora
Johns Hopkins University
arora@cs.jhu.edu

Matthew R. Gormley
Carnegie Mellon University
mgormley@cs.cmu.edu

Abstract

Modern NLP models rely heavily on engi-
neered features, which often combine word
and contextual information into complex lexi-
cal features. Such combination results in large
numbers of features, which can lead to over-
fitting. We present a new model that repre-
sents complex lexical features—comprised of
parts for words, contextual information and
labels—in a tensor that captures conjunction
information among these parts. We apply low-
rank tensor approximations to the correspond-
ing parameter tensors to reduce the parame-
ter space and improve prediction speed. Fur-
thermore, we investigate two methods for han-
dling features that include n-grams of mixed
lengths. Our model achieves state-of-the-art
results on tasks in relation extraction, PP-
attachment, and preposition disambiguation.

1 Introduction

Statistical NLP models usually rely on hand-
designed features, customized for each task. These
features typically combine lexical and contextual in-
formation with the label to be scored. In relation
extraction, for example, there is a parameter for the
presence of a specific relation occurring with a fea-
ture conjoining a word type (lexical) with depen-
dency path information (contextual). In measur-
ing phrase semantic similarity, a word type is con-
joined with its position in the phrase to signal its
role. Figure 1b shows an example in dependency
parsing, where multiple types (words) are conjoined
with POS tags or distance information.

∗Paper submitted during Mo Yu’s PhD study at HIT.

To avoid model over-fitting that often results from
features with lexical components, several smoothed
lexical representations have been proposed and
shown to improve performance on various NLP
tasks; for instance, word embeddings (Bengio et al.,
2006) help improve NER, dependency parsing and
semantic role labeling (Miller et al., 2004; Koo et
al., 2008; Turian et al., 2010; Sun et al., 2011; Roth
and Woodsend, 2014; Hermann et al., 2014).

However, using only word embeddings is not suf-
ficient to represent complex lexical features (e.g. φ
in Figure 1c). In these features, the same word em-
bedding conjoined with different non-lexical prop-
erties may result in features indicating different la-
bels; the corresponding lexical feature representa-
tions should take the above interactions into consid-
eration. Such important interactions also increase
the risk of over-fitting as feature space grows ex-
ponentially, yet how to capture these interactions in
representation learning remains an open question.

To address the above problems,1 we propose a
general and unified approach to reduce the feature
space by constructing low-dimensional feature rep-
resentations, which provides a new way of combin-
ing word embeddings, traditional non-lexical prop-
erties, and label information. Our model exploits
the inner structure of features by breaking the fea-
ture into multiple parts: lexical, non-lexical and (op-
tional) label. We demonstrate that the full feature is
an outer product among these parts. Thus, a param-
eter tensor scores each feature to produce a predic-
tion. Our model then reduces the number of param-

1Our paper only focuses on lexical features, as non-lexical
features usually suffer less from over-fitting.

1019



1 

0 
1 

0 

ϕ =wg ∧wc ∧ u ∧	 y 

“see” “PMOD” “telescope” 

postag(g+1) =“DT” 

telescope see with 

PMOD? 

a a    girl 

 
word(c)∧word(g) 

word(c)∧postag(g) 
word(p)∧word(g) 

word(c)∧postag(g+1) 
word(c)∧word(g)∧postag(g+1) 

word(c)∧word(g)∧distance(g, p) 
… 

c p g 

0 

bc cts wl
Model P R F1 P R F1 P R F1
HeadEmb
CNN (wsize=1) + local features
CNN (wsize=3) + local features
FCT local only
FCT global 60.69 42.39 49.92 56.41 34.45 42.78 41.95 31.77 36.16
FCT global (Brown) 63.15 39.58 48.66 62.45 36.47 46.05 54.95 29.93 38.75
FCT global (WordNet) 59.00 44.79 50.92 60.20 39.60 47.77 50.95 34.18 40.92
PET (Plank and Moschitti, 2013) 51.2 40.6 45.3 51.0 37.8 43.4 35.4 32.8 34.0
BOW (Plank and Moschitti, 2013) 57.2 37.1 45.0 57.5 31.8 41.0 41.1 27.2 32.7
Best (Plank and Moschitti, 2013) 55.3 43.1 48.5 54.1 38.1 44.7 39.9 35.8 37.8

Table 7: Performance on ACE2005 test sets. The first part of the table shows the performance of different models on
different sources of entity types, where ”G” means that the gold types are used and ”P” means that we are using the
predicted types. The second part of the table shows the results under the low-resource setting, where the entity types
are unknown.

Dev MRR Test MRR
Model Fine-tuning 1,000 10,000 100,000 1,000 10,000 100,000
SUM - 46.95 35.29 30.69 52.63 41.19 37.32
SUM Y 50.81 36.81 32.92 57.23 45.01 41.23
Best Recursive NN (d=50) Y 45.67 30.86 27.05 54.84 39.25 35.49
Best Recursive NN (d=200) Y 48.97 33.50 31.13 53.59 40.50 38.57
FCT N 47.53 35.58 31.31 54.33 41.96 39.10
FCT Y 51.22 36.76 33.59 61.11 46.99 44.31
FCT + LM - 49.43 37.46 32.22 53.56 42.63 39.44
FCT + LM +supervised Y 53.82 37.48 34.43 65.47 49.44 45.65

joint 56.53 41.41 36.45 68.52 51.65 46.53

Table 8: Performance on the semantic similarity task with PPDB data.

Appendix 1: Features Used in FCT

7.1 Overall performances on ACE 2005

SUM(AB) 6= SUM(BA) (7)

2n
2 |V |n (8)

A A0 of B0 B (9)

A B A0 of B0 (10)

T � f � e) Relations (11)
f ⌦ e [f : e]
FCT CNN

@`

@R

@`

@T
=

@`

@R

@R

@T

L1, L2

@L

@R
=

@L1
@R

+
@L2
@R

s(l, e1, e2, S; T ) =
nX

i=1

s(l, ewi , fwi)

=
nX

i=1

Tl � fwi � ewi (12)

@`

@T
=

nX
i=1

@`

@R
⌦ fwi ⌦ ewi , (13)

v2(wc)=1 
v3(u)=1 

v4(y)=1 

0 

v1(wg)=1 

1 

0 

0 
1 

0 

0 

(a) (b) (c) (d) 

Figure 1: An example of lexical features used in dependency parsing. To predict the “PMOD” arc (the dashed one)
between “see” and “with” in (a), we may rely on lexical features in (b). Here p, c, g are indices of the word “with”,
its child (“telescope”) and a candidate head. Figure (c) shows what the fifth feature (φ) is like, when the candidate is
“see”. As is common in multi-class classification tasks, each template generates a different feature for each label y.
Thus a feature φ = wg ∧ wc ∧ u ∧ y is the conjunction of the four parts. Figure (d) is the one-hot representation of
φ, which is equivalent to the outer product (i.e. a 4-way tensor) among the four one-hot vectors. v(x) = 1 means the
vector v has a single non-zero element in the x position.

eters by approximating the parameter tensor with a
low-rank tensor: the Tucker approximation of Yu
et al. (2015) but applied to each embedding type
(view), or the Canonical/Parallel-Factors Decompo-
sition (CP). Our models use fewer parameters than
previous work that learns a separate representation
for each feature (Ando and Zhang, 2005; Yang and
Eisenstein, 2015). CP approximation also allows for
much faster prediction, going from a method that is
cubic in rank and exponential in the number of lex-
ical parts, to a method linear in both. Furthermore,
we consider two methods for handling features that
rely on n-grams of mixed lengths.

Our model makes the following contributions
when contrasted with prior work:

Lei et al. (2014) applied CP to combine different
views of features. Compared to their work, our us-
age of CP-decomposition is different in the applica-
tion to feature learning: (1) We focus on dimension-
ality reduction of existing, well-verified features,
while Lei et al. (2014) generates new features (usu-
ally different from ours) by combining some “atom”
features. Thus their work may ignore some useful
features; it relies on binary features as supplemen-
tary but our model needs not. (2) Lei et al. (2014)’s
factorization relies on views with explicit meanings,
e.g. head/modifier/arc in dependency parsing, mak-
ing it less general. Therefore its applications to tasks
like relation extraction are less obvious.

Compared to our previous work (Gormley et al.,
2015; Yu et al., 2015), this work allows for higher-
order interactions, mixed-length n-gram features,

lower-rank representations. We also demonstrate the
strength of our new model via applications to new
tasks.

The resulting method learns smoothed feature
representations combining lexical, non-lexical and
label information, achieving state-of-the-art perfor-
mance on several tasks: relation extraction, preposi-
tion semantics and PP-attachment.

2 Notation and Definitions

We begin with some background on notation and
definitions. Let T ∈ Rd1×···×dK be a K-way ten-
sor (i.e., a tensor with K views). In this paper,
we consider the tensor k-mode product, i.e. mul-
tiplying a tensor T ∈ Rd1×···×dK by a matrix x ∈
Rdk×J (or a vector if J = 1) in mode (view) k.
The product is denoted by T ×k x and is of size
d1 × · · · × dk−1 × J × dk+1 × · · · × dK . Element-
wise, we have

(T ×k x)i1...ik−1 j ik+1...iK =
dk∑
ik=1

Ti1...ik...iKxikj ,

for j = 1, . . . , J . A mode-k fiber Ti1...ik−1•ik+1...iK
of T is the dk dimensional vector obtained by fixing
all but the kth index. The mode-k unfolding T(k) of
T is the dk ×

∏
i 6=k di matrix obtained by concate-

nating all the
∏
i 6=k di mode-k fibers along columns.

Given two matrices W1 ∈ Rd1×r1 ,W2 ∈ Rd2×r2 ,
we write W1 ⊗W2 to denote the Kronecker product
between W1 and W2 (outer product for vectors). We
define the Frobenius product (matrix dot product)
A � B = ∑i,j AijBij between two matrices with

1020



the same sizes; and define element-wise (Hadamard)
multiplication a ◦ b between vectors with the same
sizes.

Tucker Decomposition: Tucker Decomposition
represents a d1 × d2 × . . .× dK tensor T as:

T = g ×1 W1 ×2 W2 . . .×K WK (1)

where each ×i is the tensor i-mode product and
each Wi is a ri × di matrix. Tensor g with size
r1 × r2 × . . . × rK is called the core tensor. We
say that T has a Tucker rank (r(1), r(2), . . . , r(K)),
where r(i) = rank(T(i)) is the rank of mode-i un-
folding. To simplify learning, we define the Tucker
rank as r(i)=rank(g(i)), which can be bounded sim-
ply by the dimensions of g, i.e. r(i) ≤ ri; this allows
us to enforce a rank constraint on T simply by re-
stricting the dimensions ri of g, as described in §6.
CP Decomposition: CP decomposition represents
a d1×d2×. . .×dK tensor T as a sum of rank-one
tensors (i.e. a sum of outer products of K vectors):

T =
r∑
j=1

W1[j, :]⊗W2[j, :]⊗ . . .⊗WK [j, :] (2)

where each Wi is an r × di matrix and Wi[j, :] is the
vector of its j-th row. For CP decomposition, the
rank r of a tensor T is defined to be the number of
rank-one tensors in the decomposition. CP decom-
position can be viewed as a special case of Tucker
decomposition in which r1 = r2 = . . . = rK = r
and g is a superdiagonal tensor.

3 Factorization of Lexical Features

Suppose we have feature φ that includes information
from a label y, multiple lexical items w1, . . . ,wn
and non-lexical property u. This feature can be fac-
torized as a conjunction of each part: φ = y ∧ u ∧
w1∧. . .∧wn. The feature fires when all (n+2) parts
fire in the instance (reflected by the ∧ symbol in φ).
The one-hot representation of φ can then be viewed
as a tensor eφ = y⊗ u⊗w1⊗ · · · ⊗wn, where each
feature part is also represented as a one-hot vector.2

Figure 1d illustrates this case with two lexical parts.
Given an input instance x and its associated la-

bel y, we can extract a set of features S(x, y). In
2u, y, wi denote one-hot vectors instead of symbols.

a traditional log-linear model, we view the instance
x as a bag-of-features, i.e. a feature vector F (x, y).
Each dimension corresponds to a feature φ, and has
value 1 if φ ∈ S(x, y). Then the log-linear model
scores the instance as s(x, y;w) = wTF (x, y) =∑

φ∈S(x,y) s(φ;w), where w is the parameter vec-
tor. We can re-write s(x, y;w) based on the factor-
ization of the features using tensor multiplication; in
which w becomes a parameter tensor T :

s(x, y;w) = s(x, y; T ) =
∑

φ∈S(x,y)
s(φ; T ) (3)

Here each φ has the form (y, u,w1, . . . ,wn), and

s(φ; T ) = T ×l y×f u×w1 w1...×wn wn. (4)
Note that one-hot vectors wi of words themselves

are large (|wi| > 500k), thus the above formulation
with parameter tensor T can be very large, making
parameter estimation difficult. Instead of estimating
only the values of the dimensions which appear in
training data as in traditional methods, we will re-
duce the size of tensor T via a low-rank approxima-
tion. With different approximation methods, (4) will
have different equivalent forms, e.g. (6), (7) in §4.1.
Optimization objective: The loss function ` for
training the log-linear model uses (3) for scores, e.g.,
the log-loss `(x, y; T ) = − log exp{s(x,y;T )}∑

y′∈L exp{s(x,y′;T )} .
Learning can be formulated as the following opti-
mization problem:

minimize:
T

∑
(x,y)∈D

`(x, y; T )

subject to:


rank(T ) ≤ (r1, r2, ..., rn+2)

(Tucker-form)
rank(T ) ≤ r (CP-form)

(5)

where the constraints on rank(T ) depend on the cho-
sen tensor approximation method (§2).

The above framework has some advantages: First,
as discussed in §1 and here, we hope the represen-
tations capture rich interactions between different
parts of the lexical features; the low-rank tensor ap-
proximation methods keep the most important inter-
action information of the original tensor, while sig-
nificantly reducing its size. Second, the low-rank
structure will encourage weight-sharing among lex-
ical features with similar decomposed parts, leading

1021



to better model generalization. Note that there are
examples where features have different numbers of
multiple lexical parts, such as both unigram and bi-
gram features in PP-attachment. We will use two
different methods to handle these features (§5).
Remarks (advantages of our factorization)
Compared to prior work, e.g. (Lei et al., 2014;
Lei et al., 2015), the proposed factorization has the
following advantages:

1. Parameter explosion when mapping a view
with lexical properties to its representation vec-
tor (as will be discussed in 4.3): Our factoriza-
tion allows the model to treat word embeddings
as inputs to the views of lexical parts, dramati-
cally reducing the parameters. Prior work can-
not do this since its views are mixtures of lexi-
cal and non-lexical properties. Note that Lei et
al. (2014) uses embeddings by concatenating
them to specific views, which increases dimen-
sionality, but the improvement is limited.

2. No weight-sharing among conjunctions with
same lexical property, like the child-word
“word(c)” and its conjunction with head-postag
“word(c) ∧ word(g)” in Figure 1(b). The fac-
torization in prior work treats them as indepen-
dent features, greatly increasing the dimension-
ality. Our factorization builds representations
of both features based on the embedding of
“word(c)”, thus utilizing their connections and
reducing the dimensionality.

The above advantages are also key to overcome the
problems of prior work mentioned at the end of §1.

4 Feature Representations via Low-rank
Tensor Approximations

Using one-hot encodings for each of the parts of fea-
ture φ results in a very large tensor. This section
shows how to compute the score in (4) without con-
structing the full feature tensor using two tensor ap-
proximation methods (§4.1 and §4.2).

We begin with some intuition. To score the orig-
inal (full rank) tensor representation of φ, we need
a parameter tensor T of size d1 × d2 × . . . × dn+2,
where d3 = · · · = dn+2 = |V | is the vocabulary
size, n is the number of lexical parts in the feature

and d1 = |L| and d2 = |F | are the number of
different labels and non-lexical properties, respec-
tively. (§5 will handle n varying across features.)
Our methods reduce the tensor size by embedding
each part of φ into a lower dimensional space, where
we represent each label, non-lexical property and
words with an r1, r2, r3, . . . , rn+2 dimensional vec-
tor respectively (ri � di, ∀i). These embedded
features can then be scored by much smaller ten-
sors. We denote the above transformations as ma-
trices Wl ∈ Rr1×d1 , Wf ∈ Rr2×d2 , Wi ∈ Rri+2×di+2
for i = 1, . . . , n, and write corresponding low-
dimensional hidden representations as h(l)y = Wly,
h(f)u = Wfu and h

(i)
w = Wiw.

In our methods, the above transformations of em-
beddings are parts of low-rank tensors as in (5),
so the embeddings of non-lexical properties and la-
bels can be trained simultaneously with the low-rank
tensors. Note that for one-hot input encodings the
transformation matrices are essentially lookup ta-
bles, making the computation of these transforma-
tions sufficiently fast.

4.1 Tucker Form

For our first approximation, we assume that tensor
T has a low-rank Tucker decomposition: T = g ×l
Wl ×f Wf ×w1 W1 ×w2 · · · ×wn Wn. We can then
express the scoring function (4) for a feature φ =
(y, u,w1, . . .wn) with n-lexical parts, as:

s(y, u,w1, · · · ,wn; g,Wl,Wf , {Wi}ni=1)
= g ×l h(l)y ×f h(f)u ×w1 h(1)w1 · · · ×wn h(n)wn , (6)

which amounts to first projecting u, y, and wi (for
all i) to lower dimensional vectors h(f)u ,h

(l)
y ,h

(i)
wi ,

and then weighting these hidden representations us-
ing the flattened core tensor g. The low-dimensional
representations and the corresponding weights are
learned jointly using a discriminative (supervised)
criterion. We call the model based on this repre-
sentation the Low-Rank Feature Representation with
Tucker form, or LRFRn-TUCKER.

4.2 CP Form

For the Tucker approximation the number of param-
eters in (6) scale exponentially with the number of
lexical parts. For instance, suppose each h(i)wi has di-

1022



mensionality r, then |g| ∝ rn. To address scalabil-
ity and further control the complexity of our tensor
based model, we approximate the parameter tensor
using CP decomposition as in (2), resulting in the
following scoring function:

s(y, u,w1, · · · ,wn; Wl,Wf , {Wi}ni=1) =
r∑
j=1

(
h(l)y ◦ h(f)u ◦ h(1)w1 ◦ · · · ◦ h(n)wn

)
j
. (7)

We call this model Low-Rank Feature Representa-
tion with CP form (LRFRn-CP).

4.3 Pre-trained Word Embeddings
One of the computational and statistical bottlenecks
in learning these LRFRn models is the vocabulary
size; the number of parameters to learn in each ma-
trix Wi scales linearly with |V | and would require
very large sets of labeled training data. To alle-
viate this problem, we use pre-trained continuous
word embeddings (Mikolov et al., 2013) as input
embeddings rather than the one-hot word encodings.
We denote the m-dimensional word embeddings by
ew; so the transformation matrices Wi for the lexical
parts are of size ri ×m where m� |V |.

We note that when sufficiently large labeled data
is available, our model allows for fine-tuning the
pre-trained word embeddings to improve the expres-
sive strength of the model, as is common with deep
network models.

Remarks Our LRFRs introduce embeddings for
non-lexical properties and labels, making them bet-
ter suit the common setting in NLP: rich linguistic
properties; and large label sets such as open-domain
tasks (Hoffmann et al., 2010). The LRFR-CP better
suits n-gram features, since when n increases 1, the
only new parameters are the corresponding Wi. It is
also very efficient during prediction (O(nr)), since
the cost of transformations can be ignored with the
help of look-up tables and pre-computing.

5 Learning Representations for n-gram
Lexical Features of Mixed Lengths

For features with n lexical parts, we can train an
LRFRn model to obtain their representations. How-
ever, we often have features of varying n (e.g. both
unigrams (n=1) and bigrams (n=2) as in Figure 1).

We require representations for features with arbi-
trary different n simultaneously.

We propose two solutions. The first is a straight-
forward solution based on our framework, which
handles each nwith a (n+2)-way tensor. This strat-
egy is commonly used in NLP, e.g. Taub-Tabib et
al. (2015) have different kernel functions for differ-
ent order of dependency features. The second is an
approximation method which aims to use a single
tensor to handle all ns.

Multiple Low-Rank Tensors Suppose that we
can divide the feature set S(x, y) into subsets
S1(x, y), S2(x, y), . . . , Sn(x, y) which correspond
to features with one lexical part (unigram features),
two lexical parts (bigram features), . . . and n lexi-
cal parts (n-gram features), respectively. To handle
these types of features, we modify the training ob-
jective as follows:

minimize
T1,T2,··· ,Tn

∑
(x,y)∈D

`(x, y; T1, T2, . . . , ...Tn), (8)

where the score of a training instance (x, y) is de-
fined as s(x, y; T ) =∑ni=1∑φ∈Si(x,y) s(φ; Ti). We
use the Tucker form low-rank tensor for T1, and the
CP form for Ti (∀i > 1). We refer to this method as
LRFR1-TUCKER & LRFR2-CP.

Word Clusters Alternatively, to handle different
numbers of lexical parts, we replace some lexical
parts with discrete word clusters. Let c(w) denote
the word cluster (e.g. from Brown clustering) for
word w. For bigram features we have:

s(y, u,w1,w2; T )
= s(y, u∧c(w1),w2; T ) + s(y, u∧c(w2),w1; T )
= T ×l y×f (u ∧ c(w1))×w ew2

+ T ×l y×f (u ∧ c(w2))×w ew1 (9)
where for each word we have introduced an addi-
tional set of non-lexical properties that are conjunc-
tions of word clusters and the original non-lexical
properties. This allows us to reduce an n-gram
feature representation to a unigram representation.
The advantage of this method is that it uses a sin-
gle low-rank tensor to score features with different
numbers of lexical parts. This is particularly helpful
when we have very limited labeled data. We denote
this method as LRFR1-BROWN, since we use Brown
clusters in practice. In the experiments we use the

1023



Tucker form for LRFR1-BROWN.

6 Parameter Estimation

The goal of learning is to find a tensor T that solves
problem (5). Note that this is a non-convex objec-
tive, so compared to the convex objective in a tradi-
tional log-linear model, we are trading better fea-
ture representations with the cost of a harder op-
timization problem. While stochastic gradient de-
scent (SGD) is a natural choice for learning rep-
resentations in large data settings, problem (5) in-
volves rank constraints, which require an expensive
proximal operation to enforce the constraints at each
iteration of SGD. We seek a more efficient learning
algorithm. Note that we fixed the size of each trans-
formation matrix Wi ∈ Rri×di so that the smaller
dimension (ri < di) matches the upper bound on the
rank. Therefore, the rank constants are always sat-
isfied through a run of SGD and we in essence have
an unconstrained optimization problem. Note that in
this way we do not guarantee orthogonality and full-
rank of the learned transformation matrices. These
properties are assumed in general, but are not neces-
sary according to (Kolda and Bader, 2009).

The gradients are computed via the chain-rule.
We use AdaGrad (Duchi et al., 2011) and apply L2
regularization on all Wis and g, except for the case
of ri=di, where we will start with Wi = I and reg-
ularize with ‖Wi - I‖2. We use early-stopping on a
development set.

7 Experimental Settings

We evaluate LRFR on three tasks: relation extraction,
PP attachment and preposition disambiguation (see
Table 1 for a task summary). We include detailed
feature templates in Table 2.

PP-attachment and relation extraction are two
fundamental NLP tasks, and we test our models on
the largest English data sets. The preposition disam-
biguation task was designed for compositional se-
mantics, which is an important application of deep
learning and distributed representations. On all
these tasks, we compare to the state-of-the-art.

We use the same word embeddings in Belinkov et
al. (2014) on PP-attachment for a fair comparison.
For the other experiments, we use the same 200-d
word embeddings in Yu et al. (2015).

Relation Extraction We use the English portion
of the ACE 2005 relation extraction dataset (Walker
et al., 2006). Following Yu et al. (2015), we use both
gold entity spans and types, train the model on the
news domain and test on the broadcast conversation
domain. To highlight the impact of training data size
we evaluate with all 43,518 relations (entity mention
pairs) and a reduced training set of the first 10,000
relations. We report precision, recall, and F1.

We compare to two baseline methods: 1) a log-
linear model with a rich binary feature set from Sun
et al. (2011) and Zhou et al. (2005) as described
in Yu et al. (2015) (BASELINE); 2) the embedding
model (FCM) of Gormley et al. (2015), which uses
rich linguistic features for relation extraction. We
use the same feature templates and evaluate on fine-
grained relations (sub-types, 32 labels) (Yu et al.,
2015). This will evaluate how LRFR can utilize non-
lexical linguistic features.

PP-attachment We consider the prepositional
phrase (PP) attachment task of Belinkov et al.
(2014),3 where for each PP the correct head (verbs
or nouns) must be selected from content words be-
fore the PP (within a 10-word window). We formu-
late the task as a ranking problem, where we opti-
mize the score of the correct head from a list of can-
didates with varying sizes.

PP-attachment suffers from data sparsity because
of bi-lexical features, which we will model with
methods in §5. Belikov et al. show that rich fea-
tures – POS, WordNet and VerbNet – help this task.
The combination of these features give a large num-
ber of non-lexical properties, for which embeddings
of non-lexical properties in LRFR should be useful.

We extract a dev set from section 22 of the PTB
following the description in Belinkov et al. (2014).

Preposition Disambiguation We consider the
preposition disambiguation task proposed by Ritter
et al. (2014). The task is to determine the spatial re-
lationship a preposition indicates based on the two
objects connected by the preposition. For example,
“the apple on the refrigerator” indicates the “support
by Horizontal Surface” relation, while “the apple on
the branch” indicates the “Support from Above” re-
lation. Since the meaning of a preposition depends

3
http://groups.csail.mit.edu/rbg/code/pp

1024



Task Benchmark Dataset Numbers on Each View#Labels (d1) #Non-lexical Features (d2)
Relation Extraction Yu et al. (2015) ACE 2005 32 264
PP-attachment Belinkov et al. (2014) WSJ - 1,213 / 607
Preposition Disambiguation Ritter et al. (2014) Ritter et al. (2014) 6 9/3

Table 1: Statistics of each task. PP-attachment and preposition disambiguation have both unigram and bigram fea-
tures. Therefore we list the numbers of non-lexical properties for both types.

Set Template
HeadEmb {I[i = h1], I[i = h2]} (head of M1/M2)

&{φ, th1 , th2 , th1&th2}
Context I[i = h1/h2 ± 1] (left/right token of wh1/h2 )
In-between I[i > h1]&I[i < h2]&{φ, th1 , th2 , th1&th2}
On-path I[wi ∈ P ] &{φ, th1 , th2 , th1&th2}
Set Template
Bag of Words w, p & w (w is wm or wh)
Word-Position wm, wh, wm & wh
Preposition p, p & wm, p & wh, p & wm & wh

Set Template
Bag of Words w (w is wm or wh), wm&wh

Distance Dis(wh, wm) & {wm, wh, wm&wh}
Prep wp & {wm, wh, wm&wh}
POS t(wh) & {wm, wh, wm&wh}

NextPOS t(wh+1) & {wm, wh, wm&wh}
VerbNet P = {p(wh)} & {wm, wh, wm&wh}

I[wp ∈ P ] & {wm, wh, wm&wh}
WordNet Rh = {r(wh)} & {wm, wh, wm&wh}

Rm = {r(wm)} & {wm, wh, wm&wh}

Table 2: Up-left: Unigram lexical features (only showing non-lexical parts) for relation extraction (from Yu et
al. (2014)). We denote the two target entities as M1,M2 (with head indices h1, h2, NE types th1 , th2 ), and their
dependency path as P . Right: Uni/bi-gram feature for PP-attachment: Each feature is defined on tuple (wm, wp,
wh), where wp is the preposition word, wm is the child of the preposition, and wh is a candidate head of wp. t(w):
POS tag of word w; p(w): a preposition collocation of verb w from VerbNet; r(w): the root hypernym of word
w in WordNet. Dis(·, ·): the number of candidate heads between two words. Down-left: Uni/bi-gram feature for
preposition disambiguation (for each preposition word p, its modifier noun wm and head noun wh). Since the
sentences are different from each other on only p, wm and wh, we ignore the words on the other positions.

on the combination of both its head and child word,
we expect conjunctions between these word embed-
dings to help, i.e. features with two lexical parts.

We include three baselines: point-wise addition
(SUM) (Mitchell and Lapata, 2010), concatena-
tion (Ritter et al., 2014), and an SVM based on hand-
crafted features in Table 2. Ritter et al. show that the
first two methods beat other compositional models.

Hyperparameters are all tuned on the dev set.
The chosen values are learning rate η = 0.05 and the
weight of L2 regularizer λ = 0.005 for LRFR, except
for the third LRFR in Table 3 which has λ = 0.05.
We select the rank of LRFR-TUCKER with a grid
search from the following values: r1 = {10, 20, d1},
r2 = {20, 50, d2} and r3 = {50, 100, 200}. For
LRFR-CP, we select r = {50, 100, 200}. For the
PP-attachement task there is no r1 since it uses a
ranking model. For the Preposition Disambiguation
we do not choose r1 since the number of labels is
small.

8 Results

Relation Extraction All LRFR-TUCKER models
improve over BASELINE and FCM (Table 3), making

these the best reported numbers for this task. How-
ever, LRFR-CP does not work as well on the features
with only one lexical part. The Tucker-form does a
better job of capturing interactions between differ-
ent views. In the limited training setting, we find
that LRFR-CP does best.

Additionally, the primary advantage of the CP
approximation is its reduction in the number of
model parameters and running time. We report each
model’s running time for a single pass on the de-
velopment set. The LRFR-CP is by far the fastest.
The first three LRFR-TUCKER models are slightly
slower than FCM, because they work on dense non-
lexical property embeddings while FCM benefits
from sparse vectors.

PP-attachment Table 4 shows that LRFR (89.6
and 90.3) improves over the previous best stan-
dalone system HPCD (88.7) by a large margin, with
exactly the same resources. Belinkov et al. (2014)
also reported results of parsers and parser re-rankers,
which can access to additional resources (complete
parses for training and complete sentences as in-
puts) so it is unfair to compare them with the stan-
dalone systems like HPCD and our LRFR. Nonethe-

1025



Parameters Full Set (|D|=43,518) Reduced Set (|D|=10,000) Prediction
Method r1 r2 r3 P R F1 P R F1 Time (ms)
BASELINE - - - 60.2 51.2 55.3 - - - -
FCM 32/N 264/N 200/N 62.9 49.6 55.4 61.6 37.1 46.3 2,242
LRFR1-TUCKER 32/N 20/Y 200/Y 62.1 52.7 57.0 51.5 40.8 45.5 3,076
LRFR1-TUCKER 32/N 20/Y 200/N 63.5 51.1 56.6 52.8 40.1 45.6 2,972
LRFR1-TUCKER 20/Y 20/Y 200/Y 62.4 51.0 56.1 52.1 41.2 46.0 2,538
LRFR1-TUCKER 32/Y 20/Y 50/Y 57.4 52.4 54.8 49.7 46.1 47.8 1,198
LRFR1-CP 200/Y 61.3 50.7 55.5 58.3 41.6 48.6 502

Table 3: Results on test for relation extraction. Y(es)/N(o) indicates whether embeddings are updated during training.

System Resources Used Acc
SVM (Belinkov et al., 2014) distance, word, embedding, clusters, POS, WordNet, VerbNet 86.0
HPCD (Belinkov et al., 2014) distance, embedding, POS, WordNet, VerbNet 88.7
LRFR1-TUCKER & LRFR2-CP distance, embedding, POS, WordNet, VerbNet 90.3
LRFR1-BROWN distance, embedding, clusters, POS, WordNet, VerbNet 89.6
RBG (Lei et al., 2014) dependency parser 88.4
Charniak-RS (McClosky et al., 2006) dependency parser + re-ranker 88.6
RBG + HPCD (combined model) dependency parser + distance, embedding, POS, WordNet, VerbNet 90.1

Table 4: PP-attachment test accuracy. The baseline results are from Belinkov et al. (2014).

less LRFR1-TUCKER & LRFR2-CP (90.3) still out-
performs the state-of-the-art parser RBG (88.4), re-
ranker Charniak-RS (88.6), and the combination of
the state-of-the-art parser and compositional model
RBG + HPCD (90.1). Thus, even with fewer re-
sources, LRFR becomes the new best system.

Not shown in the table: we also tried LRFR1-
TUCKER & LRFR2-CP with postag features only
(89.7), and with grand-head-modifier conjunctions
removed (89.3) . Note that compared to LRFR,
RBG benefits from binary features, which also ex-
ploit grand-head-modifier structures. Yet the above
reduced models still work better than RBG (88.4)
without using additional resources.4 Moreover, the
results of LRFR can still be potentially improved by
combining with binary features. The above results
show the advantage of our factorization method,
which allows for utilizing pre-trained word embed-
dings, and thus can benefit from semi-supervised
learning.

Preposition Disambiguation LRFR improves (Ta-
ble 5) over the best methods (SUM and Concate-
nation) in Ritter et al. (2014) as well as the SVM

4Still this is not a fair comparison since we have differ-
ent training objectives. Using RBG’s factorization and training
with our objective will give a fair comparison and we leave it to
future work.

Method Accuracy
SVM - Lexical Features 85.09
SUM 80.55
Concatenation 86.73
LRFR1-TUCKER & LRFR2-CP 87.82
LRFR1-BROWN 88.18
LRFR1-BROWN - Control 84.18

Table 5: Accuracy for spatial classification of PPs.

based on the original lexical features (85.1). In this
task LRFR1-BROWN better represents the unigram
and bigram lexical features, compared to the usage
of two low-rank tensors (LRFR1-TUCKER & LRFR2-
CP). This may be because LRFR1-BROWN has fewer
parameters, which is better for smaller training sets.

We also include a control setting (LRFR1-BROWN
- Control), which has a full rank parameter ten-
sor with the same inputs on each view as LRFR1-
BROWN, but represented as one hot vectors without
transforming to the hidden representations hs. This
is equivalent to an SVM with the compound cluster
features as in Koo et al. (2008). It performs much
worse than LRFR1-BROWN, showing the advantage
of using word embeddings and low-rank tensors.

Summary For unigram lexical features, LRFRn-
TUCKER achieves better results than LRFRn-CP.
However, in settings with fewer training examples,

1026



features with more lexical parts (n-grams), or when
faster predictions are advantageous, LRFRn-CP does
best as it has fewer parameters to estimate. For n-
grams of variable length, LRFR1-TUCKER & LRFR2-
CP does best. In settings with fewer training exam-
ples, LRFR1-BROWN does best as it has only one
parameter tensor to estimate.

9 Related Work

Dimensionality Reduction for Complex Features
is a standard technique to address high-dimensional
features, including PCA, alternating structural op-
timization (Ando and Zhang, 2005), denoising au-
toencoders (Vincent et al., 2008), and feature em-
beddings (Yang and Eisenstein, 2015). These meth-
ods treat features as atomic elements and ignore the
inner structure of features, so they learn separate em-
bedding for each feature without shared parameters.
As a result, they still suffer from large parameter
spaces when the feature space is very huge.5

Another line of research studies the inner struc-
tures of lexical features: e.g. Koo et al. (2008),
Turian et al. (2010), Sun et al. (2011), Nguyen and
Grishman (2014), Roth and Woodsend (2014), and
Hermann et al. (2014) used pre-trained word embed-
dings to replace the lexical parts of features ; Sriku-
mar and Manning (2014), Gormley et al. (2015)
and Yu et al. (2015) propose splitting lexical fea-
tures into different parts and employing tensors to
perform classification. The above can therefore be
seen as special cases of our model that only embed
a certain part (view) of the complex features. This
restriction also makes their model parameters form
a full rank tensor, resulting in data sparsity and high
computational costs when the tensors are large.

Composition Models (Deep Learning) build rep-
resentations for structures based on their component
word embeddings (Collobert et al., 2011; Bordes et
al., 2012; Socher et al., 2012; Socher et al., 2013b).
When using only word embeddings, these models
achieved successes on several NLP tasks, but some-
times fail to learn useful syntactic or semantic pat-
terns beyond the strength of combinations of word

5For example, a state-of-the-art dependency parser (Zhang
and McDonald, 2014) extracts about 10 million features; in this
case, learning 100-dimensional feature embeddings involves es-
timating approximately a billion parameters.

embeddings, such as the dependency relation in Fig-
ure 1(a). To tackle this problem, some work de-
signed their model structures according to a specific
kind of linguistic patterns, e.g. dependency paths
(Ma et al., 2015; Liu et al., 2015), while a recent
trend enhances compositional models with linguis-
tic features. For example, Belinkov et al. (2014)
concatenate embeddings with linguistic features be-
fore feeding them to a neural network; Socher et
al. (2013a) and Hermann and Blunsom (2013) en-
hanced Recursive Neural Networks by refining the
transformation matrices with linguistic features (e.g.
phrase types). These models are similar to ours in
the sense of learning representations based on lin-
guistic features and embeddings.

Low-rank Tensor Models for NLP aim to handle
the conjunction among different views of features
(Cao and Khudanpur, 2014; Lei et al., 2014; Chen
and Manning, 2014). Yu and Dredze (2015) pro-
posed a model to compose phrase embeddings from
words, which has an equivalent form of our CP-
based method under certain restrictions. Our work
applies a similar idea to exploiting the inner struc-
ture of complex features, and can handle n-gram
features with different ns. Our factorization (§3) is
general and easy to adapt to new tasks. More impor-
tantly, it makes the model benefit from pre-trained
word embeddings as shown by the PP-attachment
results.

10 Conclusion

We have presented LRFR, a feature representation
model that exploits the inner structure of complex
lexical features and applies a low-rank tensor to effi-
ciently score features with this representation. LRFR
attains the state-of-the-art on several tasks, includ-
ing relation extraction, PP-attachment, and preposi-
tion disambiguation. We make our implementation
available for general use.6

Acknowledgements

A major portion of this work was done when MY
was visiting MD and RA at JHU. This research was
supported in part by NSF grant IIS-1546482.

6https://github.com/Gorov/LowRankFCM

1027



References

Rie Kubota Ando and Tong Zhang. 2005. A framework
for learning predictive structures from multiple tasks
and unlabeled data. The Journal of Machine Learning
Research, 6.

Yonatan Belinkov, Tao Lei, Regina Barzilay, and Amir
Globerson. 2014. Exploring compositional architec-
tures and word vector representations for prepositional
phrase attachment. Transactions of the Association for
Computational Linguistics, 2.

Yoshua Bengio, Holger Schwenk, Jean-Sébastien
Senécal, Fréderic Morin, and Jean-Luc Gauvain.
2006. Neural probabilistic language models. In
Innovations in Machine Learning. Springer.

Antoine Bordes, Xavier Glorot, Jason Weston, and
Yoshua Bengio. 2012. A semantic matching energy
function for learning with multi-relational data. Ma-
chine Learning.

Yuan Cao and Sanjeev Khudanpur. 2014. Online learn-
ing in tensor space. In Proceedings of the 52nd Annual
Meeting of the Association for Computational Linguis-
tics (Volume 1: Long Papers).

Danqi Chen and Christopher Manning. 2014. A fast and
accurate dependency parser using neural networks. In
Proceedings of EMNLP.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa. 2011.
Natural language processing (almost) from scratch.
JMLR, 12.

John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive subgradient methods for online learning and
stochastic optimization. The Journal of Machine
Learning Research, 12.

Matthew R. Gormley, Mo Yu, and Mark Dredze. 2015.
Improved relation extraction with feature-rich com-
positional embedding models. In Proceedings of the
2015 Conference on Empirical Methods in Natural
Language Processing.

Karl Moritz Hermann and Phil Blunsom. 2013. The role
of syntax in vector space models of compositional se-
mantics. In Association for Computational Linguis-
tics.

Karl Moritz Hermann, Dipanjan Das, Jason Weston, and
Kuzman Ganchev. 2014. Semantic frame identifica-
tion with distributed word representations. In Pro-
ceedings of the 52nd Annual Meeting of the Associ-
ation for Computational Linguistics (Volume 1: Long
Papers).

Raphael Hoffmann, Congle Zhang, and Daniel S. Weld.
2010. Learning 5000 relational extractors. In Pro-
ceedings of the 48th Annual Meeting of the Association
for Computational Linguistics.

Tamara G Kolda and Brett W Bader. 2009. Tensor de-
compositions and applications. SIAM review, 51(3).

Terry Koo, Xavier Carreras, and Michael Collins. 2008.
Simple semi-supervised dependency parsing. In Pro-
ceedings of ACL.

Tao Lei, Yu Xin, Yuan Zhang, Regina Barzilay, and
Tommi Jaakkola. 2014. Low-rank tensors for scor-
ing dependency structures. In Proceedings of the 52nd
Annual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers).

Tao Lei, Yuan Zhang, Lluı́s Màrquez, Alessandro Mos-
chitti, and Regina Barzilay. 2015. High-order low-
rank tensors for semantic role labeling. In Proceedings
of the 2015 Conference of the North American Chap-
ter of the Association for Computational Linguistics:
Human Language Technologies.

Yang Liu, Furu Wei, Sujian Li, Heng Ji, Ming Zhou, and
Houfeng WANG. 2015. A dependency-based neural
network for relation classification. In Proceedings of
the 53rd Annual Meeting of the Association for Com-
putational Linguistics and the 7th International Joint
Conference on Natural Language Processing (Volume
2: Short Papers).

Mingbo Ma, Liang Huang, Bowen Zhou, and Bing Xi-
ang. 2015. Dependency-based convolutional neural
networks for sentence embedding. In Proceedings of
the 53rd Annual Meeting of the Association for Com-
putational Linguistics and the 7th International Joint
Conference on Natural Language Processing (Volume
2: Short Papers).

David McClosky, Eugene Charniak, and Mark Johnson.
2006. Effective self-training for parsing. In Proceed-
ings of the main conference on human language tech-
nology conference of the North American Chapter of
the Association of Computational Linguistics.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Cor-
rado, and Jeff Dean. 2013. Distributed representa-
tions of words and phrases and their compositionality.
In Advances in neural information processing systems,
pages 3111–3119.

Scott Miller, Jethran Guinness, and Alex Zamanian.
2004. Name tagging with word clusters and discrimi-
native training. In Proceedings of HLT-NAACL.

Jeff Mitchell and Mirella Lapata. 2010. Composition in
distributional models of semantics. Cognitive science,
34(8).

Thien Huu Nguyen and Ralph Grishman. 2014. Employ-
ing word representations and regularization for domain
adaptation of relation extraction. In Association for
Computational Linguistics (ACL).

Samuel Ritter, Cotie Long, Denis Paperno, Marco Ba-
roni, Matthew Botvinick, and Adele Goldberg. 2014.

1028



Leveraging preposition ambiguity to assess represen-
tation of semantic interaction in cdsm. In NIPS Work-
shop on Learning Semantics.

Michael Roth and Kristian Woodsend. 2014. Compo-
sition of word representations improves semantic role
labelling. In Proceedings of EMNLP.

Richard Socher, Brody Huval, Christopher D. Manning,
and Andrew Y. Ng. 2012. Semantic compositionality
through recursive matrix-vector spaces. In Proceed-
ings of EMNLP-CoNLL 2012.

Richard Socher, John Bauer, Christopher D Manning, and
Andrew Y Ng. 2013a. Parsing with compositional
vector grammars. In Proceedings of ACL.

Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang,
Christopher D. Manning, Andrew Ng, and Christopher
Potts. 2013b. Recursive deep models for semantic
compositionality over a sentiment treebank. In Pro-
ceedings of EMNLP.

Vivek Srikumar and Christopher D Manning. 2014.
Learning distributed representations for structured out-
put prediction. In Advances in Neural Information
Processing Systems.

Ang Sun, Ralph Grishman, and Satoshi Sekine. 2011.
Semi-supervised relation extraction with large-scale
word clustering. In Proceedings of the 49th Annual
Meeting of the Association for Computational Linguis-
tics: Human Language Technologies.

Hillel Taub-Tabib, Yoav Goldberg, and Amir Glober-
son. 2015. Template kernels for dependency parsing.
In Proceedings of the 2015 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies.

Joseph Turian, Lev Ratinov, and Yoshua Bengio. 2010.
Word representations: a simple and general method for
semi-supervised learning. In Association for Compu-
tational Linguistics.

Pascal Vincent, Hugo Larochelle, Yoshua Bengio, and
Pierre-Antoine Manzagol. 2008. Extracting and com-
posing robust features with denoising autoencoders. In
Proceedings of the 25th international conference on
Machine learning.

Christopher Walker, Stephanie Strassel, Julie Medero,
and Kazuaki Maeda. 2006. ACE 2005 multilin-
gual training corpus. Linguistic Data Consortium,
Philadelphia.

Yi Yang and Jacob Eisenstein. 2015. Unsupervised
multi-domain adaptation with feature embeddings. In
Proceedings of the 2015 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
pages 672–682, Denver, Colorado, May–June. Asso-
ciation for Computational Linguistics.

Mo Yu and Mark Dredze. 2015. Learning composition
models for phrase embeddings. Transactions of the
Association for Computational Linguistics, 3.

Mo Yu, Matthew R. Gormley, and Mark Dredze. 2015.
Combining word embeddings and feature embeddings
for fine-grained relation extraction. In North American
Chapter of the Association for Computational Linguis-
tics (NAACL).

Hao Zhang and Ryan McDonald. 2014. Enforcing struc-
tural diversity in cube-pruned dependency parsing. In
Proceedings of ACL.

GuoDong Zhou, Jian Su, Jie Zhang, and Min Zhang.
2005. Exploring various knowledge in relation extrac-
tion. In Proceedings of ACL.

1029


