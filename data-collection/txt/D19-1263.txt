



















































Leveraging Frequent Query Substructures to Generate Formal Queries for Complex Question Answering


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 2614–2622,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

2614

Leveraging Frequent Query Substructures to Generate Formal Queries
for Complex Question Answering

Jiwei Ding Wei Hu∗ Qixin Xu Yuzhong Qu∗
State Key Laboratory for Novel Software Technology, Nanjing University, China
{jwding, qxxu}nju@outlook.com, {whu, yzqu}@nju.edu.cn

Abstract

Formal query generation aims to generate cor-
rect executable queries for question answer-
ing over knowledge bases (KBs), given en-
tity and relation linking results. Current ap-
proaches build universal paraphrasing or rank-
ing models for the whole questions, which are
likely to fail in generating queries for com-
plex, long-tail questions. In this paper, we
propose SubQG, a new query generation ap-
proach based on frequent query substructures,
which helps rank the existing (but nonsignif-
icant) query structures or build new query
structures. Our experiments on two bench-
mark datasets show that our approach signif-
icantly outperforms the existing ones, espe-
cially for complex questions. Also, it achieves
promising performance with limited training
data and noisy entity/relation linking results.

1 Introduction

Knowledge-based question answering (KBQA)
aims to answer natural language questions over
knowledge bases (KBs) such as DBpedia and
Freebase. Formal query generation is an important
component in many KBQA systems (Bao et al.,
2016; Cui et al., 2017; Luo et al., 2018), especially
for answering complex questions. Given entity
and relation linking results, formal query gener-
ation aims to generate correct executable queries,
e.g., SPARQL queries, for the input natural lan-
guage questions. An example question and its for-
mal query are shown in Figure 1. Generally speak-
ing, formal query generation is expected to include
but not be limited to have the capabilities of (i)
recognizing and paraphrasing different kinds of
constraints, including triple-level constraints (e.g.,
“movies” corresponds to a typing constraint for
the target variable) and higher level constraints
(e.g., subgraphs). For instance, “the same ... as”

∗Corresponding authors

How many movies have the same director as The Shawshank Redemption?

dbo:Film?Var2 ?Var1 ISA

dbo:director
dbr:TSR?Var3

COUNT

dbo:director

Figure 1: An example for complex question and query

represents a complex structure shown in the mid-
dle of Figure 1; (ii) recognizing and paraphras-
ing aggregations (e.g., “how many” corresponds
to COUNT); and (iii) organizing all the above to
generate an executable query (Singh et al., 2018;
Zafar et al., 2018).

There are mainly two kinds of query generation
approaches for complex questions. (i) Template-
based approaches choose a pre-collected template
for query generation (Cui et al., 2017; Abuja-
bal et al., 2017). Such approaches highly rely
on the coverage of templates, and perform unsta-
bly when some complex templates have very few
natural language questions as training data. (ii)
Approaches based on semantic parsing and neu-
ral networks learn entire representations for ques-
tions with different query structures, by using a
neural network following the encode-and-compare
framework (Luo et al., 2018; Zafar et al., 2018).
They may suffer from the lack of training data,
especially for long-tail questions with rarely ap-
peared structures. Furthermore, both above ap-
proaches cannot handle questions with unseen
query structures, since they cannot generate new
query structures.

To cope with the above limitations, we propose
a new query generation approach based on the
following observation: the query structure for a
complex question may rarely appear, but it usu-
ally contains some substructures that frequently
appeared in other questions. For example, the
query structure for the question in Figure 1 ap-
pears rarely, however, both “how many movies”
and “the same ... as” are common expressions,



2615

which correspond to the two query substructures
in dashed boxes. To collect such frequently ap-
peared substructures, we automatically decom-
pose query structures in the training data. In-
stead of directly modeling the query structure for
the given question as a whole, we employ multi-
ple neural networks to predict query substructures
contained in the question, each of which delivers
a part of the query intention. Then, we select an
existing query structure for the input question by
using a combinational ranking function. Also, in
some cases, no existing query structure is appro-
priate for the input question. To cope with this
issue, we merge query substructures to build new
query structures. The contributions of this paper
are summarized below:

• We formalize the notion of query structures
and define the substructure relationship be-
tween query structures.

• We propose a novel approach for formal
query generation, which firstly leverages
multiple neural networks to predict query
substructures contained in the given question,
and then ranks existing query structures by
using a combinational function.

• We merge query substructures to build new
query structures, which handles questions
with unseen query structures.

• We perform extensive experiments on two
KBQA datasets, and show that SubQG
significantly outperforms the existing ap-
proaches. Furthermore, SubQG achieves a
promising performance with limited training
data and noisy entity/relation linking results.

2 Preliminaries

An entity is typically denoted by a URI and de-
scribed with a set of properties and values. A fact
is an 〈entity, property, value〉 triple, where the
value can be either a literal or another entity. A
KB is a pair K = (E ,F), where E denotes the set
of entities and F denotes the set of facts.

A formal query (or simply called query) is the
structured representation of a natural language
question executable on a given KB. Formally, a
query is a pair Q = (V, T ), where V denotes the
set of vertices, and T denotes the set of labeled
edges. A vertex can be either a variable, an entity
or a literal, and the label of an edge can be either

How many movies were directed by the graduate of Burbank High School?

dbo:Film?Var2 ?Var1
dbo:director

dbp:edu dbr:BHS?Var3

COUNT

(a) Query
ISA

?Var2

?Var1 ?Var3

Ent1

Prop2

(c) Query substructures

?Var1

Prop1
Prop2

Ent1

?Var3

?Var2

COUNT
ISA

Class1

?Var1

COUNT

(b) Query structure

Class1?Var2 ?Var1
Prop1

Ent1?Var3

COUNT ISA

Prop2

Figure 2: Illustration of a query, a query structure and
query substructures

a built-in property or a user-defined one. For sim-
plicity, the set of all edge labels are denoted by
Le(Q). In this paper, the built-in properties in-
clude COUNT, AVG, MAX, MIN, MAXATN, MI-
NATN and ISA (RDF:TYPE), where the former
four are used to connect two variables. For ex-
ample, 〈?V ar1,COUNT, ?V ar2〉 represents that
?V ar2 is the counting result of ?V ar1. MAX-
ATN and MINATN take the meaning of OR-
DER BY in SPARQL (Bao et al., 2016). For in-
stance, 〈?V ar1,MAXATN, 2〉 means ORDER BY
DESC(?V ar1) LIMIT 1 OFFSET 1.

To classify various queries with similar query
intentions and narrow the search space for query
generation, we introduce the notion of query struc-
tures. A query structure is a set of structurally-
equivalent queries. Let Qa = (Va, Ta) and Qb =
(Vb, Tb) denote two queries. Qa is structurally-
equivalent to Qb, denoted by Qa ∼= Qb, if and
only if there exist two bijections f : Va → Vb and
g : Le(Qa)→ Le(Qb) such that:

(i) ∀v ∈ Va, v is a variable⇔ f(v) is a variable;
(ii) ∀r ∈ Le(Qa), r is a user-defined property
⇔ g(r) is a user-defined property; if r is a
built-in property, g(r) = r;

(iii) ∀v∀r∀v′〈v, r, v′〉 ∈ Ta⇔ 〈f(v), g(r), f(v′)〉
∈ Tb.

The query structure for Qa is denoted by Sa =
[Qa], which contains all the queries structurally-
equivalent to Qa. For graphical illustration, we
represent a query structure by a representative
query among the structurally-equivalent ones and
replace entities and literals with different kinds
of placeholders. An example of query and query
structure is shown in the upper half of Figure 2.

For many simple questions, two query struc-
tures, i.e., ({?V ar1, Ent1}, {〈?V ar1, P rop1,
Ent1〉}) and ({?V ar1, Ent1}, {〈Ent1, P rop1,
?V ar1〉}), are sufficient. However, for complex



2616

(a) Offline training

Training data:
<question, query> 

pairs

All existing 
query structures

Frequent query
substructures

Predictor for each 
query substructure

3. Train query 
substructure 

predictors

2. Collect 
frequent query 
substructures

1. Collect query
structures

Ranked existing 
query structures

(b) Online query generation

Input question

Output query

Probability of containing 
each query substructure

1. Predict 
query 

substructures

Merged query 
substructures

2. Rank existing 
query structures

3. Merge query 
substructures

4. Grounding 
and validation

Figure 3: Framework of the proposed approach

questions, a diversity of query structures exist and
some of them share a set of frequently-appeared
substructures, each of which delivers a part of the
query intention. We give the definition of query
substructures as follows.

Let Sa = [Qa] and Sb = [Qb] denote two query
structures. Sa is a query substructure of Sb, de-
noted by Sa � Sb, if and only if Qb has a sub-
graph Qc such that Qa ∼= Qc. Furthermore, if
Sa = [Qa] � Sb = [Qb], we say that Qb has Sa,
and Sa is contained in Qb.

For example, although the query structures for
the two questions in Figures 1 and 2 are different,
they share the same query substructure ({?V ar1,
?V ar2, Class1}, {〈?V ar1,COUNT, ?V ar2〉,
〈?V ar1, ISA, Class1〉}), which corresponds to
the phrase “how many movies”. Note that, a query
substructure can be the query structure of another
question.

The goal of this paper is to leverage a set of
frequent query (sub-)structures to generate formal
queries for answering complex questions.

3 The Proposed Approach

In this section, we present our approach, SubQG,
for query generation. We first introduce the frame-
work and general steps with a running example
(Section 3.1), and then describe some important
steps in detail in the following subsections.

3.1 Framework

Figure 3 depicts the framework of SubQG, which
contains an offline training process and an online
query generation process.

Prop1Prop1

How many movies have the same director as The Shawshank Redemption?

Class1

?Var2

?Var1
ISA

?Var2
Prop1

?Var1
Prop1

Ent1

?Var1

1. Predict query substructures contained in the question

Merge substructures ①②
score = 0.86 contains ①②③

Ent1

Grounding result:
Class1 = dbo:Film; Ent1 = dbr:TSR;
Prop1 = dbo:director
Validation: domain/range checked;
query result is not empty

4. Grounding and validation

?Var1

Ent1

empty querycorrect answer (?Var2 = 4)

① ② ④③

COUNT

Class1?Var2 ?Var1
ISA

Prop1
Prop1

Ent1?Var3

COUNT

Query structure in training data
score = 0.62 contains ①④

Ent. & rel. linking: “movies” = dbo:Film; “director” = dbo:director; “The Shawshank Redemption” = dbr:TSR

Grounding result:
Class1 = dbo:Film; Ent1 = dbr:TSR; 
Prop1 = dbo:director
Validation: dbo:Film is not the range 
of dbo:director

Class1?Var2 ?Var1
ISA

Prop1
Prop1

Ent1?Var3

COUNT

2. Rank existing query structures or 3. merge substructures to new structures

Figure 4: An example for online query generation

Offline. The offline process takes as input a
set of training data in form of 〈question, query〉
pairs, and mainly contains three steps:
1. Collect query structures. For questions in
the training data, we first discover the structurally-
equivalent queries, and then extract the set of all
query structures, denoted by TS.
2. Collect frequent query substructures. We de-
compose each query structure Si = (Vi, Ti) ∈ TS
to get the set for all query substructures. Let Tj be
a non-empty subset of Ti, and VTj be the set of ver-
tices used in Tj . Sj = (VTj , Tj) should be a query
substructure of Si according to the definition. So,
we can generate all query substructures of Si from
each subset of Ti. Disconnected query substruc-
tures would be ignored since they express discon-
tinuous meanings and should be split into smaller
query substructures. If more than γ queries in
training data have substructure Sj , we consider Sj
as a frequent query substructure. The set for all
frequent query substructures is denoted by FS∗.
3. Train query substructure predictors. We
train a neural network for each query substructure
S∗i ∈ FS∗, to predict the probability that Qy has
S∗i (i.e., S∗i � [Qy]) for input question y, where
Qy denotes the formal query for y. Details for this
step are described in Section 3.2.

Online. The online query generation process
takes as input a natural language question y, and
mainly contains four steps:
1. Predict query substructures. We first predict
the probability that S∗i � [Qy] for each S∗i ∈ FS∗,
using the query substructure predictors trained in
the offline step. An example question and four
query substructures with highest prediction prob-



2617

abilities are shown in the top of Figure 4.
2. Rank existing query structures. To find an
appropriate query structure for the input question,
we rank existing query structures (Si ∈ TS) by
using a scoring function, see Section 3.3.
3. Merge query substructures. Consider the fact
that the target query structure [Qy] may not ap-
pear in TS (i.e., there is no query in the training
data that is structurally-equivalent to Qy), we de-
sign a method (described in Section 3.4) to merge
question-contained query substructures for build-
ing new query structures. The merged results are
ranked using the same function as existing query
structures. Several query structures (including the
merged results and the existing query structures)
for the example question are shown in the middle
of Figure 4.
4. Grounding and validation. We leverage the
query structure ranking result, alongside with the
entity/relation linking result from some existing
black box systems (Dubey et al., 2018) to gen-
erate executable formal query for the input ques-
tion. For each query structure, we try all possible
combinations of the linking results according to
the descending order of the overall linking score,
and perform validation including grammar check,
domain/range check and empty query check. The
first non-empty query passing all validations is
considered as the output for SubQG. The ground-
ing and validation results for the example question
are shown in the bottom of Figure 4.

3.2 Query Substructure Prediction

In this step, we employ an attention based Bi-
LSTM network (Raffel and Ellis, 2015) to pre-
dict Pr[S∗i | y] for each frequent query substructure
S∗i ∈ FS∗, where Pr[S∗i | y] represents the proba-
bility of S∗i � [Qy]. There are mainly three rea-
sons that we use a predictor for each query sub-
structure instead of a multi-tag predictor for all
query substructures: (i) a query substructure usu-
ally expresses part of the meaning of input ques-
tion. Different query substructures may focus on
different words or phrases, thus, each predictor
should have its own attention matrix; (ii) multi-
tag predictor may have a lower accuracy since
each tag has unbalanced training data; (iii) sin-
gle pre-trained query substructure predictor from
one dataset can be directly reused on another with-
out adjusting the network structure, however, the
multi-tag predictor need to adjust the size of the

100Embedding :

BiLSTM :

WeightedSum :

Input: 

+

200

100

200

100

200 …

100

200

100

200

How many movies … as <Entity>

× × × × ×

… …

𝛼1 𝛼2 𝛼3 𝛼𝑇−1 𝛼𝑇

ℎ1 ℎ2 ℎ3 ℎ𝑇−1 ℎ𝑇

200 200 1

Att(ℎ𝑡)

…

200

1 𝑃𝑟[𝑆𝑖
∗|𝑦]Output :

Figure 5: Attention-based BiLSTM network

output layer and retrain when the set of frequent
query substructures changes.

The structure of the network is shown in Fig-
ure 5. Before the input question is fed into the net-
work, we replace all entity mentions with 〈Entity〉
using EARL (Dubey et al., 2018), to enhance the
generalization ability. Given the question word se-
quence {w1, ..., wT }, we first use a word embed-
ding matrix to convert the original sequence into
word vectors {e1, ..., eT }, followed by a BiLSTM
network to generate the context-sensitive repre-
sentation {h1, ...,hT } for each word, where

ht = [LSTM(et,
−→
h t−1); LSTM(et,

←−
h t+1)]. (1)

Then, the attention mechanism takes each ht
as input, and calculates a weight αt for each ht,
which is formulated as follows:

αt =
eAtt(ht)∑T
k=1 e

Att(hk)
, (2)

Att(ht) = vTatt tanh(Wattht + batt), (3)

where Watt ∈ R|ht|×|ht|, batt ∈ R|ht| and vatt ∈
R|ht|. Next, we get the representation for the
whole question qc as the weighted sum of ht:

qc =

T∑
t=1

αtht. (4)

The output of the network is a probability

Pr[S∗i | y] = σ(vToutqc + bout), (5)

where vout ∈ R|q
c| and bout ∈ R.

The loss function minimized during training is
the binary cross-entropy:

Loss(S∗i ) =−
∑

(y,Qy)∈Train
s.t.S∗i �[Qy ]

log(Pr[S∗i | y])

−
∑

(y,Qy)∈Train
s.t.S∗i �[Qy ]

log(1− Pr[S∗i | y]),
(6)

where Train denotes the set of training data.



2618

Algorithm 1: Query substructure merging
Input: Question y, freq. query substructures FS∗

1 FS+ := {S∗i ∈ FS∗ | Pr[S∗i | y] > 0.5};
2 M(0) := {S∗i ∈ FS∗ | Score[S∗i | y] > θ};
3 for i = 1 to K do // K is maximum iterations
4 M(i) := ∅;
5 forall S∗i ∈ FS+,Sj ∈ M(i−1) do
6 M(i) := M(i) ∪ Merge(S∗i ,Sj);

7 M(i) := {Sl ∈ M(i) | Score[Sl | y] > θ};

8 return
⋃K

i=0 M
(i);

3.3 Query Structure Ranking
In this step, we use a combinational function to
score each query structure in the training data for
the input question. Since the prediction result for
each query substructure is independent, the score
for query structure Si is measured by joint proba-
bility, which is

Score(Si | y) =
∏

S∗j ∈FS∗
s.t.S∗j�Si

Pr[S∗j | y]

×
∏

S∗j ∈FS∗

s.t.S∗j�Si

(1− Pr[S∗j | y]).
(7)

Assume thatQy ∈ Si, ∀S∗j � Si, we have S∗j �
[Qy]. Thus, Pr[S∗j | y] should be 1 in the ideal con-
dition. On the other hand, ∀S∗j � Si, Pr[S∗j | y]
should be 0. Thus, we have Score(Si | y) = 1, and
∀Sk 6= Si, we have Score(Sk | y) = 0.

3.4 Query Substructure Merging
We proposed a method, shown in Algorithm 1, to
merge question-contained query substructures to
build new query structures. In the initialization
step, it selects some query substructures of high
scores as candidates, since the query substruc-
ture may directly be the appropriate query struc-
ture for the input question. In each iteration, the
method merges each question-contained substruc-
tures with existing candidates, and the merged re-
sults of high scores are used as candidates in the
next iteration. The final output is the union of all
the results from at most K iterations.

When merging different query substructures,
we allow them to share some vertices of the same
kind (variable, entity, etc.) or edge labels, except
the variables which represent aggregation results.
Thus, the merged result of two query substructures
is a set of query structures instead of one. Also, the
following restrictions are used to filter the merged
results:

Class1
?Var2

?Var1 ∗

∗. 1 = ∗. 1

?Var2

Prop1

?Var1 Prop1

Ent1

Class1?Var2 ?Var1
Prop1

Prop1 Ent1?Var3

Class1?Var2 ?Var1
Prop1 Prop1

Ent1?Var3

∗. 1 = ∗. 2

∗

Share the same variableShare the same variable

ISA ISA

ISA
COUNT

COUNT COUNT

Figure 6: Merge results for two query substructures

(i) The merged results should be connected;

(ii) The merged results have ≤ τ triples;
(iii) The merged results have ≤ δ aggregations;

An example for merging two query substruc-
tures is shown in Figure 6.

4 Experiments and Results

In this section, we introduce the query generation
datasets and state-of-the-art systems that we com-
pare. We first show the end-to-end results of the
query generation task, and then perform detailed
analysis to show the effectiveness of each mod-
ule. Question sets, source code and experimental
results are available online.1

4.1 Experimental Setup
Datasets We employed the same datasets as
Singh et al.(2018) and Zafar et al.(2018): (i) the
large-scale complex question answering dataset
(LC-QuAD) (Trivedi et al., 2017), containing
3,253 questions with non-empty results on DBpe-
dia (2016-04), and (ii) the fifth edition of ques-
tion answering over linked data (QALD-5) dataset
(Unger et al., 2015), containing 311 questions with
non-empty results on DBpedia (2015-10). Both
datasets are widely used in KBQA studies (Zou
et al., 2014; Dubey et al., 2018), and have be-
come benchmarks for some annual KBQA com-
petitions23. We did not employ the WebQuestions
(Berant et al., 2013) dataset, since approximately
85% of its questions are simple. Also, we did not
employ the ComplexQuestions (Bao et al., 2016)
and ComplexWebQuestions (Talmor and Berant,
2018) dataset, since the existing works on these
datasets have not reported the formal query gener-
ation result, and it is difficult to separate the formal
query generation component from the end-to-end
KBQA systems in these works.

1http://ws.nju.edu.cn/SubQG/
2http://lc-quad.sda.tech
3http://qald.aksw.org/index.php?q=5

http://ws.nju.edu.cn/SubQG/
http://lc-quad.sda.tech
http://qald.aksw.org/index.php?q=5


2619

Table 1: Datasets and implementation details
LC-QuAD QALD-5

No. of questions (complex) 3,253 (2,249) 311 (192)

No. of query structures 35 52

No. of freq. substructures 37 10

Avg. training time 1,102s 272s

Avg. prediction time 0.291s 0.122s

Avg. query generation time 0.356s 0.197s

Implementation details All the experiments
were carried out on a machine with an Intel Xeon
E3-1225 3.2GHz processor, 32 GB of RAM, and
an NVIDIA GTX1080Ti GPU. For the embed-
ding layer, we used random embedding. For each
dataset, we performed 5-fold cross-validation with
the train set (70%), development set (10%), and
test set (20%). The threshold γ for frequent query
substructures is set to 30, the maximum iteration
numberK for merging is set to 2, θ in Algorithm 1
is set to 0.3, the maximum triple number τ for
merged results is set to 5, and the maximum aggre-
gation number δ is set to 2. Other detailed statis-
tics are shown in Table 1.

4.2 End-to-End Results
We compared SubQG with several existing ap-
proaches. SINA (Shekarpour et al., 2015) and
NLIWOD conduct query generation by prede-
fined rules and existing templates. SQG (Zafar
et al., 2018) firstly generates candidate queries
by finding valid walks containing all of enti-
ties and properties mentioned in questions, and
then ranks them based on Tree-LSTM similarity.
CompQA (Luo et al., 2018) is a KBQA system
which achieved state-of-the-art performance on
WebQuesions and ComplexQuestions over Free-
base. We re-implemented its query generation
component for DBpedia, which generates candi-
date queries by staged query generation, and ranks
them using an encode-and-compare network.

The average F1-scores for the end-to-end query
generation task are reported in Table 2. All
these results are based on the gold standard en-
tity/relation linking result as input. Our ap-
proach SubQG outperformed all the comparative
approaches on both datasets. Furthermore, as the
results shown in Table 3, it gained a more sig-
nificant improvement on complex questions com-
pared with CompQA.

Both SINA and NLIWOD did not employ a
query ranking mechanism, i.e., their accuracy and

4https://github.com/dice-group/NLIWOD

Table 2: Average F1-scores of query generation
LC-QuAD QALD-5

Sina (Shekarpour et al., 2015) 0.24 † 0.39 †

NLIWOD 4 0.48 † 0.49 †

SQG (Zafar et al., 2018) 0.75 † -
CompQA (Luo et al., 2018) 0.772±0.014 0.511±0.043
SubQG (our approach) 0.846±0.016 0.624±0.030
† indicates results taken from Singh et al. (2018) and SQG.

Table 3: Average F1-scores for complex questions
LC-QuAD QALD-5

CompQA 0.673±0.009 0.260±0.082
SubQG 0.779±0.017 0.392±0.156

coverage are limited by the rules and templates.
Although both CompQA and SQG have a strong
ability of generating candidate queries, they per-
form not quite well in query ranking. According
to our observation, the main reason is that these
approaches tried to learn entire representations
for questions with different query structures (from
simple to complex) using a single network, thus,
they may suffer from the lack of training data,
especially for the questions with rarely appeared
structures. As a contrast, our approach leveraged
multiple networks to learn predictors for different
query substructures, and ranked query structures
using combinational function, which gained a bet-
ter performance.

The results on QALD-5 dataset is not as high as
the result on LC-QuAD. This is because QALD-5
contains 11% of very difficult questions, requir-
ing complex filtering conditions such as REGEX
and numerical comparison. These questions are
currently beyond our approach’s ability. Also, the
size of training data is significant smaller.

4.3 Detailed Analysis

4.3.1 Ablation Study
We compared the following settings of SubQG:

Rank w/o substructures. We replaced the
query substructure prediction and query structure
ranking module, by choosing an existing query
structure in the training data for the input question,
using a BiLSTM multiple classification network.

Rank w/ substructures We removed the merg-
ing module described in Section 3.4. This setting
assumes that the appropriate query structure for an
input question exists in the training data.

Merge query substructures This setting ig-
nored existing query structures in the training data,
and only considered the merged results of query
substructures.

As the results shown in Table 4, the full ver-

https://github.com/dice-group/NLIWOD


2620

Table 4: Average F1-scores for different settings
LC-QuAD QALD-5

SubQG 0.846±0.016 0.624±0.030
Rank w/o substructures 0.756±0.012 0.383±0.024
Rank w/ substructures 0.841±0.014 0.614±0.036
Merge query substructures 0.679±0.020 0.454±0.055

Table 5: Accuracy of query substructure prediction
LC-QuAD QALD-5

BiLSTM w/ attention 0.929±0.002 0.816±0.010
BiLSTM w/o attention 0.898±0.004 0.781±0.009
BiLSTM w/ attention + POS 0.925±0.004 0.818±0.007
CNN in (Yih et al., 2015) 0.856±0.006 0.740±0.010

sion of SubQG achieved the best results on both
datasets. Rank w/o substructures gained a compar-
atively low performance, especially when there is
inadequate training data (on QALD-5). Compared
with Rank w/ substructures, SubQG gained a fur-
ther improvement, which indicates that the merg-
ing method successfully handled questions with
unseen query structures.

Table 5 shows the accuracy of some alternative
networks for query substructure prediction (Sec-
tion 3.2). By removing the attention mechanism
(replaced by unweighted average), the accuracy
declined approximately 3%. Adding additional
part of speech tag sequence of the input question
gained no significant improvement. We also tried
to replace the attention based BiLSTM with the
network in (Yih et al., 2015), which encodes ques-
tions with a convolutional layer followed by a max
pooling layer. This approach did not perform well
since it cannot capture long-term dependencies.

4.3.2 Results with Noisy Linking

We simulated the real KBQA environment by con-
sidering noisy entity/relation linking results. We
firstly mixed the correct linking result for each
mention with the top-5 candidates generated from
EARL (Dubey et al., 2018), which is a joint en-
tity/relation linking system with state-of-the-art
performance on LC-QuAD. The result is shown in
the second row of Table 6. Although the precision
for first output declined 11.4%, in 85% cases we
still can generate correct answer in top-5. This is
because SubQG ranked query structures first and
considered linking results in the last step. Many
error linking results can be filtered out by the
empty query check or domain/range check.

We also test the performance of our approach
only using the EARL linking results. The per-
formance dropped dramatically in comparison to
the first two rows. The main reason is that, for

Table 6: Average Precision@k scores of query genera-
tion on LC-QuAD with noisy linking

Precision@1 Precision@5
Gold standard 0.842±0.017 0.886±0.014
Top-5 EARL + gold standard 0.728±0.011 0.850±0.009
Top-5 EARL 0.126±0.012 0.146±0.010

82.8% of the questions, EARL provided partially
correct results. If we consider the remaining ques-
tions, our system again have 73.2% and 84.8% of
correctly-generated queries in top-1 and top-5 out-
put, respectively.

4.3.3 Results on Varied Sizes of Training
Data

We tested the performance of SubQG with dif-
ferent sizes of training data. The results on LC-
QuAD dataset are shown in Figure 7. With more
training data, our query substructure based ap-
proaches obtained stable improvements on both
precision and recall. Although the merging mod-
ule impaired the overall precision a little bit, it
shows a bigger improvement on recall, especially
when there is very few training data. Gener-
ally speaking, equipped with the merging module,
our substructure based query generation approach
showed the best performance.

4.3.4 Error Analysis

We analyzed 100 randomly sampled questions that
SubQG did not return correct answers. The major
causes of errors are summarized as follows:

Query structure errors (71%) occurred due to
multiple reasons. Firstly, 21% of error cases have
entity mentions that are not correctly detected be-
fore query substructure prediction, which highly
influenced the prediction result. Secondly, in 39%
of the cases a part of substructure predictors pro-
vided wrong prediction, which led to wrong struc-
ture ranking results. Finally, in the remaining 11%
of the cases the correct query structure did not ap-
pear in the training data, and they cannot be gen-
erated by merging substructures.

Grounding errors (29%) occurred when
SubQG generated wrong queries with cor-
rect query structures. For example, for the
question “Was Kevin Rudd the prime minis-
ter of Julia Gillard”, SubQG cannot distin-
guish 〈JG, primeMinister,KR〉 from 〈KR,
primeMinister, JG〉, since both triples exist in
DBpedia. We believe that extra training data are
required for fixing this problem.



2621

0.662 

0.751 

0.814 
0.841 

0.719 
0.764 

0.822 0.846 

0.552 

0.655 

0.717 
0.756 

0.5

0.6

0.7

0.8

0.9

20% 40% 60% 80%

F1
-S

co
re

Proportion of training data

0.771 
0.793 

0.839 0.853 

0.757 
0.783 

0.831 
0.849 

0.640 
0.681 

0.732 
0.766 

0.6

0.7

0.8

0.9

20% 40% 60% 80%

Pr
ec

is
io

n

Proportion of training data

0.580 

0.714 

0.790 
0.829 

0.685 
0.746 

0.813 0.842 

0.486 

0.630 

0.703 
0.746 

0.4

0.5

0.6

0.7

0.8

0.9

20% 40% 60% 80%

R
ec

al
l

Proportion of training data

Figure 7: Precision, recall and F1-score with varied proportions of training data

5 Related Work

Alongside with entity and relation linking, exist-
ing KBQA systems often leverage formal query
generation for complex question answering (Bao
et al., 2016; Trivedi et al., 2017). Based on our in-
vestigation, the query generation approaches can
be roughly divided into two kinds: template-based
and semantic parsing-based.

Template-based approaches transform the input
question into a formal query by employing pre-
collected query templates. Cui et al.(2017) col-
lect different natural language expressions for the
same query intention from question-answer pairs.
Singh et al.(2018) re-implement and evaluate the
query generation module in NLIWOD, which se-
lects an existing template by some simple features
such as the number of entities and relations in
the input question. Recently, several query de-
composition methods are studied to enlarge the
coverage of the templates. Abujabal et al.(2017)
present a KBQA system named QUINT, which
collects query templates for specific dependency
structures from question-answer pairs. Further-
more, it rewrites the dependency parsing results
for questions with conjunctions, and then per-
forms sub-question answering and answer stitch-
ing. Zheng et al.(2018) decompose questions by
using a huge number of triple-level templates ex-
tracted by distant supervision. Compared with
these approaches, our approach predicts all kinds
of query substructures (usually 1 to 4 triples) con-
tained in the question, making full use of the train-
ing data. Also, our merging method can handle
questions with unseen query structures, having a
larger coverage and a more stable performance.

Semantic parsing-based approaches translate
questions into formal queries using bottom up
parsing (Berant et al., 2013) or staged query graph
generation (Yih et al., 2015). gAnswer (Zou
et al., 2014; Hu et al., 2018) builds up seman-

tic query graph for question analysis and uti-
lize subgraph matching for disambiguation. Re-
cent studies combine parsing based approaches
with neural networks, to enhance the ability for
structure disambiguation. Bao et al.(2016), Luo
et al.(2018) and Zafar et al.(2018) build query
graphs by staged query generation, and follow an
encode-and-compare framework to rank candidate
queries with neural networks. These approaches
try to learn entire representations for questions
with different query structures by using a single
network. Thus, they may suffer from the lack of
training data, especially for questions with rarely
appeared structures. By contrast, our approach uti-
lizes multiple networks to learn predictors for dif-
ferent query substructures, which can gain a stable
performance with limited training data. Also, our
approach does not require manually-written rules,
and performs stably with noisy linking results.

6 Conclusion

In this paper, we introduced SubQG, a formal
query generation approach based on frequent
query substructures. SubQG firstly utilizes multi-
ple neural networks to predict query substructures
contained in the question, and then ranks existing
query structures using a combinational function.
Moreover, SubQG merges query substructures to
build new query structures for questions without
appropriate query structures in the training data.
Our experiments showed that SubQG achieved su-
perior results than the existing approaches, espe-
cially for complex questions.

In future work, we plan to add support for other
complex questions whose queries require UNION,
GROUP BY, or numerical comparison. Also, we
are interested in mining natural language expres-
sions for each query substructures, which may
help current parsing approaches.



2622

7 Acknowledgments

This work is supported by the National Natural
Science Foundation of China (Nos. 61772264 and
61872172). We would like to thank Yao Zhao for
his help in preparing evaluation.

References
Abdalghani Abujabal, Mohamed Yahya, Mirek Riede-

wald, and Gerhard Weikum. 2017. Automated tem-
plate generation for question answering over knowl-
edge graphs. In Proceedings of the 26th Interna-
tional Conference on World Wide Web, WWW 2017,
pages 1191–1200.

Jun-Wei Bao, Nan Duan, Zhao Yan, Ming Zhou, and
Tiejun Zhao. 2016. Constraint-based question an-
swering with knowledge graph. In Proceedings of
the 26th International Conference on Computational
Linguistics, COLING 2016, pages 2503–2514.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing, EMNLP 2013, pages 1533–1544.

Wanyun Cui, Yanghua Xiao, Haixun Wang, Yangqiu
Song, Seung-won Hwang, and Wei Wang. 2017.
KBQA: learning question answering over QA cor-
pora and knowledge bases. Proceedings of the
VLDB Endowment, 10(5):565–576.

Mohnish Dubey, Debayan Banerjee, Debanjan Chaud-
huri, and Jens Lehmann. 2018. EARL: joint en-
tity and relation linking for question answering over
knowledge graphs. In Proceedings of the 17th In-
ternational Semantic Web Conference, ISWC 2018,
Part I, pages 108–126.

Sen Hu, Lei Zou, Jeffrey Xu Yu, Haixun Wang, and
Dongyan Zhao. 2018. Answering natural language
questions by subgraph matching over knowledge
graphs. IEEE Transactions on Knowledge and Data
Engineering, 30(5):824–837.

Kangqi Luo, Fengli Lin, Xusheng Luo, and Kenny Q.
Zhu. 2018. Knowledge base question answering via
encoding of complex query graphs. In Proceedings
of the 2018 Conference on Empirical Methods in
Natural Language Processing, EMNLP 2018, pages
2185–2194.

Colin Raffel and Daniel P. W. Ellis. 2015. Feed-
forward networks with attention can solve
some long-term memory problems. CoRR,
abs/1512.08756.

Saeedeh Shekarpour, Edgard Marx, Axel-
Cyrille Ngonga Ngomo, and Sören Auer. 2015.
SINA: semantic interpretation of user queries for
question answering on interlinked data. Journal of
Web Semantics, 30:39–51.

Kuldeep Singh, Arun Sethupat Radhakrishna, An-
dreas Both, Saeedeh Shekarpour, Ioanna Lytra, Ri-
cardo Usbeck, Akhilesh Vyas, Akmal Khikmatul-
laev, Dharmen Punjani, Christoph Lange, Maria-
Esther Vidal, Jens Lehmann, and Sören Auer. 2018.
Why reinvent the wheel: Let’s build question an-
swering systems together. In Proceedings of the
27th International Conference on World Wide Web,
TheWebConf 2018, pages 1247–1256.

Alon Talmor and Jonathan Berant. 2018. The Web as
a knowledge-base for answering complex questions.
In Proceedings of the 2018 Conference of the North
American Chapter of the Association for Computa-
tional Linguistics: Human Language Technologies,
NAACL-HLT 2018, pages 641–651.

Priyansh Trivedi, Gaurav Maheshwari, Mohnish
Dubey, and Jens Lehmann. 2017. LC-QuAD: A cor-
pus for complex question answering over knowledge
graphs. In Proceedings of the 16th International Se-
mantic Web Conference, ISWC 2017, Part II, pages
210–218.

Christina Unger, Corina Forascu, Vanessa López,
Axel-Cyrille Ngonga Ngomo, Elena Cabrio, Philipp
Cimiano, and Sebastian Walter. 2015. Question an-
swering over linked data (QALD-5). In Working
Notes of Conference and Labs of the Evaluation Fo-
rum, CLEF 2015.

Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and
Jianfeng Gao. 2015. Semantic parsing via staged
query graph generation: Question answering with
knowledge base. In Proceedings of the 53rd Annual
Meeting of the Association for Computational Lin-
guistics, ACL 2015, pages 1321–1331.

Hamid Zafar, Giulio Napolitano, and Jens Lehmann.
2018. Formal query generation for question an-
swering over knowledge bases. In Proceedings of
the 15th Extended Semantic Web Conference, ESWC
2018, pages 714–728.

Weiguo Zheng, Jeffrey Xu Yu, Lei Zou, and Hong
Cheng. 2018. Question answering over knowledge
graphs: Question understanding via template de-
composition. Proceedings of the VLDB Endowment,
11(11):1373–1386.

Lei Zou, Ruizhe Huang, Haixun Wang, Jeffrey Xu Yu,
Wenqiang He, and Dongyan Zhao. 2014. Natu-
ral language question answering over RDF: a graph
data driven approach. In Proceedings of the Inter-
national Conference on Management of Data, SIG-
MOD 2014, pages 313–324.

https://doi.org/10.1145/3038912.3052583
https://doi.org/10.1145/3038912.3052583
https://doi.org/10.1145/3038912.3052583
http://aclweb.org/anthology/C/C16/C16-1236.pdf
http://aclweb.org/anthology/C/C16/C16-1236.pdf
http://aclweb.org/anthology/D/D13/D13-1160.pdf
http://aclweb.org/anthology/D/D13/D13-1160.pdf
https://doi.org/10.14778/3055540.3055549
https://doi.org/10.14778/3055540.3055549
https://doi.org/10.1007/978-3-030-00671-6_7
https://doi.org/10.1007/978-3-030-00671-6_7
https://doi.org/10.1007/978-3-030-00671-6_7
https://doi.org/10.1109/TKDE.2017.2766634
https://doi.org/10.1109/TKDE.2017.2766634
https://doi.org/10.1109/TKDE.2017.2766634
https://aclanthology.info/papers/D18-1242/d18-1242
https://aclanthology.info/papers/D18-1242/d18-1242
http://arxiv.org/abs/1512.08756
http://arxiv.org/abs/1512.08756
http://arxiv.org/abs/1512.08756
https://doi.org/10.1016/j.websem.2014.06.002
https://doi.org/10.1016/j.websem.2014.06.002
https://doi.org/10.1145/3178876.3186023
https://doi.org/10.1145/3178876.3186023
https://aclanthology.info/papers/N18-1059/n18-1059
https://aclanthology.info/papers/N18-1059/n18-1059
https://doi.org/10.1007/978-3-319-68204-4_22
https://doi.org/10.1007/978-3-319-68204-4_22
https://doi.org/10.1007/978-3-319-68204-4_22
http://ceur-ws.org/Vol-1391/173-CR.pdf
http://ceur-ws.org/Vol-1391/173-CR.pdf
http://aclweb.org/anthology/P/P15/P15-1128.pdf
http://aclweb.org/anthology/P/P15/P15-1128.pdf
http://aclweb.org/anthology/P/P15/P15-1128.pdf
https://doi.org/10.1007/978-3-319-93417-4_46
https://doi.org/10.1007/978-3-319-93417-4_46
https://doi.org/10.14778/3236187.3236192
https://doi.org/10.14778/3236187.3236192
https://doi.org/10.14778/3236187.3236192
https://doi.org/10.1145/2588555.2610525
https://doi.org/10.1145/2588555.2610525
https://doi.org/10.1145/2588555.2610525

