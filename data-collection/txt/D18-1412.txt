




































Syntactic Scaffolds for Semantic Structures


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 3772–3782
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

3772

Syntactic Scaffolds for Semantic Structures

Swabha Swayamdipta♠ Sam Thomson♠
Kenton Lee♦ Luke Zettlemoyerr Chris Dyer♥ Noah A. Smithr♣

♠Language Technologies Institute, Carnegie Mellon University
♦Google AI Language

rPaul G. Allen School of Computer Science & Engineering, University of Washington
♥Google DeepMind

♣Allen Institute for Artificial Intelligence
{swabha,sammthomson}@cs.cmu.edu {kentonl,cdyer}@google.com

{lsz,nasmith}@cs.washington.edu

Abstract

We introduce the syntactic scaffold, an ap-
proach to incorporating syntactic informa-
tion into semantic tasks. Syntactic scaffolds
avoid expensive syntactic processing at run-
time, only making use of a treebank during
training, through a multitask objective. We im-
prove over strong baselines on PropBank se-
mantics, frame semantics, and coreference res-
olution, achieving competitive performance on
all three tasks.

1 Introduction

As algorithms for the semantic analysis of natu-
ral language sentences have developed, the role
of syntax has been repeatedly revisited. Linguis-
tic theories have argued for a very tight integra-
tion of syntactic and semantic processing (Steed-
man, 2000; Copestake and Flickinger, 2000), and
many systems have used syntactic dependency
or phrase-based parsers as preprocessing for se-
mantic analysis (Gildea and Palmer, 2002; Pun-
yakanok et al., 2008; Das et al., 2014). Mean-
while, some recent methods forgo explicit syntac-
tic processing altogether (Zhou and Xu, 2015; He
et al., 2017; Lee et al., 2017; Peng et al., 2017).

Because annotated training datasets for se-
mantics will always be limited, we expect that
syntax—which offers an incomplete but poten-
tially useful view of semantic structure—will con-
tinue to offer useful inductive bias, encouraging
semantic models toward better generalization. We
address the central question: is there a way for se-
mantic analyzers to benefit from syntax without
the computational cost of syntactic parsing?

We propose a multitask learning approach to
incorporating syntactic information into learned

representations of neural semantics models (§2).
Our approach, the syntactic scaffold, minimizes
an auxiliary supervised loss function, derived from
a syntactic treebank. The goal is to steer the dis-
tributed, contextualized representations of words
and spans toward accurate semantic and syntactic
labeling. We avoid the cost of training or execut-
ing a full syntactic parser, and at test time (i.e.,
runtime in applications) the semantic analyzer has
no additional cost over a syntax-free baseline. Fur-
ther, the method does not assume that the syntactic
treebank overlaps the dataset for the primary task.

Many semantic tasks involve labeling spans, in-
cluding semantic role labeling (SRL; Gildea and
Jurafsky, 2002) and coreference resolution (Ng,
2010) (tasks we consider in this paper), as well
as named entity recognition and some reading
comprehension and question answering tasks (Ra-
jpurkar et al., 2016). These spans are usu-
ally syntactic constituents (cf. PropBank; Palmer
et al., 2005), making phrase-based syntax a natu-
ral choice for a scaffold. See Figure 1 for an ex-
ample sentence with syntactic and semantic anno-
tations. Since the scaffold task is not an end in
itself, we relax the syntactic parsing problem to
a collection of independent span-level predictions,
with no constraint that they form a valid parse tree.
This means we never need to run a syntactic pars-
ing algorithm.

Our experiments demonstrate that the syntactic
scaffold offers a substantial boost to state-of-the-
art baselines for two SRL tasks (§5) and corefer-
ence resolution (§6). Our models use the strongest
available neural network architectures for these
tasks, integrating deep representation learning (He
et al., 2017) and structured prediction at the level
of spans (Kong et al., 2016). For SRL, the base-



3773

themheAfter encouraging them , told goodbye and left for

STIMULATE
_EMOTION Experiencer

TELLINGTime Speaker Addressee Message

DEPARTING
GoalTime Theme

TIME_VECTOR
EventLandmark Event

Macedonia

NPNP NPNP NP

S|VP VP PP

VPPP

VP

TOP|S
ARGM-TMP
ARGM-TMP

ARG1
ARG0
ARG0 ARG1

ARG2

Syntax
Co

re
fe

re
nc

e
Fr

am
e-

 
Se

m
an

ti
cs

encourage.02 tell.01 leave.04

ARG2

Pr
op

B
an

k 
 

Se
m

an
ti

cs

after.PREP encourage.V tell.V leave.V

Figure 1: An example sentence with syntactic, PropBank and coreference annotations from OntoNotes,
and author-annotated frame-semantic structures. PropBank SRL arguments and coreference mentions are
annotated on top of syntactic constituents. All but one frame-semantic argument (Event) is a syntactic
constituent. Targets evoke frames shown in the color-coded layers.

line itself is a novel globally normalized structured
conditional random field, which outperforms the
previous state of the art.1 Syntactic scaffolds re-
sult in further improvements over prior work—
3.6 absolute F1 in FrameNet SRL, 1.1 absolute
F1 in PropBank SRL, and 0.6 F1 in coreference
resolution (averaged across three standard scores).
Our code is open source and available at https:
//github.com/swabhs/scaffolding.

2 Syntactic Scaffolds

Multitask learning (Caruana, 1997) is a collec-
tion of techniques in which two or more tasks are
learned from data with at least some parameters
shared. We assume there is only one task about
whose performance we are concerned, denoted T1
(in this paper, T1 is either SRL or coreference res-
olution). We use the term “scaffold” to refer to
a second task, T2, that can be combined with T1
during multitask learning. A scaffold task is only
used during training; it holds no intrinsic interest
beyond biasing the learning of T1, and after learn-
ing is completed, the scaffold is discarded.

A syntactic scaffold is a task designed to steer
the (shared) model toward awareness of syntactic

1This excludes models initialized with deep, contextual-
ized embeddings (Peters et al., 2018), an approach orthogonal
to ours.

structure. It could be defined through a syntac-
tic parser that shares some parameters with T1’s
model. Since syntactic parsing is costly, we use
simpler syntactic prediction problems (discussed
below) that do not produce whole trees.

As with multitask learning in general, we do not
assume that the same data are annotated with out-
puts for T1 and T2. In this work, T2 is defined
using phrase-structure syntactic annotations from
OntoNotes 5.0 (Weischedel et al., 2013; Pradhan
et al., 2013). We experiment with three settings:
one where the corpus for T2 does not overlap with
the training datasets for T1 (frame-SRL) and two
where there is a complete overlap (PropBank SRL
and coreference). Compared to approaches which
require multiple output labels over the same data,
we offer the major advantage of not requiring any
assumptions about, or specification of, the rela-
tionship between T1 and T2 output.

3 Related Work

We briefly contrast the syntactic scaffold with ex-
isting alternatives.

Pipelines. In a typical pipeline, T1 and T2 are
separately trained, with the output of T2 used to
define the inputs to T1 (Wolpert, 1992). Using
syntax as T2 in a pipeline is perhaps the most

https://github.com/swabhs/scaffolding
https://github.com/swabhs/scaffolding


3774

common approach for semantic structure predic-
tion (Toutanova et al., 2008; Yang and Mitchell,
2017; Wiseman et al., 2016).2 However, pipelines
introduce the problem of cascading errors (T2’s
mistakes affect the performance, and perhaps the
training, of T1; He et al., 2013). To date, reme-
dies to cascading errors are so computationally ex-
pensive as to be impractical (e.g., Finkel et al.,
2006). A syntactic scaffold is quite different from
a pipeline since the output of T2 is never explicitly
used.

Latent variables. Another solution is to treat
the output of T2 as a (perhaps structured) la-
tent variable. This approach obviates the need
of supervision for T2 and requires marginalization
(or some approximation to it) in order to reason
about the outputs of T1. Syntax as a latent vari-
able for semantics was explored by Zettlemoyer
and Collins (2005) and Naradowsky et al. (2012).
Apart from avoiding marginalization, the syntactic
scaffold offers a way to use auxiliary syntactically-
annotated data as direct supervision for T2, and it
need not overlap the T1 training data.

Joint learning of syntax and semantics. The
motivation behind joint learning of syntactic and
semantic representations is that any one task is
helpful in predicting the other (Lluı́s and Màrquez,
2008; Lluı́s et al., 2013; Henderson et al., 2013;
Swayamdipta et al., 2016). This typically re-
quires joint prediction of the outputs of T1 and
T2, which tends to be computationally expensive
at both training and test time.

Part of speech scaffolds. Similar to our work,
there have been multitask models that use part-
of-speech tagging as T2, with transition-based de-
pendency parsing (Zhang and Weiss, 2016) and
CCG supertagging (Søgaard and Goldberg, 2016)
as T1. Both of the above approaches assumed par-
allel input data and used both tasks as supervision.
Notably, we simplify our T2, throwing away the
structured aspects of syntactic parsing, whereas
part-of-speech tagging has very little structure
to begin with. While their approach results in
improved token-level representations learned via
supervision from POS tags, these must still be
composed to obtain span representations. In-

2 There has been some recent work on SRL which com-
pletely forgoes syntactic processing (Zhou and Xu, 2015),
however it has been shown that incorporating syntactic in-
formation still remains useful (He et al., 2017).

stead, our approach learns span-level representa-
tions from phrase-type supervision directly, for se-
mantic tasks. Additionally, these methods explore
architectural variations in RNN layers for includ-
ing supervision, whereas we focus on incorporat-
ing supervision with minimal changes to the base-
line architecture. To the best of our knowledge,
such simplified syntactic scaffolds have not been
tried before.

Word embeddings. Our definition of a scaffold
task almost includes stand-alone methods for es-
timating word embeddings (Mikolov et al., 2013;
Pennington et al., 2014; Peters et al., 2018). Af-
ter training word embeddings, the tasks implied
by models like the skip-gram or ELMo’s language
model become irrelevant to the downstream use of
the embeddings. A noteworthy difference is that,
rather than pre-training, a scaffold is integrated di-
rectly into the training of T1 through a multitask
objective.

Multitask learning. Neural architectures have
often yielded performance gains when trained for
multiple tasks together (Collobert et al., 2011; Lu-
ong et al., 2015; Chen et al., 2017; Hashimoto
et al., 2017). In particular, performance of seman-
tic role labeling tasks improves when done jointly
with other semantic tasks (FitzGerald et al., 2015;
Peng et al., 2017, 2018). Contemporaneously with
this work, Hershcovich et al. (2018) proposed a
multitask learning setting for universal syntactic
dependencies and UCCA semantics (Abend and
Rappoport, 2013). Syntactic scaffolds focus on a
primary semantic task, treating syntax as an auxil-
lary, eventually forgettable prediction task.

4 Syntactic Scaffold Model

We assume two sources of supervision: a cor-
pusD1 with instances x annotated for the primary
task’s outputs y (semantic role labeling or corefer-
ence resolution), and a treebankD2 with sentences
x, each with a phrase-structure tree z.

4.1 Loss
Each task has an associated loss, and we seek to
minimize the combination of task losses,∑

(x,y)∈D1
L1(x, y) + δ

∑
(x,z)∈D2

L2(x, z) (1)

with respect to parameters, which are partially
shared, where δ is a tunable hyperparameter. In



3775

the rest of this section, we describe the scaffold
task. We define the primary tasks in Sections 5–6.

Each input is a sequence of tokens, x =
〈x1, x2, . . . , xn〉, for some n. We refer to a span
of contiguous tokens in the sentence as xi: j =
〈xi, xi+1, . . . , x j〉, for any 1 6 i 6 j 6 n. In our
experiments we consider only spans up to a maxi-
mum length D, resulting in O(nD) spans.

Supervision comes from a phrase-syntactic tree
z for the sentence, comprising a syntactic category
zi: j ∈ C for every span xi: j in x (many spans are
given a null label). We experiment with different
sets of labels C (§4.2).

In our model, every span xi: j is represented by
an embedding vector vi: j (see details in §5.3). A
distribution over the category assigned to zi: j is de-
rived from vi: j:

p(zi: j = c | xi: j) = softmax
c

wc · vi: j (2)

where wc is a parameter vector associated with
category c. We sum the log loss terms for all the
spans in a sentence to give its loss:

L2(x, z) = −
∑

16i6 j6n
j−i6D

log p(zi: j | xi: j). (3)

4.2 Labels for the Syntactic Scaffold Task
Different kinds of syntactic labels can be used for
learning syntactically-aware span representations:
• Constituent identity: C = {0, 1}; is a span a

constituent, or not?
• Non-terminal: c is the category of a span,

including a null for non-constituents.
• Non-terminal and parent: c is the category

of a span, concatenated with the category of
its immediate ancestor. null is used for non-
constituents, and for empty ancestors.
• Common non-terminals: Since a majority

of semantic arguments and entity mentions
are labeled with a small number of syntac-
tic categories,3 we experiment with a three-
way classification among (i) noun phrase (or
prepositional phrase, for frame SRL); (ii) any
other category; and (iii) null.

In Figure 1, for the span “encouraging them”,
the constituent identity scaffold label is 1, the non-
terminal label is S|VP, the non-terminal and par-
ent label is S|VP+par=PP, and the common non-
terminals label is set to OTHER.

3In the OntoNotes corpus, which includes both syntac-
tic and semantic annotations, 44% of semantic arguments are
noun phrases and 13% are prepositional phrases.

5 Semantic Role Labeling

We contribute a new SRL model which contributes
a strong baseline for experiments with syntactic
scaffolds. The performance of this baseline itself
is competitive with state-of-the-art methods (§7).

FrameNet. In the FrameNet lexicon (Baker
et al., 1998), a frame represents a type of event,
situation, or relationship, and is associated with a
set of semantic roles, called frame elements. A
frame can be evoked by a word or phrase in a sen-
tence, called a target. Each frame element of an
evoked frame can then be realized in the sentence
as a sentential span, called an argument (or it can
be unrealized). Arguments for a given frame do
not overlap.

PropBank. PropBank similarly disambiguates
predicates and identifies argument spans. Tar-
gets are disambiguated to lexically specific senses
rather than shared frames, and a set of generic
roles is used for all targets, reducing the argument
label space by a factor of 17. Most importantly,
the arguments were annotated on top of syntactic
constituents, directly coupling syntax and seman-
tics. A detailed example for both formalisms is
provided in Figure 1.

Semantic structure prediction is the task of iden-
tifying targets, labeling their frames or senses, and
labeling all their argument spans in a sentence.
Here we assume gold targets and frames, and con-
sider only the SRL task.

Formally, a single input instance for argument
identification consists of: an n-word sentence x =
〈x1, x2, . . . , xn〉, a single target span t = 〈tstart, tend〉,
and its evoked frame, or sense, f . The argu-
ment labeling task is to produce a segmentation
of the sentence: s = 〈s1, s2, . . . , sm〉 for each in-
put x. A segment s = 〈i, j, yi: j〉 corresponds to
a labeled span of the sentence, where the label
yi: j ∈ Y f ∪ {null} is either a role that the span
fills, or null if the span does not fill any role. In
the case of PropBank, Y f consists of all possible
roles. The segmentation is constrained so that ar-
gument spans cover the sentence and do not over-
lap (ik+1 = 1 + jk for sk; i1 = 1; jm = n). Segments
of length 1 such that i = j are allowed. A separate
segmentation is predicted for each target annota-
tion in a sentence.



3776

5.1 Semi-Markov CRF

In order to model the non-overlapping arguments
of a given target, we use a semi-Markov condi-
tional random field (semi-CRF; Sarawagi et al.,
2004). Semi-CRFs define a conditional distribu-
tion over labeled segmentations of an input se-
quence, and are globally normalized. A single tar-
get’s arguments can be neatly encoded as a labeled
segmentation by giving the spans in between argu-
ments a reserved null label. Semi-Markov mod-
els are more powerful than BIO tagging schemes,
which have been used successfully for PropBank
SRL (Collobert et al., 2011; Zhou and Xu, 2015,
inter alia), because the semi-Markov assumption
allows scoring variable-length segments, rather
than fixed-length label n-grams as under an (n −
1)-order Markov assumption. Computing the
marginal likelihood with a semi-CRF can be done
using dynamic programming in O(n2) time (§5.2).
By filtering out segments longer than D tokens,
this is reduced to O(nD).

Given an input x, a semi-CRF defines a condi-
tional distribution p(s | x). Every segment s =
〈i, j, yi: j〉 is given a real-valued score, ψ(〈i, j, yi: j =
r〉, xi: j) = wr · vi: j, where vi: j is an embedding
of the span (§5.3) and wr is a parameter vector
corresponding to its label. The score of the en-
tire segmentation s is the sum of the scores of
its segments: Ψ(x, s) =

∑m
k=1 ψ(sk, xik: jk ). These

scores are exponentiated and normalized to define
the probability distribution. The sum-product vari-
ant of the semi-Markov dynamic programming al-
gorithm is used to calculate the normalization term
(required during learning). At test time, the max-
product variant returns the most probable segmen-
tation, ŝ = arg max sΨ(s, x).

The parameters of the semi-CRF are learned to
maximize a criterion related to the conditional log-
likelihood of the gold-standard segments in the
training corpus (§5.2). The learner evaluates and
adjusts segment scores ψ(sk, x) for every span in
the sentence, which in turn involves learning em-
bedded representations for all spans (§5.3).

5.2 Softmax-Margin Objective

Typically CRF and semi-CRF models are trained
to maximize a conditional log-likelihood objec-
tive. In early experiments, we found that incor-
porating a structured cost was beneficial; we do
so by using a softmax-margin training objective
(Gimpel and Smith, 2010), a “cost-aware” variant

of log-likelihood:

L1 = −
∑

(x,s∗)∈D1
log

exp Ψ(s∗, x)
Z(x, s∗)

, (4)

Z(x, s∗) =
∑

s
exp {Ψ(s, x) + cost(s, s∗)}. (5)

We design the cost function so that it factors by
predicted span, in the same way Ψ does:

cost(s, s∗) =
∑
s∈s

cost(s, s∗) =
∑
s∈s
I(s < s∗). (6)

The softmax-margin criterion, like log-likelihood,
is globally normalized over all of the exponentially
many possible labeled segmentations. The follow-
ing zeroth-order semi-Markov dynamic program
(Sarawagi et al., 2004) efficiently computes the
new partition function:

α j =
∑

s=〈i, j,yi: j〉
j−i6D

αi−1 exp{Ψ(s, x) + cost(s, s∗)}, (7)

where Z = αn, under the base case α0 = 1.
The prediction under the model can be calcu-

lated using a similar dynamic program with the
following recurrence where γ0 = 1:

γ j = max
s=〈i, j,yi: j〉

j−i6D

γi−1 exp Ψ(s, x). (8)

Our model formulation enforces that arguments do
not overlap. We do not enforce any other SRL
constraints, such as non-repetition of core frame
elements (Das et al., 2012).

5.3 Input Span Representation
This section describes the neural architecture used
to obtain the span embedding, vi: j, correspond-
ing to a span xi: j and the target in consideration,
t = 〈tstart, tend〉. For the scaffold task, since the
syntactic treebank does not contain annotations for
semantic targets, we use the last verb in the sen-
tence as a placeholder target, wherever target fea-
tures are used. If there are no verbs, we use the
first token in the sentence as a placeholder target.
The parameters used to learn v are shared between
the tasks.

We construct an embedding for the span using
• hi and h j: contextualized embeddings for the

words at the span boundary (§5.3.1),
• ui: j: a span summary that pools over the con-

tents of the span (§5.3.2), and



3777

• ai: j: and a hand-engineered feature vector for
the span (§5.3.3).

This embedding is then passed to a feedforward
layer to compute the span representation, vi: j.

5.3.1 Contextualized Token Embeddings
To obtain contextualized embeddings of each to-
ken in the input sequence, we run a bidirectional
LSTM (Graves, 2012) with ` layers over the full
input sequence. To indicate which token is a pred-
icate, a linearly transformed one-hot embedding v
is used, following Zhou and Xu (2015) and He
et al. (2017). The input vector representing the
token at position q in the sentence is the concate-
nation of a fixed pretrained embedding xq and vq.
When given as input to the bidirectional LSTM,
this yields a hidden state vector hq representing
the qth token in the context of the sentence.

5.3.2 Span Summary
Tokens within a span might convey different
amounts of information necessary to label the span
as a semantic argument. Following Lee et al.
(2017), we use an attention mechanism (Bahdanau
et al., 2014) to summarize each span. Each con-
textualized token in the span is passed through a
feed-forward network to obtain a weight, normal-
ized to give σk = softmax

i6k6 j
whead · hk, where whead

is a learned parameter. The weights σ are then
used to obtain a vector that summarizes the span,
ui: j =

∑
i6k6 j; j−i<D σk · hk.

5.3.3 Span Features
We use the following three features for each span:
• width of the span in tokens (Das et al., 2014)
• distance (in tokens) of the span from the tar-

get (Täckström et al., 2015)
• position of the span with respect to the tar-

get (before, after, overlap) (Täckström et al.,
2015)

Each of these features is encoded as a one-hot-
embedding and then linearly transformed to yield
a feature vector, ai: j.

6 Coreference Resolution

Coreference resolution is the task of determin-
ing clusters of mentions that refer to the same
entity. Formally, the input is a document x =
x1, x2, . . . , xn consisting of n words. The goal is
to predict a set of clusters c = {c1, c2, . . .}, where
each cluster c = {s1, s2, . . .} is a set of spans and

each span s = 〈i, j〉 is a pair of indices such that
1 6 i 6 j 6 n.

As a baseline, we use the model of Lee et al.
(2017), which we describe briefly in this section.
This model decomposes the prediction of coref-
erence clusters into a series of span classification
decisions. Every span s predicts an antecedent
ws ∈ Y(s) = {null, s1, s2, . . . , sm}. Labels s1 to
sm indicate a coreference link between s and one
of the m spans that precede it, and null indicates
that s does not link to anything, either because it
is not a mention or it is in a singleton cluster. The
predicted clustering of the spans can be recovered
by aggregating the predicted links.

Analogous to the SRL model (§5), every span
s is represented by an embedding vs, which is
central to the model. For each span s and a po-
tential antecedent a ∈ Y(s), pairwise coreference
scores Ψ(vs, va, φ(s, a)) are computed via feedfor-
ward networks with the span embeddings as input.
φ(s, a) are pairwise discrete features encoding the
distance between span s and span a and metadata,
such as the genre and speaker information. We re-
fer the reader to Lee et al. (2017) for the details of
the scoring function.

The scores from Ψ are normalized over the pos-
sible antecedents Y(s) of each span to induce a
probability distribution for every span:

p(ws = a) = softmax
a∈Y(s)

Ψ(vs, va, φ(s, a)) (9)

In learning, we minimize the negative log-
likelihood marginalized over the possibly correct
antecedents:

L1 = −
∑
s∈D

log
∑

a∗∈G(s)∩Y(s)
p(ws = a∗) (10)

whereD is the set of spans in the training dataset,
and G(s) indicates the gold cluster of s if it belongs
to one and {null} otherwise.

To operate under reasonable computational re-
quirements, inference under this model requires a
two-stage beam search, which reduces the number
of span pairs considered. We refer the reader to
Lee et al. (2017) for details.

Input span representation. The input span em-
bedding, vs for coreference resolution and its syn-
tactic scaffold follow the definition used in §5.3,
with the key difference of using no target features.
Since there is a complete overlap of input sen-
tences betweenDsc andDpr as the coreference an-
notations are also from OntoNotes (Pradhan et al.,



3778

2012), we reuse the v for the scaffold task. Addi-
tionally, instead of the entire document, each sen-
tence in it is independently given as input to the
bidirectional LSTMs.

7 Results

We evaluate our models on the test set of
FrameNet 1.5 for frame SRL and on the test set
of OntoNotes for both PropBank SRL and coref-
erence. For the syntactic scaffold in each case,
we use syntactic annotations from OntoNotes
5.0 (Weischedel et al., 2013; Pradhan et al.,
2013).4 Further details on experimental settings
and datasets have been elaborated in the supple-
mental material.

Frame SRL. Table 1 shows the performance of
all the scaffold models on frame SRL with respect
to prior work and a semi-CRF baseline (§5.1)
without a syntactic scaffold. We follow the offi-
cial evaluation from the SemEval shared task for
frame-semantic parsing (Baker et al., 2007).

Prior work for frame SRL has relied on pre-
dicted syntactic trees, in two different ways: by
using syntax-based rules to prune out spans of text
that are unlikely to contain any frame’s argument;
and by using syntactic features in their statistical
model (Das et al., 2014; Täckström et al., 2015;
FitzGerald et al., 2015; Kshirsagar et al., 2015).

The best published results on FrameNet 1.5 are
due to Yang and Mitchell (2017). In their sequen-
tial model (seq), they treat argument identification
as a sequence-labeling problem using a deep bidi-
rectional LSTM with a CRF layer. In their rela-
tional model (Rel), they treat the same problem as
a span classification problem. Finally, they intro-
duce an ensemble to integerate both models, and
use an integer linear program for inference satis-
fying SRL constraints. Though their model does
not do any syntactic pruning, it does use syntactic
features for argument identification and labeling.5

Notably, all prior systems for frame SRL listed
in Table 1 use a pipeline of syntax and seman-
tics. Our semi-CRF baseline outperforms all prior
work, without any syntax. This highlights the ben-

4http://cemantix.org/data/ontonotes.html
5Yang and Mitchell (2017) also evaluated on the full

frame-semantic parsing task, which includes frame-SRL as
well as identifying frames. Since our frame SRL performance
improves over theirs, we expect that incorporation into a full
system (e.g., using their frame identification module) would
lead to overall benefits as well; this experiment is left to fu-
ture work.

efits of modeling spans and of global normaliza-
tion.

Turning to scaffolds, even the most coarse-
grained constituent identity scaffold improves the
performance of our syntax-agnostic baseline. The
nonterminal and nonterminal and parent scaffolds,
which use more detailed syntactic representations,
improve over this. The greatest improvements
come from the scaffold model predicting com-
mon nonterminal labels (NP and PP, which are the
most common syntactic categories of semantic ar-
guments, vs. others): 3.6% absolute improvement
in F1 measure over prior work.

Contemporaneously with this work, Peng et al.
(2018) proposed a system for joint frame-semantic
and semantic dependency parsing. They report re-
sults for joint frame and argument identification,
and hence cannot be directly compared in Table 1.
We evaluated their output for argument identifica-
tion only; our semi-CRF baseline model exceeds
their performance by 1 F1, and our common non-
terminal scaffold by 3.1 F1.6

Model Prec. Rec. F1
Kshirsagar et al. (2015) 66.0 60.4 63.1
Yang and Mitchell (2017) (Rel) 71.8 57.7 64.0
Yang and Mitchell (2017) (Seq) 63.4 66.4 64.9
†Yang and Mitchell (2017) (All) 70.2 60.2 65.5
Semi-CRF baseline 67.8 66.2 67.0

+ constituent identity 68.1 67.4 67.7
+ nonterminal and parent 68.8 68.2 68.5
+ nonterminal 69.4 68.0 68.7
+ common nonterminals 69.2 69.0 69.1

Table 1: Frame SRL results on the test set of
FrameNet 1.5., using gold frames. Ensembles are
denoted by †.

Model Prec. Rec. F1
Zhou and Xu (2015) - - 81.3
He et al. (2017) 81.7 81.6 81.7
He et al. (2018a) 83.9 73.7 82.1
Tan et al. (2018) 81.9 83.6 82.7

Semi-CRF baseline 84.8 81.2 83.0

+ common nonterminals 85.1 82.6 83.8

Table 2: PropBank sSRL results, using gold pred-
icates, on CoNLL 2012 test. For fair comparison,
we show only non-ensembled models.

6This result is not reported in Table 1 since Peng et al.
(2018) used a preprocessing which renders the test set slightly
larger — the difference we report is calculated using their test
set.

http://cemantix.org/data/ontonotes.html


3779

Model MUC B3 CEAFφ4 Avg. F1
Prec. Rec. F1 Prec. Rec. F1 Prec. Rec. F1

Wiseman et al. (2016) 77.5 69.8 73.4 66.8 57.0 61.5 62.1 53.9 57.7 64.2
Clark and Manning (2016b) 79.9 69.3 74.2 71.0 56.5 63.0 63.8 54.3 58.7 65.3
Clark and Manning (2016a) 79.2 70.4 74.6 69.9 58.0 63.4 63.5 55.5 59.2 65.7

Lee et al. (2017) 78.4 73.4 75.8 68.6 61.8 65.0 62.7 59.0 60.8 67.2

+ common nonterminals 78.4 74.3 76.3 68.7 62.9 65.7 62.9 60.2 61.5 67.8

Table 3: Coreference resolution results on the test set on the English CoNLL-2012 shared task. The
average F1 of MUC, B3, and CEAFφ4 is the main evaluation metric. For fair comparison, we show only
non-ensembled models.

PropBank SRL. We use the OntoNotes data
from the CoNLL shared task in 2012 (Pradhan
et al., 2013) for Propbank SRL. Table 2 reports
results using gold predicates.

Recent competitive systems for PropBank SRL
follow the approach of Zhou and Xu (2015), em-
ploying deep architectures, and forgoing the use of
any syntax. He et al. (2017) improve on those re-
sults, and in analysis experiments, show that con-
straints derived using syntax may further improve
performance. Tan et al. (2018) employ a similar
approach but use feed-forward networks with self-
attention. He et al. (2018a) use a span-based clas-
sification to jointly identify and label argument
spans.

Our syntax-agnostic semi-CRF baseline model
improves on prior work (excluding ELMo), show-
ing again the value of global normalization in se-
mantic structure prediction. We obtain further im-
provement of 0.8 absolute F1 with the best syn-
tactic scaffold from the frame SRL task. This in-
dicates that a syntactic inductive bias is benefi-
cial even when using sophisticated neural archi-
tectures.

He et al. (2018a) also provide a setup where ini-
tialization was done with deep contextualized em-
beddings, ELMo (Peters et al., 2018), resulting in
85.5 F1 on the OntoNotes test set. The improve-
ments from ELMo are methodologically orthogonal
to syntactic scaffolds.

Since the datasets for learning PropBank se-
mantics and syntactic scaffolds completely over-
lap, the performance improvement cannot be at-
tributed to a larger training corpus (or, by exten-
sion, a larger vocabulary), though that might be a
factor for frame SRL.

A syntactic scaffold can match the performance
of a pipeline containing carefully extracted syntac-
tic features for semantic prediction (Swayamdipta
et al., 2017). This, along with other recent ap-

proaches (He et al., 2017, 2018b) show that syntax
remains useful, even with strong neural models for
SRL.

Coreference. We report the results on four stan-
dard scores from the CoNLL evaluation: MUC, B3

and CEAFφ4 , and their average F1 in Table 3. Prior
competitive coreference resolution systems (Wise-
man et al., 2016; Clark and Manning, 2016b,a) all
incorporate synctactic information in a pipeline,
using features and rules for mention proposals
from predicted syntax.

Our baseline is the model from Lee et al.
(2017), described in §6. Similar to the baseline
model for frame SRL, and in contrast with prior
work, this model does not use any syntax.

We experiment with the best syntactic scaffold
from the frame SRL task. We used NP, OTHER, and
null as the labels for the common nonterminals
scaffold here, since coreferring mentions are rarely
prepositional phrases. The syntactic scaffold out-
performs the baseline by 0.6 absolute F1. Contem-
poraneously, Lee et al. (2018) proposed a model
which takes in account higher order inference and
more aggressive pruning, as well as initialization
with ELMo embeddings, resulting in 73.0 average
F1. All the above are orthogonal to our approach,
and could be incorporated to yield higher gains.

8 Discussion

To investigate the performance of the syntactic
scaffold, we focus on the frame SRL results, where
we observed the greatest improvement with re-
spect to a non-syntactic baseline.

We consider a breakdown of the performance
by the syntactic phrase types of the arguments,
provided in FrameNet7 in Figure 2. Not surpris-

7We used FrameNet syntactic phrase annotations for anal-
ysis only, and not in our models, since they are annotated only
for the gold arguments.



3780

N
P PP N Sf
in

AJ
P

VP
to

AV
P A

Po
ss

VP
br

st

Phrase Types

0.4

0.5

0.6

0.7

0.8

0.9

Fr
am

eN
et

 T
es

t 
F1

Baseline
Common NT Scaffold

Figure 2: Performance breakdown by argu-
ment’s phrase category, sorted left to right by
frequency, for top ten phrase categories.

En
ti

ty

Ti
m

e

Lo
ca

le

Th
em

e

Ag
en

t

G
ro

un
d

Ev
en

t

G
oa

l

Fi
gu

re

U
ni

t

0.5

0.6

0.7

0.8

0.9

1.0

Fr
am

eN
et

 T
es

t 
F1

Baseline
Common NT Scaffold

Figure 3: Performance breakdown by top ten
frame element types, sorted left to right by fre-
quency.

ingly, we observe large improvements in the com-
mon nonterminals used (NP and PP). However,
the phrase type annotations in FrameNet do not
correspond exactly to the OntoNotes phrase cat-
egories. For instance, FrameNet annotates non-
maximal (A) and standard adjective phrases (AJP),
while OntoNotes annotations for noun-phrases are
flat, ignore the underlying adjective phrases. This
explains why the syntax-agnostic baseline is able
to recover the former while the scaffold is not.

Similarly, for frequent frame elements, scaffold-
ing improves performance across the board, as
shown in Fig. 3. The largest improvements come
for Theme and Goal, which are predominantly re-
alized as noun phrases and prepositional phrases.

9 Conclusion

We introduced syntactic scaffolds, a multitask
learning approach to incorporate syntactic bias
into semantic processing tasks. Unlike pipelines
and approaches which jointly model syntax and
semantics, no explicit syntactic processing is re-
quired at runtime. Our method improves the per-
formance of competitive baselines for semantic
role labeling on both FrameNet and PropBank,
and for coreference resolution. While our focus
was on span-based tasks, syntactic scaffolds could
be applied in other settings (e.g., dependency and
graph representations). Moreover, scaffolds need
not be syntactic; we can imagine, for example, se-
mantic scaffolds being used to improve NLP appli-
cations with limited annotated data. It remains an
open empirical question to determine the relative
merits of different kinds of scaffolds and multi-
task learners, and how they can be most produc-

tively combined. Our code is publicly available at
https://github.com/swabhs/scaffolding.

Acknowledgments

We thank several members of UW-NLP, partic-
ularly Luheng He, as well as David Weiss and
Emily Pitler for thoughtful discussions on prior
versions of this paper. We also thank the three
anonymous reviewers for their valuable feedback.
This work was supported in part by NSF grant IIS-
1562364 and by the NVIDIA Corporation through
the donation of a Tesla GPU.

References
Omri Abend and Ari Rappoport. 2013. Universal Con-

ceptual Cognitive Annotation (UCCA). In ACL.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2014. Neural machine translation by jointly
learning to align and translate. ArXiv:1409.0473.

Collin Baker, Michael Ellsworth, and Katrin Erk. 2007.
SemEval’07 Task 19: Frame semantic structure ex-
traction. In Proc. of SemEval.

Collin F. Baker, Charles J. Fillmore, and John B. Lowe.
1998. The Berkeley FrameNet project. In Proc. of
ACL.

Rich Caruana. 1997. Multitask learning. Machine
Learning, 28(1).

Xinchi Chen, Zhan Shi, Xipeng Qiu, and Xuanjing
Huang. 2017. Adversarial multi-criteria learning for
chinese word segmentation. ArXiv:1704.07556.

Kevin Clark and Christopher D Manning. 2016a. Deep
reinforcement learning for mention-ranking corefer-
ence models. In Proc. of EMNLP.

https://github.com/swabhs/scaffolding


3781

Kevin Clark and Christopher D. Manning. 2016b. Im-
proving coreference resolution by learning entity-
level distributed representations. In Proc. of ACL.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
scratch. Journal of Machine Learning Research,
12:2493–2537.

Ann Copestake and Dan Flickinger. 2000. An
open source grammar development environment and
broad-coverage English grammar using HPSG. In
Proc. of LREC.

Dipanjan Das, Desai Chen, André FT Martins, Nathan
Schneider, and Noah A Smith. 2014. Frame-
semantic parsing. Computational linguistics,
40(1):9–56.

Dipanjan Das, André F. T. Martins, and Noah A. Smith.
2012. An exact dual decomposition algorithm for
shallow semantic parsing with constraints. In Proc.
of *SEM.

Jenny Rose Finkel, Christopher D Manning, and An-
drew Y Ng. 2006. Solving the problem of cascading
errors: Approximate bayesian inference for linguis-
tic annotation pipelines. In Proc. of EMNLP.

Nicholas FitzGerald, Oscar Täckström, Kuzman
Ganchev, and Dipanjan Das. 2015. Semantic role
labeling with neural network factors. In Proc. of
EMNLP.

Daniel Gildea and Daniel Jurafsky. 2002. Automatic
labeling of semantic roles. Computational Linguis-
tics, 28(3):245–288.

Daniel Gildea and Martha Palmer. 2002. The necessity
of parsing for predicate argument recognition. In
Proc. of ACL.

Kevin Gimpel and Noah A. Smith. 2010. Softmax-
margin CRFs: Training log-linear models with cost
functions. In Proc. of NAACL.

Alex Graves. 2012. Supervised Sequence Labelling
with Recurrent Neural Networks, volume 385 of
Studies in Computational Intelligence. Springer.

Alex Graves. 2013. Generating sequences with recur-
rent neural networks. ArXiv:1308.0850.

Kazuma Hashimoto, Caiming Xiong, Yoshimasa Tsu-
ruoka, and Richard Socher. 2017. A joint many-task
model: Growing a neural network for multiple NLP
tasks. In Proc. of EMNLP.

He He, Hal Daumé III, and Jason Eisner. 2013. Dy-
namic feature selection for dependency parsing. In
Proc. of EMNLP.

Luheng He, Kenton Lee, Omer Levy, and Luke Zettle-
moyer. 2018a. Jointly predicting predicates and ar-
guments in neural semantic role labeling. In Proc.
of ACL.

Luheng He, Kenton Lee, Mike Lewis, and Luke Zettle-
moyer. 2017. Deep semantic role labeling: What
works and what’s next. In Proc. of ACL.

Shexia He, Zuchao Li, Hai Zhao, and Hongxiao Bai.
2018b. Syntax for semantic role labeling, to be, or
not to be. In Proc. of ACL.

James Henderson, Paola Merlo, Ivan Titov, and
Gabriele Musillo. 2013. Multi-lingual joint pars-
ing of syntactic and semantic dependencies with a
latent variable model. Computational Linguistics,
39(4):949–998.

Daniel Hershcovich, Omri Abend, and Ari Rappoport.
2018. Multitask parsing across semantic representa-
tions. In Proc. of ACL.

Diederik P. Kingma and Jimmy Ba. 2014.
ADAM: A method for stochastic optimization.
ArXiV:1412.6980.

Lingpeng Kong, Chris Dyer, and Noah A. Smith. 2016.
Segmental Recurrent Neural Networks. In Proc. of
ICLR.

Meghana Kshirsagar, Sam Thomson, Nathan Schnei-
der, Jaime Carbonell, Noah A Smith, and Chris
Dyer. 2015. Frame-semantic role labeling with het-
erogeneous annotations. In Proc. of NAACL.

Kenton Lee, Luheng He, Mike Lewis, and Luke Zettle-
moyer. 2017. End-to-end neural coreference resolu-
tion. In Proc. of EMNLP.

Kenton Lee, Luheng He, and Luke Zettlemoyer. 2018.
Higher-order coreference resolution with coarse-to-
fine inference. In Proc. of NAACL.

Xavier Lluı́s, Xavier Carreras, and Lluı́s Màrquez.
2013. Joint arc-factored parsing of syntactic and
semantic dependencies. Transactions of the ACL,
1:219–230.

Xavier Lluı́s and Lluı́s Màrquez. 2008. A joint model
for parsing syntactic and semantic dependencies. In
Proc. of CoNLL.

Minh-Thang Luong, Quoc V Le, Ilya Sutskever, Oriol
Vinyals, and Lukasz Kaiser. 2015. Multi-task se-
quence to sequence learning. ArXiv:1511.06114.

Tomas Mikolov, Kai Chen, Gregory S. Corrado, and
Jeffrey Dean. 2013. Efficient estimation of word
representations in vector space. ArXiv:1301.3781.

Vinod Nair and Geoffrey E. Hinton. 2010. Rectified
linear units improve restricted Boltzmann machines.
In Proc. of ICML.

Jason Naradowsky, Sebastian Riedel, and David A.
Smith. 2012. Improving NLP through marginal-
ization of hidden syntactic structure. In Proc. of
EMNLP.

Vincent Ng. 2010. Supervised noun phrase coreference
research: The first fifteen years. In Proc. of ACL.



3782

Martha Palmer, Daniel Gildea, and Paul Kingsbury.
2005. The Proposition Bank: An annotated cor-
pus of semantic roles. Computational Linguistics,
31(1):71–106.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proc. of ACL.

Hao Peng, Sam Thomson, Swabha Swayamdipta, and
Noah A. Smith. 2018. Learning joint semantic
parsers from disjoint data. In Proc. of NAACL.

Jeffrey Pennington, Richard Socher, and Christo-
pher D. Manning. 2014. GloVe: Global vectors for
word representation. In Proc. of EMNLP.

Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. ArXiv:1802.05365.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Hwee Tou Ng, Anders Björkelund, Olga Uryupina,
Yuchen Zhang, and Zhi Zhong. 2013. Towards ro-
bust linguistic analysis using OntoNotes. In Proc. of
CoNLL.

Sameer Pradhan, Alessandro Moschitti, Nianwen Xue,
Olga Uryupina, and Yuchen Zhang. 2012. CoNLL-
2012 shared task: Modeling multilingual unre-
stricted coreference in OntoNotes. In Proc. of
EMNLP.

Vasin Punyakanok, Dan Roth, and Wen-tau Yih. 2008.
The importance of syntactic parsing and inference in
semantic role labeling. Computational Linguistics,
34(2):257–287.

Pranav Rajpurkar, Jian Zhang, Konstantin Lopy-
rev, and Percy Liang. 2016. SQuAD: 100,000+
questions for machine comprehension of text.
ArXiv:1606.05250.

Sunita Sarawagi, William W Cohen, et al. 2004. Semi-
markov conditional random fields for information
extraction. In Proc. of NIPS, volume 17.

Anders Søgaard and Yoav Goldberg. 2016. Deep
multi-task learning with low level tasks supervised
at lower layers. In Proc. of ACL.

Rupesh Kumar Srivastava, Klaus Greff, and Jürgen
Schmidhuber. 2015. Training very deep networks.
In Proc. of NIPS.

Mark Steedman. 2000. Information structure and
the syntax-phonology interface. Linguistic Inquiry,
31(4):649–689.

Swabha Swayamdipta, Miguel Ballesteros, Chris Dyer,
and Noah A. Smith. 2016. Greedy, joint syntactic-
semantic parsing with Stack LSTMs. In Proc. of
CoNLL.

Swabha Swayamdipta, Sam Thomson, Chris Dyer, and
Noah A. Smith. 2017. Frame-semantic parsing with
softmax-margin segmental rnns and a syntactic scaf-
fold. Arxiv:1706.09528.

Oscar Täckström, Kuzman Ganchev, and Dipanjan
Das. 2015. Efficient inference and structured learn-
ing for semantic role labeling. Transactions of the
ACL, 3:29–41.

Zhixing Tan, Mingxuan Wang, Jun Xie, Yidong Chen,
and Xiaodong Shi. 2018. Deep semantic role label-
ing with self-attention. In Proc. of AAAI.

Kristina Toutanova, Aria Haghighi, and Christopher D.
Manning. 2008. A global joint model for se-
mantic role labeling. Computational Linguistics,
34(2):161–191.

Ralph Weischedel, Martha Palmer, Mitchell Marcus,
Eduard Hovy, Sameer Pradhan, Lance Ramshaw,
Nianwen Xue, Ann Taylor, Jeff Kaufman, Michelle
Franchini, et al. 2013. OntoNotes release 5.0
ldc2013t19. Linguistic Data Consortium, Philadel-
phia, PA.

Sam Wiseman, Alexander M Rush, and Stuart M
Shieber. 2016. Learning global features for coref-
erence resolution. In Proc. of NAACL.

David H Wolpert. 1992. Stacked generalization. Neu-
ral networks, 5(2):241–259.

Bishan Yang and Tom Mitchell. 2017. A joint sequen-
tial and relational model for frame-semantic parsing.
In Proc. of EMNLP.

Luke S Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form: Structured
classification with probabilistic categorial gram-
mars. In Proc. of UAI.

Yuan Zhang and David Weiss. 2016. Stack-
propagation: Improved representation learning for
syntax. In Proc. of ACL.

Jie Zhou and Wei Xu. 2015. End-to-end learning of
semantic role labeling using recurrent neural net-
works. In Proc. of ACL.


