











































StructVAE: Tree-structured Latent Variable Models for Semi-supervised Semantic Parsing


Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 754–765
Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics

754

STRUCTVAE: Tree-structured Latent Variable Models for
Semi-supervised Semantic Parsing

Pengcheng Yin, Chunting Zhou, Junxian He, Graham Neubig
Language Technologies Institute

Carnegie Mellon University
{pcyin,ctzhou,junxianh,gneubig}@cs.cmu.edu

Abstract

Semantic parsing is the task of transducing
natural language (NL) utterances into for-
mal meaning representations (MRs), com-
monly represented as tree structures. An-
notating NL utterances with their cor-
responding MRs is expensive and time-
consuming, and thus the limited availabil-
ity of labeled data often becomes the bot-
tleneck of data-driven, supervised mod-
els. We introduce STRUCTVAE, a vari-
ational auto-encoding model for semi-
supervised semantic parsing, which learns
both from limited amounts of parallel data,
and readily-available unlabeled NL utter-
ances. STRUCTVAE models latent MRs
not observed in the unlabeled data as tree-
structured latent variables. Experiments
on semantic parsing on the ATIS domain
and Python code generation show that
with extra unlabeled data, STRUCTVAE
outperforms strong supervised models.1

1 Introduction

Semantic parsing tackles the task of mapping nat-
ural language (NL) utterances into structured for-
mal meaning representations (MRs). This in-
cludes parsing to general-purpose logical forms
such as λ-calculus (Zettlemoyer and Collins,
2005, 2007) and the abstract meaning represen-
tation (AMR, Banarescu et al. (2013); Misra and
Artzi (2016)), as well as parsing to computer-
executable programs to solve problems such as
question answering (Berant et al., 2013; Yih et al.,
2015; Liang et al., 2017), or generation of domain-
specific (e.g., SQL) or general purpose program-
ming languages (e.g., Python) (Quirk et al., 2015;
Yin and Neubig, 2017; Rabinovich et al., 2017).

1Code available at http://pcyin.me/struct vae

Structured Latent Semantic Space (MRs)

p(z)

Inference Model
q�(z|x)

Reconstruction Model
p✓(x|z)

Sort my_list in descending order

z

Figure 1: Graphical Representation of STRUCTVAE

While these models have a long history (Zelle
and Mooney, 1996; Tang and Mooney, 2001), re-
cent advances are largely attributed to the success
of neural network models (Xiao et al., 2016; Ling
et al., 2016; Dong and Lapata, 2016; Iyer et al.,
2017; Zhong et al., 2017). However, these mod-
els are also extremely data hungry: optimization
of such models requires large amounts of training
data of parallel NL utterances and manually anno-
tated MRs, the creation of which can be expensive,
cumbersome, and time-consuming. Therefore, the
limited availability of parallel data has become the
bottleneck of existing, purely supervised-based
models. These data requirements can be alleviated
with weakly-supervised learning, where the deno-
tations (e.g., answers in question answering) of
MRs (e.g., logical form queries) are used as indi-
rect supervision (Clarke et al. (2010); Liang et al.
(2011); Berant et al. (2013), inter alia), or data-
augmentation techniques that automatically gen-
erate pseudo-parallel corpora using hand-crafted
or induced grammars (Jia and Liang, 2016; Wang
et al., 2015).

In this work, we focus on semi-supervised
learning, aiming to learn from both limited

http://pcyin.me/struct_vae


755

amounts of parallel NL-MR corpora, and unla-
beled but readily-available NL utterances. We
draw inspiration from recent success in applying
variational auto-encoding (VAE) models in semi-
supervised sequence-to-sequence learning (Miao
and Blunsom, 2016; Kociský et al., 2016), and
propose STRUCTVAE — a principled deep gener-
ative approach for semi-supervised learning with
tree-structured latent variables (Fig. 1). STRUCT-
VAE is based on a generative story where the
surface NL utterances are generated from tree-
structured latent MRs following the standard VAE
architecture: (1) an off-the-shelf semantic parser
functions as the inference model, parsing an ob-
served NL utterance into latent meaning represen-
tations (§ 3.2); (2) a reconstruction model decodes
the latent MR into the original observed utterance
(§ 3.1). This formulation enables our model to
perform both standard supervised learning by op-
timizing the inference model (i.e., the parser) us-
ing parallel corpora, and unsupervised learning
by maximizing the variational lower bound of the
likelihood of the unlabeled utterances (§ 3.3).

In addition to these contributions to semi-
supervised semantic parsing, STRUCTVAE con-
tributes to generative model research as a whole,
providing a recipe for training VAEs with struc-
tured latent variables. Such a structural latent
space is contrast to existing VAE research using
flat representations, such as continuous distributed
representations (Kingma and Welling, 2013), dis-
crete symbols (Miao and Blunsom, 2016), or hy-
brids of the two (Zhou and Neubig, 2017).

We apply STRUCTVAE to semantic parsing
on the ATIS domain and Python code genera-
tion. As an auxiliary contribution, we implement a
transition-based semantic parser, which uses Ab-
stract Syntax Trees (ASTs, § 3.2) as intermedi-
ate MRs and achieves strong results on the two
tasks. We then apply this parser as the inference
model for semi-supervised learning, and show that
with extra unlabeled data, STRUCTVAE outper-
forms its supervised counterpart. We also demon-
strate that STRUCTVAE is compatible with differ-
ent structured latent representations, applying it to
a simple sequence-to-sequence parser which uses
λ-calculus logical forms as MRs.

2 Semi-supervised Semantic Parsing
In this section we introduce the objectives for
semi-supervised semantic parsing, and present
high-level intuition in applying VAEs for this task.

2.1 Supervised and Semi-supervised Training
Formally, semantic parsing is the task of map-
ping utterance x to a meaning representation z.
As noted above, there are many varieties of MRs
that can be represented as either graph structures
(e.g., AMR) or tree structures (e.g., λ-calculus
and ASTs for programming languages). In this
work we specifically focus on tree-structured MRs
(see Fig. 2 for a running example Python AST),
although application of a similar framework to
graph-structured representations is also feasible.

Traditionally, purely supervised semantic
parsers train a probabilistic model pφ(z|x) using
parallel data L of NL utterances and annotated
MRs (i.e., L = {〈x, z〉}). As noted in the
introduction, one major bottleneck in this ap-
proach is the lack of such parallel data. Hence,
we turn to semi-supervised learning, where the
model additionally has access to a relatively large
amount of unlabeled NL utterances U = {x}.
Semi-supervised learning then aims to maximize
the log-likelihood of examples in both L and U:

J =
∑

〈x,z〉 ∈L

log pφ(z|x)︸ ︷︷ ︸
supervised obj. Js

+α
∑
x∈U

log p(x)︸ ︷︷ ︸
unsupervised obj. Ju

(1)

The joint objective consists of two terms: (1) a
supervised objective Js that maximizes the con-
ditional likelihood of annotated MRs, as in stan-
dard supervised training of semantic parsers; and
(2) a unsupervised objective Ju, which maximizes
the marginal likelihood p(x) of unlabeled NL ut-
terances U, controlled by a tuning parameter α.
Intuitively, if the modeling of pφ(z|x) and p(x)
is coupled (e.g., they share parameters), then op-
timizing the marginal likelihood p(x) using the
unsupervised objective Ju would help the learn-
ing of the semantic parser pφ(z|x) (Zhu, 2005).
STRUCTVAE uses the variational auto-encoding
framework to jointly optimize pφ(z|x) and p(x),
as outlined in § 2.2 and detailed in § 3.

2.2 VAEs for Semi-supervised Learning
From Eq. (1), our semi-supervised model must be
able to calculate the probability p(x) of unlabeled
NL utterances. To model p(x), we use VAEs,
which provide a principled framework for gener-
ative models using neural networks (Kingma and
Welling, 2013). As shown in Fig. 1, VAEs define a
generative story (bold arrows in Fig. 1, explained
in § 3.1) to model p(x), where a latent MR z is



756

sampled from a prior, and then passed to the recon-
struction model to decode into the surface utter-
ance x. There is also an inference model qφ(z|x)
that allows us to infer the most probable latent MR
z given the input x (dashed arrows in Fig. 1, ex-
plained in § 3.2). In our case, the inference pro-
cess is equivalent to the task of semantic parsing
if we set qφ(·) , pφ(·). VAEs also provide a
framework to compute an approximation of p(x)
using the inference and reconstruction models, al-
lowing us to effectively optimize the unsupervised
and supervised objectives in Eq. (1) in a joint fash-
ion (Kingma et al. (2014), explained in § 3.3).

3 STRUCTVAE: VAEs with
Tree-structured Latent Variables

3.1 Generative Story

STRUCTVAE follows the standard VAE architec-
ture, and defines a generative story that explains
how an NL utterance is generated: a latent mean-
ing representation z is sampled from a prior dis-
tribution p(z) over MRs, which encodes the la-
tent semantics of the utterance. A reconstruction
model pθ(x|z) then decodes the sampled MR z
into the observed NL utterance x.

Both the prior p(z) and the reconstruction
model p(x|z) takes tree-structured MRs as inputs.
To model such inputs with rich internal structures,
we follow Konstas et al. (2017), and model the dis-
tribution over a sequential surface representation
of z, zs instead. Specifically, we have p(z) ,
p(zs) and pθ(x|z) , pθ(x|zs)2. For code gener-
ation, zs is simply the surface source code of the
AST z. For semantic parsing, zs is the linearized
s-expression of the logical form. Linearization al-
lows us to use standard sequence-to-sequence net-
works to model p(z) and pθ(x|z). As we will ex-
plain in § 4.3, we find these two components per-
form well with linearization.

Specifically, the prior is parameterized by
a Long Short-Term Memory (LSTM) language
model over zs. The reconstruction model is an
attentional sequence-to-sequence network (Luong
et al., 2015), augmented with a copying mech-
anism (Gu et al., 2016), allowing an out-of-
vocabulary (OOV) entity in zs to be copied to x
(e.g., the variable name my list in Fig. 1 and its
AST in Fig. 2). We refer readers to Appendix B
for details of the neural network architecture.

2Linearizion is used by the prior and the reconstruction
model only, and not by the inference model.

3.2 Inference Model

STRUCTVAE models the semantic parser pφ(z|x)
as the inference model qφ(z|x) in VAE (§ 2.2),
which maps NL utterances x into tree-structured
meaning representations z. qφ(z|x) can be any
trainable semantic parser, with the correspond-
ing MRs forming the structured latent semantic
space. In this work, we primarily use a seman-
tic parser based on the Abstract Syntax Descrip-
tion Language (ASDL) framework (Wang et al.,
1997) as the inference model. The parser en-
codes x into ASTs (Fig. 2). ASTs are the native
meaning representation scheme of source code in
modern programming languages, and can also be
adapted to represent other semantic structures, like
λ-calculus logical forms (see § 4.2 for details).
We remark that STRUCTVAE works with other se-
mantic parsers with different meaning representa-
tions as well (e.g., using λ-calculus logical forms
for semantic parsing on ATIS, explained in § 4.3).

Our inference model is a transition-based parser
inspired by recent work in neural semantic pars-
ing and code generation. The transition system is
an adaptation of Yin and Neubig (2017) (hereafter
YN17), which decomposes the generation process
of an AST into sequential applications of tree-
construction actions following the ASDL gram-
mar, thus ensuring the syntactic well-formedness
of generated ASTs. Different from YN17, where
ASTs are represented as a Context Free Grammar
learned from a parsed corpus, we follow Rabi-
novich et al. (2017) and use ASTs defined under
the ASDL formalism (§ 3.2.1).

3.2.1 Generating ASTs with ASDL Grammar

First, we present a brief introduction to ASDL. An
AST can be generated by applying typed construc-
tors in an ASDL grammar, such as those in Fig. 3
for the Python ASDL grammar. Each constructor
specifies a language construct, and is assigned to
a particular composite type. For example, the con-
structor Call has type expr (expression), and it
denotes function calls. Constructors are associated
with multiple fields. For instance, the Call con-
structor and has three fields: func, args and key-
words. Like constructors, fields are also strongly
typed. For example, the func field of Call has
expr type. Fields with composite types are in-
stantiated by constructors of the same type, while
fields with primitive types store values (e.g., iden-
tifier names or string literals). Each field also has



757

Expr

Name

Call

value

func

Name

args keywords

Keyword
sorted

id

id

my_list reverse Name

valuearg

True

t1

t2

t3

t4

t5

t6

t8

t9 t10

t11

id

sorted(my_list, reverse=True)

t Frontier Field Action
t1 stmt root Expr(expr value)
t2 expr value Call(expr func, expr* args,

keyword* keywords)
t3 expr func Name(identifier id)
t4 identifier id GENTOKEN[sorted]
t5 expr* args Name(identifier id)
t6 identifier id GENTOKEN[my list]
t7 expr* args REDUCE (close the frontier field)
t8 keyword* keywords keyword(identifier arg,

expr value)
t9 identifier arg GENTOKEN[reverse]
t10 expr value Name(identifier id)
t11 identifier id GENTOKEN[True]
t12 keyword* keywords REDUCE (close the frontier field)

Figure 2: Left An example ASDL AST with its surface source code. Field names are labeled on upper arcs. Blue squares
denote fields with sequential cardinality. Grey nodes denote primitive identifier fields, with annotated values. Fields are labeled
with time steps at which they are generated. Right Action sequences used to construct the example AST. Frontier fields are
denoted by their signature (type name). Each constructor in the Action column refers to an APPLYCONSTR action.

stmt    FunctionDef(identifier name, 
                               arguments args, stmt* body)
     |  ClassDef(identifier name, expr* bases, stmt* body)
     |  Expr(expr value)
     |  Return(expr? value)

7!

expr    Call(expr func, expr* args, keyword* keywords)
     |  Name(identifier id)
     |  Str(string s)

7!

Figure 3: Excerpt of the python abstract syntax gram-
mar (Python Software Foundation, 2016)

a cardinality (single, optional ?, and sequential ∗),
specifying the number of values the field has.

Each node in an AST corresponds to a typed
field in a constructor (except for the root node).
Depending on the cardinality of the field, an AST
node can be instantiated with one or multiple con-
structors. For instance, the func field in the ex-
ample AST has single cardinality, and is instan-
tiated with a Name constructor; while the args
field with sequential cardinality could have multi-
ple constructors (only one shown in this example).

Our parser employs a transition system to gen-
erate an AST using three types of actions. Fig. 2
(Right) lists the sequence of actions used to gen-
erate the example AST. The generation process
starts from an initial derivation with only a root
node of type stmt (statement), and proceeds ac-
cording to the top-down, left-to-right traversal of
the AST. At each time step, the parser applies an
action to the frontier field of the derivation:

APPLYCONSTR[c] actions apply a constructor
c to the frontier composite field, expanding the
derivation using the fields of c. For fields with sin-
gle or optional cardinality, an APPLYCONSTR ac-
tion instantiates the empty frontier field using the
constructor, while for fields with sequential car-
dinality, it appends the constructor to the frontier
field. For example, at t2 the Call constructor is

applied to the value field of Expr, and the deriva-
tion is expanded using its three child fields.

REDUCE actions complete generation of a field
with optional or multiple cardinalities. For in-
stance, the args field is instantiated by Name at t5,
and then closed by a REDUCE action at t7.

GENTOKEN[v] actions populate an empty
primitive frontier field with token v. A primitive
field whose value is a single token (e.g., identi-
fier fields) can be populated with a single GEN-
TOKEN action. Fields of string type can be in-
stantiated using multiple such actions, with a final
GENTOKEN[</f>] action to terminate the genera-
tion of field values.

3.2.2 Modeling qφ(z|x)
The probability of generating an AST z is natu-
rally decomposed into the probabilities of the ac-
tions {at} used to construct z:

qφ(z|x) =
∏
t

p(at|a<t,x).

Following YN17, we parameterize qφ(z|x) using
a sequence-to-sequence network with auxiliary re-
current connections following the topology of the
AST. Interested readers are referred to Appendix B
and Yin and Neubig (2017) for details of the neu-
ral network architecture.

3.3 Semi-supervised Learning

In this section we explain how to optimize the
semi-supervised learning objective Eq. (1) in
STRUCTVAE.

Supervised Learning For the supervised learn-
ing objective, we modify Js, and use the labeled
data to optimize both the inference model (the se-



758

mantic parser) and the reconstruction model:

Js ,
∑

(x,z)∈L

(
log qφ(z|x) + log pθ(x|z)

)
(2)

Unsupervised Learning To optimize the unsu-
pervised learning objective Ju in Eq. (1), we max-
imize the variational lower-bound of log p(x):

log p(x) ≥ Ez∼qφ(z|x)
(
log pθ(x|z)

)
− λ ·KL[qφ(z|x)||p(z)] = L (3)

where KL[qφ||p] is the Kullback-Leibler (KL) di-
vergence. Following common practice in optimiz-
ing VAEs, we introduce λ as a tuning parameter
of the KL divergence to control the impact of the
prior (Miao and Blunsom, 2016; Bowman et al.,
2016).

To optimize the parameters of our model in the
face of non-differentiable discrete latent variables,
we follow Miao and Blunsom (2016), and ap-
proximate ∂L∂φ using the score function estimator
(a.k.a. REINFORCE, Williams (1992)):
∂L
∂φ

=
∂

∂φ
Ez∼qφ(z|x)(

log pθ(x|z)− λ
(
log qφ(z|x)− log p(z)

))︸ ︷︷ ︸
learning signal

=
∂

∂φ
Ez∼qφ(z|x)l

′(x, z)

≈ 1
|S(x)|

∑
zi∈S(x)

l′(x, zi)
∂ log qφ(zi|x)

∂φ (4)

where we approximate the gradient using a set of
samples S(x) drawn from qφ(·|x). To ensure the
quality of sampled latent MRs, we follow Guu
et al. (2017) and use beam search. The term
l′(x, z) is defined as the learning signal (Miao
and Blunsom, 2016). The learning signal weights
the gradient for each latent sample z. In REIN-
FORCE, to cope with the high variance of the
learning signal, it is common to use a baseline
b(x) to stabilize learning, and re-define the learn-
ing signal as

l(x, z) , l′(x, z)− b(x). (5)
Specifically, in STRUCTVAE, we define

b(x) = a · log p(x) + c, (6)
where log p(x) is a pre-trained LSTM language
model. This is motivated by the empirical obser-
vation that log p(x) correlates well with the recon-
struction score log pθ(x|z), hence with l′(x, z).

Finally, for the reconstruction model, its gradi-

ent can be easily computed:
∂L
∂θ
≈ 1
|S(x)|

∑
zi∈S(x)

∂ log pθ(x|zi)
∂θ

.

Discussion Perhaps the most intriguing question
here is why semi-supervised learning could im-
prove semantic parsing performance. While the
underlying theoretical exposition still remains an
active research problem (Singh et al., 2008), in
this paper we try to empirically test some likely
hypotheses. In Eq. (4), the gradient received by
the inference model from each latent sample z is
weighed by the learning signal l(x, z). l(x, z) can
be viewed as the reward function in REINFORCE
learning. It can also be viewed as weights associ-
ated with pseudo-training examples {〈x, z〉 : z ∈
S(x)} sampled from the inference model. Intu-
itively, a sample z with higher rewards should:
(1) have z adequately encode the input, leading
to high reconstruction score log pθ(x|z); and (2)
have z be succinct and natural, yielding high prior
probability. Let z∗ denote the gold-standard MR
of x. Consider the ideal case where z∗ ∈ S(x)
and l(x, z∗) is positive, while l(x, z′) is negative
for other imperfect samples z′ ∈ S(x), z′ 6= z∗.
In this ideal case, 〈x, z∗〉would serve as a positive
training example and other samples 〈x, z′〉 would
be treated as negative examples. Therefore, the in-
ference model would receive informative gradient
updates, and learn to discriminate between gold
and imperfect MRs. This intuition is similar in
spirit to recent efforts in interpreting gradient up-
date rules in reinforcement learning (Guu et al.,
2017). We will present more empirical statistics
and observations in § 4.3.

4 Experiments

4.1 Datasets

In our semi-supervised semantic parsing experi-
ments, it is of interest how STRUCTVAE could
further improve upon a supervised parser with ex-
tra unlabeled data. We evaluate on two datasets:

Semantic Parsing We use the ATIS dataset, a
collection of 5,410 telephone inquiries of flight
booking (e.g., “Show me flights from ci0 to ci1”).
The target MRs are defined using λ-calculus log-
ical forms (e.g., “lambda $0 e (and (flight
$0) (from $ci0) (to $ci1))”). We use the
pre-processed dataset released by Dong and Lap-
ata (2016), where entities (e.g., cities) are canoni-
calized using typed slots (e.g., ci0). To predict λ-



759

calculus logical forms using our transition-based
parser, we use the ASDL grammar defined by Ra-
binovich et al. (2017) to convert between logical
forms and ASTs (see Appendix C for details).

Code Generation The DJANGO dataset (Oda
et al., 2015) contains 18,805 lines of Python
source code extracted from the Django web frame-
work. Each line of code is annotated with an NL
utterance. Source code in the DJANGO dataset
exhibits a wide variety of real-world use cases
of Python, including IO operation, data structure
manipulation, class/function definition, etc. We
use the pre-processed version released by Yin and
Neubig (2017) and use the astor package to con-
vert ASDL ASTs into Python source code.

4.2 Setup

Labeled and Unlabeled Data STRUCTVAE re-
quires access to extra unlabeled NL utterances for
semi-supervised learning. However, the datasets
we use do not accompany with such data. We
therefore simulate the semi-supervised learning
scenario by randomly sub-sampling K examples
from the training split of each dataset as the la-
beled set L. To make the most use of the NL ut-
terances in the dataset, we construct the unlabeled
set U using all NL utterances in the training set3,4.
Training Procedure Optimizing the unsuper-
vised learning objective Eq. (3) requires sampling
structured MRs from the inference model qφ(z|x).
Due to the complexity of the semantic parsing
problem, we cannot expect any valid samples
from randomly initialized qφ(z|x). We therefore
pre-train the inference and reconstruction mod-
els using the supervised objective Eq. (2) until
convergence, and then optimize using the semi-
supervised learning objective Eq. (1). Throughout
all experiments we set α (Eq. (1)) and λ (Eq. (3))
to 0.1. The sample size |S(x)| is 5. We observe
that the variance of the learning signal could still
be high when low-quality samples are drawn from
the inference model qφ(z|x). We therefore clip

3We also tried constructing U using the disjoint portion
of the NL utterances not presented in the labeled set L, but
found this yields slightly worse performance, probably due
to lacking enough unlabeled data. Interpreting these results
would be an interesting avenue for future work.

4While it might be relatively easy to acquire additional
unlabeled utterances in practical settings (e.g., through query
logs of a search engine), unfortunately most academic seman-
tic parsing datasets, like the ones used in this work, do not
feature large sets of in-domain unlabeled data. We therefore
perform simulated experiments instead.

|L| SUP. SELFTRAIN STRUCTVAE
500 63.2 65.3 66.0
1,000 74.6 74.2 75.7
2,000 80.4 83.3 82.4
3,000 82.8 83.6 83.6
4,434 (All) 85.3 – 84.5

Previous Methods ACC.
ZC07 (Zettlemoyer and Collins, 2007) 84.6
WKZ14 (Wang et al., 2014) 91.3
SEQ2TREE (Dong and Lapata, 2016)† 84.6
ASN (Rabinovich et al., 2017)† 85.3

+ supervised attention 85.9

Table 1: Performance on ATIS w.r.t. the size of labeled train-
ing data L. †Existing neural network-based methods

|L| SUP. SELFTRAIN STRUCTVAE
1,000 49.9 49.5 52.0
2,000 56.6 55.8 59.0
3,000 61.0 61.4 62.4
5,000 63.2 64.5 65.6
8,000 70.3 69.6 71.5
12,000 71.1 71.6 72.0
16,000 (All) 73.7 – 72.3

Previous Method ACC.
YN17 (Yin and Neubig, 2017) 71.6

Table 2: Performance on DJANGO w.r.t. the size of labeled
training data L

all learning signals lower than k = −20.0. Early-
stopping is used to avoid over-fitting. We also pre-
train the prior p(z) (§ 3.3) and the baseline func-
tion Eq. (6). Readers are referred to Appendix D
for more detail of the configurations.

Metric As standard in semantic parsing re-
search, we evaluate by exact-match accuracy.

4.3 Main Results
Tab. 1 and Tab. 2 list the results on ATIS and
DJANGO, resp, with varying amounts of labeled
data L. We also present results of training the
transition-based parser using only the supervised
objective (SUP., Eq. (2)). We also compare
STRUCTVAE with self-training (SELFTRAIN), a
semi-supervised learning baseline which uses the
supervised parser to predict MRs for unlabeled
utterances in U − L, and adds the predicted ex-
amples to the training set to fine-tune the super-
vised model. Results for STRUCTVAE are aver-
aged over four runs to account for the additional
fluctuation caused by REINFORCE training.

Supervised System Comparison First, to high-
light the effectiveness of our transition parser
based on ASDL grammar (hence the reliability of



760

−30 −20 −10 0 10 200.0

0.1

0.2 z∗(µ̂ = 2.59, σ̂ = 30.80)
z′(µ̂ = −5.12, σ̂ = 214.62)

(a) DJANGO

−30 −20 −10 0 10 200.0

0.1

0.2
z∗(µ̂ = 0.94, σ̂ = 19.06)
z′(µ̂ = −3.35, σ̂ = 96.66)

(b) ATIS

Figure 4: Histograms of learning signals on DJANGO (|L| =
5000) and ATIS (|L| = 2000). Difference in sample means
is statistically significant (p < 0.05).

our supervised baseline), we compare the super-
vised version of our parser with existing parsing
models. On ATIS, our supervised parser trained
on the full data is competitive with existing neural
network based models, surpassing the SEQ2TREE
model, and on par with the Abstract Syntax Net-
work (ASN) without using extra supervision. On
DJANGO, our model significantly outperforms the
YN17 system, probably because the transition sys-
tem used by our parser is defined natively to con-
struct ASDL ASTs, reducing the number of ac-
tions for generating each example. On DJANGO,
the average number of actions is 14.3, compared
with 20.3 reported in YN17.

Semi-supervised Learning Next, we discuss
our main comparison between STRUCTVAE with
the supervised version of the parser (recall that the
supervised parser is used as the inference model
in STRUCTVAE, § 3.2). First, comparing our
proposed STRUCTVAE with the supervised parser
when there are extra unlabeled data (i.e., |L| <
4, 434 for ATIS and |L| < 16, 000 for DJANGO),
semi-supervised learning with STRUCTVAE con-
sistently achieves better performance. Notably, on
DJANGO, our model registers results as compet-
itive as previous state-of-the-art method (YN17)
using only half the training data (71.5 when |L| =
8000 v.s. 71.6 for YN17). This demonstrates
that STRUCTVAE is capable of learning from un-
labeled NL utterances by inferring high quality,
structurally rich latent meaning representations,
further improving the performance of its super-
vised counterpart that is already competitive. Sec-
ond, comparing STRUCTVAE with self-training,
we find STRUCTVAE outperforms SELFTRAIN
in eight out of ten settings, while SELFTRAIN

1 2 3 4 5
0.0

0.4

0.8

(a) DJANGO
1 2 3 4 5

0.0

0.4

0.8

(b) ATIS

Figure 5: Distribution of the rank of l(x,z∗) in sampled set

under-performs the supervised parser in four out
of ten settings. This shows self-training does not
necessarily yield stable gains while STRUCTVAE
does. Intuitively, STRUCTVAE would perform
better since it benefits from the additional signal of
the quality of MRs from the reconstruction model
(§ 3.3), for which we present more analysis in our
next set of experiments.

For the sake of completeness, we also report the
results of STRUCTVAE when L is the full train-
ing set. Note that in this scenario there is no extra
unlabeled data disjoint with the labeled set, and
not surprisingly, STRUCTVAE does not outper-
form the supervised parser. In addition to the su-
pervised objective Eq. (2) used by the supervised
parser, STRUCTVAE has the extra unsupervised
objective Eq. (3), which uses sampled (probably
incorrect) MRs to update the model. When there
is no extra unlabeled data, those sampled (incor-
rect) MRs add noise to the optimization process,
causing STRUCTVAE to under-perform.

Study of Learning Signals As discussed
in § 3.3, in semi-supervised learning, the gradient
received by the inference model from each sam-
pled latent MR is weighted by the learning signal.
Empirically, we would expect that on average,
the learning signals of gold-standard samples z∗,
l(x, z∗), are positive, larger than those of other
(imperfect) samples z′, l(x, z′). We therefore
study the statistics of l(x, z∗) and l(x, z′) for all
utterances x ∈ U − L, i.e., the set of utterances
which are not included in the labeled set.5 The
statistics are obtained by performing inference
using trained models. Figures 4a and 4b depict
the histograms of learning signals on DJANGO
and ATIS, resp. We observe that the learning
signals for gold samples concentrate on positive
intervals. We also show the mean and variance
of the learning signals. On average, we have
l(x, z∗) being positive and l(x, z) negative. Also
note that the distribution of l(x, z∗) has smaller
variance and is more concentrated. Therefore the
inference model receives informative gradient up-
dates to discriminate between gold and imperfect

5We focus on cases where z∗ is in the sample set S(x).



761

NL join p and cmd into a file path, substitute it for f
zs1 f = os.path.join(p, cmd) 3

log q(z|x) = −1.00 log p(x|z) = −2.00
log p(z) = −24.33 l(x,z) = 9.14

zs2 p = path.join(p, cmd) 7

log q(z|x) = −8.12 log p(x|z) = −20.96
log p(z) = −27.89 l(x,z) = −9.47

NL append i-th element of existing to child loggers
zs1 child loggers.append(existing[i]) 3

log q(z|x) = −2.38 log p(x|z) = −9.66
log p(z) = −13.52 l(x,z) = 1.32

zs2 child loggers.append(existing[existing])7

log q(z|x) = −1.83 log p(x|z) = −16.11
log p(z) = −12.43 l(x,z) = −5.08

NL split string pks by ’,’, substitute the result for pri-
mary keys

zs1 primary keys = pks.split(’,’) 3

log q(z|x) = −2.38 log p(x|z) = −11.39
log p(z) = −10.24 l(x,z) = 2.05

zs2 primary keys = pks.split + ’,’ 7

log q(z|x) = −0.84 log p(x|z) = −14.87
log p(z) = −20.41 l(x,z) = −2.60

Table 3: Inferred latent MRs on DJANGO (|L| = 5000). For
simplicity we show the surface representation of MRs (zs,
source code) instead.

samples. Next, we plot the distribution of the
rank of l(x, z∗), among the learning signals of
all samples of x, {l(x, zi) : zi ∈ S(x)}. Results
are shown in Fig. 5. We observe that the gold
samples z∗ have the largest learning signals in
around 80% cases. We also find that when z∗ has
the largest learning signal, its average difference
with the learning signal of the highest-scoring
incorrect sample is 1.27 and 0.96 on DJANGO and
ATIS, respectively.

Finally, to study the relative contribution of
the reconstruction score log p(x|z) and the prior
log p(z) to the learning signal, we present ex-
amples of inferred latent MRs during training
(Tab. 3). Examples 1&2 show that the reconstruc-
tion score serves as an informative quality measure
of the latent MR, assigning the correct samples zs1
with high log p(x|z), leading to positive learning
signals. This is in line with our assumption that a
good latent MR should adequately encode the se-
mantics of the utterance. Example 3 shows that
the prior is also effective in identifying “unnatu-
ral” MRs (e.g., it is rare to add a function and a
string literal, as in zs2). These results also sug-
gest that the prior and the reconstruction model
perform well with linearization of MRs. Finally,
note that in Examples 2&3 the learning signals for
the correct samples zs1 are positive even if their in-
ference scores q(z|x) are lower than those of zs2.

|L| SUPERVISED STRUCTVAE-SEQ
500 47.3 55.6
1,000 62.5 73.1
2,000 73.9 74.8
3,000 80.6 81.3
4,434 (All) 84.6 84.2

Table 4: Performance of the STRUCTVAE-SEQ on ATIS
w.r.t. the size of labeled training data L

ATIS DJANGO
|L| SUP. MLP LM |L| SUP. MLP LM
500 63.2 61.5† 66.0 1,000 49.9 47.0† 52.0
1,000 74.6 76.3 75.7 5,000 63.2 62.5† 65.6
2,000 80.4 82.9 82.4 8,000 70.3 67.6† 71.5
3,000 82.8 81.4† 83.6 12,000 71.1 71.6 72.0

Table 5: Comparison of STRUCTVAE with different base-
line functions b(x), italic†: semi-supervised learning with
the MLP baseline is worse than supervised results.

This result further demonstrates that learning sig-
nals provide informative gradient weights for op-
timizing the inference model.

Generalizing to Other Latent MRs Our main
results are obtained using a strong AST-based se-
mantic parser as the inference model, with copy-
augmented reconstruction model and an LSTM
language model as the prior. However, there are
many other ways to represent and infer structure
in semantic parsing (Carpenter, 1998; Steedman,
2000), and thus it is of interest whether our ba-
sic STRUCTVAE framework generalizes to other
semantic representations. To examine this, we
test STRUCTVAE using λ-calculus logical forms
as latent MRs for semantic parsing on the ATIS
domain. We use standard sequence-to-sequence
networks with attention (Luong et al., 2015) as
inference and reconstruction models. The infer-
ence model is trained to construct a tree-structured
logical form using the transition actions defined
in Cheng et al. (2017). We use a classical tri-gram
Kneser-Ney language model as the prior. Tab. 4
lists the results for this STRUCTVAE-SEQ model.

We can see that even with this very different
model structure STRUCTVAE still provides signif-
icant gains, demonstrating its compatibility with
different inference/reconstruction networks and
priors. Interestingly, compared with the results
in Tab. 1, we found that the gains are especially
larger with few labeled examples — STRUCT-
VAE-SEQ achieves improvements of 8-10 points
when |L| < 1000. These results suggest that
semi-supervision is especially useful in improving
a mediocre parser in low resource settings.



762

0.0 0.2 0.4 0.6 0.8 1.0
λ

0.62

0.64

0.66

A
cc

u
ra

cy
StructVAE

Sup.

Figure 6: Performance on DJANGO (|L| = 5000) w.r.t. the
KL weight λ

1000 5000 8000 12000 14000 16000
Size of Unlabeled Data

0.645

0.650

0.655

A
cc

u
ra

cy

StructVAE

Figure 7: Performance on DJANGO (|L| = 5000) w.r.t. the
size of unlabeled data U

Impact of Baseline Functions In § 3.3 we dis-
cussed our design of the baseline function b(x)
incorporated in the learning signal (Eq. (4)) to
stabilize learning, which is based on a language
model (LM) over utterances (Eq. (6)). We com-
pare this baseline with a commonly used one in
REINFORCE training: the multi-layer perceptron
(MLP). The MLP takes as input the last hidden
state of the utterance given by the encoding LSTM
of the inference model. Tab. 5 lists the results
over sampled settings. We found that although
STRUCTVAE with the MLP baseline sometimes
registers better performance on ATIS, in most set-
tings it is worse than our LM baseline, and could
be even worse than the supervised parser. On the
other hand, our LM baseline correlates well with
the learning signal, yielding stable improvements
over the supervised parser. This suggests the im-
portance of using carefully designed baselines in
REINFORCE learning, especially when the re-
ward signal has large range (e.g., log-likelihoods).

Impact of the Prior p(z) Fig. 6 depicts the per-
formance of STRUCTVAE as a function of the KL
term weight λ in Eq. (3). When STRUCTVAE
degenerates to a vanilla auto-encoder without the
prior distribution (i.e., λ = 0), it under-performs
the supervised baseline. This is in line with our
observation in Tab. 3 showing that the prior helps
identify unnatural samples. The performance of
the model also drops when λ > 0.1, suggesting
that empirically controlling the influence of the
prior to the inference model is important.

Impact of Unlabeled Data Size Fig. 7 illus-
trates the accuracies w.r.t. the size of unlabeled
data. STRUCTVAE yields consistent gains as the
size of the unlabeled data increases.

5 Related Works
Semi-supervised Learning for NLP Semi-
supervised learning comes with a long his-
tory (Zhu, 2005), with applications in NLP from
early work of self-training (Yarowsky, 1995), and
graph-based methods (Das and Smith, 2011), to
recent advances in auto-encoders (Cheng et al.,
2016; Socher et al., 2011; Zhang et al., 2017) and
deep generative methods (Xu et al., 2017). Our
work follows the line of neural variational infer-
ence for text processing (Miao et al., 2016), and
resembles Miao and Blunsom (2016), which uses
VAEs to model summaries as discrete latent vari-
ables for semi-supervised summarization, while
we extend the VAE architecture for more complex,
tree-structured latent variables.

Semantic Parsing Most existing works allevi-
ate issues of limited parallel data through weakly-
supervised learning, using the denotations of MRs
as indirect supervision (Reddy et al., 2014; Kr-
ishnamurthy et al., 2016; Neelakantan et al.,
2016; Pasupat and Liang, 2015; Yin et al., 2016).
For semi-supervised learning of semantic pars-
ing, Kate and Mooney (2007) first explore us-
ing transductive SVMs to learn from a semantic
parser’s predictions. Konstas et al. (2017) ap-
ply self-training to bootstrap an existing parser
for AMR parsing. Kociský et al. (2016) em-
ploy VAEs for semantic parsing, but in con-
trast to STRUCTVAE’s structured representation
of MRs, they model NL utterances as flat la-
tent variables, and learn from unlabeled MR data.
There have also been efforts in unsupervised se-
mantic parsing, which exploits external linguis-
tic analysis of utterances (e.g., dependency trees)
and the schema of target knowledge bases to infer
the latent MRs (Poon and Domingos, 2009; Poon,
2013). Another line of research is domain adap-
tation, which seeks to transfer a semantic parser
learned from a source domain to the target domain
of interest, therefore alleviating the need of paral-
lel data from the target domain (Su and Yan, 2017;
Fan et al., 2017; Herzig and Berant, 2018).

6 Conclusion

We propose STRUCTVAE, a deep generative
model with tree-structured latent variables for
semi-supervised semantic parsing. We apply
STRUCTVAE to semantic parsing and code gen-
eration tasks, and show it outperforms a strong su-
pervised parser using extra unlabeled data.



763

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-

gio. 2015. Neural machine translation by jointly
learning to align and translate. In Proceedings of
ICLR.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proceedings of LAW-ID@ACL.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on freebase from
question-answer pairs. In Proceedings of EMNLP.

Samuel R. Bowman, Luke Vilnis, Oriol Vinyals, An-
drew M. Dai, Rafal Józefowicz, and Samy Ben-
gio. 2016. Generating sentences from a continuous
space. In Proceedings of the SIGNLL.

Bob Carpenter. 1998. Type-logical Semantics.

Jianpeng Cheng, Siva Reddy, Vijay Saraswat, and
Mirella Lapata. 2017. Learning structured natural
language representations for semantic parsing. In
Proceedings of ACL.

Yong Cheng, Wei Xu, Zhongjun He, Wei He, Hua
Wu, Maosong Sun, and Yang Liu. 2016. Semi-
supervised learning for neural machine translation.
In Proceedings of ACL.

James Clarke, Dan Goldwasser, Ming-Wei Chang, and
Dan Roth. 2010. Driving semantic parsing from the
world’s response. In Proceedings of CoNLL.

Dipanjan Das and Noah A. Smith. 2011. Semi-
supervised frame-semantic parsing for unknown
predicates. In Proceedings of HLT .

Li Dong and Mirella Lapata. 2016. Language to logical
form with neural attention. In Proceedings of ACL.

Xing Fan, Emilio Monti, Lambert Mathias, and Markus
Dreyer. 2017. Transfer learning for neural seman-
tic parsing. In Proceedings of the 2nd Workshop on
Representation Learning for NLP.

Jiatao Gu, Zhengdong Lu, Hang Li, and Victor O. K.
Li. 2016. Incorporating copying mechanism in
sequence-to-sequence learning. In Proceedings of
ACL.

Kelvin Guu, Panupong Pasupat, Evan Zheran Liu,
and Percy Liang. 2017. From language to pro-
grams: Bridging reinforcement learning and maxi-
mum marginal likelihood. In Proceedings of ACL.

Jonathan Herzig and Jonathan Berant. 2018. Decou-
pling structure and lexicon for zero-shot semantic
parsing. arXiv preprint arXiv:1804.07918 .

Srinivasan Iyer, Ioannis Konstas, Alvin Cheung,
Jayant Krishnamurthy, and Luke Zettlemoyer. 2017.
Learning a neural semantic parser from user feed-
back. In Proceedings of ACL.

Robin Jia and Percy Liang. 2016. Data recombination
for neural semantic parsing. In Proceedings of ACL.

Rohit J. Kate and Raymond J. Mooney. 2007. Semi-
supervised learning for semantic parsing using sup-
port vector machines. In Proceedings of NAACL-
HLT .

Diederik P. Kingma and Jimmy Ba. 2014. Adam:
A method for stochastic optimization. CoRR
abs/1412.6980.

Diederik P Kingma, Shakir Mohamed, Danilo Jimenez
Rezende, and Max Welling. 2014. Semi-supervised
learning with deep generative models. In Proceed-
ings of NIPS.

Diederik P Kingma and Max Welling. 2013. Auto-
encoding variational bayes. arXiv preprint
arXiv:1312.6114 .

Tomás Kociský, Gábor Melis, Edward Grefenstette,
Chris Dyer, Wang Ling, Phil Blunsom, and
Karl Moritz Hermann. 2016. Semantic parsing with
semi-supervised sequential autoencoders. In Pro-
ceedings of EMNLP.

Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin
Choi, and Luke Zettlemoyer. 2017. Neural amr:
Sequence-to-sequence models for parsing and gen-
eration. In Proceedings of ACL.

Jayant Krishnamurthy, Oyvind Tafjord, and Aniruddha
Kembhavi. 2016. Semantic parsing to probabilistic
programs for situated question answering. In Pro-
ceedings of EMNLP.

Chen Liang, Jonathan Berant, Quoc Le, Kenneth D.
Forbus, and Ni Lao. 2017. Neural symbolic ma-
chines: Learning semantic parsers on freebase with
weak supervision. In Proceedings of ACL.

Percy Liang, Michael I. Jordan, and Dan Klein. 2011.
Learning dependency-based compositional seman-
tics. In Proceedings of ACL.

Wang Ling, Phil Blunsom, Edward Grefenstette,
Karl Moritz Hermann, Tomás Kociský, Fumin
Wang, and Andrew Senior. 2016. Latent predictor
networks for code generation. In Proceedings of
ACL.

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-
based neural machine translation. In Proceedings
of EMNLP.

Yishu Miao and Phil Blunsom. 2016. Language as a
latent variable: Discrete generative models for sen-
tence compression. In Proceedings of EMNLP.

Yishu Miao, Lei Yu, and Phil Blunsom. 2016. Neu-
ral variational inference for text processing. In Pro-
ceedings of ICML.



764

Dipendra K. Misra and Yoav Artzi. 2016. Neural shift-
reduce CCG semantic parsing. In Proceedings of
EMNLP.

Arvind Neelakantan, Quoc V. Le, and Ilya Sutskever.
2016. Neural programmer: Inducing latent pro-
grams with gradient descent. In Proceedings of
ICLR.

Yusuke Oda, Hiroyuki Fudaba, Graham Neubig,
Hideaki Hata, Sakriani Sakti, Tomoki Toda, and
Satoshi Nakamura. 2015. Learning to generate
pseudo-code from source code using statistical ma-
chine translation (T). In Proceedings of ASE.

Panupong Pasupat and Percy Liang. 2015. Composi-
tional semantic parsing on semi-structured tables. In
Proceedings of ACL.

Hoifung Poon. 2013. Grounded unsupervised semantic
parsing. In Proceedings of ACL.

Hoifung Poon and Pedro Domingos. 2009. Unsuper-
vised semantic parsing. In Proceedings of EMNLP.

Python Software Foundation. 2016. Python abstract
grammar. https://docs.python.org/2/library/ast.html.

Chris Quirk, Raymond J. Mooney, and Michel Galley.
2015. Language to code: Learning semantic parsers
for if-this-then-that recipes. In Proceedings of ACL.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code generation
and semantic parsing. In Proceedings of ACL.

Siva Reddy, Mirella Lapata, and Mark Steedman. 2014.
Large-scale semantic parsing without question-
answer pairs. Transactions of ACL .

Aarti Singh, Robert D. Nowak, and Xiaojin Zhu. 2008.
Unlabeled data: Now it helps, now it doesn’t. In
Proceedings of NIPS.

Richard Socher, Jeffrey Pennington, Eric H. Huang,
Andrew Y. Ng, and Christopher D. Manning. 2011.
Semi-supervised recursive autoencoders for predict-
ing sentiment distributions. In Proceedings of
EMNLP.

Mark Steedman. 2000. The Syntactic Process.

Yu Su and Xifeng Yan. 2017. Cross-domain seman-
tic parsing via paraphrasing. In Proceedings of
EMNLP.

Lappoon R. Tang and Raymond J. Mooney. 2001. Us-
ing multiple clause constructors in inductive logic
programming for semantic parsing. In Proceedings
of ECML.

Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly.
2015. Pointer networks. In Proceedings of NIPS.

Adrienne Wang, Tom Kwiatkowski, and Luke Zettle-
moyer. 2014. Morpho-syntactic lexical generaliza-
tion for ccg semantic parsing. In Proceedings of
EMNLP.

Daniel C. Wang, Andrew W. Appel, Jeffrey L. Korn,
and Christopher S. Serra. 1997. The zephyr ab-
stract syntax description language. In Proceedings
of DSL.

Yushi Wang, Jonathan Berant, and Percy Liang. 2015.
Building a semantic parser overnight. In Proceed-
ings of ACL.

Ronald J. Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine Learning .

Chunyang Xiao, Marc Dymetman, and Claire Gardent.
2016. Sequence-based structured prediction for se-
mantic parsing. In Proceedings of ACL.

Weidi Xu, Haoze Sun, Chao Deng, and Ying Tan.
2017. Variational autoencoder for semi-supervised
text classification. In Proceedings of AAAI.

David Yarowsky. 1995. Unsupervised word sense dis-
ambiguation rivaling supervised methods. In Pro-
ceedings of ACL.

Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and
Jianfeng Gao. 2015. Semantic parsing via staged
query graph generation: Question answering with
knowledge base. In Proceedings of ACL.

Pengcheng Yin, Zhengdong Lu, Hang Li, and Ben Kao.
2016. Neural enquirer: Learning to query tables in
natural language. In Proceedings of IJCAI.

Pengcheng Yin and Graham Neubig. 2017. A syntactic
neural model for general-purpose code generation.
In Proceedings of ACL.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
2014. Recurrent neural network regularization.
arXiv preprint arXiv:1409.2329 .

John M. Zelle and Raymond J. Mooney. 1996. Learn-
ing to parse database queries using inductive logic
programming. In Proceedings of AAAI.

Luke Zettlemoyer and Michael Collins. 2005. Learn-
ing to map sentences to logical form structured clas-
sification with probabilistic categorial grammars. In
Proceedings of UAI.

Luke S. Zettlemoyer and Michael Collins. 2007. On-
line learning of relaxed ccg grammars for parsing to
logical form. In Proceedings of EMNLP-CoNLL.

Xiao Zhang, Yong Jiang, Hao Peng, Kewei Tu, and Dan
Goldwasser. 2017. Semi-supervised structured pre-
diction with neural crf autoencoder. In Proceedings
of EMNLP.

Victor Zhong, Caiming Xiong, and Richard Socher.
2017. Seq2sql: Generating structured queries
from natural language using reinforcement learning.
arXiv preprint arXiv:1709.00103 .



765

Chunting Zhou and Graham Neubig. 2017. Multi-
space variational encoder-decoders for semi-
supervised labeled sequence transduction. In
Proceedings of ACL.

Xiaojin Zhu. 2005. Semi-supervised learning literature
survey. Technical Report 1530, Computer Sciences,
University of Wisconsin-Madison.


