



















































Parsing with Dynamic Continuized CCG


Proceedings of the 13th International Workshop on Tree Adjoining Grammars and Related Formalisms (TAG+13), pages 71–83,
Umeå, Sweden, September 4–6, 2017. c© 2017 Association for Computational Linguistics

Parsing with Dynamic Continuized CCG

Michael White and Jordan Needle
Department of Linguistics
The Ohio State University

Columbus, OH 43210
mwhite@ling.osu.edu
needle.6@osu.edu

Simon Charlow
Department of Linguistics

Rutgers University
New Brunswick, NJ 08901

simon.charlow@rutgers.edu

Dylan Bumford
Department of Linguistics

New York University
New York, NY 10003
dbumford@nyu.edu

Abstract

We present an implemented method
of parsing with Combinatory Categorial
Grammar (CCG) that for the first time
derives the exceptional scope behavior
of indefinites in a principled and plau-
sibly practical way. The account im-
plements Charlow’s (2014) monadic ap-
proach to dynamic semantics, in which in-
definites’ exceptional scope taking follows
from the way the side effect of introduc-
ing a discourse referent survives the pro-
cess of delimiting the scope of true quan-
tifiers in a continuized grammar. To effi-
ciently parse with this system, we extend
Barker and Shan’s (2014) method of pars-
ing with continuized grammars to only in-
voke monadic lifting and lowering where
necessary, and define novel normal form
constraints on lifting and lowering to avoid
spurious ambiguities. We also integrate
Steedman’s (2000) CCG for deriving basic
predicate-argument structure and enrich it
with a method of lexicalizing scope island
constraints. We argue that the resulting
system improves upon Steedman’s CCG in
terms of theoretical perspicuity and empir-
ical coverage while retaining many of its
attractive computational properties.

1 Introduction

A long-standing puzzle in natural language se-
mantics has been how to explain the exceptional
scope behavior of indefinites. For example, (1a)
has a reading where there’s a specific relative
(a steel magnate, say) such that if she dies, the
speaker will be rich. By contrast, (1b) has no
analogous reading where the universal takes wide
scope: this sentence cannot mean that every rela-

tive is such that if that particular relative dies, I’ll
be rich.1 If one takes the antecedent of a condi-
tionals to be a scope island (as suggested by the
< . . . > bracketing), then it’s not surprising that
the universal in (1b) is blocked from taking wide
scope; what instead requires explanation is how
the indefinite in (1a) can exceptionally take scope
out of this island.

(1) a. If <a relative of mine dies>, I’ll inherit a
fortune. (∃ > if)

b. If <every relative of mine dies>, I’ll in-
herit a fortune. (* ∀ > if)

Charlow (2014) has recently shown that the
exceptional scope behavior of indefinites can be
derived from their role of introducing discourse
referents in a dynamic semantics. To do so,
he showed that (1) a monadic approach to dy-
namic semantics can be seamlessly integrated with
Barker and Shan’s (2014) approach to scope tak-
ing in continuized grammars, and (2) once one
does so, the exceptional scope of indefinites fol-
lows from the way the side effect of introducing
a discourse referent survives the process of delim-
iting the scope of true quantifiers, such as those
expressed with each and every.

To date, computationally implemented ap-
proaches to scope taking2 have not distinguished
indefinites from true quantifiers in a way that
accounts for their exceptional scope taking. In
Bos’s (2003) implementation of Discourse Repre-
sentation Theory (Kamp and Reyle, 1993, DRT),
for example, scope taking is independent of how

1That is, (1b) cannot mean the same thing as If any rel-
ative of mine dies, I’ll inherit a fortune; see Barker and
Shan (2014) for a compatible treatment of negative polarity
items such as any.

2See e.g. (Copestake et al., 2005; Koller et al., 2003; Gar-
dent and Kallmeyer, 2003; Nesson and Shieber, 2006; Pogo-
dalla and Pompigne, 2012), inter alia.

71



indefinites are treated. Although Steedman (2012)
has developed an account of indefinites’ excep-
tional scope taking in a non-standard static seman-
tics for Combinatory Categorial Grammar (Steed-
man, 2000, CCG), this treatment has not been fully
implemented (to our knowledge); moreover, as
Barker and Shan point out, Steedman’s theory ap-
pears to undergenerate by not allowing true quan-
tifiers to take scope from medial positions.

Barker and Shan offer a brief sketch of how a
parser for their continuized grammars can be im-
plemented, including how lifting can be invoked
lazily to ensure parsing terminates. In this paper,
we show how their approach can be seamlessly
combined with Steedman’s CCG and extended to
include Charlow’s monadic dynamic semantics,
thereby providing the first computational imple-
mentation of a system that accounts for the ex-
ceptional scope behavior of indefinites in a prin-
cipled and plausibly practical way. To efficiently
parse with this system, we devise rules to only in-
voke monadic lifting and lowering where neces-
sary, and define novel normal form constraints
on lifting and lowering to avoid spurious ambi-
guities. We also integrate a method of lexicalizing
scope island constraints (Barker and Shan, 2006),
as Charlow’s account does not provide a practi-
cal and empirically satisfactory means of enforc-
ing such constraints. We argue that the resulting
system improves upon Steedman’s CCG in terms
of theoretical perspicuity—insofar as it builds
upon an account of dynamic semantics that is in-
dependently necessary—and empirical coverage,
in that it allows quantifiers to take scope from me-
dial positions and from some subordinate clauses.
At the same time, it also retains many of CCG’s at-
tractive computational properties; in particular, it
respects Steedman’s Principle of Adjacency, only
combining overtly realized adjacent constituents,
thereby making it easy to use with well-studied
parsing algorithms. An open source prototype im-
plementation, suitable for testing out grammatical
analyses, is available online.3

2 Are Scope Islands Real?

Steedman (2012) observes that although the em-
pirical status of scope islands remains unsettled in
the linguistics literature (Farkas and Giannakidou,
1996; Reinhart, 1997; Ruys and Winter, 2011;
Syrett and Lidz, 2011; Syrett, 2015), the possi-

3https://github.com/mwhite14850/dyc3g

ble scopings of true quantifiers appear to be much
more limited than commonly assumed in compu-
tational approaches to scope taking, arguing there-
fore in favor of a surface-compositional approach
that aims to capture all and only the attested read-
ings; in particular, Steedman takes as his work-
ing hypothesis that scope inversion should be sub-
ject to syntactic island constraints. While we are
sympathetic to Steedman’s point of view, we are
skeptical of his working hypothesis, as it appears
to incorrectly predict that quantifiers should never
be able to take scope from subjects of finite com-
plement clauses. Acknowledging that universals
sometime appear to do so, Steedman appeals to
Fox & Sauerland’s (1996) illusory scope analyis,
where the quantificational force is argued to stem
from a main clause generic. However, Farkas and
Giannakidou (1996) provide numerous examples
in English and Greek of episodic sentences such
as (2) where the universal takes extra-wide scope.

(2) Yesterday, a guide made sure that <every
tour to the Louvre was fun>. (∀ > ∃)

By contrast, a corpus analysis given in the ap-
pendix suggests that conditionals and relative
clauses plausibly represent cases where scope is-
lands should be treated as hard constraints. As
such, in this paper we adopt the working hypoth-
esis that scope island constraints can be given an
accurate lexicalized treatment. Alternatively, one
could pursue an approach based solely on soft con-
straints, where a probabilistic model simply makes
scope taking beyond finite clause boundaries very
unlikely. Even in this scenario, we contend that the
approach to exceptionally scoping indefinites im-
plemented here will greatly simplify the learning
task, since the ability of indefinites to take excep-
tional scope would not need to be learned.

3 Continuized CCG

A continuized grammar is one where the meaning
of expressions can be defined as a function on a
portion of its surrounding context, or continuation
(Barker, 2002; Shan and Barker, 2006; Barker and
Shan, 2014). To make it easier to reason about
continuized grammars, Barker & Shan devised the
“tower” notation illustrated in Figure 1.4 For ex-
ample, everyone has a tower category with NP on

4Semantic types are suppressed in this and subsequent fig-
ures, except where essential for understanding.

72



someone loves everyone

S S

NP (S\NP)/NP
S S

NP
∃x.[ ]
x λyx.love(x, y)

∀y.[ ]
y

↑
S S

(S\NP)/NP
[ ]

λyx.love(x, y)
C,>

S S

S\NP
∀y.[ ]

λx.love(x, y)
C,<

S S

S
∃x.∀y.[ ]
love(x, y)

↓
S

∃x.∀y.love(x, y)
(a) Surface Scope with Explicit Lifting

someone loves everyone

S S

NP (S\NP)/NP
S S

NP
∃x.[ ]
x λyx.love(x, y)

∀y.[ ]
y
↑L,>

S S

S\NP
∀y.[ ]

λx.love(x, y)
↑L,↑R,<

S S

S S

S
∀y.[ ]
∃x.[ ]

love(x, y)
↓

S
∀y.∃x.love(x, y)

(b) Inverse Scope with Integrated Lifting

Figure 1: Continuized CCG Derivations

the bottom and two Ss on top; reading counter-
clockwise from the bottom, this category repre-
sents a constituent that acts locally as an NP , takes
scope over an S, and returns an S. The seman-
tics is λk.∀y.ky, a function from a continuation
k of type e → t to a universally quantified ex-
pression of type t. A continuized meaning of this
form can be abbreviated by representing the loca-

tion where the continuation argument applies with
[ ] and putting the argument to the continuation on
the bottom of the tower, as shown.

In a continuized grammar, all expressions can
potentially be given continuized meanings via the
Lift (↑) operation. This is illustrated in Figure 1a
where the category for loves is lifted, taking on
the semantics λk.k(λyx.love(x, y)). Lifting the
category for loves allows it to combine with that
of everyone using scopal combination. The way
in which scopal combination works in the tower
notation is shown in Figure 2b (left): on the tower
top, the continuized functions g[ ] and h[ ] compose
in surface order, yielding g[h[ ]]; meanwhile, re-
cursing on the tower bottom, the expressions a and
b combine as they normally would in CCG (using
the combinators in Figure 2a), yielding c.5 In the
example, [ ] and ∀y.[ ] compose to again yield ∀y.[ ]
on the tower top, with λyx.love(x, y) applying to
y and yielding λx.love(x, y) on the bottom.

As Barker & Shan observe, the explicit lifting
step seen in Figure 1a can be integrated with the
scopal combination step, as shown in the other
recursively defined rules in Figure 2b, thereby
avoiding an infinite regress when applying the lift-
ing rule. Figure 1b shows how Lift Left (↑L) and
Lift Right (↑R) can be applied in sequence—as
part of a single parsing step combining adjacent
signs—to create a three-level tower where every-
one ends up taking inverse scope over the sub-
ject:6 first, in applying Lift Left, the entire tower
for someone is matched as A, while the bottom of
the tower for loves everyone, S\NP , is matched
as B, and then the rules are reapplied with A and
B as inputs; next, Lift Right is applied, with the
bottom of the tower for someone, NP , matched as
A, and S\NP again matched as B, and the rules
are reapplied once more; this time, the categories
can combine directly using Backward Application
(<), ending the recursion; as the rules unwind,
the three-level tower for someone loves everyone
is constructed, with inverse scope semantics, as
shown. The final representations are derived by
collapsing the towers using the recursively defined
Lower (↓) operation in Figure 2c, which repeat-

5The combinator for combining two scopal terms m and
n is λmnk.m(λx.n(λy.k(xy))), assuming forward applica-
tion on the tower bottom. Formulating the rules recursively
allows the base combinator to be factored out while also gen-
eralizing to multi-level towers.

6Though everyone is right peripheral in the example,
nothing would prevent it from taking inverse scope from me-
dial position, in contrast to Steedman’s (2012) approach.

73



Forward Backward Forward Forward
Application Application Composition Type Raising

X/Y Y
f : α→ β a : α

>
X

fa : β

Y X\Y
a : α f : α→ β

<
X

fa : β

X/Y Y/Z
f : β → γ g : α→ β

>B
X

λx.f(gx) : α→ γ

NP
a : e

>T
S/(S\NP)

λp.pa : (e→ t)→ t
(a) Base CCG Combinators (not exhaustive)

Combine Lift Left Lift Right

D E

A

E F

B
g[ ]

a

h[ ]

b
C

D F

C
g[h[ ]]

c

A

E F

B

a

h[ ]

b
↑L

E F

C
h[ ]

c

D E

A B

g[ ]

a b
↑R

D E

C
g[ ]

c

if A : a B : b
C : c

(b) Combination with Lifting

Lower

S S

S
g[ ]

a
↓

S
g[a]

S S

A
g[ ]

a
↓

S
g[c]

if A : a
↓

S : c

(c) Lowering (base and recursive)

Figure 2: Continuized CCG

edly applies the continuized semantics to the iden-
tity continuation λk.k.

4 Monadic Dynamic Semantics

Charlow’s (2014) dynamic semantics makes use
of the State.Set monad (Hutton and Meijer, 1996),
which combines the State monad for handling side
effects with the Set monad for non-determinism.
The State monad pairs ordinary semantic values
with a state, which is threaded through computa-
tions. The Set monad models non-deterministic
choices as sets, facilitating a non-deterministic
treatment of indefinites. For example, the dynamic
meaning of a linguist swims appears in (3): here,
the proposition that x swims, where x is some lin-
guist, is paired with a state that augments the input
state s with the discourse referent x.

(3) λs.{〈swim(x), ŝx〉 | linguist(x)}

More formally, the State.Set monad is defined
as in (4). For each type α, the corresponding
monadic typeMα is a function from states of type
s to sets pairing items of type α with such states.
The η function injects values into the monad, sim-
ply yielding a singleton set consisting of the input

item paired with the input state. The bind opera-
tion ( sequences two monadic computations by
sequencing the two computations pointwise, feed-
ing each result of m applied to the input state s
into π and unioning the results.7 Less formally,
the ( operation can be thought of as “run m to
determine v in π.”

(4) State.Set Monad

Mα = s→ α× s→ t
aη = λs.{〈a, s〉}

mv ( π = λs.
⋃
〈a,s′〉∈ms π[a/v]s

′

Since the only operation on states that we will
be concerned with in this paper is adding discourse
referents, it suffices to leave the states implicit in
the implementation, only explicitly representing
the new discourse referents—much as in compu-
tational implementations of Discourse Represen-
tation Theory (Bos, 2003), where assignments are
not explicitly represented in Discourse Represen-
tation Structures. Consequently, we will represent

7Note that the notation mv ( π is just syntactic sugar
for m( λv.π, which may be more familiar.

74



(3) as (5), which can be translated to first-order
logic in much the same way as with DRT.8

(5) {〈swim(x), x〉 | linguist(x)}
; ∃x.linguist(x) ∧ swim(x)

The definition of State.Set sequencing allows us to
define a sequence reduction operation where the
value of m is substituted into π for v and the dis-
course referents and conditions are combined. For
example, the representation of a linguist can be se-
quenced with that of swim and simplified as in (6).

(6) {〈x, x〉 | linguist(x)}y ( {〈swim(y), �〉}
; {〈swim(x), x〉 | linguist(x)}

As in DRT, negation in Charlow’s dynamic se-
mantics is defined in a way that captures dis-
course referents, making them inaccessible for
subsequent reference. Conditionals and universals
are defined in terms of negation, thereby explain-
ing their effects on discourse referent accessiblity;
for representational simplicity, we will instead as-
sume directly defined meanings for conditionals
and universals, as in DRT.

5 Dynamic Combinatory Rules

The rules for combining signs in Dynamic Con-
tinuized CCG appear in Figures 3 and 4, augment-
ing those in Figure 2. We first give an overview of
these rules and then illustrate with examples.9

As Charlow (2014) explains in detail, con-
tinuized grammars can be reconceptualized as op-
erating over an underlying monad, where monadic
lifting is identified with applying the underlying
monad’s sequencing operator (() and monadic
lowering with applying the injection function (η).
Accordingly, we include the rules for monadic
lifting and lowering in Figure 3a-b. The lifting
rule takes a category A with monadic value a of
type Mα and sequences it with a new continu-
ation, yielding a function λk.av ( kv of type
(α → Mβ) → Mβ for a tower category with
A on the bottom. Monadic lowering is defined re-
cursively, with the two base cases on the left and

8Explicitly representing the states could simplify the
treatment of discourse referent accessibility; we leave inves-
tigating this alternative for future work.

9The side conditions for these rules (preceded by ‘if’)
sometimes serve to define the rules recursively, as in the ear-
lier Figure 2, and sometimes serve to specify sub-cases of in-
terest. Rules for anaphora resolution are left for future work.

the two recursive cases on the right. The base
cases apply η to the value a on the tower bottom
before filling it in for the continuation; the sec-
ond base case enables lowering to apply to the
CCG categories S/NP and S\NP used in rela-
tive clauses. The recursive cases on the right again
enable multi-level towers to be lowered in one fell
swoop, with the second rule enabling towers with
tower-result categories on the bottom to be fully
lowered.

To implement scope islands, the rules in Fig-
ure 3c together with the unary type constructor 〈·〉
enable categories to specify that their arguments
must be scope delimited by undergoing a reset (i.e.
lower then re-lift) before combination is permit-
ted.10 Figure 3d enables a double-continuation
analysis of determiners by triggering a lowering
when two categories combine to yield a category
with a lowerable tower result. Finally, the rules in
Figure 4 apply when the functor category expects
a monadic value on the tower bottom; the rules
in Figure 4a use η to coerce the input to the right
type, while the ones in Figure 4b invoke lowering
to do so.

An example illustrating exceptional scope for
an indefinite appears in Figure 5a. Even though
the category for if requires the category for its
antecedent someone complains to be reset prior
to combination, the side effect of discourse ref-
erent introduction survives the reset operation—
enabling a wide-scope reading of the indefinite—
irrespective of whether sequence reduction is car-
ried out immediately, as in Figure 5c. (Figure 8
in the appendix shows how side effects are un-
affected by reset in the general case, using the
monadic identity and associativity laws.) Fig-
ure 5b shows how the narrow scope reading for the
indefinite can be derived instead using monadic
type–driven lowering. By contrast, Figure 6 shows
why the narrow scope reading is the only one
available for the universal in if everyone com-
plains, since the reset operation closes off the
scope of the universal, as illustrated in detail in
Figure 6b. The appendix gives two further ex-
amples: Figure 10a illustrates result tower lower-
ing in an inverse linking example—including the
possibility of medial scoping, which is not possi-
ble with Steedman’s CCG—while Figure 9 shows

10The Delimit rules must apply first to ensure that entire
towers are reset. This is accomplished using a cut in the
Prolog implementation; alternatively, these rules could be de-
fined at the level of signs rather than categories.

75



Lift

A
a :Mα

↑
S S

A
av ( [ ] :Mβ

v : α

(a) Monadic Lifting

Lower

A S

S
g[ ]

a
↓

A
g[aη]

S S

A
g[ ]

p
↓

A
λx.g[(px)η]

S S

A
g[ ]

a
↓

C
g[c]

S S

A
g[ ]

a
↓

C
λk.g[ck]

, if A is

D E

F
S

S

if A is S/Y or S\Y if A : a
↓

C : c

(b) Monadic Lowering (base and recursive)

Delimit Right Delimit Left

...
X/〈Y 〉

...
Y

a b
DR

...
X
c

...
Y

...
X\〈Y 〉

b a
DL

...
X
c

if
...
Y
b
↑,↓

...
Y
b′

by Lower
then Lift,

and
...

X/Y

...
Y

a b′

...
X
c

...
Y

...
X\Y

b′ a

...
X
c

(c) Delimiting Scope with Reset

Lower Result

A : a B : b
↓RS

C : c

if
A : a B : b

D E

F
G

H

: d

and
D E

F
G

H

: d

↓
C : c

(d) Result Lowering

Figure 3: Dynamic Continuized CCG: Monadic Lifting and Lowering

by contrast how universals are trapped in relative
clause scope islands.

6 Prototype Implementation

Barker & Shan suggest that the rules in Figure 2
can form the basis of a practical parser. While the
worst-case complexity of parsing with such rules
has yet to be investigated, the way in which tow-
ers can grow to arbitrary heights is apt to at least
limit the utility of dynamic programming in prac-
tice, potentially posing efficiency problems even
when using aggressive statistical pruning (Clark
and Curran, 2007). However, recent work on pars-
ing with global neural network models has moved
away from dynamic programming solutions, as
the global models are incompatible with dynamic
programming locality requirements. In particular,
Lee et al. (2016) have shown that global neural
models can be used with A* search to obtain a

new state-of-the-art in CCG in parsing accuracy
while maintaining impressive speed, even though
the search space is exponential. As such, given
that our approach respects Steedman’s Principle
of Adjacency, we suggest that it may be possible
to extend CCG statistical parsing methods to the
current setting, thereby resolving scope ambigu-
ities the same way as other derivational ambigui-
ties, rather than in a post-process as in earlier com-
putational work on scope taking. While we are
aware of no large-scale scope-annotated corpora
at present, small-scale corpora do exist that would
enable this conjecture to be tested in future work,
such as the corpora used in work on CCG semantic
parsing (Artzi and Zettlemoyer, 2013, inter alia).

Towards that end, we have implemented a pro-
totype shift-reduce parser in Prolog that uses the
unary and binary combination rules defined in Fig-
ure 2 together with additional rules defined in

76



Forward Application Backward Application
with η with η

X/Y Y
f :Mα→ β a : α

>η

X
faη : β

Y X\Y
a : α f :Mα→ β

<η

X
faη : β

(a) Base CCG Combinators with Monadic Type Coercion
(not exhaustive)

Lower Right Lower Left

...
A

...
B

a :Mα→ β b : γ
↓R

...
C
c : β

...
B

...
A

b : γ a :Mα→ β
↓L

...
C
c : β

if
...
B
b : γ

↓
B′

b′ :Mα

and
...
A B

′

a :Mα→ β b′ :Mα
...
C
c : β

B′
...
A

b′ :Mα a :Mα→ β
...
C
c : β

(b) Monadic Type–Driven Lowering

Figure 4: Dynamic Continuized CCG: Monadic
Arguments

Section 5 for implementing Charlow’s monadic
dynamic semantics.11 When implementing the
parser, we found it paid off to only invoke low-
ering where necessary, as discussed in Section 5,
rather than simply invoking lowering whenever
possible. Moreover, in Section 7, we will see how
enforcing scope islands keeps tower heights un-
der control, while also providing an opportunity
to define normal form constraints that limit spu-
rious ambiguity, another important practical con-
sideration. To test the implementation, we devel-
oped an initial test suite of 40 examples of aver-
age length 6.7 words, roughly comparable in size

11https://github.com/mwhite14850/dyc3g

and complexity to Baldridge’s (2002) OpenCCG12

test suite. With the normal form constraints, pars-
ing time was 60ms per item on a laptop, similar
to OpenCCG on the same hardware. By contrast,
with the normal form constraints turned off, the
parsing time increased to 4.6s per item, nearly two
orders of magnitude slower.

7 Normal Form Constraints

A normal form parse is the simplest parse in an
equivalence class of parses yielding the same in-
terpretation. Normal form constraints can play an
important role in practical CCG parsing by elimi-
nating derivations leading to spurious ambiguities
without requiring expensive pairwise equivalence
checks on λ-terms (Eisner, 1996; Clark and Cur-
ran, 2007; Hockenmaier and Bisk, 2010; Lewis
and Steedman, 2014). Continuized CCG can em-
ploy existing CCG normal form constraints at the
base level. The main additional source of spurious
ambiguity is illustrated in Figure 7.13 In the fig-
ure, the two towers at the upper left are combined
via ↑R and ↑L to yield a three-level tower, which
potentially allows an operator to subsequently take
scope between any scopal elements present in the
left and right input signs. However, if this three-
level tower is subsequently lowered without any
operator taking intermediate scope, the derivation
will yield an interpretation that is equivalent to
the one yielded by the simpler derivation that just
combines the two signs in their surface scope order
(i.e., without yielding a three-level tower).14 As
such, the lowering operations triggered by scope
islands or sentence boundaries provide an oppor-
tunity to recursively detect and eliminate such
non–normal form derivations, as follows:

Trigger If a sign is created using a lower op-
eration, check the input sign for a spurious
↑R, ↑L combination.

Base A sign constructed via . . . , ↑R, ↑L, . . . has
a spurious ↑R, ↑L combination.

Non-Scopal A sign that is derived from a non-
scopal input sign—i.e., one whose category

12http://openccg.sourceforge.net/
13Spurious ambiguity can also arise from the inversion of

two indefinites; we leave this issue for future work.
14As noted in Section 5, it remains for future work to add

the lowering rules for multi-level towers that enable Char-
low’s treatment of selective exceptional scope; the normal
form constraints will need to be augmented accordingly.

77



if someone complains Vincent quits

S/〈S〉/〈S〉
S S

NP S\NP S

λxy.(x→ y)η
{〈x, x〉}u ( [ ]

u λx.complain(x) quit(v)
↑R,<

S S

S
{〈x, x〉}u ( [ ]
complain(u)

DR,↑L,>η
S S

S/〈S〉
{〈complain(x), x〉}p ( [ ]

λy.(pη → y)η
DR,↑R,>η

S S

S
{〈complain(x), x〉}p ( [ ]

(pη → quit(v)η)η
↓

S
{〈complain(x)η → quit(v)η, x〉}
; ∃x.(complain(x)→ quit(v))

(a) Wide Scope Indefinite

if someone complains Vincent quits

S/〈S〉/〈S〉
S S

S S

λxy.(x→ y)η
{〈x, x〉}u ( [ ]
complain(u) quit(v)

Mt→Mt→Mt (t→Mt)→Mt t
DR,↓R,>

S/〈S〉
λy.({〈complain(x), x〉} → y)η

Mt→Mt
DR,>η

S
({〈complain(x), x〉} → quit(v)η)η

Mt

; ∀x.(complain(x)→ quit(v))
(b) Narrow Scope via Type-Driven Lowering

{〈x, x〉}u ( [ ]
complain(u)

↓

{〈x, x〉}u ( {〈complain(u), �〉}
≡

{〈complain(x), x〉}
↑

{〈complain(x), x〉}p ( [ ]
p

(c) Resetting someone complains

Figure 5: Conditional with Indefinite Example

has no tower top—has a spurious ↑R, ↑L
combination if the other input sign has a spu-
rious ↑R, ↑L combination. This case is illus-
trated in Figure 7, where H is such a non-
scopal input sign.

Inversion A sign that is derived by a ↑L, ↑ R in-
version has a spurious ↑R, ↑L combination if
either input sign has a spurious ↑R, ↑ L com-
bination.

Recurse Right A sign that is derived by a C, ↑L
has a spurious ↑R, ↑L combination if the

right input sign has a spurious ↑R, ↑L com-
bination. Note that ↑L,C can derive interme-
diate scope for the left input sign.

Recurse Left A sign that is derived by a ↑R,C
has a spurious ↑R, ↑L combination if the left
input sign has a spurious ↑R, ↑L combina-
tion. Note that C, ↑R can derive intermediate
scope for the right input sign.

These rules have been tested for safety in the
reference implementation by ensuring that all six
(3!) desired interpretations result from a ditransi-

78



if everyone complains Vincent quits

S/〈S〉/〈S〉
S S

S S

λxy.(x→ y)η
(∀x[ ])η

complain(x) quit(v)
DR,↑L,>η

S S

S/〈S〉
[ ]

λy.((∀x complain(x)η)η → y)η
DR,↑R,>η

S S

S
[ ]

((∀x complain(x)η)η → quit(v)η)η
↓

S
((∀x complain(x)η)η → quit(v)η)η

; (∀x.complain(x))→ quit(v)
(a) Narrow Scope for Universal

(∀x[ ])η
complain(x)

↓

(∀x complain(x)η)η
↑

[ ]

∀x complain(x)η

(b) Resetting everyone complains

Figure 6: Conditional with Universal Example

A B

C

D E

F H
*** ↑R,↑L,...
A B

D E

G
↑R,...

A B

D E

I
↓,...

J

Figure 7: Non–Normal Form Derivation

tive verb combined with three scopal arguments,
and all 4! desired interpretations result from a 4-
argument verb in combination with four scopal ar-
guments. With the ditransitive verb, all spurious
ambiguity is eliminated, reducing 78 derivations
in an otherwise unambiguous sentence down to
just the six normal form derivations. The rules
are not quite complete though, as six spuriously
equivalent derivations remain with the 4-argument

verb, where 525 derivations are whittled down to
30; safely filtering the remaining six spuriously
equivalent derivations would require more com-
plex rules that track the level at which the ↑R, ↑L
operations apply in the base case, which may not
be worth the added complexity in practice.15

8 Conclusion

We have presented a method of parsing with Dy-
namic Continuized CCG that for the first time de-
rives the exceptional scope behavior of indefinites
in a principled and plausibly practical way. Our
approach (i) extends Barker and Shan’s (2014)
method of parsing with continuized grammars to
only invoke Charlow’s (2014) monadic lifting and
lowering where necessary, (ii) integrates Steed-
man’s (2000) CCG for deriving basic predicate-
argument structure and enriches it with a practical
method of lexicalizing scope island constraints,
and (iii) takes advantage of the resulting scope is-
lands in defining novel normal form constraints for
efficient parsing. We have argued that the account
(i) improves upon Steedman’s (2012) approach to
quantifier scope in terms of theoretical perspicuity
by taking advantage of a dynamic semantics for in-
definites independently needed for anaphora, and
(ii) offers better empirical coverage by allowing
quantifiers to take scope from medial positions and
some subordinate clauses. At the same time, by
respecting the Principle of Adjacency, only com-
bining overtly realized adjacent constituents, our
approach is easy to use with well-studied parsing
algorithms, as with Steedman’s CCG. Although
the normal form constraints are quite effective
in small-scale experiments, it remains for future
work to verify quantitatively whether these con-
straints suffice for practical parsing in conjunc-
tion with statistical filtering techniques. It also re-
mains for future work to computationally explore
the novel analyses made possible by this frame-
work, including order-sensitivity in negative po-
larity items (Barker and Shan, 2014) and selective
exceptional scope for indefinites and focus alter-
natives (Charlow, 2014). Towards that end, we
have made available online an open source proto-
type implementation suitable for testing out gram-
matical analyses.

15Normal form constraints need not be complete to be
practically useful, as any remaining ambiguity can be han-
dled by pairwise checks.

79



Acknowledgments

We thank Carl Pollard, Scott Martin, Mark Steed-
man, the OSU Clippers and Synners Groups, the
Midwest Speech and Language Days 2016 au-
dience and the anonymous reviewers for helpful
comments and discussion. This work was sup-
ported in part by a Targeted Investment in Excel-
lence Grant from OSU Arts & Sciences and by
NSF grant IIS-1319318.

References
Yoav Artzi and Luke Zettlemoyer. 2013. Weakly su-

pervised learning of semantic parsers for mapping
instructions to actions. Transactions of the Associa-
tion for Computational Linguistics 1(1):49–62.

Jason Baldridge. 2002. Lexically Specified Deriva-
tional Control in Combinatory Categorial Gram-
mar. Ph.D. thesis, University of Edinburgh.

Chris Barker. 2002. Continuations and the nature
of quantification. Natural Language Semantics
10(3):211–242.

Chris Barker and Chung-chieh Shan. 2006. Types
as graphs: Continuations in type logical gram-
mar. Journal of Logic, Language and Information
15:331–370.

Chris Barker and Chung-chieh Shan. 2014. Continua-
tions and Natural Language. Oxford Studies in The-
oretical Linguistics.

Johan Bos. 2003. Implementing the bind-
ing and accommodation theory for anaphora
resolution and presupposition projection.
Computational Linguistics 29(2):179–210.
https://aclweb.org/anthology/J/J03/J03-2002.pdf.

Simon Charlow. 2014. On the semantics of exceptional
scope. Ph.D. thesis, New York University.

Stephen Clark and James R. Curran. 2007.
Wide-Coverage Efficient Statistical Pars-
ing with CCG and Log-Linear Models.
Computational Linguistics 33(4):493–552.
https://aclweb.org/anthology/J/J07/.

Ann Copestake, Dan Flickinger, Carl Pollard, and Ivan
Sag. 2005. Minimal recursion semantics: An intro-
duction. Research on Language and Computation
3:281–332.

Jason Eisner. 1996. Efficient normal-form pars-
ing for Combinatory Categorial Grammar. In
Proceedings of the 34th Annual Meeting of
the Association for Computational Linguis-
tics. Association for Computational Linguistics,
Santa Cruz, California, USA, pages 79–86.
https://doi.org/10.3115/981863.981874.

Donka F. Farkas and Anastasia Giannakidou. 1996.
How clause-bounded is the scope of universals? In
Proceedings of Semantics and Linguistic Theory.
Cornell University, volume 6, pages 35–52.

Danny Fox and Uli Sauerland. 1996. Illusive scope of
universal quantifiers. In Proceedings of the North
Eastern Linguistic Society (NELS). volume 26,
pages 71–86.

Claire Gardent and Laura Kallmeyer. 2003. Semantic
construction in feature-based TAG. In Proceedings
of EACL-03.

Julia Hockenmaier and Yonatan Bisk. 2010. Normal-
form parsing for Combinatory Categorial Grammars
with generalized composition and type-raising. In
Proceedings of the 23rd International Conference
on Computational Linguistics (Coling 2010). Coling
2010 Organizing Committee, Beijing, China, pages
465–473. http://www.aclweb.org/anthology/C10-
1053.

Graham Hutton and Erik Meijer. 1996. Monadic Parser
Combinators. Technical Report NOTTCS-TR-96-
4, Department of Computer Science, University of
Nottingham.

Hans Kamp and Uwe Reyle. 1993. From Discourse
to Logic: An Introduction to Modeltheoretic Seman-
tics of Natural Language, Formal Logic and DRT .
Kluwer, Dordrecht, The Netherlands.

Alexander Koller, Joachim Niehren, and Stefan Thater.
2003. Bridging the gap between underspecifica-
tion formalisms: Hole semantics as dominance con-
straints. In Proceedings of EACL-03.

Richard Larson. 1985. Quantifying into NP. MIT
Manuscript.

Kenton Lee, Mike Lewis, and Luke Zettlemoyer.
2016. Global neural CCG parsing with opti-
mality guarantees. In Proceedings of the 2016
Conference on Empirical Methods in Natural
Language Processing. Association for Computa-
tional Linguistics, Austin, Texas, pages 2366–2376.
https://aclweb.org/anthology/D16-1262.

Roger Levy and Galen Andrew. 2006. Tregex
and Tsurgeon: tools for querying and manip-
ulating tree data structures. In Proceedings
of the Fifth International Conference on Lan-
guage Resources and Evaluation (LREC’06). Eu-
ropean Language Resources Association (ELRA).
http://aclweb.org/anthology/L06-1311.

Mike Lewis and Mark Steedman. 2014. Im-
proved CCG parsing with semi-supervised
supertagging. Transactions of the Associa-
tion of Computational Linguistics 2:327–338.
http://aclweb.org/anthology/Q14-1026.

Rebecca Nesson and Stuart M. Shieber. 2006. Simpler
TAG semantics through synchronization. In Pro-
ceedings of the 11th Conference on Formal Gram-
mar.

80



Sylvain Pogodalla and Florent Pompigne. 2012. Con-
trolling extraction in abstract categorial grammars.
In Formal Grammar. Springer, pages 162–177.

Tanya Reinhart. 1997. Quantifier scope: How labor is
divided between QR and choice functions. Linguis-
tics and philosophy 20(4):335–397.

E.G. Ruys and Yoad Winter. 2011. Quantifier scope
in formal linguistics. In Handbook of philosophical
logic, Springer, pages 159–225.

Chung-chieh Shan and Chris Barker. 2006. Explaining
crossover and superiority as left-to-right evaluation.
Linguistics and Philosophy 29(1):91–134.

Mark Steedman. 2000. The syntactic process. MIT
Press, Cambridge, MA, USA.

Mark Steedman. 2012. Taking Scope: The Natural Se-
mantics of Quantifiers. MIT Press, Cambridge, MA,
USA.

Kristen Syrett. 2015. Experimental support for
inverse scope readings of finite-clause-embedded
antecedent-contained-deletion sentences. Linguistic
Inquiry .

Kristen Syrett and Jeffrey Lidz. 2011. Competence,
performance, and the locality of quantifier raising:
Evidence from 4-year-old children. Linguistic In-
quiry 42(2):305–337.

81



Fact 4.1 (Reset and monadic programs).

*,
m⌫( [ ]

f ⌫
+-
#"
=

m⌫( [ ]
f ⌫

Proof.

*,
m⌫( [ ]

f ⌫
+-
#"
= (m⌫( ( f ⌫)⌘ )" #

=
(m⌫( ( f ⌫)⌘ )u( [ ]

u
"

=
m⌫( ( f ⌫)

⌘
u( [ ]

u
Assoc

=
m⌫( [ ]

f ⌫
LeftID

More generally, because " is identified with(, any side e�ects that survive evaluation are free to
take scope post-evaluation: sequencing an evaluated, impure program ⇡ with a new, post-evaluation
continuation/scope k means that any side e�ects in ⇡ inevitably influence the evaluation of k. Thus,
for example, Reset has no e�ect on e.g. a linguist left, see (4.2). Evaluation brings us to a fully
evaluated expression, and Lifting brings us back into a scopal expression. Nothing, however, has
changed. The indefiniteness retains scope over its continuation.

Fact 4.2 (Resetting a linguist left).

*,
a.lingx( [ ]

left x
+-
#"
=

a.lingx( [ ]
left x

Similarly for she left. Reset has no e�ect:

Fact 4.3 (Resetting she left).

*,
prox( [ ]

left x
+-
#"
=

prox( [ ]
left x

However, crucially, the situation is quite di�erent for every linguist left, see Fact 4.4. Evaluating
the derived meaning for this sentence yields a trivial Mt program which just bottles up the truth
condition that every linguist left and lacks either nondeterministic or state-changing e�ects. Evaluation
thus utterly discharges the scope-taking ability of the universal. Even after Lifting back into a
tower, the new continuation scopes over the universal: the quantificational force that inhered in the
pre-evaluated meaning is relegated to a truth condition on the bottom of the derived tower, and that is
where its role ends.

91

Figure 8: Side Effects Not Affected By Reset
(Charlow, 2014, Fact 4.1)

A Supplemental Material

A.1 Exceptional Scope in the Penn Treebank

As noted in Section 2, the empirical status of scope
islands remains unsettled, with further corpus-
based and experimental work necessary to ade-
quately characterize the distribution of true quan-
tifiers. Nevertheless, a search of the Penn Tree-
bank reveals that if scope islands do not represent
hard constraints, then violations are at least very
rare. We used Tregex (Levy and Andrew, 2006) to
search the Wall Street Journal portion of the Penn
Treebank with the pattern

SBAR << /MD|VBD|VBP|VBZ/ << /ˆevery|ˆeach/

and found that only 385 finite subordinate clauses
contain (a form of) every or each, including 80
relative clauses and just 9 conditionals, with none
showing clear evidence of the universal scoping
out of the finite clause. There were, however,
a couple of potential counter-examples, such as
7, that appear amenable to an analysis involving
functional readings, rather than exceptional scope;
these deserve further study.

(7) Tandy said its experience during the short-
age didn’t merit the $5 million to $50 million
investmenti <U.S. Memories is seeking from
eachi investor>.

By contrast, exceptionally scoping indefinites are
quite easy to find.

A.2 Side Effects and Reset

Figure 8 reproduces Charlow’s (2014) proof that
in the general case, side effects in an underlying
monad are not affected by reset if the lift and lower

senator who everyone likes

N N\N/〈S/NP〉
S S

S/NP

senator λqpx.px ∧ qx
(∀y [ ])η

λx.like(y, x)
DR,↑L,>

S S

N\N
[ ]

λpx.px ∧ ∀y like(y, x)η
↑L,<

S S

N
[ ]

λx.senator(x) ∧ ∀y like(y, x)η

Figure 9: Relative Clause Example

operations in the continuized grammar are identi-
fed with the monad’s sequencing (() and injec-
tion (η) operators.

A.3 Relative Clauses and Inverse Linking
Figure 9 gives an example of a relative clause
scope island. The category for the relative pro-
noun requires its clausal argument to be delimited,
triggering a reset via the Delimit Right (DR) rule,
which closes off the semantic scope for everyone.
Not shown is the derivation of the base category
S/NP for everyone likes, which can be derived
using standard CCG rules on the bottom without
invoking empty string elements. The lowering rule
for incomplete clauses is required in order for this
base category to be lowerable.

By contrast, Figure 10 shows how inverse scope
goes through for the nominal PP in every state,
since the preposition category does not require its
argument to be delimited. One-fell-swoop result
lowering implements Larson’s (1985) constraint
barring interleaved inverse scope out of NPs while
preserving the ability of the universal to bind sub-
sequent pronouns. Although Steedman’s (2012)
account handles examples such as the one in Fig-
ure 10, where the inversely linked PP is right pe-
ripheral, his treatment—unlike the present one—
cannot handle examples such as few votersi [in
every state] whoi supported Trump participated in
the protests where the inversely linked PP is in me-
dial position. (Note that the relative clause here
must be interpreted restrictively, and thus is not
tenable as an appositive, contra Steedman’s sug-
gested analysis of related examples.)

82



a voter in every state protests

S S

NP
S

S/N
N N\N/NP

S S

NP S\NP
λk.{〈x, x〉 | [ ]}u ( ku

λp.px voter λypx.px ∧ in(x, y)
(∀y state(y)η [ ])η

y protest
↑L,>

S S

N\N
(∀y state(y)η [ ])η
λpx.p(x) ∧ in(x, y)

↑L,<
S S

N
(∀y state(y)η [ ])η

λx.voter(x) ∧ in(x, y)
↓,↑L,↑R,>

S S

NP
(∀y state(y)η {〈x, x〉 | voter(x) ∧ in(x, y)}u ( [ ])η

u
↑R,<

S S

S
(∀y state(y)η {〈x, x〉 | voter(x) ∧ in(x, y)}u ( [ ])η

protest(u)
↓

S
(∀y state(y)η {〈protest(x), x〉 | voter(x) ∧ in(x, y)})η

; ∀y.state(y)→ ∃x.voter(x) ∧ in(x, y) ∧ protest(x)
(a) Wide Scope for Universal

S S

S S

NP
S

S
(∀y state(y)η [ ])η

λk.{〈x, x〉 | [ ]}u ( ku
voter(x) ∧ in(x, y)

↓
S S

NP
λk.(∀y state(y)η {〈x, x〉 | (voter(x) ∧ in(x, y))η}u ( ku)η

(b) Lowering Result Tower

Figure 10: Inverse Linking Example

83


