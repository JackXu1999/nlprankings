



















































Adversarial Reprogramming of Text Classification Neural Networks


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 5216–5225,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

5216

Adversarial Reprogramming of Text Classification Neural Networks

Paarth Neekhara1, Shehzeen Hussain2, Shlomo Dubnov1,3, Farinaz Koushanfar2
1Department of Computer Science

2Department of Electrical and Computer Engineering
3Department of Music

University of California San Diego
{pneekhar,ssh028}@ucsd.edu

Abstract

In this work, we develop methods to repur-
pose text classification neural networks for al-
ternate tasks without modifying the network
architecture or parameters. We propose a con-
text based vocabulary remapping method that
performs a computationally inexpensive input
transformation to reprogram a victim classifi-
cation model for a new set of sequences. We
propose algorithms for training such an input
transformation in both white box and black
box settings where the adversary may or may
not have access to the victim model’s archi-
tecture and parameters. We demonstrate the
application of our model and the vulnerability
of neural networks by adversarially repurpos-
ing various text-classification models includ-
ing LSTM, bi-directional LSTM and CNN for
alternate classification tasks.

1 Introduction

While neural network based machine learning
models serve as the backbone of many text and im-
age processing systems, recent studies have shown
that they are vulnerable to adversarial examples.
Traditionally, an adversarial example is a sam-
ple from the classifier’s input domain which has
been perturbed in such a way that is intended to
cause a machine learning model to misclassify
it. While the perturbation is usually impercepti-
ble, such an adversarial input results in the neu-
ral network model outputting an incorrect class la-
bel with higher confidence. Several studies have
shown such adversarial attacks to be successful in
both the continuous input domain (Szegedy et al.,
2014; Papernot et al., 2016a, 2017, 2016b; Brown
et al., 2017; Goodfellow et al., 2015) and discrete
input spaces (Papernot et al., 2016c; Hu and Tan,
2018; Yang et al., 2018).

Adversarial Reprogramming (Elsayed et al.,
2019) is a new class of adversarial attacks where a

machine learning model is repurposed to perform
a new task chosen by the attacker. The proposed
attack is interesting because it allows an adversary
to move a step beyond mere mis-classification of
a victim network’s output onto having the con-
trol to repurpose the network fully. The authors
demonstrated how an adversary may repurpose a
pre-trained ImageNet (Deng et al., 2009) model
for an alternate classification task like classifica-
tion of MNIST digits or CIFAR-10 images with-
out modifying the network parameters. Since ma-
chine learning agents can be reprogrammed to per-
form unwanted actions as desired by the adversary,
such an attack can lead to theft of computational
resources such as cloud-hosted machine learning
models. Besides theft of computational resources,
the adversary may perform a task that violates the
code of ethics of the system provider.

The adversarial reprogramming approach pro-
posed by (Elsayed et al., 2019) trains an addi-
tive contribution θ to the inputs of the neural net-
work to repurpose it for the desired alternate task.
This approach assumes a white-box attack sce-
nario where the adversary has full access to the
network’s parameters. Also, the adversarial pro-
gram proposed in this work is only applicable to
tasks where the input space of the the original and
adversarial task is continuous.

In our work, we propose a method to adver-
sarially repurpose neural networks which operate
on sequences from a discrete input space. The
task is to learn a simple transformation (adversar-
ial program) from the input space of the adversar-
ial task to the input space of the neural network
such that the neural network can be repurposed
for the adversarial task. We propose a context-
based vocabulary remapping function as an ad-
versarial program for sequence classification net-
works. We propose training procedures for this
adversarial program in both white-box and black-



5217

box scenarios. In the white-box attack scenario,
where the adversary has access to the classifier’s
parameters, a Gumbel-Softmax trick (Jang et al.,
2016) is used to train the adversarial program. As-
suming a black-box attack scenario, where the ad-
versary may not have access to the classifier’s pa-
rameters, we present a REINFORCE (Williams,
1992) based optimization algorithm to train the ad-
versarial program.

H e n r i q u e sAdversarial Task: Name Classification

Adversarial Reprogramming Function (f )

Victim Model - Questions Classifier (C)

 other always live What Who does ind Who gold is off ...Original Task: Question Classification

Portuguese

Human
Label Remapping (fL)

Figure 1: Example of Adversarial Reprogramming for
Sequence Classification. We aim to design and train
the adversarial reprogramming function fθ, such that it
can be used to repurpose a pre-trained classifier C, for
a desired adversarial task.

We apply our proposed methodology on var-
ious text classification models including Recur-
rent Neural Networks such as LSTMs and bidi-
rectional LSTMs, and Convolutional Neural Net-
works (CNNs). We demonstrate experimentally,
how these neural networks trained on a partic-
ular (original) text classification task can be re-
purposed for alternate (adversarial) classification
tasks. We experiment with different text classifi-
cation datasets given in table 1 as candidate orig-
inal and adversarial tasks and adversarially repro-
gram the aforementioned text classification mod-
els to study the robustness of the attack.

2 Background and Related Work

2.1 Adversarial Examples
Traditionally, adversarial examples are intention-
ally designed inputs to a machine learning model
that cause the model to make a mistake (Goodfel-
low et al., 2015). These attacks can be broadly
classified into untargeted and targeted attacks. In
the untargeted attack scenario, the adversary suc-
ceeds as long as the victim model classifies the ad-
versarial input into any class other than the correct
class, while in the targeted attack scenario, the ad-
versary succeeds only if the model classifies the
adversarial input into a specific incorrect class. In
both these scenarios, the intent of the adversary
is usually malicious and the outcome of the vic-
tim model is still limited to the original task being

performed by the model.
Adversarial attacks of image-classification

models often use gradient descent on an image
to create a small perturbation that causes the ma-
chine learning model to mis-classify it (Szegedy
et al., 2014; Biggio et al., 2013). There has been
a similar line of adversarial attacks on neural
networks with discrete input domains (Papernot
et al., 2016c; Yang et al., 2018), where the adver-
sary modifies a few tokens in the input sequence
to cause mis-classification by a sequence model.
In addition, efforts have been made in design-
ing more general adversarial attacks in which
the same modification can be applied to many
different inputs to generate adversarial examples
(Brown et al., 2017; Goodfellow et al., 2015;
Moosavi-Dezfooli et al., 2017). For example,
authors (Baluja and Fischer, 2018) trained an
Adversarial Transformation Network that can
be applied to all inputs to generate adversarial
examples targeting a victim model or a set of
victim models. In this work, we aim to learn such
universal transformations of discrete sequences
for a fundamentally different task: Adversarial
Reprogramming described below.

2.2 Adversarial Reprogramming

Adversarial Reprogramming (Elsayed et al., 2019)
introduced a new class of adversarial attacks
where the adversary wishes to repurpose an ex-
isting neural network for a new task chosen by
the attacker, without the attacker needing to com-
pute the specific desired output. The adversary
achieves this by first defining a hard-coded one-to-
one label remapping function hg that maps the out-
put labels of the adversarial task to the label space
of the classifier f ; and learning a corresponding
adversarial reprogramming function hf (.; θ) that
transforms an input (X̃) 1 from the input space of
the new task to the input space of the classifier.
The authors proposed an adversarial reprogram-
ming function hf (.; θ), for repurposing ImageNet
models for adversarial classification tasks. An ad-
versarial example Xadv for an input image X̃ can
be generated using the following adversarial pro-
gram: 2

Xadv = hf (X̃; θ) = X̃ + tanh(θ)

1X̃ is an ImageNet size (n× n× 3) padded input image
2Masking ignored because it is only a visualization con-

venience



5218

Update θ
Update θ

ls

Label Remapping fL
lt

Reward
+1 : Correct Preditcion
-1 : Incorrect Prediction

t1 t2 t3 t4 t5 tN

s1 s2 s3 s4 s5 sN

Adversarial Program - 
Policy Network

Action - Sample a token

REINFORCE

Pad Pad

Text Classifier C

target = fL-1( lt ) Cross Entropy Loss

t1 t2 t3 t4 t5 tN

g1 g2 g3 g4 g5 gN
Distributions over Vs (πi’s) Distributions over Vs (πi’s)

Adversarial Program - 
Policy Network

Generate Gumbel
Distribution Backpropatgation

Pad Pad

Text Classifier C

Figure 2: Adversarial Reprogramming Function and Training Procedures. Left: White-box Adversarial Re-
programming. The adversary generates gumbel distributions gi at each time-step which are passed as a soft version
of one-hot vectors to the classifier C. The cross-entropy loss between the predictions and the mapped class is back-
propagated to train the adversarial program θ. Right: Black-box Adversarial Reprogramming. The adversarial
reprogramming function is used as a policy network and the sampled action (sequence s) is passed to the classifier
C to get a reward based on prediction correctness. The adversarial program is then trained using REINFORCE.

where θ ∈ Rn×n×3 is the learnable weight ma-
trix of the adversarial program (where n is the
ImageNet image width). Let P (y|X) denote the
probability of the victim model predicting label
y for an input X . The goal of the adversary
is to maximize the probability P (hg(yadv)|Xadv)
where yadv is the label of the adversarial input
Xadv. The following optimization problem that
maximizes the log-likelihood of predictions for
the adversarial classification task, can be solved
using backpropagation to train the adversarial pro-
gram parameterized by θ:

θ̂ = argminθ
(
− logP (hg(yadv)|Xadv) + λ||θ||22

)
(1)

where λ is the regularization hyperparameter.
Since the adversarial program proposed is a train-
able additive contribution θ to the inputs, it’s
application is limited to neural networks with
a continuous input space. Also, since the the
above optimization problem is solved by back-
propagating through the victim network, it as-
sumes a white-box attack scenario where the ad-
versary has gained access to the victim model’s
parameters. In this work, we describe how we can
learn a simple transformation in the discrete space
to extend the application of adversarial reprogram-
ming on sequence classification problems. We
also propose a training algorithm in the black-box
setting where the adversary may not have access
to the model parameters.

2.3 Transfer Learning

Transfer Learning (Raina et al., 2007) is a study
closely related to Adversarial Reprogramming.

During training, neural networks learn represen-
tations that are generic and can be useful for many
related tasks. A pre-trained neural network can be
effectively used as a feature extractor and the pa-
rameters of just the last few layers are retrained to
realign the output layer of the neural network for
the new task. Prior works have also applied trans-
fer learning on text classification tasks (Do and
Ng, 2006; Semwal et al., 2018). While transfer
learning approaches exploit the learnt representa-
tions for the new task, they cannot be used to re-
purpose an exposed neural network for a new task
without modifying some intermediate layers and
parameters.

Adversarial Reprogramming (2019) studied
whether it is possible to keep all the parameters
of the neural network unchanged and simply learn
an input transformation that can realign the out-
puts of the neural network for the new task. This
makes it possible to repurpose exposed neural net-
work models like cloud-based photo services to a
new task where transfer learning is not applicable
since we do not have access to intermediate layer
outputs.

3 Methodology

3.1 Threat Model

Consider a sequence classifier C trained on the
original task of mapping a sequence s ∈ S to a
class label lS ∈ LS i.e C : s 7→ lS . An adver-
sary wishes to repurpose the original classifier C
for the adversarial task C ′ of mapping a sequence
t ∈ T to a class label lT ∈ LT i.e C ′ : t 7→ lT .
The adversary can achieve this by hard-coding a



5219

one-to-one label remapping function:

fL : lS 7→ lT

that maps an original task label to the new task
label and learning a corresponding adversarial re-
programming function:

fθ : t 7→ s

that transforms an input from the input space of
the adversarial task to the input space of the orig-
inal task. The adversary aims to update the pa-
rameters θ of the adversarial program fθ such that
the mapping fL(C(fθ(t))) can perform the adver-
sarial classification task C ′ : t 7→ lT . Note that
the victim model’s parameters will be kept frozen
while training the reprogramming function fθ.

3.2 Adversarial Reprogramming Function
The goal of the adversarial reprogramming func-
tion fθ : t 7→ s is to map a sequence t to s such
that it is labeled correctly by the classifier fL(C).

The tokens in the sequence s and t belong to
some vocabulary lists VS and VT respectively. We
can represent the sequence s as s = s1, s2, .., sN
where si is the vocabulary index of the ith token
in sequence s in the vocabulary list VS . Similarly
sequence t can be represented as t = t1, t2, .., tN
where ti is the vocabulary index of the ith token of
sequence t in the vocabulary list VT .

In the simplest scenario, the adversary may try
to learn a vocabulary mapping from VT to VS us-
ing which each ti can be independently mapped
to some si to generate the adversarial sequence.
Such an adversarial program has limited potential
since the representational capacity of such a re-
programming function is very limited. We experi-
mentally support this hypothesis by showing how
such a transformation has limited potential for the
purpose of adversarial reprogramming.

A more sophisticated adversarial program can
be a sequence to sequence machine translation
model (Sutskever et al., 2014) that learns a transla-
tion t 7→ s for adversarial reprogramming. While
theoretically this is a good choice, it defeats the
purpose of adversarial reprogramming. This is
because the computational complexity of training
and using such a machine translation model would
be similar if not greater than that of a new se-
quence classifier for the adversarial task C ′.

The adversarial reprogramming function should
be computationally inexpensive but powerful

enough for adversarial repurposing. To this end,
we propose a context-based vocabulary remapping
model that produces a distribution over the tar-
get vocabulary at each time-step based on the sur-
rounding input tokens. More specifically, we de-
fine our adversarial program as a trainable 3-d ma-
trix θk×|VT |×|VS | where k is the context size. Using
this, we generate a probability distribution πi over
the vocabulary VS at each time-step i as follows:

hi =
k−1∑
j=0

θ[j, ti+bk/2c−j ] (2)

πi = softmax(hi) (3)

Both hi and πi are vectors of length |VS |. To gen-
erate the adversarial sequence swe sample each si
independently from the distribution πi i.e si ∼ πi

In practice, during training, we implement this
adversarial program as a single layer of 1-d convo-
lution over the sequence of one-hot encoded vec-
tors of adversarial tokens ti with |VT | input chan-
nels and |VS | output channels with k-length ker-
nels parameterized by θk×|VT |×|VS |.

3.3 White-box Attack

In the white-box attack scenario, we assume that
the adversary has gained access to the victim net-
work’s parameters and architecture. To train the
adversarial reprogramming function fθ, we use an
optimization objective similar to equation 1. Let
P (l|s) denote the probability of predicting label l
for a sequence s by classifier C. We wish to maxi-
mize the probability P (f−1L (lt)|fθ(t)) which is the
probability of the output label of the classifier be-
ing mapped to the correct class lt for an input t in
the domain of the adversarial task. Therefore we
need to solve the following log-likelihood maxi-
mization problem:

θ̂ = argminθ(−
∑
t

log(P (f−1L (lt)|fθ(t))))

(4)
Note that that the output of the adversarial pro-

gram s = fθ(t) is a sequence of discrete to-
kens. This makes the above optimization prob-
lem non-differentiable. Prior works (Kusner and
Hernández-Lobato, 2016; Gu et al., 2017; Yang
et al., 2018) have demonstrated how we can
smoothen such an optimization problem using the
Gumbel-Softmax (Jang et al., 2016) distribution.



5220

In order to backpropagate the gradient infor-
mation from the classifier to the adversarial pro-
gram, we smoothen the generated tokens si using
Gumbel-Softmax trick as per the following:

For an input sequence t, we generate a sequence
of Gumbel distributions g = g1, g2, .., gN . The
nth component of distribution gi is generated as
follows:

gni =
exp((log(πni ) + rn)/temp)∑
j exp((log(π

j
i ) + rj)/temp)

where πi is the softmax distribution at the ith
time-step obtained using equation 3, rn is a ran-
dom number sampled from the Gumbel distribu-
tion (Gumbel, 1954) and temp is the temperature
of Gumbel-Softmax.

The sequence then passed to the classifier C is
the sequence g which serves as a soft version of the
one-hot encoded vectors of si’s. Since the model
is now differentiable, we can solve the following
optimization problem using backpropagation:

θ̂ = argminθ(−
∑
t

log(P (f−1L (lt)|g)))

During training the temperature parameter is
annealed from some high value tmax to a very low
value tmin. The details of this annealing process
for our experiments have been included in the ap-
pendix.

3.4 Black-box Attack
In the black-box attack scenario, the adversary can
only query the victim classifier C for labels (and
not the class probabilities). We assume that the
adversary has the knowledge of the vocabulary VS
of the victim model. Since the adversarial pro-
gram needs to produce a discrete output to feed
as input to the classifier C, it is not possible to
pass the gradient update from the classifier fL(C)
to the adversarial program θ using standard back-
propagation. Also, in the black-box attack setting
it is not possible to back-propagate the cross en-
tropy loss through the classifierC in the first place.

We formulate the sequence generation problem
as a Reinforcement Learning problem (Bachman
and Precup, 2015; Bahdanau et al., 2016; Yu et al.,
2016) where the adversarial reprogramming func-
tion is the policy network. The state of the adver-
sarial program is a sequence t ∈ T and an action
of our policy network is to produce a sequence of
tokens s ∈ S. The adversarial program parameter-
ized by θ, models the stochastic policy πadv(s|t; θ)

such that a sequence s ∈ S may be sampled from
this policy conditioned on t ∈ T . We use a sim-
ple reward function where we assign a reward +1
for a correct prediction and -1 for an incorrect pre-
diction using the classifier fL(C) where fL is the
label remapping function and C is the classifier.
Formally:

r(t, s) =

{
+1, fL(C(s)) = lt

−1, fL(C(s)) 6= lt

The optimization objective to train the policy net-
work is the following:

max
θ
J(θ) where, J(θ) = Eπadv [r(t, s)]

Following the REINFORCE algorithm (Williams,
1992) we can write the gradient of the expectation
with respect to θ as per the following:

∇θJ = ∇θ
[
E
πadv

[r(t, s)]

]
= ∇θ

[∑
s

πadv(s|t; θ)r(t, s)

]
=

∑
s

πadv(s|t; θ)∇θ log(πadv(s|t; θ))r(t, s)

= E
πadv

[r(t, s)∇θ log(πadv(s|t; θ))]

= E
πadv

[r(t, s)∇θ log(πadv(s1, .., sN |t; θ))]

= E
πadv

[
r(t, s)∇θ log(

∏
i

πadv(si|t; θ))

]

= E
πadv

[
r(t, s)

∑
i

∇θ log(πadv(si|t; θ))

]

Note that πadv(si|t; θ) is the same as πi de-
fined in equation 3 which can be differentiated
with respect to θ. The expectations are estimated
as sample averages. Having obtained the gradient
of expected reward, we can use mini-batch gradi-
ent ascent to update θ with a learning rate α as:
θ ← θ + α∇θJ .

4 Experiments

4.1 Datasets and Classifiers
We demonstrate the application of the pro-
posed reprogramming techniques on various text-
classification tasks. In our experiments, we design
adversarial programs to attack both word-level and
character-level text classifiers. Additionally, we



5221

aim to adversarially repurpose a character-level
text classifier for a word-level classification task
and vice-versa. To this end, we choose the follow-
ing text-classification datasets as candidates for
the original and adversarial classification tasks:

1. Surname Classification Dataset (Names-18,
Names-5) (Robertson, 2017): The dataset catego-
rizes surnames from 18 languages of origin. We
use a subset of this dataset Names-5 containing
Names from 5 classes: Dutch, Scottish, Polish,
Korean and Portuguese, as a candidate for adver-
sarial task in the experiments.
2. Experimental Data for Question Classifica-
tion (Questions) (Li and Roth, 2002): catego-
rizes around 5500 questions into 6 classes: Ab-
breviation, Entity, Description, Human, Location,
Numeric.
3. Sentiment Classification Dataset (Abdulla
et al., 2013) (Arabic) : contains 2000 binary la-
beled tweets on diverse topics such as politics and
arts.
4. Large Movie Review Dataset (IMDB) for sen-
timent classification (Maas et al., 2011): con-
tains 50,000 movie reviews categorized into bi-
nary class of positive and negative sentiment.

The statistics of the above mentioned datasets
have been given in table 1. We train adversar-
ial reprogramming functions to repurpose various
text-classifiers based on Long Short-Term Mem-
ory (LSTM) network (Hochreiter and Schmidhu-
ber, 1997), bidirectional LSTM network (Graves
et al., 2005) and Convolutional neural network
(Kim, 2014) models. All the aforementioned
models can be trained for both word-level and
character-level classification. We use charac-
ter level classifiers for Names-18 and Names-
5 datasets and word-level classifiers for IMDB,
Questions and Arabic datasets. We use randomly
initialized word/character embeddings which are
trained along with the classification model pa-
rameters. For LSTM, we use the output at last
timestep for prediction. For the Bi-LSTM, we
combine the outputs of the first and last time step
for prediction. For the Convolutional Neural Net-
work we follow the same architecture as (Kim,
2014). Additionally, to understand the effective-
ness of adversarial reprogramming, we train a
sigle layer CNN with convolutional filter width 5
and discuss the results of this experiment in Sec-
tion 4.4. The details of these classifiers have been
included in table 2 of the supplementary material.

Data Set # Classes TrainSamples
Test

Samples |V |
Avg

Length

Names-18 18 115,028 28,758 90 7.1
Names-5 5 3632 909 66 6.5
Questions 6 4361 1091 1205 11.2
Arabic 2 1600 400 955 9.7
IMDB 2 25,000 25,000 10000 246.8

Table 1: Summary of datasets. |V | denotes the vocab-
ulary size of each dataset.

Data Set LSTM Bi-LSTM CNN 1-CNN

Names-18 97.84 97.84 97.88 74.04
Names-5 99.88 99.88 99.77 71.51
Questions 96.70 98.25 98.07 83.77
Arabic 87.25 88.75 88.00 74.75
IMDB 86.83 89.43 90.02 83.32

Table 2: Test accuracy of various classification mod-
els. We use character-level models for Names-5 and
Names-18 and word-level models for all other tasks. 1-
CNN is a single layer CNN model with filter width 5.

4.2 Experimental Setup

As described in the methodology section, the la-
bel remapping function fL we use, is a one-to-one
mapping between the labels of the original task
and the adversarial task. Therefore it is required
to apply the constraint that the number of classes
of the adversarial task are less than or equal to the
number of classes of the original task. We choose
Names-5, Arabic and Question Classification as
candidates for the adversarial tasks and repurpose
the models allowed under this constraint. We use
context size k = 5 for all our experiments.

In white-box attacks, we use the Gumbel-
Softmax based approach described in the method-
ology to train the adversarial program. The details
of the temperature annealing process are included
in table 1 of the supplementary material. For
black-box attacks, we use the REINFORCE algo-
rithm described in methodology, on mini-batches
of sequences. Since the action space for certain
reprogramming problems, (eg. reprogramming of
IMDB classifier) is large (|VS | = 10000), we re-
strict the output of the adversarial program to most
frequent 1000 tokens in the vocabulary VS . We
use Adam optimizer (Kingma and Ba, 2015) for
all our experiments. Hyperparameter details of all
our experiments are included in table 1 of the sup-
plementary material.



5222

Test Accuracy (%)

Original
Task

Adversarial
Task

Victim
Model

Black
box

White
Box

White
Box on
Random
Network

Questions Names-5
LSTM 80.96 97.03 44.33
Bi-LSTM 93.51 99.66 63.14
CNN 88.90 99.22 93.06

Questions Arabic
LSTM 73.50 87.50 50.00
Bi-LSTM 81.75 83.50 70.00
CNN 82.25 87.25 76.25

Names-18 Questions
LSTM 68.56 95.23 28.23
Bi-LSTM 94.96 97.15 80.01
CNN 71.03 97.61 33.45

Names-18 Arabic
LSTM 83.00 84.75 51.50
Bi-LSTM 78.75 84.25 69.25
CNN 80.75 86.50 60.00

IMDB Arabic
LSTM 80.75 88.25 50.50
Bi-LSTM 83.25 86.75 84.00
CNN 84.00 87.00 84.25

Table 3: Adversarial Reprogramming Experiments:
The accuracies of white-box and black-box reprogram-
ming experiments on different combinations of original
task, adversarial task and model. Figures in bold corre-
spond to our best results on a particular adversarial task
in the given attack scenario (black-box and white-box).
White-box on Random Network column presents results
of the white-box attack on an untrained neural network.
Context size k = 5 is used for all our experiments.

4.3 Results and Discussion
The accuracies of all adversarial reprogramming
experiments have been reported in table 3. To
interpret the results in context, the accuracies
achieved by the LSTM, Bi-LSTM and CNN text
classification models on the adversarial tasks can
be found in table 1.

We demonstrate how character-level models
trained on Names-18 dataset can be repurposed
for word-level sequence classification tasks like
Question Classification and Arabic Tweet Senti-
ment Classification. Similarly, word-level clas-
sifiers trained on Question Classification Dataset
can be repurposed for the character-level Surname
classification task. Interestingly, classifiers trained
on IMDB Movie Review Dataset can be repur-
posed for Arabic Tweet Sentiment Classification
even though there is a high difference between the
vocabulary size (10000 vs 955) and average se-
quence length(246.8 vs 9.7) of the two tasks. It
can be seen that all of the three classification mod-
els are susceptible to adversarial reprogramming
in both white-box and black-box setting.

White-box based reprogramming outperforms
the black-box based approach in all of our ex-
periments. In practice, we find that training the
adversarial program in the black-box scenario re-
quires careful hyper-parameter tuning for REIN-
FORCE to work. We believe that improved rein-
forcement learning techniques for sequence gener-
ation tasks (Bahdanau et al., 2016; Bachman and
Precup, 2015) can make the training procedure for
black-box attack more stable. We propose such
improvement as a direction of future research.

To assess the importance of the original task on
which the network was trained, we also present re-
sults of white-box adversarial reprogramming on
untrained random network. Our results are co-
herent with similar experiments on adversarial re-
programming of untrained ImageNet models (El-
sayed et al., 2019) demonstrating that adversarial
reprogramming is less effective when it targets un-
trained networks. The figures in table 3 suggest
that the representations learned by training a text
classifier on an original task, are important for re-
purposing it for an alternate task. However another
plausible reason as discussed by Elsayed et al. is
that the reduced performance on random networks
might be because of simpler reasons like poor scal-
ing of network weight initialization making the
optimization problem harder.

4.4 Complexity of Reprogramming Function

As motivated earlier in Section 3.2, computational
efficiency of the adversarial program is critical for
adversarial reprogramming to be of interest to an
adversary. If the adversary can achieve the desired
results using a computationally inexpensive clas-
sifier, it defeats the purpose of adversarial repro-
gramming. To understand if this is the case, we
train a one-layer CNN with the same convolutional
filter width as our adversarial program and aver-
age the activations across all time-steps to clas-
sify a given phrase. The results of such a classifier
on various datasets have been reported in Table 2.
We can observe that our white-box attack on pre-
trained networks, outperforms this classifier in all
scenarios (refer to Table 3). Our best black-box at-
tacks also outperform a one-layer CNN for all ad-
versarial tasks. This experiment demonstrates that
the reprogramming function exploits the learned
feature representation of the victim model. Also,
the observation that adversarial reprogramming is
significantly less effective on randomly initialized



5223

untrained networks further reinforces the impor-
tance of utilizing a trained victim model.

Since the reprogramming function is a context
based vocabulary remapping function, we can im-
plement it as a look-up table that maps a combina-
tion of k tokens from the vocabulary Vt to a token
in the source vocabulary Vs. The time complex-
ity for transforming a sentence t to an adversarial
sentence is just O(length(t)).

4.4.1 Adversarial Sequences
Figure 3 shows some adversarial sequences gener-
ated by the adversarial program for Names-5 Clas-
sification while attacking a CNN trained on the
Question Classification dataset. A sequence t in
the first column is transformed into the adversar-
ial sequence s in the second column by the trained
adversarial reprogramming function. While these
adversarial sequences may not make semantic or
grammatical sense, it exploits the learned repre-
sentation of the classifier to map the inputs to the
desired class. For example, sequences that should
be mapped to HUMAN class have words like Who
in the generated adversarial sequence. Similarly,
sequences that should be mapped to LOCATION
class have words like world, city in the adversar-
ial sequence. Other such interpretable transforma-
tions are depicted via colored text in the adversar-
ial sequences of Figure 3.

Adversarial 
Task 

Sequence (t) 
(Names-5)

Adversarial Program Output (s) (Question 
Classification)

Prediction by 
Classifier

Mapped 
Class Actual Class

Ryoo white sport substance animal All off .. ENTITY Korean Korean
Houtum player video exp abb What does off is off .. ABBREVIATION Dutch Dutch

Winogrodzki manner France manner video def oil def reason desc What do All off .. DESCRIPTION Polish Polish

Murphy world live exp city What university All is off .. LOCATION Scottish Scottish

Paulissen player stars along abb abb exp exp always abb What is off .. ABBREVIATION Dutch Dutch

Henriques other always live What Who does ind Who gold is off .. HUMAN Portuguese Portuguese

Maly world attend home abb home is off .. LOCATION Scottish Polish

Kasprzak does exp exp def manner does reason What does off .. DESCRIPTION Polish Polish

Ferreiro e-mail Who ind exp Who ind university university gold off .. HUMAN Portuguese Portuguese

Hong sport cremat substance university is off .. ENTITY Korean Korean

Figure 3: Adversarial sequences generated by our ad-
versarial program for Names-5 Classification (adver-
sarial task), when targeting a CNN trained on the Ques-
tion Classification dataset (original task). Interpretable
transformations are shown as colored words in the sec-
ond column.

4.4.2 Effect of Context Size
By varying the context size k of the convolu-
tional kernel θk×|VT |×|VS | in our adversarial pro-
gram we are able to control the representational
capacity of the adversarial reprogramming func-

tion. Figure 4 shows the percentage accuracy ob-
tained when training the adversarial program with
different context sizes k on two different adversar-
ial tasks: Arabic Tweets Classification and Name
Classification. Using a context size k = 1 re-
duces the adversarial reprogramming function to
simply a vocabulary remapping function from VS
to VT . It can be observed that the performance of
the adversarial reprogramming model at k = 1 is
significantly worse than that at higher values of k.
While higher values of k improve the performance
of the adversarial program, they come at a cost of
increased computational complexity and memory
required for the adversarial reprogramming func-
tion. For the adversarial tasks studied in this paper,
we observe that k = 5 is a reasonable choice for
context size of the adversarial program.

50
55
60
65
70
75
80
85
90
95

100

1 3 5 7

Pe
rc

en
ta

ge
 A

cc
ur

ac
y

Adversarial Program Context Size (k)

Original Task: Names-18 Adversarial Task: Arabic Tweets

Bi-LSTM
CNN
LSTM

50
55
60
65
70
75
80
85
90
95

100

1 3 5 7

Pe
rc

en
ta

ge
 A

cc
ur

ac
y

Adversarial Program Context Size (k)

Original Task: Questions Adversarial Task: Names-5

Bi-LSTM
CNN
LSTM

Figure 4: Accuracy vs Context size (k) plots for all 3
classification models on 2 different adversarial repro-
gramming experiments.

5 Conclusion

In this paper, we extend adversarial reprogram-
ming, a new class of adversarial attacks, to tar-
get text classification neural networks. Our results
demonstrate the effectiveness of such attacks in
the more challenging black-box settings, posing
them as a strong threat in real-world attack sce-
narios. We demonstrate that neural networks can
be effectively reprogrammed for alternate tasks,
which were not originally intended by a service
provider. Our proposed end-to-end approach can
be used to further understand the vulnerabilities
and blind spots of deep neural network based
text classification systems. We recommend future
work to study the scope of adversarial reprogram-
ming for other NLP applications such as machine
translation, text to speech synthesis and text to im-



5224

age synthesis where the input space is discrete.
Furthermore, due to the threat presented by adver-
sarial reprogramming, we recommend future work
to study defenses against such attacks.

References
N. A. Abdulla, N. A. Ahmed, M. A. Shehab, and M. Al-

Ayyoub. 2013. Arabic sentiment analysis: Lexicon-
based and corpus-based. In 2013 IEEE Jordan Con-
ference on Applied Electrical Engineering and Com-
puting Technologies (AEECT).

Philip Bachman and Doina Precup. 2015. Data gener-
ation as sequential decision making. In Advances
in Neural Information Processing Systems, pages
3249–3257.

Dzmitry Bahdanau, Philemon Brakel, Kelvin Xu,
Anirudh Goyal, Ryan Lowe, Joelle Pineau, Aaron C.
Courville, and Yoshua Bengio. 2016. An actor-
critic algorithm for sequence prediction. CoRR,
abs/1607.07086.

Shumeet Baluja and Ian Fischer. 2018. Learning to
attack: Adversarial transformation networks. In
AAAI.

Battista Biggio, Igino Corona, Davide Maiorca, Blaine
Nelson, Nedim Šrndić, Pavel Laskov, Giorgio Giac-
into, and Fabio Roli. 2013. Evasion attacks against
machine learning at test time. In Machine Learning
and Knowledge Discovery in Databases.

Tom B. Brown, Dandelion Mané, Aurko Roy, Martı́n
Abadi, and Justin Gilmer. 2017. Adversarial patch.
CoRR, abs/1712.09665.

J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-
Fei. 2009. ImageNet: A Large-Scale Hierarchical
Image Database. In CVPR09.

Chuong B. Do and Andrew Y. Ng. 2006. Trans-
fer learning for text classification. In Y. Weiss,
B. Schölkopf, and J. C. Platt, editors, Advances
in Neural Information Processing Systems 18. MIT
Press.

Gamaleldin F. Elsayed, Ian J. Goodfellow, and Jascha
Sohl-Dickstein. 2019. Adversarial reprogramming
of neural networks. In ICLR.

Ian Goodfellow, Jonathon Shlens, and Christian
Szegedy. 2015. Explaining and harnessing adversar-
ial examples. In International Conference on Learn-
ing Representations.

Alex Graves, Santiago Fernández, and Jürgen Schmid-
huber. 2005. Bidirectional lstm networks for
improved phoneme classification and recognition.
In Proceedings of the 15th International Con-
ference on Artificial Neural Networks: Formal
Models and Their Applications - Volume Part II,
ICANN’05, pages 799–804, Berlin, Heidelberg.
Springer-Verlag.

Jiatao Gu, Daniel Jiwoong Im, and Victor O. K. Li.
2017. Neural machine translation with gumbel-
greedy decoding. CoRR, abs/1706.07518.

E.J. Gumbel. 1954. Statistical theory of extreme val-
ues and some practical applications: a series of lec-
tures. Applied mathematics series. U. S. Govt. Print.
Office.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Comput., 9(8).

Weiwei Hu and Ying Tan. 2018. Black-box attacks
against rnn based malware detection algorithms. In
Workshops at the Thirty-Second AAAI Conference
on Artificial Intelligence.

Eric Jang, Shixiang Gu, and Ben Poole. 2016. Cat-
egorical reparameterization with gumbel-softmax.
CoRR, abs/1611.01144.

Yoon Kim. 2014. Convolutional neural networks for
sentence classification. In EMNLP.

Diederik P Kingma and Jimmy Ba. 2015. Adam: A
method for stochastic optimization. In Proc. ICLR.

Matt J. Kusner and José Miguel Hernández-Lobato.
2016. GANS for sequences of discrete elements
with the gumbel-softmax distribution. CoRR,
abs/1611.04051.

Xin Li and Dan Roth. 2002. Learning question classi-
fiers. In Proceedings of the 19th International Con-
ference on Computational Linguistics - Volume 1,
COLING ’02, Stroudsburg, PA, USA. Association
for Computational Linguistics.

Andrew L. Maas, Raymond E. Daly, Peter T. Pham,
Dan Huang, Andrew Y. Ng, and Christopher Potts.
2011. Learning word vectors for sentiment analysis.
In Proceedings of the 49th Annual Meeting of the
Association for Computational Linguistics: Human
Language Technologies, Portland, Oregon, USA.

S. Moosavi-Dezfooli, A. Fawzi, O. Fawzi, and
P. Frossard. 2017. Universal adversarial perturba-
tions. In 2017 IEEE Conference on Computer Vision
and Pattern Recognition (CVPR), pages 86–94.

Nicolas Papernot, Patrick McDaniel, Ian Goodfel-
low, Somesh Jha, Z Berkay Celik, and Ananthram
Swami. 2017. Practical black-box attacks against
machine learning. In Proceedings of the 2017 ACM
on Asia conference on computer and communica-
tions security. ACM.

Nicolas Papernot, Patrick McDaniel, Somesh Jha, Matt
Fredrikson, Z Berkay Celik, and Ananthram Swami.
2016a. The limitations of deep learning in adversar-
ial settings. In 2016 IEEE European Symposium on
Security and Privacy (EuroS&P). IEEE.

Nicolas Papernot, Patrick D. McDaniel, and Ian J.
Goodfellow. 2016b. Transferability in machine
learning: from phenomena to black-box attacks us-
ing adversarial samples. CoRR, abs/1605.07277.

https://doi.org/10.1109/AEECT.2013.6716448
https://doi.org/10.1109/AEECT.2013.6716448
http://www.esprockets.com/papers/aaai2018.pdf
http://www.esprockets.com/papers/aaai2018.pdf
http://arxiv.org/abs/1712.09665
http://papers.nips.cc/paper/2843-transfer-learning-for-text-classification.pdf
http://papers.nips.cc/paper/2843-transfer-learning-for-text-classification.pdf
http://arxiv.org/abs/1412.6572
http://arxiv.org/abs/1412.6572
http://dl.acm.org/citation.cfm?id=1986079.1986220
http://dl.acm.org/citation.cfm?id=1986079.1986220
https://books.google.com/books?id=SNpJAAAAMAAJ
https://books.google.com/books?id=SNpJAAAAMAAJ
https://books.google.com/books?id=SNpJAAAAMAAJ
https://doi.org/10.1162/neco.1997.9.8.1735
https://doi.org/10.1162/neco.1997.9.8.1735
http://dblp.uni-trier.de/db/journals/corr/corr1611.html#JangGP16
http://dblp.uni-trier.de/db/journals/corr/corr1611.html#JangGP16
http://aclweb.org/anthology/D/D14/D14-1181.pdf
http://aclweb.org/anthology/D/D14/D14-1181.pdf
https://doi.org/10.3115/1072228.1072378
https://doi.org/10.3115/1072228.1072378
http://www.aclweb.org/anthology/P11-1015
https://doi.org/10.1109/CVPR.2017.17
https://doi.org/10.1109/CVPR.2017.17
http://arxiv.org/abs/1605.07277
http://arxiv.org/abs/1605.07277
http://arxiv.org/abs/1605.07277


5225

Nicolas Papernot, Patrick D. McDaniel, Ananthram
Swami, and Richard E. Harang. 2016c. Crafting
adversarial input sequences for recurrent neural net-
works. CoRR, abs/1604.08275.

Rajat Raina, Alexis Battle, Honglak Lee, Benjamin
Packer, and Andrew Y. Ng. 2007. Self-taught learn-
ing: Transfer learning from unlabeled data. In Pro-
ceedings of the Twenty-fourth International Confer-
ence on Machine Learning.

Sean Robertson. 2017. Classifying names
with a character-level rnn - pytroch tu-
torial. https://pytorch.org/
tutorials/intermediate/char_rnn_
classification_tutorial.html.

Tushar Semwal, Gaurav Mathur, Promod Yenigalla,
and Shivashankar B. Nair. 2018. A practition-
ers’ guide to transfer learning for text classifica-
tion using convolutional neural networks. CoRR,
abs/1801.06480.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. In NIPS.

Christian Szegedy, Wojciech Zaremba, Ilya Sutskever,
Joan Bruna, Dumitru Erhan, Ian Goodfellow, and
Rob Fergus. 2014. Intriguing properties of neural
networks. In ICLR.

Ronald J. Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine Learning, 8(3-4).

Puyudi Yang, Jianbo Chen, Cho-Jui Hsieh, Jane-Ling
Wang, and Michael I. Jordan. 2018. Greedy attack
and gumbel attack: Generating adversarial examples
for discrete data. CoRR, abs/1805.12316.

Lantao Yu, Weinan Zhang, Jun Wang, and Yong Yu.
2016. Seqgan: Sequence generative adversarial nets
with policy gradient. CoRR, abs/1609.05473.

http://arxiv.org/abs/1604.08275
http://arxiv.org/abs/1604.08275
http://arxiv.org/abs/1604.08275
https://pytorch.org/tutorials/intermediate/char_rnn_classification_tutorial.html
https://pytorch.org/tutorials/intermediate/char_rnn_classification_tutorial.html
https://pytorch.org/tutorials/intermediate/char_rnn_classification_tutorial.html
http://arxiv.org/abs/1801.06480
http://arxiv.org/abs/1801.06480
http://arxiv.org/abs/1801.06480
http://dl.acm.org/citation.cfm?id=2969033.2969173
http://dl.acm.org/citation.cfm?id=2969033.2969173
http://arxiv.org/abs/1312.6199
http://arxiv.org/abs/1312.6199
https://doi.org/10.1007/BF00992696
https://doi.org/10.1007/BF00992696
https://doi.org/10.1007/BF00992696
http://arxiv.org/abs/1805.12316
http://arxiv.org/abs/1805.12316
http://arxiv.org/abs/1805.12316
http://dblp.uni-trier.de/db/journals/corr/corr1609.html#YuZWY16
http://dblp.uni-trier.de/db/journals/corr/corr1609.html#YuZWY16

