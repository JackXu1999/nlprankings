



















































Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics


Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 484–495
Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/P17-1045

Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 484–495
Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/P17-1045

Towards End-to-End Reinforcement Learning of
Dialogue Agents for Information Access

Bhuwan Dhingra? Lihong Li† Xiujun Li† Jianfeng Gao†
Yun-Nung Chen‡ Faisal Ahmed† Li Deng†

?Carnegie Mellon University, Pittsburgh, PA, USA
†Microsoft Research, Redmond, WA, USA
‡National Taiwan University, Taipei, Taiwan

?bdhingra@andrew.cmu.edu †{lihongli,xiul,jfgao}@microsoft.com ‡y.v.chen@ieee.org

Abstract

This paper proposes KB-InfoBot1 — a
multi-turn dialogue agent which helps
users search Knowledge Bases (KBs)
without composing complicated queries.
Such goal-oriented dialogue agents typ-
ically need to interact with an external
database to access real-world knowledge.
Previous systems achieved this by issuing
a symbolic query to the KB to retrieve en-
tries based on their attributes. However,
such symbolic operations break the differ-
entiability of the system and prevent end-
to-end training of neural dialogue agents.
In this paper, we address this limitation
by replacing symbolic queries with an in-
duced “soft” posterior distribution over the
KB that indicates which entities the user is
interested in. Integrating the soft retrieval
process with a reinforcement learner leads
to higher task success rate and reward in
both simulations and against real users.
We also present a fully neural end-to-end
agent, trained entirely from user feedback,
and discuss its application towards person-
alized dialogue agents.

1 Introduction

The design of intelligent assistants which interact
with users in natural language ranks high on the
agenda of current NLP research. With an increas-
ing focus on the use of statistical and machine
learning based approaches (Young et al., 2013),
the last few years have seen some truly remark-
able conversational agents appear on the market
(e.g. Apple Siri, Microsoft Cortana, Google Allo).
These agents can perform simple tasks, answer

1The source code is available at: https://github.
com/MiuLab/KB-InfoBot

factual questions, and sometimes also aimlessly
chit-chat with the user, but they still lag far be-
hind a human assistant in terms of both the va-
riety and complexity of tasks they can perform.
In particular, they lack the ability to learn from
interactions with a user in order to improve and
adapt with time. Recently, Reinforcement Learn-
ing (RL) has been explored to leverage user inter-
actions to adapt various dialogue agents designed,
respectively, for task completion (Gašić et al.,
2013), information access (Wen et al., 2016b), and
chitchat (Li et al., 2016a).

We focus on KB-InfoBots, a particular type of
dialogue agent that helps users navigate a Knowl-
edge Base (KB) in search of an entity, as illus-
trated by the example in Figure 1. Such agents
must necessarily query databases in order to re-
trieve the requested information. This is usually
done by performing semantic parsing on the input
to construct a symbolic query representing the be-
liefs of the agent about the user goal, such as Wen
et al. (2016b), Williams and Zweig (2016), and Li
et al. (2017)’s work. We call such an operation
a Hard-KB lookup. While natural, this approach
has two drawbacks: (1) the retrieved results do not
carry any information about uncertainty in seman-
tic parsing, and (2) the retrieval operation is non
differentiable, and hence the parser and dialog pol-
icy are trained separately. This makes online end-
to-end learning from user feedback difficult once
the system is deployed.

In this work, we propose a probabilistic frame-
work for computing the posterior distribution of
the user target over a knowledge base, which we
term a Soft-KB lookup. This distribution is con-
structed from the agent’s belief about the attributes
of the entity being searched for. The dialogue pol-
icy network, which decides the next system action,
receives as input this full distribution instead of a
handful of retrieved results. We show in our ex-

484

https://doi.org/10.18653/v1/P17-1045
https://doi.org/10.18653/v1/P17-1045


Movie=?
Actor=Bill Murray

Release Year=1993

Find me the Bill Murray’s movie.

I think it came out in 1993.

When was it released?

Groundhog Day is a Bill Murray 
movie which came out in 1993. 

KB-InfoBotUser

Entity-Centric Knowledge Base

Movie Actor
Release 

Year

Groundhog Day Bill Murray 1993

Australia Nicole Kidman X

Mad Max: Fury Road X 2015

Figure 1: An interaction between a user looking
for a movie and the KB-InfoBot. An entity-centric
knowledge base is shown above the KB-InfoBot
(missing values denoted by X).

periments that this framework allows the agent to
achieve a higher task success rate in fewer dia-
logue turns. Further, the retrieval process is dif-
ferentiable, allowing us to construct an end-to-end
trainable KB-InfoBot, all of whose components
are updated online using RL.

Reinforcement learners typically require an en-
vironment to interact with, and hence static dia-
logue corpora cannot be used for their training.
Running experiments on human subjects, on the
other hand, is unfortunately too expensive. A
common workaround in the dialogue community
(Young et al., 2013; Schatzmann et al., 2007b;
Scheffler and Young, 2002) is to instead use user
simulators which mimic the behavior of real users
in a consistent manner. For training KB-InfoBot,
we adapt the publicly available2 simulator de-
scribed in Li et al. (2016b).

Evaluation of dialogue agents has been the sub-
ject of much research (Walker et al., 1997; Möller
et al., 2006). While the metrics for evaluating an
InfoBot are relatively clear — the agent should re-
turn the correct entity in a minimum number of
turns — the environment for testing it not so much.
Unlike previous KB-based QA systems, our focus
is on multi-turn interactions, and as such there are
no publicly available benchmarks for this prob-
lem. We evaluate several versions of KB-InfoBot
with the simulator and on real users, and show
that the proposed Soft-KB lookup helps the re-
inforcement learner discover better dialogue poli-
cies. Initial experiments on the end-to-end agent
also demonstrate its strong learning capability.

2
https://github.com/MiuLab/TC-Bot

2 Related Work

Our work is motivated by the neural GenQA (Yin
et al., 2016a) and neural enquirer (Yin et al.,
2016b) models for querying KBs via natural lan-
guage in a fully “neuralized” way. However, the
key difference is that these systems assume that
users can compose a complicated, compositional
natural language query that can uniquely identify
the element/answer in the KB. The research task
is to parse the query, i.e., turning the natural lan-
guage query into a sequence of SQL-like opera-
tions. Instead we focus on how to query a KB
interactively without composing such complicated
queries in the first place. Our work is motivated
by the observations that (1) users are more used to
issuing simple queries of length less than 5 words
(Spink et al., 2001); (2) in many cases, it is unrea-
sonable to assume that users can construct com-
positional queries without prior knowledge of the
structure of the KB to be queried.

Also related is the growing body of literature
focused on building end-to-end dialogue systems,
which combine feature extraction and policy opti-
mization using deep neural networks. Wen et al.
(2016b) introduced a modular neural dialogue
agent, which uses a Hard-KB lookup, thus break-
ing the differentiability of the whole system. As a
result, training of various components of the di-
alogue system is performed separately. The in-
tent network and belief trackers are trained using
supervised labels specifically collected for them;
while the policy network and generation network
are trained separately on the system utterances.
We retain modularity of the network by keeping
the belief trackers separate, but replace the hard
lookup with a differentiable one.

Dialogue agents can also interface with the
database by augmenting their output action space
with predefined API calls (Williams and Zweig,
2016; Zhao and Eskenazi, 2016; Bordes and We-
ston, 2016; Li et al., 2017). The API calls modify
a query hypothesis maintained outside the end-to-
end system which is used to retrieve results from
this KB. This framework does not deal with uncer-
tainty in language understanding since the query
hypothesis can only hold one slot-value at a time.
Our approach, on the other hand, directly models
the uncertainty to construct the posterior over the
KB.

Wu et al. (2015) presented an entropy mini-
mization dialogue management strategy for In-

485



foBots. The agent always asks for the value of
the slot with maximum entropy over the remain-
ing entries in the database, which is optimal in
the absence of language understanding errors, and
serves as a baseline against our approach. Rein-
forcement learning neural turing machines (RL-
NTM) (Zaremba and Sutskever, 2015) also allow
neural controllers to interact with discrete external
interfaces. The interface considered in that work
is a one-dimensional memory tape, while in our
work it is an entity-centric KB.

3 Probabilistic KB Lookup

This section describes a probabilistic framework
for querying a KB given the agent’s beliefs over
the fields in the KB.

3.1 Entity-Centric Knowledge Base (EC-KB)

A Knowledge Base consists of triples of the form
(h, r, t), which denotes that relation r holds be-
tween the head h and tail t. We assume that
the KB-InfoBot has access to a domain-specific
entity-centric knowledge base (EC-KB) (Zwickl-
bauer et al., 2013) where all head entities are of
a particular type (such as movies or persons), and
the relations correspond to attributes of these head
entities. Such a KB can be converted to a table
format whose rows correspond to the unique head
entities, columns correspond to the unique relation
types (slots henceforth), and some entries may be
missing. An example is shown in Figure 1.

3.2 Notations and Assumptions

Let T denote the KB table described above and
Ti,j denote the jth slot-value of the ith entity.
1 ≤ i ≤ N and 1 ≤ j ≤M . We let V j denote the
vocabulary of each slot, i.e. the set of all distinct
values in the j-th column. We denote missing val-
ues from the table with a special token and write
Ti,j = Ψ. Mj = {i : Ti,j = Ψ} denotes the set
of entities for which the value of slot j is missing.
Note that the user may still know the actual value
of Ti,j , and we assume this lies in V j . We do not
deal with new entities or relations at test time.

We assume a uniform prior G ∼ U [{1, ...N}]
over the rows in the table T , and let binary ran-
dom variables Φj ∈ {0, 1} indicate whether the
user knows the value of slot j or not. The agent
maintains M multinomial distributions ptj(v) for
v ∈ V j denoting the probability at turn t that the
user constraint for slot j is v, given their utterances

U t1 till that turn. The agent also maintains M bi-
nomials qtj = Pr(Φj = 1) which denote the prob-
ability that the user knows the value of slot j.

We assume that column values are indepen-
dently distributed to each other. This is a strong
assumption but it allows us to model the user goal
for each slot independently, as opposed to model-
ing the user goal over KB entities directly. Typi-
cally maxj |V j | < N and hence this assumption
reduces the number of parameters in the model.

3.3 Soft-KB Lookup
Let ptT (i) = Pr(G = i|U t1) be the posterior prob-
ability that the user is interested in row i of the
table, given the utterances up to turn t. We as-
sume all probabilities are conditioned on user in-
puts U t1 and drop it from the notation below. From
our assumption of independence of slot values,
we can write ptT (i) ∝

∏M
j=1 Pr(Gj = i), where

Pr(Gj = i) denotes the posterior probability of
user goal for slot j pointing to Ti,j . Marginalizing
this over Φj gives:

Pr(Gj = i) =

1∑

φ=0

Pr(Gj = i,Φj = φ) (1)

= qtj Pr(Gj = i|Φj = 1)+
(1− qtj) Pr(Gj = i|Φj = 0).

For Φj = 0, the user does not know the value of
the slot, and from the prior:

Pr(Gj = i|Φj = 0) =
1

N
, 1 ≤ i ≤ N (2)

For Φj = 1, the user knows the value of slot j, but
this may be missing from T , and we again have
two cases:

Pr(Gj = i|Φj = 1) =
{

1
N
, i ∈Mj

ptj(v)

Nj(v)

(
1− |Mj |

N

)
, i 6∈Mj

(3)

Here, Nj(v) is the count of value v in slot j. De-
tailed derivation for (3) is provided in Appendix A.
Combining (1), (2), and (3) gives us the procedure
for computing the posterior over KB entities.

4 Towards an End-to-End-KB-InfoBot

We claim that the Soft-KB lookup method has two
benefits over the Hard-KB method – (1) it helps
the agent discover better dialogue policies by pro-
viding it more information from the language un-
derstanding unit, (2) it allows end-to-end training
of both dialogue policy and language understand-
ing in an online setting. In this section we describe
several agents to test these claims.

486



Belief Trackers

Policy Network Beliefs Summary

Soft-KB 
Lookup

KB-InfoBot

User

User 
Utterance

System 
Action

Figure 2: High-level overview of the end-to-end
KB-InfoBot. Components with trainable parame-
ters are highlighted in gray.

4.1 Overview

Figure 2 shows an overview of the components of
the KB-InfoBot. At each turn, the agent receives a
natural language utterance ut as input, and selects
an action at as output. The action space, denoted
byA, consists ofM+1 actions — request(slot=i)
for 1 ≤ i ≤ M will ask the user for the value of
slot i, and inform(I) will inform the user with an
ordered list of results I from the KB. The dialogue
ends once the agent chooses inform.

We adopt a modular approach, typical to goal-
oriented dialogue systems (Wen et al., 2016b),
consisting of: a belief tracker module for iden-
tifying user intents, extracting associated slots,
and tracking the dialogue state (Yao et al., 2014;
Hakkani-Tür et al., 2016; Chen et al., 2016b; Hen-
derson et al., 2014; Henderson, 2015); an inter-
face with the database to query for relevant results
(Soft-KB lookup); a summary module to summa-
rize the state into a vector; a dialogue policy which
selects the next system action based on current
state (Young et al., 2013). We assume the agent
only responds with dialogue acts. A template-
based Natural Language Generator (NLG) can
be easily constructed for converting dialogue acts
into natural language.

4.2 Belief Trackers

The InfoBot consists of M belief trackers, one for
each slot, which get the user input xt and produce
two outputs, ptj and q

t
j , which we shall collectively

call the belief state: ptj is a multinomial distribu-
tion over the slot values v, and qtj is a scalar prob-
ability of the user knowing the value of slot j. We
describe two versions of the belief tracker.

Hand-Crafted Tracker: We first identify men-
tions of slot-names (such as “actor”) or slot-values
(such as “Bill Murray”) from the user input ut, us-
ing token-level keyword search. Let {w ∈ x} de-

note the set of tokens in a string x3, then for each
slot in 1 ≤ j ≤ M and each value v ∈ V j , we
compute its matching score as follows:

stj [v] =
|{w ∈ ut} ∩ {w ∈ v}|

|{w ∈ v}| (4)

A similar score btj is computed for the slot-names.
A one-hot vector reqt ∈ {0, 1}M denotes the pre-
viously requested slot from the agent, if any. qtj is
set to 0 if reqt[j] is 1 but stj [v] = 0 ∀v ∈ V j , i.e.
the agent requested for a slot but did not receive a
valid value in return, else it is set to 1.

Starting from an prior distribution p0j (based on
the counts of the values in the KB), ptj [v] is up-
dated as:

ptj [v] ∝ pt−1j [v] + C
(
stj [v] + b

t
j + 1(req

t[j] = 1)
)

(5)

Here C is a tuning parameter, and the normaliza-
tion is given by setting the sum over v to 1.

Neural Belief Tracker: For the neural tracker
the user input ut is converted to a vector repre-
sentation xt, using a bag of n-grams (with n = 2)
representation. Each element of xt is an integer
indicating the count of a particular n-gram in ut.
We let V n denote the number of unique n-grams,
hence xt ∈ NV n0 .

Recurrent neural networks have been used for
belief tracking (Henderson et al., 2014; Wen et al.,
2016b) since the output distribution at turn t de-
pends on all user inputs till that turn. We use a
Gated Recurrent Unit (GRU) (Cho et al., 2014) for
each tracker, which, starting from h0j = 0 com-
putes htj = GRU(x

1, . . . , xt) (see Appendix B for
details). htj ∈ Rd can be interpreted as a summary
of what the user has said about slot j till turn t.
The belief states are computed from this vector as
follows:

ptj = softmax(W
p
j h

t
j + b

p
j ) (6)

qtj = σ(W
Φ
j h

t
j + b

Φ
j ) (7)

Here W pj ∈ RV
j×d, bpj ∈ RV

j
, WΦj ∈ Rd and

bΦj ∈ R, are trainable parameters.

4.3 Soft-KB Lookup + Summary
This module uses the Soft-KB lookup described
in section 3.3 to compute the posterior ptT ∈ RN
over the EC-KB from the belief states (ptj , q

t
j).

3We use the NLTK tokenizer available at http://www.
nltk.org/api/nltk.tokenize.html

487



Collectively, outputs of the belief trackers and the
soft-KB lookup can be viewed as the current dia-
logue state internal to the KB-InfoBot. Let st =
[pt1, p

t
2, ..., p

t
M , q

t
1, q

t
2, ..., q

t
M , p

t
T ] be the vector of

size
∑

j V
j+M+N denoting this state. It is pos-

sible for the agent to directly use this state vector
to select its next action at. However, the large size
of the state vector would lead to a large number of
parameters in the policy network. To improve effi-
ciency we extract summary statistics from the be-
lief states, similar to (Williams and Young, 2005).

Each slot is summarized into an entropy statistic
over a distribution wtj computed from elements of
the KB posterior ptT as follows:

wtj(v) ∝
∑

i:Ti,j=v
ptT (i) + p

0
j (v)

∑

i:Ti,j=Ψ
ptT (i) .

(8)
Here, p0j is a prior distribution over the values of
slot j, estimated using counts of each value in the
KB. The probability mass of v in this distribu-
tion is the agent’s confidence that the user goal has
value v in slot j. This two terms in (8) correspond
to rows in KB which have value v, and rows whose
value is unknown (weighted by the prior probabil-
ity that an unknown might be v). Then the sum-
mary statistic for slot j is the entropy H(wtj). The
KB posterior ptT is also summarized into an en-
tropy statistic H(ptT ).

The scalar probabilities qtj are passed as is to
the dialogue policy, and the final summary vector
is s̃t = [H(p̃t1), ...,H(p̃

t
M ), q

t
1, ..., q

t
M , H(p

t
T )].

Note that this vector has size 2M + 1.

4.4 Dialogue Policy
The dialogue policy’s job is to select the next ac-
tion based on the current summary state s̃t and the
dialogue history. We present a hand-crafted base-
line and a neural policy network.

Hand-Crafted Policy: The rule based policy is
adapted from (Wu et al., 2015). It asks for the
slot ĵ = arg minH(p̃tj) with the minimum en-
tropy, except if – (i) the KB posterior entropy
H(ptT ) < αR, (ii) H(p̃

t
j) < min(αT , βH(p̃

0
j ),

(iii) slot j has already been requestedQ times. αR,
αT , β,Q are tuned to maximize reward against the
simulator.

Neural Policy Network: For the neural ap-
proach, similar to (Williams and Zweig, 2016;
Zhao and Eskenazi, 2016), we use an RNN to al-
low the network to maintain an internal state of

dialogue history. Specifically, we use a GRU unit
followed by a fully-connected layer and softmax
nonlinearity to model the policy π over actions in
A (W π ∈ R|A|×d, bπ ∈ R|A|):

htπ = GRU(s̃
1, ..., s̃t) (9)

π = softmax(W πhtπ + b
π) . (10)

During training, the agent samples its actions
from the policy to encourage exploration. If this
action is inform(), it must also provide an ordered
set of entities indexed by I = (i1, i2, . . . , iR) in
the KB to the user. This is done by sampling R
items from the KB-posterior ptT . This mimics a
search engine type setting, where R may be the
number of results on the first page.

5 Training

Parameters of the neural components (denoted by
θ) are trained using the REINFORCE algorithm
(Williams, 1992). We assume that the learner has
access to a reward signal rt throughout the course
of the dialogue, details of which are in the next
section. We can write the expected discounted
return of the agent under policy π as J(θ) =
Eπ

[∑H
t=0 γ

trt

]
(γ is the discounting factor). We

also use a baseline reward signal b, which is the
average of all rewards in a batch, to reduce the
variance in the updates (Greensmith et al., 2004).
When only training the dialogue policy π using
this signal, updates are given by (details in Ap-
pendix C):

∇θJ(θ) = Eπ
[ H∑

k=0

∇θ log πθ(ak)
H∑

t=0

γt(rt−b)
]
,

(11)
For end-to-end training we need to update both

the dialogue policy and the belief trackers using
the reinforcement signal, and we can view the re-
trieval as another policy µθ (see Appendix C). The
updates are given by:

∇θJ(θ) =Ea∼π,I∼µ
[(
∇θ logµθ(I)+

H∑

h=0

∇θ log πθ(ah)
) H∑

k=0

γk(rk − b)
]
,

(12)

In the case of end-to-end learning, we found that
for a moderately sized KB, the agent almost al-
ways fails if starting from random initialization.

488



In this case, credit assignment is difficult for the
agent, since it does not know whether the failure
is due to an incorrect sequence of actions or in-
correct set of results from the KB. Hence, at the
beginning of training we have an Imitation Learn-
ing (IL) phase where the belief trackers and pol-
icy network are trained to mimic the hand-crafted
agents. Assume that p̂tj and q̂

t
j are the belief states

from a rule-based agent, and ât its action at turn t.
Then the loss function for imitation learning is:

L(θ) = E
[
D(p̂tj ||ptj(θ))+H(q̂tj , qtj(θ))−log πθ(ât)

]

D(p||q) and H(p, q) denote the KL divergence
and cross-entropy between p and q respectively.

The expectations are estimated using a mini-
batch of dialogues of size B. For RL we use
RMSProp (Hinton et al., 2012) and for IL we use
vanilla SGD updates to train the parameters θ.

6 Experiments and Results

Previous work in KB-based QA has focused on
single-turn interactions and is not directly compa-
rable to the present study. Instead we compare dif-
ferent versions of the KB-InfoBot described above
to test our claims.

6.1 KB-InfoBot versions
We have described two belief trackers – (A) Hand-
Crafted and (B) Neural, and two dialogue policies
– (C) Hand-Crafted and (D) Neural.

Rule agents use the hand-crafted belief track-
ers and hand-crafted policy (A+C). RL agents use
the hand-crafted belief trackers and the neural pol-
icy (A+D). We compare three variants of both sets
of agents, which differ only in the inputs to the
dialogue policy. The No-KB version only takes
entropy H(p̂tj) of each of the slot distributions.
The Hard-KB version performs a hard-KB lookup
and selects the next action based on the entropy of
the slots over retrieved results. This is the same
approach as in Wen et al. (2016b), except that
we take entropy instead of summing probabilities.
The Soft-KB version takes summary statistics of
the slots and KB posterior described in Section 4.
At the end of the dialogue, all versions inform the
user with the top results from the KB posterior ptT ,
hence the difference only lies in the policy for ac-
tion selection. Lastly, the E2E agent uses the neu-
ral belief tracker and the neural policy (B+D), with
a Soft-KB lookup. For the RL agents, we also ap-
pend q̂tj and a one-hot encoding of the previous

KB-split N M maxj |V j | |Mj |
Small 277 6 17 20%

Medium 428 6 68 20%
Large 857 6 101 20%

X-Large 3523 6 251 20%

Table 1: Movies-KB statistics for four splits. Re-
fer to Section 3.2 for description of columns.

agent action to the policy network input. Hyperpa-
rameter details for the agents are provided in Ap-
pendix D.

6.2 User Simulator
Training reinforcement learners is challenging be-
cause they need an environment to operate in. In
the dialogue community it is common to use sim-
ulated users for this purpose (Schatzmann et al.,
2007a,b; Cuayáhuitl et al., 2005; Asri et al., 2016).
In this work we adapt the publicly-available user
simulator presented in Li et al. (2016b) to fol-
low a simple agenda while interacting with the
KB-InfoBot, as well as produce natural language
utterances . Details about the simulator are in-
cluded in Appendix E. During training, the sim-
ulated user also provides a reward signal at the
end of each dialogue. The dialogue is a success
if the user target is in top R = 5 results re-
turned by the agent; and the reward is computed
as max(0, 2(1 − (r − 1)/R)), where r is the ac-
tual rank of the target. For a failed dialogue the
agent receives a reward of −1, and at each turn it
receives a reward of −0.1 to encourage short ses-
sions4. The maximum length of a dialogue is 10
turns beyond which it is deemed a failure.

6.3 Movies-KB
We use a movie-centric KB constructed using the
IMDBPy5 package. We constructed four differ-
ent splits of the dataset, with increasing number of
entities, whose statistics are given in Table 1. The
original KB was modified to reduce the number
of actors and directors in order to make the task
more challenging6. We randomly remove 20% of
the values from the agent’s copy of the KB to sim-
ulate a scenario where the KB may be incomplete.
The user, however, may still know these values.

4A turn consists of one user action and one agent action.
5http://imdbpy.sourceforge.net/
6We restricted the vocabulary to the first few unique val-

ues of these slots and replaced all other values with a random
value from this set.

489



Agent Small KB Medium KB Large KB X-Large KBT S R T S R T S R T S R

No KB Rule 5.04 .64 .26±.02 5.05 .77 .74±.02 4.93 .78 .82±.02 4.84 .66 .43±.02RL 2.65 .56 .24±.02 3.32 .76 .87±.02 3.71 .79 .94±.02 3.64 .64 .50±.02
Hard KB Rule 5.04 .64 .25±.02 3.66 .73 .75±.02 4.27 .75 .78±.02 4.84 .65 .42±.02RL 3.36 .62 .35±.02 3.07 .75 .86±.02 3.53 .79 .98±.02 2.88 .62 .53±.02

Soft KB
Rule 2.12 .57 .32±.02 3.94 .76 .83±.02 3.74 .78 .93±.02 4.51 .66 .51±.02
RL 2.93 .63 .43±.02 3.37 .80 .98±.02 3.79 .83 1.05±.02 3.65 .68 .62±.02
E2E 3.13 .66 .48±.02 3.27 .83 1.10±.02 3.51 .83 1.10±.02 3.98 .65 .50±.02

Max 3.44 1.0 1.64 2.96 1.0 1.78 3.26 1.0 1.73 3.97 1.0 1.37

Table 2: Performance comparison. Average (±std error) for 5000 runs after choosing the best model
during training. T: Average number of turns. S: Success rate. R: Average reward.

6.4 Simulated User Evaluation

We compare each of the discussed versions along
three metrics: the average rewards obtained (R),
success rate (S) (where success is defined as pro-
viding the user target among top R results), and
the average number of turns per dialogue (T). For
the RL and E2E agents, during training we fix the
model every 100 updates and run 2000 simulations
with greedy action selection to evaluate its perfor-
mance. Then after training we select the model
with the highest average reward and run a further
5000 simulations and report the performance in
Table 2. For reference we also show the perfor-
mance of an agent which receives perfect informa-
tion about the user target without any errors, and
selects actions based on the entropy of the slots
(Max). This can be considered as an upper bound
on the performance of any agent (Wu et al., 2015).

In each case the Soft-KB versions achieve the
highest average reward, which is the metric all
agents optimize. In general, the trade-off between
minimizing average turns and maximizing success
rate can be controlled by changing the reward sig-
nal. Note that, except the E2E version, all versions
share the same belief trackers, but by re-asking
values of some slots they can have different pos-
teriors ptT to inform the results. This shows that
having full information about the current state of
beliefs over the KB helps the Soft-KB agent dis-
cover better policies. Further, reinforcement learn-
ing helps discover better policies than the hand-
crafted rule-based agents, and we see a higher re-
ward for RL agents compared to Rule ones. This is
due to the noisy natural language inputs; with per-
fect information the rule-based strategy is optimal.
Interestingly, the RL-Hard agent has the minimum
number of turns in 2 out of the 4 settings, at the
cost of a lower success rate and average reward.
This agent does not receive any information about
the uncertainty in semantic parsing, and it tends to

RL
­Ha

rd

Ru
le­S

oft

RL
­So

ft

E2
E­S

oft
0.4

0.5

0.6

0.7

0.8

0.9

1.0

S
uc

ce
ss

 R
at

e

p=0.01

ns

p=0.03

109

105 121

103

RL
­Ha

rd

Ru
le­S

oft

RL
­So

ft

E2
E­S

oft
1

2

3

4

5

6

7

8

9

10

# 
T

ur
ns

Figure 3: Performance of KB-InfoBot versions
when tested against real users. Left: Success rate,
with the number of test dialogues indicated on
each bar, and the p-values from a two-sided per-
mutation test. Right: Distribution of the number
of turns in each dialogue (differences in mean are
significant with p < 0.01).

inform as soon as the number of retrieved results
becomes small, even if they are incorrect.

Among the Soft-KB agents, we see that
E2E>RL>Rule, except for the X-Large KB. For
E2E, the action space grows exponentially with
the size of the KB, and hence credit assignment
gets more difficult. Future work should focus on
improving the E2E agent in this setting. The dif-
ficulty of a KB-split depends on number of enti-
ties it has, as well as the number of unique values
for each slot (more unique values make the prob-
lem easier). Hence we see that both the “Small”
and “X-Large” settings lead to lower reward for
the agents, since maxj |V

j |
N is small for them.

6.5 Human Evaluation

We further evaluate the KB-InfoBot versions
trained using the simulator against real subjects,
recruited from the author’s affiliations. In each
session, in a typed interaction, the subject was first
presented with a target movie from the “Medium”
KB-split along with a subset of its associated slot-

490



Turn Dialogue Rank Dialogue Rank Dialogue Rank

1
can i get a movie directed by maiellaro

75
find a movie directed by hemecker

7
peter greene acted in a family comedy - what was it?

35
request actor request actor request actor

2
neal

2
i dont know

7
peter

28
request mpaa_rating request mpaa_rating request mpaa_rating

3
not sure about that

2
i dont know

7
i don't know that

28
request critic_rating request critic_rating request critic_rating

4
i don't remember

2
7.6

13
the critics rated it as 6.5

3
request genre request critic_rating inform

5
i think it's a crime movie

1
7.9

23
inform request critic_rating

6
7.7

41
inform

Figure 4: Sample dialogues between users and the KB-InfoBot (RL-Soft version). Each turn begins
with a user utterance followed by the agent response. Rank denotes the rank of the target movie in the
KB-posterior after each turn.

values from the KB. To simulate the scenario
where end-users may not know slot values cor-
rectly, the subjects in our evaluation were pre-
sented multiple values for the slots from which
they could choose any one while interacting with
the agent. Subjects were asked to initiate the con-
versation by specifying some of these values, and
respond to the agent’s subsequent requests, all in
natural language. We test RL-Hard and the three
Soft-KB agents in this study, and in each session
one of the agents was picked at random for test-
ing. In total, we collected 433 dialogues, around
20 per subject. Figure 3 shows a comparison of
these agents in terms of success rate and number of
turns, and Figure 4 shows some sample dialogues
from the user interactions with RL-Soft.

In comparing Hard-KB versus Soft-KB lookup
methods we see that both Rule-Soft and RL-Soft
agents achieve a higher success rate than RL-Hard,
while E2E-Soft does comparably. They do so in an
increased number of average turns, but achieve a
higher average reward as well. Between RL-Soft
and Rule-Soft agents, the success rate is similar,
however the RL agent achieves that rate in a lower
number of turns on average. RL-Soft achieves a
success rate of 74% on the human evaluation and
80% against the simulated user, indicating mini-
mal overfitting. However, all agents take a higher
number of turns against real users as compared to
the simulator, due to the noisier inputs.

The E2E gets the highest success rate against
the simulator, however, when tested against real
users it performs poorly with a lower success
rate and a higher number of turns. Since it has
more trainable components, this agent is also most
prone to overfitting. In particular, the vocabulary
of the simulator it is trained against is quite lim-
ited (V n = 3078), and hence when real users

1.0 1.5 2.0
NLG Temperature

0.2

0.4

0.6

0.8

1.0

1.2

A
ve

ra
ge

 R
ew

ar
d

RL­Hard
RL­Soft
End2End

Figure 5: Average rewards against simulator as
temperature of softmax in NLG output is in-
creased. Higher temperature leads to more noise
in output. Average over 5000 simulations after se-
lecting the best model during training.

provided inputs outside this vocabulary, it per-
formed poorly. In the future we plan to fix this
issue by employing a better architecture for the
language understanding and belief tracker com-
ponents Hakkani-Tür et al. (2016); Liu and Lane
(2016); Chen et al. (2016b,a), as well as by pre-
training on separate data.

While its generalization performance is poor,
the E2E system also exhibits the strongest learn-
ing capability. In Figure 5, we compare how dif-
ferent agents perform against the simulator as the
temperature of the output softmax in its NLG is in-
creased. A higher temperature means a more uni-
form output distribution, which leads to generic
simulator responses irrelevant to the agent ques-
tions. This is a simple way of introducing noise
in the utterances. The performance of all agents
drops as the temperature is increased, but less
so for the E2E agent, which can adapt its belief
tracker to the inputs it receives. Such adaptation

491



is key to the personalization of dialogue agents,
which motivates us to introduce the E2E agent.

7 Conclusions and Discussion

This work is aimed at facilitating the move to-
wards end-to-end trainable dialogue agents for in-
formation access. We propose a differentiable
probabilistic framework for querying a database
given the agent’s beliefs over its fields (or slots).
We show that such a framework allows the down-
stream reinforcement learner to discover better di-
alogue policies by providing it more information.
We also present an E2E agent for the task, which
demonstrates a strong learning capacity in simula-
tions but suffers from overfitting when tested on
real users. Given these results, we propose the
following deployment strategy that allows a dia-
logue system to be tailored to specific users via
learning from agent-user interactions. The system
could start off with an RL-Soft agent (which gives
good performance out-of-the-box). As the user in-
teracts with this agent, the collected data can be
used to train the E2E agent, which has a strong
learning capability. Gradually, as more experience
is collected, the system can switch from RL-Soft
to the personalized E2E agent. Effective imple-
mentation of this, however, requires the E2E agent
to learn quickly and this is the research direction
we plan to focus on in the future.

Acknowledgements

We would like to thank Dilek Hakkani-Tür and re-
viewers for their insightful comments on the pa-
per. We would also like to acknowledge the vol-
unteers from Carnegie Mellon University and Mi-
crosoft Research for helping us with the human
evaluation. Yun-Nung Chen is supported by the
Ministry of Science and Technology of Taiwan un-
der the contract number 105-2218-E-002-033, In-
stitute for Information Industry, and MediaTek.

References
Layla El Asri, Jing He, and Kaheer Suleman. 2016.

A sequence-to-sequence model for user simula-
tion in spoken dialogue systems. arXiv preprint
arXiv:1607.00070 .

Antoine Bordes and Jason Weston. 2016. Learn-
ing end-to-end goal-oriented dialog. arXiv preprint
arXiv:1605.07683 .

Yun-Nung Chen, Dilek Hakanni-Tür, Gokhan Tur, Asli
Celikyilmaz, Jianfeng Guo, and Li Deng. 2016a.

Syntax or semantics? knowledge-guided joint se-
mantic frame parsing.

Yun-Nung Chen, Dilek Hakkani-Tür, Gokhan Tur,
Jianfeng Gao, and Li Deng. 2016b. End-to-end
memory networks with knowledge carryover for
multi-turn spoken language understanding. In Pro-
ceedings of The 17th Annual Meeting of the Interna-
tional Speech Communication Association.

Kyunghyun Cho, Bart Van Merriënboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using rnn encoder-decoder
for statistical machine translation. EMNLP .

Heriberto Cuayáhuitl, Steve Renals, Oliver Lemon, and
Hiroshi Shimodaira. 2005. Human-computer dia-
logue simulation using hidden markov models. In
Automatic Speech Recognition and Understanding,
2005 IEEE Workshop on. IEEE, pages 290–295.

M Gašić, Catherine Breslin, Matthew Henderson,
Dongho Kim, Martin Szummer, Blaise Thomson,
Pirros Tsiakoulis, and Steve Young. 2013. On-
line policy optimisation of bayesian spoken dialogue
systems via human interaction. In 2013 IEEE Inter-
national Conference on Acoustics, Speech and Sig-
nal Processing. IEEE, pages 8367–8371.

Peter W Glynn. 1990. Likelihood ratio gradient esti-
mation for stochastic systems. Communications of
the ACM 33(10):75–84.

Evan Greensmith, Peter L Bartlett, and Jonathan Bax-
ter. 2004. Variance reduction techniques for gradi-
ent estimates in reinforcement learning. Journal of
Machine Learning Research 5(Nov):1471–1530.

Dilek Hakkani-Tür, Gokhan Tur, Asli Celikyilmaz,
Yun-Nung Chen, Jianfeng Gao, Li Deng, and Ye-
Yi Wang. 2016. Multi-domain joint semantic frame
parsing using bi-directional RNN-LSTM. In Pro-
ceedings of The 17th Annual Meeting of the Interna-
tional Speech Communication Association.

Matthew Henderson. 2015. Machine learning for dia-
log state tracking: A review. Machine Learning in
Spoken Language Processing Workshop .

Matthew Henderson, Blaise Thomson, and Steve
Young. 2014. Word-based dialog state tracking with
recurrent neural networks. In Proceedings of the
15th Annual Meeting of the Special Interest Group
on Discourse and Dialogue (SIGDIAL). pages 292–
299.

Geoffrey Hinton, N Srivastava, and Kevin Swersky.
2012. Lecture 6a overview of mini–batch gradi-
ent descent. Coursera Lecture slides https://class.
coursera. org/neuralnets-2012-001/lecture,[Online .

Jiwei Li, Will Monroe, Alan Ritter, Michel Galley,
Jianfeng Gao, and Dan Jurafsky. 2016a. Deep
reinforcement learning for dialogue generation.
EMNLP .

492



Xiujun Li, Zachary C Lipton, Bhuwan Dhingra, Lihong
Li, Jianfeng Gao, and Yun-Nung Chen. 2016b. A
user simulator for task-completion dialogues. arXiv
preprint arXiv:1612.05688 .

Xuijun Li, Yun-Nung Chen, Lihong Li, and Jianfeng
Gao. 2017. End-to-end task-completion neural dia-
logue systems. arXiv preprint arXiv:1703.01008 .

Bing Liu and Ian Lane. 2016. Attention-based recur-
rent neural network models for joint intent detection
and slot filling. Interspeech 2016 pages 685–689.

Sebastian Möller, Roman Englert, Klaus-Peter Engel-
brecht, Verena Vanessa Hafner, Anthony Jameson,
Antti Oulasvirta, Alexander Raake, and Norbert Re-
ithinger. 2006. Memo: towards automatic usability
evaluation of spoken dialogue services by user error
simulations. In INTERSPEECH.

Jost Schatzmann, Blaise Thomson, Karl Weilhammer,
Hui Ye, and Steve Young. 2007a. Agenda-based
user simulation for bootstrapping a pomdp dialogue
system. In Human Language Technologies 2007:
The Conference of the North American Chapter
of the Association for Computational Linguistics;
Companion Volume, Short Papers. Association for
Computational Linguistics, pages 149–152.

Jost Schatzmann, Blaise Thomson, and Steve Young.
2007b. Statistical user simulation with a hidden
agenda. Proc SIGDial, Antwerp 273282(9).

Konrad Scheffler and Steve Young. 2002. Automatic
learning of dialogue strategy using dialogue simu-
lation and reinforcement learning. In Proceedings
of the second international conference on Human
Language Technology Research. Morgan Kaufmann
Publishers Inc., pages 12–19.

Amanda Spink, Dietmar Wolfram, Major BJ Jansen,
and Tefko Saracevic. 2001. Searching the web: The
public and their queries. Journal of the Association
for Information Science and Technology 52(3):226–
234.

Marilyn A Walker, Diane J Litman, Candace A Kamm,
and Alicia Abella. 1997. Paradise: A framework for
evaluating spoken dialogue agents. In Proceedings
of the eighth conference on European chapter of the
Association for Computational Linguistics. Associa-
tion for Computational Linguistics, pages 271–280.

Tsung-Hsien Wen, Milica Gašić, Nikola Mrkšić,
Lina M. Rojas-Barahona, Pei-Hao Su, Stefan Ultes,
David Vandyke, and Steve Young. 2016a. Condi-
tional generation and snapshot learning in neural di-
alogue systems. EMNLP .

Tsung-Hsien Wen, Milica Gašić, Nikola Mrkšić,
Lina M. Rojas-Barahona, Pei-Hao Su, Stefan Ultes,
David Vandyke, and Steve Young. 2016b. A
network-based end-to-end trainable task-oriented di-
alogue system. arXiv preprint arXiv:1604.04562 .

Tsung-Hsien Wen, Milica Gašić, Nikola Mrkšić, Pei-
Hao Su, David Vandyke, and Steve Young. 2015.
Semantically conditioned lstm-based natural lan-
guage generation for spoken dialogue systems.
EMNLP .

Jason D Williams and Steve Young. 2005. Scaling
up POMDPs for dialog management: The “Sum-
mary POMDP” method. In IEEE Workshop on
Automatic Speech Recognition and Understanding,
2005.. IEEE, pages 177–182.

Jason D Williams and Geoffrey Zweig. 2016. End-
to-end lstm-based dialog control optimized with su-
pervised and reinforcement learning. arXiv preprint
arXiv:1606.01269 .

Ronald J Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine learning 8(3-4):229–256.

Ji Wu, Miao Li, and Chin-Hui Lee. 2015. A proba-
bilistic framework for representing dialog systems
and entropy-based dialog management through dy-
namic stochastic state evolution. IEEE/ACM Trans-
actions on Audio, Speech, and Language Processing
23(11):2026–2035.

Kaisheng Yao, Baolin Peng, Yu Zhang, Dong Yu, Ge-
offrey Zweig, and Yangyang Shi. 2014. Spoken lan-
guage understanding using long short-term memory
neural networks. In Spoken Language Technology
Workshop (SLT), 2014 IEEE. IEEE, pages 189–194.

Jun Yin, Xin Jiang, Zhengdong Lu, Lifeng Shang,
Hang Li, and Xiaoming Li. 2016a. Neural gener-
ative question answering. International Joint Con-
ference on Artificial Intelligence .

Pengcheng Yin, Zhengdong Lu, Hang Li, and Ben Kao.
2016b. Neural enquirer: Learning to query tables.
International Joint Conference on Artificial Intelli-
gence .

Steve Young, Milica Gašić, Blaise Thomson, and Ja-
son D Williams. 2013. POMDP-based statistical
spoken dialog systems: A review. Proceedings of
the IEEE 101(5):1160–1179.

Wojciech Zaremba and Ilya Sutskever. 2015. Rein-
forcement learning neural Turing machines-revised.
arXiv preprint arXiv:1505.00521 .

Tiancheng Zhao and Maxine Eskenazi. 2016. To-
wards end-to-end learning for dialog state tracking
and management using deep reinforcement learning.
arXiv preprint arXiv:1606.02560 .

Stefan Zwicklbauer, Christin Seifert, and Michael
Granitzer. 2013. Do we need entity-centric knowl-
edge bases for entity disambiguation? In Pro-
ceedings of the 13th International Conference on
Knowledge Management and Knowledge Technolo-
gies. ACM, page 4.

493



A Posterior Derivation

Here, we present a derivation for equation 3, i.e.,
the posterior over the KB slot when the user knows
the value of that slot. For brevity, we drop Φj = 0
from the condition in all probabilities below. For
the case when i ∈Mj , we can write:

Pr(Gj = i)

= Pr(Gj ∈Mj) Pr(Gj = i|Gj ∈Mj)

=
|Mj |
N

1

|Mj |
=

1

N
, (13)

where we assume all missing values to be equally
likely, and estimate the prior probability of the
goal being missing from the count of missing val-
ues in that slot. For the case when i = v 6∈Mj :

Pr(Gj = i)

= Pr(Gj 6∈Mj) Pr(Gj = i|Gj 6∈Mj)

=

(
1− |Mj |

N

)
×
ptj(v)

Nj(v)
, (14)

where the second term comes from taking the
probability mass associated with v in the belief
tracker and dividing it equally among all rows with
value v.

We can also verify that the above distribution is
valid: i.e., it sums to 1:

∑

i

Pr(Gj = i)

=
∑

i∈Mj
Pr(Gj = i) +

∑

i 6∈Mj
Pr(Gj = i)

=
∑

i∈Mj

1

N
+
∑

i 6∈Mj

(
1− |Mj |

N

)
ptj(v)

#jv

=
|Mj |
N

+

(
1− |Mj |

N

) ∑

i 6∈Mj

ptj(v)

#jv

=
|Mj |
N

+

(
1− |Mj |

N

)∑

i∈V j
#jv

ptj(v)

#jv

=
|Mj |
N

+

(
1− |Mj |

N

)
× 1

= 1 .

B Gated Recurrent Units

A Gated Recurrent Unit (GRU) (Cho et al., 2014)
is a recurrent neural network which operates on an
input sequence x1, . . . , xt. Starting from an initial

state h0 (usually set to 0 it iteratively computes the
final output ht as follows:

rt = σ(Wrxt + Urht−1 + br)

zt = σ(Wzxt + Uzht−1 + bz)

h̃t = tanh(Whxt + Uh(rt � ht−1) + bh)
ht = (1− zt)� ht−1 + zt � h̃t . (15)

Here σ denotes the sigmoid nonlinearity, and� an
element-wise product.

C REINFORCE updates

We assume that the learner has access to a reward
signal rt throughout the course of the dialogue, de-
tails of which are in the next section. We can write
the expected discounted return of the agent under
policy π as follows:

J(θ) = E

[
H∑

t=0

γtrt

]
(16)

Here, the expectation is over all possible trajecto-
ries τ of the dialogue, θ denotes the trainable pa-
rameters of the learner, H is the maximum length
of an episode, and γ is the discounting factor. We
can use the likelihood ratio trick (Glynn, 1990) to
write the gradient of the objective as follows:

∇θJ(θ) = E
[
∇θ log pθ(τ)

H∑

t=0

γtrt

]
, (17)

where pθ(τ) is the probability of observing a par-
ticular trajectory under the current policy. With a
Markovian assumption, we can write

pθ(τ) = p(s0)
H∏

k=0

p(sk+1|sk, ak)πθ(ak|sk),

(18)
where θ denotes dependence on the neural net-
work parameters. From 17,18 we obtain

∇θJ(θ) = Ea∼π
[ H∑

k=0

∇θ log πθ(ak)
H∑

t=0

γtrt

]
,

(19)
If we need to train both the policy network and

the belief trackers using the reinforcement signal,
we can view the KB posterior ptT as another pol-
icy. During training then, to encourage explo-
ration, when the agent selects the inform action we

494



sampleR results from the following distribution to
return to the user:

µ(I) = ptT (i1)×
ptT (i2)

1− ptT (i1)
× · · · . (20)

This formulation also leads to a modified ver-
sion of the episodic REINFORCE update rule
(Williams, 1992). Specifically, eq. 18 now be-
comes,

pθ(τ) =

[
p(s0)

H∏

k=0

p(sk+1|sk, ak)πθ(ak|sk)
]
µθ(I),

(21)
Notice the last term µθ above which is the poste-
rior of a set of results from the KB. From 17,21 we
obtain

∇θJ(θ) =Ea∼π,I∼µ
[(
∇θ logµθ(I)+

H∑

h=0

∇θ log πθ(ah)
) H∑

k=0

γkrk

]
,

(22)

D Hyperparameters

We use GRU hidden state size of d = 50 for the
RL agents and d = 100 for the E2E, a learning
rate of 0.05 for the imitation learning phase and
0.005 for the reinforcement learning phase, and
minibatch size 128. For the rule agents, hyperpa-
rameters were tuned to maximize the average re-
ward of each agent in simulations. For the E2E
agent, imitation learning was performed for 500
updates, after which the agent switched to rein-
forcement learning. The input vocabulary is con-
structed from the NLG vocabulary and bigrams in
the KB, and its size is 3078.

E User Simulator

At the beginning of each dialogue, the simulated
user randomly samples a target entity from the EC-
KB and a random combination of informable slots
for which it knows the value of the target. The re-
maining slot-values are unknown to the user. The
user initiates the dialogue by providing a subset
of its informable slots to the agent and requesting
for an entity which matches them. In subsequent
turns, if the agent requests for the value of a slot,
the user complies by providing it or informs the
agent that it does not know that value. If the agent
informs results from the KB, the simulator checks
whether the target is among them and provides the
reward.

We convert dialogue acts from the user into nat-
ural language utterances using a separately trained
natural language generator (NLG). The NLG is
trained in a sequence-to-sequence fashion, us-
ing conversations between humans collected by
crowd-sourcing. It takes the dialogue actions
(DAs) as input, and generates template-like sen-
tences with slot placeholders via an LSTM de-
coder. Then, a post-processing scan is performed
to replace the slot placeholders with their actual
values, which is similar to the decoder module in
(Wen et al., 2015, 2016a). In the LSTM decoder,
we apply beam search, which iteratively consid-
ers the top k best sentences up to time step t when
generating the token of the time step t+ 1. For the
sake of the trade-off between the speed and perfor-
mance, we use the beam size of 3 in the following
experiments.

There are several sources of error in user utter-
ances. Any value provided by the user may be cor-
rupted by noise, or substituted completely with an
incorrect value of the same type (e.g., “Bill Mur-
ray” might become just “Bill” or “Tom Cruise”).
The NLG described above is inherently stochas-
tic, and may sometimes generate utterances irrel-
evant to the agent request. By increasing the tem-
perature of the output softmax in the NLG we can
increase the noise in user utterances.

495


	Towards End-to-End Reinforcement Learning of Dialogue Agents for Information Access

