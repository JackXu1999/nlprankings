



















































Language Modeling for Code-Switching: Evaluation, Integration of Monolingual Data, and Discriminative Training


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 4175–4185,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

4175

Language Modeling for Code-Switching:
Evaluation, Integration of Monolingual Data, and Discriminative Training

Hila Gonen1 and Yoav Goldberg1,2
1Department of Computer Science, Bar-Ilan University

2Allen Institute for Artificial Intelligence
{hilagnn,yoav.goldberg}@gmail.com

Abstract

We focus on the problem of language model-
ing for code-switched language, in the con-
text of automatic speech recognition (ASR).
Language modeling for code-switched lan-
guage is challenging for (at least) three rea-
sons: (1) lack of available large-scale code-
switched data for training; (2) lack of a repli-
cable evaluation setup that is ASR directed yet
isolates language modeling performance from
the other intricacies of the ASR system; and
(3) the reliance on generative modeling. We
tackle these three issues: we propose an ASR-
motivated evaluation setup which is decoupled
from an ASR system and the choice of vo-
cabulary, and provide an evaluation dataset for
English-Spanish code-switching. This setup
lends itself to a discriminative training ap-
proach, which we demonstrate to work better
than generative language modeling. Finally,
we explore a variety of training protocols and
verify the effectiveness of training with large
amounts of monolingual data followed by fine-
tuning with small amounts of code-switched
data, for both the generative and discrimina-
tive cases.

1 Introduction

This work deals with neural language modeling
of code-switched language, motivated by an ap-
plication to speech recognition. Code-switching
(CS) is a linguistic phenomenon defined as “the
alternation of two languages within a single dis-
course, sentence or constituent.” (Poplack, 1980).
Since CS is widely used in spoken platforms, deal-
ing with code-switched language becomes an im-
portant challenge for automatic speech recognition
(ASR) systems. To get a feeling how an ASR
system trained on monolingual data performs on
code-switched language, we fed the IBM English

and Spanish systems1 with audio files of code-
switched conversations from the Bangor Miami
Corpus (see Section 7). The results (examples
available in Table 1) exhibit two failure modes:
(1) Words and sentences in the opposite language
are not recognized correctly; and (2) Code-switch
points also hurt recognition of words from the
main language. This demonstrates the need for
designated speech recognition systems for CS. A
crucial component in such a CS ASR system is a
strong CS language model, which is used to rank
the bilingual candidates produced by the ASR sys-
tem for a given acoustic signal.

Language models are traditionally evaluated
with perplexity. However, this measure suffers
from several shortcomings, in particular strong de-
pendence on vocabulary size and lack of ability
to directly evaluate scores assigned to malformed
sentences. We address these deficiencies by pre-
senting a new evaluation scheme for LM that sim-
ulates an ASR setup. Rather than requiring the
LM to produce a probability for a gold sentence,
we instead present the LM with a set of alterna-
tive sentences, including the gold one, and require
it to rank the gold one higher. This evaluation
is more realistic since it simulates the role a lan-
guage model plays in the process of converting au-
dio into text (Section 3). We create such an eval-
uation dataset for English-Spanish CS – Spangli-
shEval (Section 4).

Additionally, LM for CS poses a unique chal-
lenge: while data for training monolingual LMs
is easy to obtain in large quantities, CS occurs
primarily in spoken language. This severely lim-
its data availability, thus, small amounts of train-
ing data are an intrinsic property of CS LM. A
natural approach to overcome this problem is to
train monolingual language models—for which

1https://www.ibm.com/watson/services/
speech-to-text/

https://www.ibm.com/watson/services/speech-to-text/
https://www.ibm.com/watson/services/speech-to-text/


4176

Original sentence (audio) English model output Spanish model output
no pero vino porque he came to check on
my machine

No but we no longer he came to check on
my machine

Cual provino de que en dicha cámara
chino

yo le invité pa Easter porque me daba pena
el pobre aquı́ solo sin familia ni nada

feeling betrayed by eastern lap and I
bought a new solo seem funny any now

y el envite paı́s tampoco nada pero por
aquı́ solo sin familia ni nada

Table 1: Examples of the output of IBM’s English and Spanish speech recognition systems on code-switched audio.

we have huge amounts of data—for each lan-
guage separately, and combine them somehow
into a code-switched LM. While this is rela-
tively straightforward to do in an n-gram language
model, it is not obvious how to perform such an
LM combination in a non-markovian, RNN-based
language model. We use a protocol for LSTM-
based CS LM training which can take advantage
of monolingual data (Baheti et al., 2017) and ver-
ify its effectiveness (Section 5).

Based on the new evaluation scheme we
present, we further propose to learn a model for
this ranking task using discriminative training.
This model, as opposed to LMs, no longer depends
on estimating next-word probabilities for the en-
tire vocabulary. Instead, during training the model
is introduced with positive and negative examples
and is encouraged to prefer the positive examples
over the negative ones. This model gives signifi-
cantly better results (Section 6).

Our contributions in this work are four-fold:
(a) We propose a new, vocabulary-size inde-
pendent evaluation scheme for LM in general,
motivated by ASR. This evaluation scheme is
ranking-based and also suits CS LM; (b) We
describe a process for automatically creating
such datasets, and provide a concrete evaluation
dataset for English-Spanish CS (SpanglishEval);
(c) We present a model for this new ranking task
that uses discriminative training and is decou-
pled of probability estimations, this model sur-
passes the standard LMs; (d) We verify the ef-
fectiveness of pretraining CS LM for this rank-
ing task with monolingual data and show signif-
icant improvement over various baselines. The
CS LM evaluation dataset and the code for
the model are available at https://github.
com/gonenhila/codeswitching-lm.

2 Background

Code-Switching Code-switching (CS) is de-
fined as the use of two languages at the same
discourse (Poplack, 1980). The mixing of
different languages in various levels has been

widely studied from social and linguistic point of
view (Auer, 1999; Muysken, 2000; Bullock and
Toribio, 2009), and started getting attention also in
the NLP community in the past few years (Solorio
and Liu, 2008; Adel et al., 2013a; Cotterell et al.,
2014).

Below is an example of code-switching between
Spanish and English (taken from the Bangor Mi-
ami corpus described in Section 7). Translation to
English follows:

• “that es su tı́o that has lived with him like I
don’t know how like ya several years...”
that his uncle who has lived with him like, I
don’t know how, like several years already...

Code-switching is becoming increasingly pop-
ular, mainly among bilingual communities. Yet,
one of the main challenges when dealing with CS
is the limited data and its unique nature: it is usu-
ally found in non standard platforms such as spo-
ken data and social media and accessing it is not
trivial (Çetinoğlu et al., 2016).

Shortcomings of Perplexity-based Evaluation
for LM The most common evaluation measure
of language models is perplexity. Given a lan-
guage model M and a test sequence of words
w1, ..., wN , the perplexity of M over the sequence
is defined as:

2−
1
N

∑N
i=1 log2 M(wi)

where M(wi) is the probability the model assigns
to wi.

A better model is expected to give higher prob-
ability to sentences in the test set, that is, lower
perplexity. However, this measure is not always
well aligned with the quality of a language model
as it should be. For example, Tran et al. (2018)
show that RNNs capture long-distance syntactic
dependencies better than attention-only LMs, de-
spite having higher (worse) perplexity. Similarly,
better perplexities often do not translate to better
word-error-rate (WER) scores in an ASR system
(Huang et al., 2018).

https://github.com/gonenhila/codeswitching-lm
https://github.com/gonenhila/codeswitching-lm


4177

This highlights a shortcoming of perplexity-
based evaluation: the method is rewarded for as-
signing high probability to gold sentences, but is
not directly penalized for assigning high probabil-
ity to highly implausible sentences. When used in
a speech recognition setup, the LM is expected to
do just that: score correct sentences above incor-
rect hypotheses.

Another shortcoming of perplexity-based eval-
uation is that it requires the compared models to
have the same support (in other words, the same
vocabulary). Simply adding words to the vocab-
ulary, even if no additional change is done to the
model, will likely result in higher perplexity for
the same dataset. It is also sketchy to compare per-
plexities of word-based LMs and character-based
LMs for the same reason.

Problem with WER-based evaluation Evalu-
ating LM models based on the final WER of an
ASR system side-steps these two issues: it eval-
uates the LM on incorrect sentences, and seam-
lessly compares LMs with different support. How-
ever, this makes the evaluation procedure highly
dependent on a particular ASR system. This is
highly undesirable, as ASR systems are hard to
set up and tune and are not standardized. This
both conflates the LM performance with perfor-
mance of other aspects of the ASR system, and
makes it hard to replicate the evaluation procedure
and fairly compare results across different publi-
cations. Indeed, as discussed in Section 10, most
previous works on CS LM use an ASR system as
part of their evaluation setup, and none of them
compares to any other work. Moreover, no stan-
dard benchmark or evaluation setup exists for CS
LM.

3 An Alternative Evaluation Method

We propose an evaluation technique for language
models which is ASR-system-independent, that
does take into account incorrect sentences and al-
lows to compare LMs with different support or
OOV handling techniques.

We seek a method that meets the following re-
quirements: (1) Prefers language models that pri-
oritize correct sentences over incorrect ones; (2)
Does not depend on the support (vocabulary) of
the language model; (3) Is independent of and not
coupled with a speech recognition system.

To meet these criteria, we propose to assemble a
dataset comprising of gold sentences, where each

gold sentence is associated with a set of alternative
sentences, and require the LM to identify the gold
sentence in each set. The alternative sentences in a
set should be related to the gold sentence. Follow-
ing the ASR motivation, we take the alternative
set to contain sentences that are phonetically re-
lated (similar-sounding) to the gold sentence. This
setup simulates the task an LM is intended to per-
form as a part of an ASR system: given several
candidates, all originating from the same acoustic
signal, the LM should choose the correct sentence
over the others.

A New Evaluation metric Given this setup, we
propose to use the accuracy metric: the percentage
of sets in which the LM (or other method) suc-
cessfully identified the gold sentence among the
alternatives.2 The natural way of using an LM for
identifying the gold sentences is assigning a prob-
ability to each sentence in the set, and choosing
the one with highest probability. Yet, the scor-
ing mechanism is independent of perplexity, and
addresses the two deficiencies of perplexity based
evaluation discussed above.

Our proposed evaluation method is similar in
concept to the NMT evaluation proposed by Sen-
nrich (2016). There, the core idea is to measure
whether a reference translation is more probable
under an NMT model than a contrastive transla-
tion which introduces a specific type of error.

4 Evaluation Dataset

We now turn to construct such an evaluation
dataset. One method of obtaining sentence-sets is
feeding acoustic waves into an ASR system and
tracking the resulting lattices. However, this re-
quires access to the audio signals, as well as a
trained system for the relevant languages. We pro-
pose instead a generation method that does not re-
quire access to an ASR system.

The dataset we create is designed for evaluating
English-Spanish CS LMs, but the creation process
can be applied to other languages and language
pairs.3

2We chose accuracy over WER as the default metric since
in our case, WER should be treated with caution: the alterna-
tives created might be “too close” to the gold sentence (e.g.
when only a small fraction of the gold sentence is sampled
and replaced) or “too far” (e.g. a Spanish alternative for an
English sentence), thus affecting the WER.

3The requirements for creating an evaluation dataset for a
language pair L1,L2 is to have access to code-switched sen-
tences where each word is tagged with a language ID (lan-



4178

Example 1:
Gold: pero i thought ella fue like very good
Alt-CS: pero i thought a llevó alike very good
Alt-EN: peru i thought a of alike very could
Alt-SP: pero azote la fue la que rico

Example 2:
Gold: vamos a ser juntos twenty four seven
Alt-CS: vamos a ser juntos when de for saben
Alt-EN: follows a santos twenty for seven
Alt-SP: vamos hacer junto sentı́ for saben

Figure 1: Examples from SpanglishEval – the English-
Spanish evaluation dataset. The first sentence in each
example is the gold sentence, followed by a generated
code-switched alternative, a generated English alterna-
tive, and a generated Spanish one. Blue (normal) marks
English, while red (italic) marks Spanish.

The process of alternative sentence creation is
as follows: (1) Convert a sequence of language-
tagged words (either CS or monolingual) into a
sequence of the matching phonemes (using pro-
nunciation dictionaries); (2) Decode the sequence
of phonemes into new sentences, which include
words from either language (possibly both); (3)
When decoding, allow minor changes in the se-
quence of phonemes to facilitate the differences
between the languages.

These steps can be easily implemented using
composition of finite-state transducers (FSTs).4

For each gold sentence (which can be either
code-switched or monolingual) we create alterna-
tives of all three types: (a) code-switched sen-
tences, (b) sentences in L1 only, (c) sentences in
L2 only.

We created such a dataset for English-Spanish
with gold sentences from the Bangor Miami Cor-
pus (Section 7). Figure 1 shows two examples
from the dataset. In each, the gold sentence is fol-
lowed by a single code-switched alternative, a sin-
gle English alternative, and a single Spanish one
(a subset of the full set).

guage ID is not mandatory, but helps in cases in which a
word is found in the vocabulary of both languages and is pro-
nounced differently), compatible pronunciation dictionaries
and unigram word probabilities for each of the languages.

4Specifically, we compose the following FSTs: (a) an FST
for converting a sentence into a sequence of phonemes, (b) an
FST that allows minor changes in the phoneme sequence, (c)
an FST for decoding a sequence of phonemes into a sentence,
the inverse of (a).

dev set test set
no. of sets 1000 1000
no. of sentences 30884 30811
no. of CS alternatives 10000 10000
no. of English alternatives 9999 9993
no. of Spanish alternatives 9885 9818
no. of CS gold sentences 250/1000 250/1000

Table 2: Statistics of the dataset.

4.1 Technical details
When creating code-switched alternatives, we
want to encourage the creation of sentences that
include both languages, and that differ from each
other. This is done with scores determined by
some heuristics, such as preferring sentences that
include more words from the language that was
less dominant in the original one and vice versa.
As part of this we also try to avoid noise from ad-
dition of short frequent words, by encouraging the
average word length to be high5. We create 1000-
best alternatives from the FST, re-score them ac-
cording to the heuristic and keep the top 10.

We discard sets in which the gold sentence has
less than three words (excluding punctuation), and
also sets with less than 5 alternatives in one of the
three types.

We randomly choose 250 sets in which the gold
sentence is code-switched, and 750 sets in which
the gold sentence is monolingual, both for the de-
velopment set and for the test set. This percentage
of CS sentences is higher than in the underlying
corpus in order to aid a meaningful comparison
between the models regarding their ability to pre-
fer gold CS sentences over alternatives. The statis-
tics of the dataset are detailed in Table 2.

Further details regarding the implementation
can be found in the Appendix.

5 Using Monolingual Data for CS LM

Data for code-switching is relatively scarce, while
monolingual data is easy to obtain. The question
then is how do we efficiently incorporate monolin-
gual data when training a CS LM?

We use an effective training protocol
(FINETUNED) for incorporating monolingual
data into the language model, similar to the best
protocol introduced in (Baheti et al., 2017). We
first pre-train a model with monolingual sentences

5The implementation of these heuristics is part of our code
that is available online.



4179

from both English and Spanish (with shared
vocabulary for both languages). This essentially
trains two monolingual models, one for English
and one for Spanish, but with full sharing of
parameters. Note that in this pre-training phase,
the model is not exposed to any code-switched
sentence.

We then use the little amount of available code-
switched data to further train the model, making
it familiar with code-switching examples that mix
the two languages. This fine-tunning procedure
enables the model to learn to correctly combine
the two languages in a single sentence.

We show in Section 8 that adding the CS data
only at the end, in the described manner, works
substantially better than several alternatives, veri-
fying the results from (Baheti et al., 2017).

6 Discriminative Training

Our new evaluation method gives rise to training
models that are designated to the ranking task. As
our main goal is to choose a single best sentence
out of a set of candidate sentences, we can fo-
cus on training models that score whole sentences
with discriminative training, rather than using the
standard probability setting of LMs. Discrimina-
tive approach unbinds us from the burden of esti-
mating probability distributions over all the words
in the vocabulary and allows us to simply create
representations of sentences and match them with
scores.

Using negative examples is not straight forward
in LM training, but is essential for speech recog-
nition, where the language model needs to distin-
guish between “good” and “bad” sentences. Our
discriminative training is based on the idea of us-
ing both positive and negative examples during
training. The training data we use is similar in na-
ture to that of our test data: sets of sentences in
which only a single one is a genuine example col-
lected from a real CS corpus, while all the others
are synthetically created.

During training, we aim to assign the gold sen-
tences with a higher score than the scores of the
others. For each sentence, we require the differ-
ence between its score and the score of the gold
sentence to be as large as its WER with respect to
the gold sentence. This way, the farther a sentence
is from the gold one, the lower its score is.

Formally, let s1 be the gold sentence, and
s2, ..., sm be the other sentences in that set.

The loss of the set is the sum of losses over all
sentences, except for the gold one:

∑m
i=2max(0,WER(s1, si)− [score(s1)− score(si)])

where score(si) is computed by the multiplication
of the representation of si and a learned vector w:

score(si) = w · repr(si)

A sentence is represented with its BiLSTM rep-
resentation – the concatenation of the final states
of forward and backward LSTMs. Formally, a
sentence s = w1, ..., wn is represented as follows:

repr(s) = LSTM(w1, ..., wn) ◦ LSTM(wn, ..., w1)

where ◦ is the concatenation operation.

Incorporating monolingual data In order to
use monolingual data in the case of discrimina-
tive training, we follow the same protocol: as a
first step, we create alternative sentences for each
monolingual sentence from the monolingual cor-
pora. We train a model using this data, and as a
next step, we fine-tune this model with the sets of
sentences that are created from the CS corpus.

7 Empirical Experiments

Models and Baselines We report results on
two models that use discriminative training: CS-
ONLY-DISCRIMINATIVE only trains on data that is
created based on the small code-switched corpus,
while FINE-TUNED-DISCRIMINATIVE first trains
on data created based on the monolingual corpora
and is then fine-tuned using the data created from
the code-switched corpus.

We compare our models to several base-
lines, all of which use standard LM train-
ing: ENGLISHONLY-LM and SPANISHONLY-LM
train on the monolingual data only. Two addi-
tional models train on a combination of the code-
switched corpus and the two monolingual cor-
pora: the first (ALL:SHUFFLED-LM) trains on all
sentences (monolingual and code-switched) pre-
sented in a random order. The second (ALL:CS-
LAST-LM) trains each epoch on the monolin-
gual datasets followed by a pass on the small
code-switched corpus. The models CS-ONLY-
LM and FINE-TUNED-LM are the equivalents of
CS-ONLY-DISCRIMINATIVE and FINE-TUNED-
DISCRIMINATIVE but with standard LM training.



4180

Code-switching corpus We use the Bangor Mi-
ami Corpus, consisting of transcripts of conversa-
tions by Spanish-speakers in Florida, all of whom
are bilingual in English.6

We split the sentences (45,621 in total) to
train/dev/test with ratio of 60/20/20 respectively,
and evaluate perplexity on the dev and test sets.

The dataset described in Section 4 is based on
sentences from the dev and test sets, and serves as
our main evaluation method.

Monolingual corpora The monolingual cor-
pora used for training the English and Spanish
monolingual models are taken from the OpenSub-
titles2018 corpus (Tiedemann, 2009),7 of subtitles
of movies and TV series.

We use 1M lines from each language, with a
split of 60/20/20 for train/dev/test, respectively.
The test set is reserved for future use. For dis-
criminative training we use 1/6 of the monolin-
gual training data (as creating the data results in
roughly 30 sentences per gold sentence).

Additional details on preprocessing and statis-
tics of the data can be found in the Appendix.

Training We implement our language models in
DyNet (Neubig et al., 2017). Our basic config-
uration is similar to that of Gal and Ghahramani
(2016) with minor changes. It has a standard ar-
chitecture of a 2-layer LSTM followed by a soft-
max layer, and the optimization is done with SGD
(see Appendix for details).

Tuning of hyper-parameters was done on the
PTB corpus, in order to be on par with state-of-
the-art models such as that of Merity et al. (2017).
We then trained the same LM on our CS corpus
with no additional tuning and got perplexity of
44.06, better than the 52.99 of Merity et al. (2017)
when using their default parameters on the CS cor-
pus.8 We thus make no further tuning of hyper-
parameters.

When changing to discriminative training, we
perform minimal necessary changes: discarding
weight decay and reducing the learning rate to 1.
The weight vector in the discriminative setting is
learned jointly with the other parameters of the
network.

6http://bangortalk.org.uk/speakers.
php?c=miami

7http://opus.nlpl.eu/
OpenSubtitles2018.php
http://www.opensubtitles.org/

8https://github.com/salesforce/
awd-lstm-lm

dev test
perp ↓ acc ↑ wer ↓ perp ↓ acc ↑ wer ↓

SPANISH-ONLY-LM 329.68 26.6 30.47 322.26 25.1 29.62
ENGLISH-ONLY-LM 320.92 29.3 32.02 314.04 30.3 32.51
ALL:CS-LAST-LM 76.64 47.8 14.56 76.97 49.2 14.13
ALL:SHUFFLED-LM 68.00 51.8 13.64 68.72 51.4 13.89
CS-ONLY-LM 43.20 60.7 12.60 43.42 57.9 12.18
CS-ONLY+VOCAB-LM 45.61 61.0 12.56 45.79 58.8 12.49
FINE-TUNED-LM 39.76 66.9 10.71 40.11 65.4 10.17
CS-ONLY-DISC – 72.0 6.35 – 70.5 6.70
FINE-TUNED-DISC – 74.2 5.85 – 75.5 5.59

Table 3: Results on the dev set and on the test set. “perp”
stands for perplexity, “acc” stands for accuracy (in percents),
and “wer” stands for word-error-rate.

As done in previous work, in order to be able
to give a reliable probability to every next-token
in the test set, we include all the tokens from the
test set in our vocabulary and we do not use the
“<unk>” token. We only train those that ap-
pear in the train set. Handling of unknown to-
kens becomes easier with discriminative training,
as scores are assigned to full sentences. However,
we leave this issue for future work.

8 Results

The results of the different models are presented in
Table 3. For each model we report both perplexity
and accuracy (except for discriminative training,
where perplexity is not valid), where each of them
is reported according to the best performing model
on that measure (on the dev set). We also report
the WER of all models, which correlates perfectly
with the accuracy measure.

8.1 Using monolingual data

As mentioned above, both in standard LM and in
discriminative training, using monolingual data in
a correct manner (FINE-TUNED-LM and FINE-
TUNED-DISCRIMINATIVE) significantly improves
over using solely the code-switching data. In stan-
dard LM, adding monolingual data results in an
improvement of 7.5 points (improving from an ac-
curacy of 57.9% to 65.4%), and in the discrim-
inative training it results in an improvement of
5 points (improving from an accuracy of 70.5%
to 75.5%). Even though both ALL:SHUFFLED-
LM and ALL:CS-LAST-LM use the same data as
the FINE-TUNED-LM model, they perform even
worse than CS-ONLY-LM that does not use the
monolingual data at all. This emphasizes that the
manner of integration of the monolingual data has
a very strong influence.

Note that the FINE-TUNED-LM model also im-

http://bangortalk.org.uk/speakers.php?c=miami
http://bangortalk.org.uk/speakers.php?c=miami
http://opus.nlpl.eu/OpenSubtitles2018.php
http://opus.nlpl.eu/OpenSubtitles2018.php
http://www.opensubtitles.org/
https://github.com/salesforce/awd-lstm-lm
https://github.com/salesforce/awd-lstm-lm


4181

25% train 50% train 75% train full train
dev test dev test dev test dev test

CS-ONLY 58.4 58.9 65.2 63.6 70.8 68.8 72.0 70.5
FINE-TUNED 68.4 67.7 71.9 70.1 72.8 73.0 74.2 75.5

Table 4: Results on the dev set and on the test set using dis-
criminative training with only subsets of the code-switched
data.

proves perplexity. As perplexity is significantly
affected by the size of the vocabulary—and to en-
sure fair comparison—we also add the additional
vocabulary from the monolingual data to CS-
ONLY-LM (CS-ONLY+VOCAB-LM). Extending
the vocabulary without training those additional
words, results in a 2.37-points loss on the per-
plexity measure, while our evaluation metric (ac-
curacy) stays essentially the same. This demon-
strates the utility of our proposed evaluation com-
pared to using perplexity, allowing it to fairly com-
pare models with different vocabulary sizes.

In order to examine the contribution of the
monolingual data, we also experimented with sub-
sets of the code-switching training data. Table 4
depicts the results when using subsets of the CS
training data with discriminative training. The
less code-switching data we use, the more the ef-
fect of using the monolingual data is significant:
we gain 8.8, 6.5, 4.2 and 5 more accuracy points
with 25%, 50%, 75% and 100% of the data, re-
spectively. In the case of 25% of the data, the
FINE-TUNED-DISCRIMINATIVE model improves
over CS-ONLY-DISCRIMINATIVE by 17 relative
percents.

8.2 Standard LMs vs. Discriminative
Training

In the standard training setting, The FINE-
TUNED-LM baseline is the strongest baseline,
outperforming all others with an accuracy of
65.4%. Similarly, when using discriminative train-
ing, the FINE-TUNED-DISCRIMINATIVE model
outperforms the CS-ONLY-DISCRIMINATIVE
model. Note that using discriminative training,
even with no additional monolingual data, leads to
better performance than that of the best language
model: the CS-ONLY-DISCRIMINATIVE model
achieves an accuracy of 70.5%, 5.1 points more
than the accuracy of the FINE-TUNED-LM
model. We gain further improvement by adding
monolingual data and get an even higher accuracy
of 75.5%, which is 10.1 points higher than the
best language model.

Limitations Our evaluation setup in the dis-
criminative training case is not ideal: the nega-
tive samples in both the train and test sets are ar-
tificially created by the same mechanism. Thus,
high performance on the test set in the discrimina-
tive case may result from “leakage” in which the
model learns to rely on idiosyncrasies and artifcats
of the data generation mechanism. As such, these
results may not transfer as is to a real-world ASR
scenario, and should be considered as an opti-
mistic estimate of the actual gains.9 Nevertheless,
we do believe that the accuracy improvements of
the discriminative setup are real, and should trans-
late to improvements also in the real-world sce-
nario.

To alleviate the concerns to some extent, we
consider the case in which the leakage is in the
induced negative words distribution.10 We re-train
the discriminative model using a BOW representa-
tion of the sentence. This results in accuracies of
52.1% and 47.4% for dev and test, respectively,
far below those of the basic model. A model
that leaks in word distribution would score much
higher in this evaluation, indicating that the im-
provement is likely not due to this form of leakage,
and that most of the improvement of the discrim-
inative training is likely to translate to a real ASR
scenario.

9 Analysis

Table 5 breaks down the results of the different
models according to two conditions: when the
gold sentence is code-switched, and when the gold
sentence is monolingual.

As expected, the FINE-TUNED-
DISCRIMINATIVE model is able to prioritize
the gold sentence better than all other models,
under both conditions. The improvement we get
is most significant when the gold sentence is CS:
in those cases we get a dramatic improvement of
27.73 accuracy points (a relative improvement of
58%). Note that for the standard LMs, the cases

9An ideal evaluation setup will use an artificial dataset
for training, and a dataset obtained from an acoustic model
of a code-switched ASR system for testing. However, such
an evaluation setup requires access to a high-quality code-
switched acoustic model, which we do not posses nor have
the means to obtain. Furthermore, it would also tie the evalu-
ation to a specific ASR system, which we aim to avoid.

10As our generation process, much like an acoustic model,
makes only local word replacements, the choice of replace-
ment words is the most salient difference from a real acoustic
model, and has the largest leakage potential.



4182

dev test
CS mono CS mono

CS-ONLY-LM 45.20 65.87 43.20 62.80
FINE-TUNED-LM 49.60 72.67 47.60 71.33
CS-ONLY-DISC 75.60 70.40 70.80 70.53
FINE-TUNED-DISC 70.80 74.40 75.33 75.87

Table 5: Accuracy on the dev set and on the test set, accord-
ing to the type of the gold sentence in the set: code-switched
(CS) vs. monolingual (mono).

in which the gold sentence is CS are much harder,
and they perform badly on this portion of the
test set. However, using discriminative learning
enable us to get improved performance on both
portions of the test set and to get comparable
results on both parts.

A closer examination of the mistakes of
the FINE-TUNED-LM and FINE-TUNED-
DISCRIMINATIVE models reveals the superiority
of the discriminative training in various cases.
Table 6 presents several examples in which FINE-
TUNED-LM prefers a wrong sentence whereas
FINE-TUNED-DISCRIMINATIVE identifies the
gold one. In examples 1–4 the gold sentence was
code-switched but FINE-TUNED-LM forced an
improbable monolingual one. Examples 5 and 6
show mistakes in monolingual sentences.

While discriminative training is significantly
better than the standard LM training, it can still
be improved quite a bit. Table 7 lists some of the
mistakes of the FINE-TUNED-DISCRIMINATIVE
model: in examples 1, 2 and 3, the gold sen-
tence was code-switched but the model preferred a
monolingual one, in example 4 the model prefers
a wrong CS sentence over the gold monolingual
one, and in 5 and 6 the model makes mistakes in
monolingual sentences.

10 Related Work

CS Most prior work on CS focused on Language
Identification (LID) (Solorio et al., 2014; Molina
et al., 2016) and POS tagging (Solorio and Liu,
2008; Vyas et al., 2014; Ghosh et al., 2016; Bar-
man et al., 2016). In this work we focus on lan-
guage modeling, which we find more challenging.

LM Language models have been traditionally
created by using the n-grams approach (Brown
et al., 1992; Chen and Goodman, 1996). Recently,
neural models gained more popularity, both using
a feed-forward network for an n-gram language

model (Bengio et al., 2003; Morin and Bengio,
2005) and using recurrent architectures that are fed
with the sequence of words, one word at a time
(Mikolov et al., 2010; Zaremba et al., 2014; Gal
and Ghahramani, 2016; Foerster et al., 2017; Melis
et al., 2017).

Some work has been done also on optimizing
LMs for ASR purposes, using discriminative train-
ing. Kuo et al. (2002), Roark et al. (2007) and
Dikici et al. (2013) all improve LM for ASR by
maximizing the probability of the correct candi-
dates. All of them use candidates of ASR systems
as “negative” examples and train n-gram LMs or
use linear models for classifying candidates. A
closer approach to ours is used by Huang et al.
(2018). There, they optimize an RNNLM with a
discriminative loss as part of training an ASR sys-
tem. Unlike our proposed model, they still use the
standard setting of LM. In addition, their training
is coupled with an end-to-end ASR system, in par-
ticular, as in previous works, the “negative” exam-
ples they use are candidates of that ASR system.

LM for CS Some work has been done also
specifically on LM for code-switching. In Chan et
al. (2009), the authors compare different n-gram
language models, Vu et al. (2012) suggest to im-
prove language modeling by generating artificial
code-switched text. Li and Fung (2012) propose a
language model that incorporates a syntactic con-
straint and combine both a code-switched LM and
a monolingual LM in the decoding process of an
ASR system. Later on, they also suggest to in-
corporate a different syntactic constraint and to
learn the language model from bilingual data us-
ing it (Li and Fung, 2014). Pratapa et al. (2018)
also use a syntactic constraint to improve LM by
augmenting synthetically created CS sentences in
which this constraint is not violated. Adel et al.
(2013a) introduce an RNN based LM, where the
output layer is factorized into languages, and POS
tags are added to the input. In Adel et al. (2013b),
they further investigate an n-gram based factorized
LM where each word in the input is concatenated
with its POS tag and its language identifier. Adel
et al. (2014; 2015) also investigate the influence
of syntactic and semantic features in the frame-
work of factorized language models. Sreeram and
Sinha (2017) also use a factorize LM with the ad-
dition of POS tags. Baheti et al. (2017) explore
several different training protocols for CS LM and
find that fine-tuning with CS data after pretrain-



4183

no. type Gold sentence Choice of FINE-TUNED-LM model
1 CS→ mono and in front of everybody me saltó . and in front of everybody muscle too .
2 CS→ mono porque the sewer system has them in there porque . porque de ser sistemas de mil de porque .
3 CS→ mono entonces what i had done is gone ahead and printed it out . and all says what i had done is gone ahead and printed it out .
4 CS→ mono es que creo que quedan como novecientos oportunidades para beta testers . es que creo que que del como novecientos oportunidad esperaba de estar .
5 mono→ mono we we stop beyond getting too cruel . we we stop be and getting to cruel .
6 mono→ mono en mi casa tengo tanto huevo duro . en mi casa tengo tanto a futuro .

Table 6: Examples of sentences the FINE-TUNED-DISCRIMINATIVE model identifies correctly while the FINE-TUNED-LM
model does not.

no. type Gold sentence Choice of FINE-TUNED-DISCRIMINATIVE model
1 CS→ mono que by the way se vino ilegal . que va de esa vino ilegal .
2 CS→ mono son un website there . so noon website there .
3 CS→ mono no i have never felt nothing close to the espı́ritu santo never . no i have never felt nothing close to the a spirits on to never .
4 mono→ CS Tú sabes que que el cuerpo empieza a sentirse raro . Tú sabes que que el cuerpo empieza sentir ser arrow .
5 mono→ mono bueno ya son las las y cuarenta casi casi . bueno ya son las lassie cuarenta que si casi .
6 mono→ mono we have a peter lang . we have a bitter lung .

Table 7: Examples of sentences that the FINE-TUNED-DISCRIMINATIVE model fails to identify.

ing on monolingual data works best. Finally, an-
other line of works suggests using a dual language
model, where two monolingual LMs are combined
by a probabilistic model (Garg et al., 2017, 2018).

No standard benchmark or evaluation setup ex-
ists for CS LM, and most previous works use
an ASR system as part of their evaluation setup.
This makes comparison of methods very challeng-
ing. Indeed, all the works listed above use differ-
ent setups and don’t compare to each other, even
for works coming from the same group. We be-
lieve the evaluation setup we propose in this work
and our English-Spanish dataset, which is easy to
replicate and decoupled from an ASR system, is
a needed step towards meaningful comparison of
CS LM approaches.

11 Conclusions and Future Work

We consider the topic of language modeling
for code-switched data. We propose a novel
ranking-based evaluation method for language
models, motivated by speech recognition, and
create an evaluation dataset for English-Spanish
code-switching LM (SpanglishEval).

We further present a discriminative training for
this ranking task that is intended for ASR pur-
poses. This training procedure is not bound to
probability distributions, and uses both positive
and negative training sentences. This significantly
improves performance. Such discriminative train-
ing can also be applied to monolingual data.

Finally, we verify the effectiveness of the train-
ing protocol for CS LM presented in Baheti et
al. (2017): pre-training on a mix of monolin-
gual sentences, followed by fine-tuning on a code-

switched dataset. This protocol significantly out-
performs various baselines. Moreover, we show
that the less code-switched training data we use,
the more effective it is to incorporate the monolin-
gual data.

Our proposed evaluation framework and dataset
will facilitate future work by providing the ability
to meaningfully compare the performance of dif-
ferent methods to each other, an ability that was
sorely missing in previous work.

Acknowledgments

The work was supported by The Israeli Science
Foundation (grant number 1555/15).

References

Heike Adel, Katrin Kirchhoff, Dominic Telaar,
Ngoc Thang Vu, Tim Schlippe, and Tanja Schultz.
2014. Features for factored language models for
code-switching speech. In Proceedings of SLTU.

Heike Adel, Ngoc Thang Vu, Katrin Kirchhoff, Do-
minic Telaar, and Tanja Schultz. 2015. Syntactic
and semantic features for code-switching factored
language models. IEEE Transactions on Audio,
Speech, and Language Processing, 23(3).

Heike Adel, Ngoc Thang Vu, Franziska Kraus, Tim
Schlippe, Haizhou Li, and Tanja Schultz. 2013a.
Recurrent neural network language modeling for
code switching conversational speech. In Proceed-
ings of ICASSP, IEEE International Conference.

Heike Adel, Ngoc Thang Vu, and Tanja Schultz. 2013b.
Combination of recurrent neural networks and fac-
tored language models for code-switching language
modeling. In Proceedings of ACL.



4184

Peter Auer. 1999. From codeswitching via language
mixing to fused lects: Toward a dynamic typology
of bilingual speech. International journal of bilin-
gualism, 3(4):309–332.

Ashutosh Baheti, Sunayana Sitaram, Monojit Choud-
hury, and Kalika Bali. 2017. Curriculum design for
code-switching: Experiments with language iden-
tification and language modeling with deep neu-
ral networks. In Proceedings of the 14th Interna-
tional Conference on Natural Language Processing
(ICON-2017).

Utsab Barman, Joachim Wagner, and Jennifer Foster.
2016. Part-of-speech tagging of code-mixed social
media content: Pipeline, stacking and joint mod-
elling. In Proceedings of the Second Workshop on
Computational Approaches to Code Switching.

Yoshua Bengio, Réjean Ducharme, Pascal Vincent, and
Christian Jauvin. 2003. A neural probabilistic lan-
guage model. Journal of machine learning research,
3:1137–1155.

Peter F Brown, Peter V Desouza, Robert L Mercer,
Vincent J Della Pietra, and Jenifer C Lai. 1992.
Class-based n-gram models of natural language.
Computational linguistics, 18(4):467–479.

Barbara E. Bullock and Almeida Jacqueline Toribio.
2009. The Cambridge handbook of linguistic code-
switching. Cambridge University Press Cambridge.

Özlem Çetinoğlu, Sarah Schulz, and Ngoc Thang Vu.
2016. Challenges of computational processing of
code-switching. In Proceedings of the 2nd Work-
shop on Computational Approaches to Linguistic
Code Switching, EMNLP.

Joyce YC Chan, Houwei Cao, PC Ching, and Tan Lee.
2009. Automatic recognition of cantonese-english
code-mixing speech. Computational Linguistics
and Chinese Language Processing, 14(3):281–304.

Stanley F Chen and Joshua Goodman. 1996. An em-
pirical study of smoothing techniques for language
modeling. In Proceedings of ACL, pages 310–318.

Ryan Cotterell, Adithya Renduchintala, Naomi Saphra,
and Chris Callison-Burch. 2014. An algerian
arabic-french code-switched corpus. In Workshop
on Free/Open-Source Arabic Corpora and Corpora
Processing Tools Workshop Programme.

Erinç Dikici, Murat Semerci, Murat Saraclar, and
Ethem Alpaydin. 2013. Classification and ranking
approaches to discriminative language modeling for
asr. IEEE Transactions on Audio, Speech, and Lan-
guage Processing, 21(2):291–300.

Jakob N Foerster, Justin Gilmer, Jan Chorowski, Jascha
Sohl-Dickstein, and David Sussillo. 2017. Intelli-
gible language modeling with input switched affine
networks. arXiv preprint arXiv:1611.09434.

Yarin Gal and Zoubin Ghahramani. 2016. A theoret-
ically grounded application of dropout in recurrent
neural networks. In Proceedings of NIPS.

Saurabh Garg, Tanmay Parekh, and Preethi
Jyothi. 2017. Dual language models for code
switched speech recognition. arXiv preprint
arXiv:1711.01048.

Saurabh Garg, Tanmay Parekh, and Preethi Jyothi.
2018. Code-switched language models using dual
rnns and same-source pretraining. arXiv preprint
arXiv:1809.01962.

Souvick Ghosh, Satanu Ghosh, and Dipankar Das.
2016. Part-of-speech tagging of code-mixed social
media text. In Proceedings of the Second Workshop
on Computational Approaches to Code Switching.

Jiaji Huang, Yi Li, Wei Ping, and Liang Huang. 2018.
Large margin neural language model. In Proceed-
ings of EMNLP.

Hong-Kwang Jeff Kuo, Eric Fosler-Lussier, Hui Jiang,
and Chin-Hui Lee. 2002. Discriminative training of
language models for speech recognition. In Acous-
tics, Speech, and Signal Processing (ICASSP), 2002
IEEE International Conference on, volume 1. IEEE.

Ying Li and Pascale Fung. 2012. Code-switch lan-
guage model with inversion constraints for mixed
language speech recognition. In Proceedings of
COLING, pages 1671–1680.

Ying Li and Pascale Fung. 2014. Language model-
ing with functional head constraint for code switch-
ing speech recognition. In Proceedings of EMNLP,
pages 907–916.

Gábor Melis, Chris Dyer, and Phil Blunsom. 2017. On
the state of the art of evaluation in neural language
models. arXiv:1707.05589.

Stephen Merity, Nitish Shirish Keskar, and Richard
Socher. 2017. Regularizing and optimizing lstm lan-
guage models. arXiv:1708.02182.

Tomas Mikolov, Martin Karafiát, Lukas Burget, Jan
Cernockỳ, and Sanjeev Khudanpur. 2010. Recurrent
neural network based language model. In Proceed-
ings of Interspeech.

Giovanni Molina, Fahad AlGhamdi, Mahmoud
Ghoneim, Abdelati Hawwari, Nicolas Rey-
Villamizar, Mona Diab, and Thamar Solorio. 2016.
Overview for the second shared task on language
identification in code-switched data. In Proceed-
ings of the Second Workshop on Computational
Approaches to Code Switching.

Frederic Morin and Yoshua Bengio. 2005. Hierarchi-
cal probabilistic neural network language model. In
Proceedings of the International Workshop on Arti-
ficial Intelligence and Statistics, volume 5.



4185

Pieter Muysken. 2000. Bilingual speech: A typology
of code-mixing, volume 11. Cambridge University
Press.

Graham Neubig, Chris Dyer, Yoav Goldberg, Austin
Matthews, Waleed Ammar, Antonios Anastasopou-
los, Miguel Ballesteros, David Chiang, Daniel
Clothiaux, Trevor Cohn, et al. 2017. Dynet: The
dynamic neural network toolkit. arXiv:1701.03980.

Shana Poplack. 1980. Sometimes i’ll start a sentence
in spanish y termino en español: toward a typology
of code-switching. Linguistics, 18(7-8):581–618.

Adithya Pratapa, Gayatri Bhat, Monojit Choudhury,
Sunayana Sitaram, Sandipan Dandapat, and Kalika
Bali. 2018. Language modeling for code-mixing:
The role of linguistic theory based synthetic data. In
Proceedings of ACL.

Brian Roark, Murat Saraclar, and Michael Collins.
2007. Discriminative n-gram language modeling.
Computer Speech & Language, 21(2):373–392.

Rico Sennrich. 2016. How grammatical is character-
level neural machine translation? assessing
MT quality with contrastive translation pairs.
arXiv:1612.04629.

Thamar Solorio, Elizabeth Blair, Suraj Mahar-
jan, Steven Bethard, Mona Diab, Mahmoud
Ghoneim, Abdelati Hawwari, Fahad AlGhamdi, Ju-
lia Hirschberg, Alison Chang, and Pascale Fung.
2014. Overview for the first shared task on language
identification in code-switched data. In Proceedings
of the First Workshop on Computational Approaches
to Code Switching.

Thamar Solorio and Yang Liu. 2008. Part-of-speech
tagging for english-spanish code-switched text. In
Proceedings of EMNLP, pages 1051–1060.

Ganji Sreeram and Rohit Sinha. 2017. Language mod-
eling for code-switched data: Challenges and ap-
proaches. arXiv:1711.03541.

Jörg Tiedemann. 2009. News from OPUS - A collec-
tion of multilingual parallel corpora with tools and
interfaces. In N. Nicolov, K. Bontcheva, G. An-
gelova, and R. Mitkov, editors, Recent Advances in
Natural Language Processing, pages 237–248.

Ke Tran, Arianna Bisazza, and Christof Monz. 2018.
The importance of being recurrent for modeling hi-
erarchical structure. arXiv:1803.03585.

Ngoc Thang Vu, Dau-Cheng Lyu, Jochen Weiner, Do-
minic Telaar, Tim Schlippe, Fabian Blaicher, Eng-
Siong Chng, Tanja Schultz, and Haizhou Li. 2012.
A first speech recognition system for mandarin-
english code-switch conversational speech. In Pro-
ceedings of ICASSP, IEEE International Confer-
ence, pages 4889–4892.

Yogarshi Vyas, Spandana Gella, Jatin Sharma, Kalika
Bali, and Monojit Choudhury. 2014. POS tagging of
English-Hindi code-mixed social media content. In
Proceedings of EMNLP.

Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals.
2014. Recurrent neural network regularization.
arXiv:1409.2329.


