
























































Computational Syntax-Semantics Interface with Type-Theory of Acyclic Recursion for Underspecified Semantics


Proceedings of the IWCS 2019 Workshop on Computing Semantics with Types, Frames and Related Structures, pages 37–48
Gothenburg, Sweden, May 24, 2019. c©2019 Association for Computational Linguistics

37

Computational Syntax-Semantics Interface with Type-Theory of

Acyclic Recursion for Underspecified Semantics

Roussanka Loukanova

Stockholm University

loukanova@gmail.com

Abstract

The paper provides a technique for algorithmic syntax-semantics interface in computational

grammar with underspecified semantic representations of human language. The technique is intro-

duced for expressions that contain NP quantifiers, by using computational, generalised Constraint-

Based Lexicalised Grammar (GCBLG) that represents major, common syntactic characteristics of a

variety of approaches to formal grammar and natural language processing (NLP). Our solution can

be realised by any of the grammar formalisms in the CBLG class, e.g., Head-Driven Phrase Structure

Grammar (HPSG), Lexical Functional Grammar (LFG), Categorial Grammar (CG). The type-theory

of acyclic recursion Lλ
ar

, provides facility for representing major semantic ambiguities, as under-

specification, at the object level of the formal language of Lλ
ar

, without recourse of meta-language

variables. Specific semantic representations can be obtained by instantiations of underspecified Lλ
ar

-

terms, in context. These are subject to constraints provided by a newly introduced feature-structure

description of syntax-semantics interface in GCBLG.

1 Introduction

Ambiguity permeates human language, in all of its manifestations, by interdependences, across lexicon,

syntax, semantics, discourse, context, etc. Alternative interpretations may persist even when specific

context and discourse resolve or discard some specific instances in syntax and semantics. We present

computational grammar that integrates lexicon, syntax, types, constraints, and semantics. The formal fa-

cilities of the grammar have components that integrate syntactic constructions with semantic representa-

tions. The syntax-semantic interface, internally in the grammar, handles some ambiguities as phenomena

of underspecification in human language.

We employ a computational grammar, which we call Generalised Constraint-Based Lexicalised

Grammar (GCBLG). The formal system GCBLG uses feature-value descriptions and constraints in a

grammar with a hierarchy of dependent types, which covers lexicon, phrasal structures, and semantic

representations. In GCBLG, for the syntax, we use feature-value descriptions, similar to that in Sag et al.

(2003), which are presented formally in Loukanova (2017a) as a class of formal languages designating

mathematical structures of functional domains of linguistics information. GCBLG is a generalisation

from major lexical and syntactic facilities of frameworks in the class of Constraint-Based Lexicalist

Grammar (CBLG) approaches. To some extend, this is reminiscence of Vijay-Shanker and Weir (1994).

We lift the idea of extending classic formal grammars to cover semantic representations with semantic

underspecification via syntax-semantics interface within computational grammar.

We introduce the technique here for varieties of grammar formalisms from the CBLG approach, in

particular: Categorial Grammar (CG), e.g., see Moortgat (1996); Head-Driven Phrase Structure Gram-

mar (HPSG), e.g., see Pollard and Sag (1994); Lexical Functional Grammar (LFG), e.g., see Bresnan

(2001), Dalrymple (2001), Kroeger (2004); Tree-Adjoining Grammar (TAG), e.g., see Joshi et al. (1975);

Joshi (1987); and other grammar approaches, such as the Grammatical Framework GF, see Ranta (2011).

The valance features that we use here with corresponding semantic representations can be translated di-

rectly into HPSG, LFG, and Categorial Grammar (CG).



38

The grammar rules and constraints in GCBLG, in syntax and lexicon, carry semantic representations.

The formal language of the semantic representations is a specialised feature-value encoding of terms of

the formal language of acyclic recursion Lλar, see Moschovakis (2006).

2 Overview of Moschovakis Type-Theory of Acyclic Recursion

2.1 Syntax of Lλar

TypesLλar is the smallest set defined recursively, e.g., by presenting the rules in Backus-Naur form:

τ ::= e | t | s | (τ → τ) (Types)

Typed Vocabulary of Lλar: For each type τ ∈ Types, L
λ
ar has typed constants, and variables.

Constants K: a denumerable (e.g., finite) set, Kτ = {c0
τ , . . . , cτk}, K =

⋃
τ Kτ

Pure variables PV: a denumerable set: PVτ = {v0, v1, . . .}; PV =
⋃

τ PVτ
Recursion (memory) variables RV: a denumerable set: RVτ = {r0, r1, . . .}; RV =

⋃
τ RVτ

The sets of constants and variables of both kinds are mutually distinct: K 6= RV 6= PV.

Terms of Lλar: The set of the terms of L
λ
ar is Terms = ∪τ∈Types Termsτ , where for every τ ∈ Types,

the terms in Termsτ are defined recursively as follows:

• Constants: If c ∈ Kτ , then c ∈ Termsτ , denoted by c : τ and c
τ

• Variables: If x ∈ PVτ ∪RVτ , then x ∈ Termsτ , denoted by x : τ and x
τ

• Application Terms: If A ∈ Terms(σ→τ) and B ∈ Termsσ, then A(B) ∈ Termsτ , denoted by
A(B) : τ and [A(B)]τ

• λ-abstraction terms: If x ∈ PVσ, and A ∈ Termsτ , then λ(x)(A) ∈ Terms(σ→τ), denoted by

λ(x)(A) : (σ → τ) and [λ(x)(A)](σ→τ)

• Recursion terms: For any n ≥ 0, if Ai ∈ Termsσi (i = 0, . . . , n) and pi ∈ RVσi (i = 1, . . . , n) are
such that p1, . . . , pn are pairwise different, and the sequence { p1 := A1, . . . , pn := An } satisfies
the Acyclicity Constraint, i.e., it is acyclic, then A0 where {p1 := A1, . . . , pn := An} ∈ Termsσ0 .
The type assignment of the recursion term is denoted by:

A0 where { p1 := A1, . . . , pn := An } : σ0 (1a)

[A0 where { p1 := A1, . . . , pn := An }]
σ0 (1b)

Acyclicity Constraint (AC): the sequence of assignments {p1 := A1, . . . , pn := An} is acyclic iff
there is a function rank : {p1, . . . , pn} −→ N such that, for all pi, pj ∈ {p1, . . . , pn},

if pj occurs freely in Ai then rank(pj) < rank(pi) (2)

We use the meta-symbol ≡ for identity between expressions, e.g., E1 ≡ E2, and in abbreviations.
The sets FreeV(A) and BoundV(A), respectively of the free and bound variables of a term A, are

defined by structural recursion, in the usual way, with the exception of the recursion terms. For any given

recursion term A ≡ [A0 where {p1 := A1, . . . , pn := An}], all occurrences of p1, . . . , pn ∈ RV in A
are bound, and all other free (bound) occurrences of variables (constants) in A0, . . . , An are also free

(bound) in A.

The reduction calculus of Lλar has a set of reduction rules that reduce each L
λ
ar-term A to its unique,

up to congruence, canonical form cf(A), i.e., A ⇒ cf(A). Informally, for every A,B ∈ Terms:
A ≈ B iff (1) A and B are proper terms and their denotations are equal and computed by the same

algorithm determined by cf(A) and cf(B); (2) or, A and B are immediate, and A and B have the same
denotations.

See Moschovakis (2006) and Loukanova (2016, 2019, 2018), for details on the denotational and

algorithmic semantics of Lλar. For the first representation of semantic underspecification with the theory
of acyclic algorithms, see Loukanova (2007).



39

3 Underspecified Terms and Universal Syntax

Definition 1 (Underspecified Lλar-Terms). For any A ∈ Terms, we call A an underspecified term, in case
FreeV(A)∩RV 6= ∅, i.e., when A has free occurrences of recursion variables; otherwise A is specified.

We represent some of the semantic ambiguities of natural language sentences by rendering them

into underspecified Lλar-terms. In this paper, we consider a class of typical ambiguous sentences, which
have different scope readings, due to occurrences of multiple quantifier NPs in them. For any such

sentence Φ, direct representation of alternative readings, by a set of different Lλar-terms, is available,

e.g., Φ
render
−−−→ Ai, i = 1, . . . , n, for some n ≥ 1. Without any specific context, all of these alternative

readings can be potentially viable. Instead of rendering Φ into the set of these specific terms, e.g., by
some (syntactic or other) analyses, we render Φ into a single, underspecified term A that represents the
set of the alternatives. When context information is available, e.g., by data driven methods, individual

or all Ai can be derived from A. That can be done by instantiating the free recursion variables of A,

and thus instantiating A, via expanding A by adding recursion assignments that bind its free recursion

variables. We impose constraints over the free recursion variables FreeV(A) ∩ RV, e.g., due to the
syntactic structure of A, via syntax-semantic analysis, to prevent undesirable alternative instantiations

and denotational interpretations denA(A)(g).
Informally, we can restrict the instantiations of A by constraints over possible bindings of recursion

variables that occur in A. For any given A,R ∈ Terms and p ∈ RV, the relation (R rBind p) holds
between R and p in A, when R recursively binds p in A, via a sequence of recursion assignments and/or

by λ-abstraction across recursion assignments. Thus, rBind provides specification relation between un-

derspecified and specified Lλar-terms. The formal treatment of rBind, which is not in the subject of this
paper, is based on the binding relation introduced in Loukanova (2017b). Here, we focus on the technique

of rendering natural language expressions into underspecified terms, via syntax-semantics interface.

For example, the terms in (3d)–(3f) render the sentence “Fido barks”, via unordered, i.e., abstract,

universal syntax. (3c) renders the verb “barks”, which is of lexical type verb in the lexicon, to the Lλar-
term Tb. Tb has in its where-assignment, the term barks : (ẽ → t̃), which is not a constant, but a complex
term that caries information about time in relation to possible, underspecified time of potential utterance,

see Loukanova (2011b). While the term Tb : t̃ is of sentential type, it is unsaturated because it has a free
recursion variable p that fills the argument slot of b, and which is without any constraint over it, regarding

possible binding of p.

- NP word in lexicon; semantically specified:

[Fido]NP
render
−−−→ Ti ≡ i where { i := fido } : ẽ (3a)

- V lexeme in lexicon; rendered to a constant; semantically specified:

[bark]V
render
−−−→ T

(̃e→t̃)
lex−b ≡ bark : (ẽ → t̃) (3b)

- Inflected V word in lexicon; semantically underspecified term carrying information about time; unsat-

urated for p ∈ FreeV(T t̃b ); it becomes constrained VP in the sentence analysis:

[barks]V
render
−−−→ T t̃b ≡ b(p) where { b := barks } : t̃ (3c)

- Sentence: universal, unordered syntax with SynSem; semantically underspecified; SynSem constrained:

{ [Fido]NP, [barks]VP }S
render
−−−→ T1 ≡ b(p) where { i := fido, b := barks } : t̃

such that { (i rBind p) }
(3d)

- Universal, unordered syntax with SynSem; semantically specified by the SynSem constraint:

{ [Fido]NP, [barks]VP }S
render
−−−→ T 1univ ≡ b(p) where { p := i, i := fido, b := barks } (3e)

- Semantically specified by the SynSem constraint; reduced chain assignments:

{ [Fido]NP, [barks]VP }S
render
−−−→ T ≡ Tuniv ≡ b(p) where { p := fido, b := barks } (3f)



40

- Surface ordered syntax with SynSem; semantically specified by the SynSem constraint:

{ [Fido]NP, [barks]VP }S
render
−−−→ T ≡ Tuniv ≡ b(p) where { p := fido, b := barks } (3g)

An alternative syntax-semantics analysis of the same sentence “Fido barks”, can be obtained by us-

ing a λ-term [T ′b]
(̃e→t̃) rendering a VP like “barks”, as in (4), the type of which, via λ(x)-abstraction,

reflects that it is of a functional type. This analysis results in the same term for rendering the sentence,

as in (3g), but with different intermediate reductions of the canonical forms. The analysis uses interme-

diate steps with γ∗-reduction, or, alternatively, γ-reduction, introduced in Loukanova (2019, 2018) for

canonical forms cfγ* and cfγ , correspondingly. These reduction extensions of the classic reduction from

Moschovakis (2006), provide computational simplifications in many cases, like this one.

- Inflected V word of type verb in lexicon; p′ ∈ FreeV(T ′b), p
′(x) designates an actant; semantically

underspecified:

[barks]VP
render
−−−→ [T ′b]

(̃e→t̃) ≡ [λ(x)(b(p′(x))) where { b := barks }] : (ẽ → t̃) (4)

In (5a)–(5e), we present stages of syntax-semantics analysis, of a sentence with one quantifier NP

and an intransitive verb, via unordered, i.e., abstract, universal syntax-semantics interface. (5b) renders

the verb “barks”, which is of lexical type verb (a subtype of the type word) in the lexicon, to the Lλar-term
Tb. The term Tb has in its where-assignment, the term barks : (ẽ → t̃), which is not a constant, but a
complex term that caries information about time in relation to possible time of a potential utterance, see

Loukanova (2011b). While the term Tb : t̃ is of sentential type, it is unsaturated because it has a free
recursion variable p that fills the argument slot of b, and which is without any constraint over it, regarding

possible binding of p. The syntactic structure of the sentence saturates the syntactic argument of the VP,

[barks]VP, with the subject NP, e.g., [every dog]NP.

- NP phrase, in grammar with SynSem; semantically specified:

[Every, dog]NP
render
−−−→ [K]((̃e→t̃)→t̃)

≡ [Q(d)]((̃e→t̃)→t̃) where {Q := every , d := dog }
(5a)

- Inflected V word in lexicon; semantically underspecified term carrying information about time; unsat-

urated for p ∈ FreeV(T t̃b ); it becomes constrained VP in the sentence analysis:

[barks]VP
render
−−−→ [Tb]

t̃ ≡ b(p) where { b(ẽ→t̃) := barks(ẽ→t̃) } : t̃ (5b)

- Sentence: universal, unordered syntax with SynSem; semantically underspecified; SynSem constrained:

{ [Every dog]NP, [barks]VP }S
render
−−−→ [T ]t̃ ≡ i where {

k := Q(d), Q := every , d := dog ,

h := b(p), b := barks }

such that { (k rBind p) }

(5c)

- Universal, unordered syntax with SynSem; semantically specified by SynSem constraint:
process
−−−−→ [T ]t̃ ≡ i where { i := k(λ(x)(h(x))) ≈ k(h),

k := Q(d), Q := every , d := dog ,

h := λ(x)(b(p′(x))), p′ := λ(x)(x), b := barks }

such that { (k rBind p′) }

(5d)

- Surface ordered syntax with SynSem; semantically specified by the SynSem constraint:

{ [Every dog]NP [barks]VP }S
render
−−−→ [T ]t̃ ≡ i where { i := k(λ(x)(h(x))) ≈ k(h),

k := Q(d), Q := every , d := dog ,

h := λ(x)(b(p′(x))), p′ := λ(x)(x), b := barks }

such that { (k rBind p′) }

(5e)



41

Note that the tree structures of the syntactic analyses in Sect. 6 have unordered daughters, and in

essence, these are three demential graphs.

4 Syntax-Semantics Interface in GCBLG by the Type-Theory of Acyclic

Recursion

A formal background on generalised GCBLG is given in Loukanova (2017a). We use a formal feature-

value language for type-theoretical descriptions of computational syntax of human language. Sag et al.

(2003) is a detailed introduction to formal grammar of human language, by providing and using theo-

retical linguistics. In this version of generalised GCBLG, semantic representations of human language

expressions, are provided by Lλar-terms of the formal language of acyclic recursion L
λ
ar, by using feature-

value structures, via the technique introduced in Loukanova (2011a). Here, we provide two of the major

grammatical rules of GCBLG, enhanced with semantic representation, and a new, additional feature-

value description on constraints over semantic representations, via syntax-semantics interface. For this,

we introduce a new feature SYNSEM of type synsem, with values of type list-of(propositions).

The analysed natural language expressions are rendered into Lλar-terms, in canonical forms, by using
feature-value representations of the recursion terms, according to the following rule:

Rendering syntactic structures into Lλar-terms: Assume that a natural language expression E is
analysed by GCBLG as a feature-value description F (A). Assume that, in F (A), the value of the

feature T-HEAD is a Lλar-term A0, and the value of the feature WHERE is a sequence
−→p :=

−→
A of where-

assignments. Then, E
render
−−−→ A0 where {

−→p :=
−→
A }. The value of the feature L-TYPE is the Lλar-type of

A0. We use recursion variables to designate the rendering terms in the feature-value descriptions, which

can be used in the combined terms.

The rules HSR and HCR1 take as inputs expressions that have semantic representations in canonical

forms and generate phrases with semantic representations that are in canonical forms too. The values of

T-HEAD and WHERE of the left hand side of the rules are determined by: the semantic types T1 and T2
of the daughter nodes; the values of T-HEAD and WHERE in the daughters’ feature structures on the right

hand side; and the definition of the canonical form cf(A) of each term A.

Head Specifier Rule (HSR): (6)



phrase

SYN

[
VAL

[
SPR 〈 〉

]]

SYNSEM

[
append( 2 , R′)

]

SEM




L-TYPE T

TERM




TERM-RV L

T-HEAD A0

WHERE U










−→ 1




SEM




L-TYPE T1

TERM




TERM-RV L1

T-HEAD A1,0

WHERE U1










H




SYN


VAL

[
SPR 〈 1L1 〉

COMPS 〈 〉

]


SYNSEM

[
2 append(L1 rBind p,R)

]

SEM




L-TYPE T2

TERM

[
T-HEAD A2,0[p]

WHERE U2[p]

]







Head Complement Rule (HCR1): (7)



phrase

SYN

[
VAL

[
COMPS a

]]

SYNSEM

[
append( 2 , R′)

]

SEM




L-TYPE T

TERM




TERM-RV L

T-HEAD A0

WHERE U










−→ H




SYN


VAL


COMPS




FIRST 1L1

REST a

[
list

]









SYNSEM

[
2 append(L1 rBind p,R)

]

SEM




L-TYPE T2

TERM

[
T-HEAD A2,0[p]

WHERE U2[p]

]







1




SEM




L-TYPE T1

TERM




TERM-RV L1

T-HEAD A1,0

WHERE U1












42

In both rules (6)–(7), p ∈ RV, A2,0[p], U2[p] indicate that p may fill up some argument slots in some of
the sub-terms, and the following cases can be realised:

Case1: Ti ≡ (σ → τ) and Tj ≡ σ, for i, j ∈ {1, 2} and i 6= j, T ≡ τ
There are two sub-cases, (8) and (9), for the term [A0 where U ] in (6)–(7):
(1) if Aj,0 is immediate, then:

A0 ≡ Ai,0(Aj,0) and U ≡ append(U1, U2) (8)
(2) otherwise, i.e., if Aj,0 is proper, then:

A0 ≡ Ai,0(q0) and U ≡ append({q0 := Aj,0}, append(U1, U2)) (9)
Case2: T2 : t̃; and T1 : ((ẽ → t̃) → t̃) or T1 : ((ẽ → t̃) → ((ẽ → t̃) → t̃))
The binding constraints in the value of the feature SYNSEM provide suitable terms for A0 and U ,

by combining the parts Aj,0, Uj , for j = 1, 2, and adding new constraints, as needed. The detailed
specifications use the definition of the relation rBind.

Case2 covers expressions such as NPs, VPs, and sentences S, where some argument slots are bound

by sub-terms of the renderings of NP quantifiers, via recursion variables. The technique is exemplified by

the analysis of the sentence “Every cat hugs some dog”, which represents a general pattern for multiple

quantifier scopes. It is presented in Fig. 3.

5 Scope Underspecification and Specification

Scope Underspecification: The feature-value structural description given in Fig. 3 is a pattern of one of

the possible ways to represent multiple semantic scopes of quantification. The syntax-semantics interface

is provided by the HSR and HCR1 rules of GCBLG, while the formal calculi of Lλar, provides terms for
algorithmic semantics. A sentence that has occurrences of multiple quantifier NPs can be rendered into a

single Lλar-term that represents the multiple possibilities simultaneously. It is underspecified, by having
constrained free recursion variables filling up the argument slots that are bound by the corresponding

NPs.

Scope Specification: The binding relation rBind in Lλar provides a syntax-semantics facility to con-
strain the possible bindings in specific scopes, via restricting free recursion variables occurring in an

underspecified term. An underspecified term can be expanded into specified terms only if they satisfy

the rBind-constraints. Thus, constraints expressed by rBind also restrict the possible interpretations of

the free recursion variables. For instance, the semantic rendering in Fig. 3 can be expanded into specified

semantic representation, which has to satisfy the constraints imposed by the structural combinations.

Fig. (4) presents one of the available possibilities to instantiate the free recursion variables, i.e., to bind

them by the corresponding NP quantifiers.

6 Grammar Analyses with Syntax-Semantics Interface in GCBLG

In this section, we provide several analyses of typical sentences with head verbs taking NPs as their

syntactic, and corresponding semantic, arguments. We exemplify the classes of intransitive and transitive

head verbs having NP subjects and single NP complements.

Note that in the analysis in Fig. 1, we do not render the NP that is a proper name into a term of a

generalised quantifier, since that would introduce unnecessary complexity in the analysis of expressions

of this kind. Furthermore, the term [Tb]
t̃ that renders the VP is as in (5b). Optionally, we can use a

λ-abstraction term [T ′b]
(̃e→t̃), and then, the sentence gets rendered to an algorithmically equivalent term

by the γ∗-reduction calculus of Lλar, see Loukanova (2019, 2018).
In Fig. 2, we present a syntax-semantics analysis of a sentence with a single quantifier NP, in the

subject position of the intransitive V. Optionally, we can use a λ-abstraction term [T ′b]
(̃e→t̃), resulting in

an algorithmically equivalent term for the sentence, by the γ∗-reduction calculus of Lλar.



43

S




SYN


VAL

[
COMPS 〈 〉

SPR 〈 〉

]


SEM




L-TYPE t̃

TERM




T

T-HEAD b(p)

WHERE { (p := i, i := fido)

p := fido,

b := barks }










NPi

1




SYN




HEAD 4

VAL

[
COMPS 〈 〉

SPR 〈 〉

]



SEM




L-TYPE ẽ

TERM



Ti

T-HEAD i

WHERE { i := fido }










Fido

V(P)

H




word

SYN




HEAD 0

[
verb

AGR 3

]

VAL

[
COMPS 〈 〉

SPR 〈 1 i 〉

]




SYNSEM

[
i rBind p

]

SEM




L-TYPE t̃

TERM



T t̃b
T-HEAD b(p)

WHERE { b := barks}










barks

Figure 1: A Proper Name as the Specifier of an Intransitive Verb

S




SYNSEM

[
i rBind p′, Q rBind p′

]

SEM




L-TYPE t̃

TERM




T

T-HEAD i

WHERE { i := Q(λ(x)(h(x))) ≈ Q(h),

Q := q(d),

q := some , d := dog ,

h := λ(x)(b(p′(x))),

p′ := λ(x)(x),

b := barks }










NPQ

1




SYN




HEAD 4

VAL

[
COMPS 〈 〉

SPR 〈 〉

]



SEM




L-TYPE (ẽ → t̃) → t̃

TERM




Q0

T-HEAD q(d)

WHERE { q := some ,

d := dog }










2




SYN




HEAD

[
det

]

VAL

[
SPR 〈 〉

COMPS 〈 〉

]




SEM




L-TYPE ((ẽ → t̃) → ((ẽ → t̃) → t̃))

TERM



q0

T-HEAD some

WHERE { }










some

H




SYN




HEAD 4

[
noun

]

VAL


SPR

〈
2

〉

COMPS 〈 〉







SEM




L-TYPE (ẽ → t̃)

TERM



d0

T-HEAD dog

WHERE { }










dog

V(P)

H




word

SYN




HEAD 0

[
verb

AGR 3

]

VAL

[
COMPS 〈 〉

SPR 〈 1 i 〉

]




SYNSEM

[
Q rBind p

]

SEM




L-TYPE t̃

b : (ẽ → t̃)

TERM



Tb

T-HEAD b(p)

WHERE { b := barks }










barks

Figure 2: Quantifier NP in Subject Position, Specified



44

In Fig. 3, we present a syntax-semantics analysis of a sentence with two quantifier NPs, in subject and

compliment positions of the head verb V. In Fig. 4, we present its specification to one of the alternative

scope distributions. In it, we have specified the VP at the intermediate level of the analysis, in the node

marked by (n1) VP. Pragmatically, it is more viable for this node to be underspecified as it is in 3, and
the specification is at the node (n0) S, at the sentence level, e.g., when disambiguating information is
available at that level.

In Fig. 5, we present an optional analysis of the same sentence, by rendering the head verb to a λ-

term, which is congruent to λ(xd2)λ(xd1)h(p
′

1(xd1))(p
′

2(xd2)). In such a case, there is a correspondence
between the syntactic and semantic saturation types of the V and VP expressions. But, the term that

renders the sentence at the node (n0) S, is not algorithmically equivalent to the one in Fig. 3, and naturally
reflect on the algorithmic steps that are used during the analyses for filling up arguments. Similarly, the

specification terms corresponding to these two options are not algorithmically equivalent.

7 Conclusions and Future Work

We have presented how the formal language of the theory of acyclic recursion Lλar can be used for se-
mantic representations of natural language via syntax-semantics interface in computational grammar. We

have introduced the technique by generalised GCBLG that employs feature-value descriptions. GCBLG

is type theoretical by its hierarchy of constraints, which are of dependent types, for the syntactic com-

positions. The feature-value descriptions embed semantic representations by the higher-order Lλar-terms.
We have focused on two of the major grammar rules for saturation of syntactic and semantic arguments,

for underspecified semantic representations of multiple quantifier scopes. A sentence that has two (or

more) quantifier NPs, with ambiguous semantic scopes, can be rendered into a single, underspecified

Lλar-term A. The key idea is that A has free recursion variables saturating arguments that can be bound
by corresponding quantifier NPs in alternative orders. The phrasal rules of GCBLG introduce restrictions

over possible bindings via recursion assignments in syntax-semantics interface.

We foresee extending and implementing the technique for computational syntax-semantics interface

in lexical and phrasal structures, for broader grammatical constructions.

References

Bresnan, J. (2001). Lexical-Functional Syntax. Oxford: Blackwell Publishers.

Dalrymple, M. (2001). Lexical Functional Grammar, Volume 34 of Syntax and Semantics. New York:

Academic Press.

Joshi, A. K. (1987). An introduction to tree adjoining grammars. Mathematics of Language 1, 87–115.

Joshi, A. K., L. S. Levy, and M. Takahashi (1975, February). Tree adjunct grammars. J. Comput. Syst.

Sci. 10(1), 136–163.

Kroeger, P. (2004). Analyzing Syntax: A Lexical-Functional Approach. Cambridge: Cambridge Univer-

sity Press.

Loukanova, R. (2007, August). Typed Lambda Language of Acyclic Recursion and Scope Underspec-

ification. In R. Muskens (Ed.), Workshop on New Directions in Type-theoretic Grammars, ESSLLI

2007, Dublin, Ireland, pp. 73–89. The Association for Logic, Language and Information.

Loukanova, R. (2011a). Semantics with the Language of Acyclic Recursion in Constraint-Based Gram-

mar. In G. Bel-Enguix and M. D. Jiménez-López (Eds.), Bio-Inspired Models for Natural and Formal

Languages, pp. 103–134. Cambridge Scholars Publishing.



45

(n
0
)

S

                        S
Y

N

  V
A

L

[ S
P

R
〈
〉

C
O

M
P

S
〈
〉]
 

S
Y

N
S

E
M

[ l
1
rB

in
d
T

,
l 2

rB
in
d
T

,

Q
1
rB

in
d
p
1
,
R

1
rB

in
d
p
1
,Q

2
rB

in
d
p
2
,R

2
rB

in
d
p
2

]

S
E

M

            L
-T

Y
P

E
t̃

T
E

R
M

         R
3

T
-H

E
A

D
T

W
H

E
R

E
{
l 1

: =
Q

1
(R

1
),
l 2

: =
Q

2
(R

2
),

Q
1
: =

q 1
(d

1
),
q 1

: =
so
m
e
,
d
1
: =

d
og

,

Q
2
: =

q 2
(d

2
),
q 2

: =
e
v
e
ry
,
d
2
: =

ca
t
,

R
0
: =

h
(p

1
)(
p
2
),
h
: =

h
u
g
}

                     

                        

(n
2
)

N
P
Q

2

2

                S
Y

N

   H
E

A
D

4

V
A

L

[ C
O

M
P

S
〈
〉

S
P

R
〈
〉]
   

S
E

M

       L
-T

Y
P

E
((
ẽ
→

t̃)
→

t̃)

T
E

R
M

    Q
2

T
-H

E
A

D
q 2
(d

2
)

W
H

E
R

E
{
q 2

: =
e
v
e
ry

,

d
2
: =

ca
t
}

           

                

3

           S
Y

N

    H
E

A
D

[ d
et
]

V
A

L

[ S
P

R
〈
〉

C
O

M
P

S
〈
〉]

    

S
E

M

  T
E

R
M

[ T
-H

E
A

D
e
v
e
ry

W
H

E
R

E
{
}

] 

           

ev
er

y

H

              S
Y

N

     H
E

A
D

4

[ n
o
u
n
]

V
A

L

 S
P

R

〈
3

〉

C
O

M
P

S
〈
〉

      

S
E

M

   L
-T

Y
P

E
(ẽ

→
t̃)

T
E

R
M

[ T
-H

E
A

D
ca
t

W
H

E
R

E
{
}

]   

              

ca
t

(n
1
)

V
P

                         S
Y

N

    H
E

A
D

[ v
er

b
]

V
A

L

[ S
P

R
〈
2
Q

2
〉

C
O

M
P

S
〈
〉

]    

S
Y

N
S

E
M

[ (
Q

2
rB

in
d
p
2
),

(Q
1
rB

in
d
p
1
),

(R
1
rB

in
d
p
1
)]

S
E

M

          L
-T

Y
P

E
t̃

T
E

R
M

       T
0

T
-H

E
A

D
l 1

W
H

E
R

E
{
l 1

: =
Q

1
(R

1
),

Q
1
: =

q 1
(d

1
),
q 1

: =
so
m
e
,
d
1
: =

d
og

,

R
0
: =

h
(p

1
)(
p
2
),
h
: =

h
u
g
}

                 

                         

(n
3
)

V

                         w
o
rd

S
Y

N

    H
E

A
D

[ v
er

b
]

V
A

L

[ S
P

R
〈
2
Q

2
〉

C
O

M
P

S
〈
1
Q

1
〉]

    

S
Y

N
S

E
M

[ Q
1
rB

in
d
p
1
,Q

2
rB

in
d
p
2
,
]

S
E

M

          s
em

-c
a
t

L
-T

Y
P

E
t̃ h
:
(ẽ

→
(ẽ

→
t̃)
)

T
E

R
M

  R
0

T
-H

E
A

D
h
(p

1
)(
p
2
)

W
H

E
R

E
{
h
: =

h
u
g
}  

                                   

h
u
g
s

(n
5
)

N
P
Q

1

1

                S
Y

N

   H
E

A
D

5

V
A

L

[ C
O

M
P

S
〈
〉

S
P

R
〈
〉]
   

S
E

M

       L
-T

Y
P

E
(ẽ

→
t̃)

→
t̃

T
E

R
M

    Q
1

T
-H

E
A

D
q 1
(d

1
)

W
H

E
R

E
{
q 1

: =
so
m
e

,

d
1
: =

d
og

}

           

                

so
m

e
d
o
g

F
ig

u
re

3
:

U
n
d
er

sp
ec

ifi
ed

S
co

p
e:

Q
u
an

ti
fi

er
N

P
as

S
u
b
je

ct
an

d
Q

u
an

ti
fi

er
N

P
as

C
o
m

p
le

m
en

t



46

(n
0
)

S

                       S
Y

N
S

E
M

[ Q
1
rB

in
d
p
′ 1
,Q

2
rB

in
d
p
′ 2
,
R

2 1
rB

in
d
p
′ 1
,
R

2
rB

in
d
p
′ 2

]

S
E

M

                   L
-T

Y
P

E
t̃

T
E

R
M

                R
3

T
-H

E
A

D
l 2

W
H

E
R

E
{
l 2

: =
Q

2
(R

2
),

R
2
: =

λ
(x

d
2
)Q

1
(R

2 1
(x

d
2
))

,

R
2 1
: =

λ
(x

d
2
)λ
(x

d
1
)R

2 0
(x

d
2
)(
x
d
1
),

R
2 0
: =

λ
(x

d
2
)λ
(x

d
1
)h
(p

′ 1
(x

d
1
))
(p

′ 2
(x

d
2
))

,

Q
1
: =

q 1
(d

1
),

q 1
: =

so
m
e
,
d
1
: =

d
og

,

Q
2
: =

q 2
(d

2
),

q 2
: =

e
v
e
ry
,
d
2
: =

ca
t
,

h
: =

h
u
g

,
p
′ 1
: =

λ
(x
)(
x
),

p
′ 2
: =

λ
(x
)(
x
)
}                

                                          

(n
2
)

N
P
Q

2

2

                S
Y

N

   H
E

A
D

4

V
A

L

[ C
O

M
P

S
〈
〉

S
P

R
〈
〉]
   

S
E

M

       L
-T

Y
P

E
(ẽ

→
t̃)

→
t̃

T
E

R
M

    Q
2

T
-H

E
A

D
q 2
(d

2
)

W
H

E
R

E
{
q 2

: =
e
v
e
ry

,

d
2
: =

ca
t
}

           

                

3

           S
Y

N

    H
E

A
D

[ d
et
]

V
A

L

[ S
P

R
〈
〉

C
O

M
P

S
〈
〉]

    

S
E

M

  T
E

R
M

[ T
-H

E
A

D
e
v
e
ry

W
H

E
R

E
{
}

] 

           

ev
er

y

H

              S
Y

N

     H
E

A
D

4

[
n
o
u
n
]

V
A

L

 S
P

R

〈
3

〉

C
O

M
P

S
〈
〉

      

S
E

M

   L
-T

Y
P

E
(ẽ

→
t̃)

T
E

R
M

[ T
-H

E
A

D
ca
t

W
H

E
R

E
{
}

]   

              

ca
t

(n
1
)

V
P

                            S
Y

N

    H
E

A
D

[ v
er

b
]

V
A

L

[ S
P

R
〈
2
Q

2
〉

C
O

M
P

S
〈
〉

]    

S
Y

N
S

E
M

[ Q
1
rB

in
d
p
′ 1
,
R

1 1
rB

in
d
p
′ 1
,
Q

2
rB

in
d
p
2

]

S
E

M

               L
-T

Y
P

E
t̃

T
E

R
M

            R
1 2

T
-H

E
A

D
l 1

W
H

E
R

E
{
l 1

: =
Q

1
(R

1 1
),

R
1 1
: =

λ
(x

d
1
)R

1 0
(x

d
1
),

R
1 0
: =

λ
(x

d
1
)h
(p

′ 1
(x

d
1
))
(p

2
),

Q
1
: =

q 1
(d

1
),
q 1

: =
so
m
e
,
d
1
: =

d
og

,

h
: =

h
u
g

,
p
′ 1
: =

λ
(x
)(
x
)
}

                           

                            

(n
3
)

V

                         w
o
rd

S
Y

N

    H
E

A
D

[ v
er

b
]

V
A

L

[ S
P

R
〈
2
Q

2
〉

C
O

M
P

S
〈
1
Q

1
〉]

    

S
Y

N
S

E
M

[ Q
1
rB

in
d
p
1
,Q

2
rB

in
d
p
2
,
]

S
E

M

          s
em

-c
a
t

L
-T

Y
P

E
t̃ h
:
(ẽ

→
(ẽ

→
t̃)
)

T
E

R
M

  R
0 0

T
-H

E
A

D
h
(p

1
)(
p
2
)

W
H

E
R

E
{
h
: =

h
u
g
}

            

                         

h
u
g
s

(n
5
)

N
P
Q

1

1

                S
Y

N

   H
E

A
D

5

V
A

L

[ C
O

M
P

S
〈
〉

S
P

R
〈
〉]
   

S
E

M

       L
-T

Y
P

E
(ẽ

→
t̃)

→
t̃

T
E

R
M

    Q
1

T
-H

E
A

D
q 1
(d

1
)

W
H

E
R

E
{
q 1

: =
so
m
e

,

d
1
: =

d
og

}

           

                

so
m

e
d
o
g

F
ig

u
re

4
:

S
p
ec

ifi
ca

ti
o
n
:

Q
u
an

ti
fi

er
N

P
as

S
u
b
je

ct
an

d
Q

u
an

ti
fi

er
N

P
as

C
o
m

p
le

m
en

t:
d
e

d
ic

to



47

(n
0
)

S

                           S
Y

N

  V
A

L

[ S
P

R
〈
〉

C
O

M
P

S
〈
〉]
 

S
Y

N
S

E
M

[ l
1
rB

in
d
T

,
l 2

rB
in
d
T

,

Q
1
rB

in
d
p
1
,
R

1
rB

in
d
p
1
,Q

2
rB

in
d
p
2
,R

2
rB

in
d
p
2

]

S
E

M

               L
-T

Y
P

E
t̃

T
E

R
M

            R
3

T
-H

E
A

D
T

W
H

E
R

E
{
l 1

: =
Q

1
(R

1
),
l 2

: =
Q

2
(R

2
),

Q
1
: =

q 1
(d

1
),
q 1

: =
so
m
e
,
d
1
: =

d
og

,

Q
2
: =

q 2
(d

2
),
q 2

: =
e
v
e
ry
,
d
2
: =

ca
t
,

R
2 0
: =

λ
(x

d
2
)λ
(x

d
1
)h
(p

′ 1
(x

d
1
))
(p

′ 2
(x

d
2
))

,

h
: =

h
u
g
}

                           

                           

(n
2
)

N
P
Q

2

2

                S
Y

N

   H
E

A
D

4

V
A

L

[ C
O

M
P

S
〈
〉

S
P

R
〈
〉]
   

S
E

M

       L
-T

Y
P

E
((
ẽ
→

t̃)
→

t̃)

T
E

R
M

    Q
2

T
-H

E
A

D
q 2
(d

2
)

W
H

E
R

E
{
q 2

: =
e
v
e
ry

,

d
2
: =

ca
t
}

           

                

3

           S
Y

N

    H
E

A
D

[ d
et
]

V
A

L

[ S
P

R
〈
〉

C
O

M
P

S
〈
〉]

    

S
E

M

  T
E

R
M

[ T
-H

E
A

D
e
v
e
ry

W
H

E
R

E
{
}

] 

           

ev
er

y

H

              S
Y

N

     H
E

A
D

4

[ n
o
u
n
]

V
A

L

 S
P

R

〈
3

〉

C
O

M
P

S
〈
〉

      

S
E

M

   L
-T

Y
P

E
(ẽ

→
t̃)

T
E

R
M

[ T
-H

E
A

D
ca
t

W
H

E
R

E
{
}

]   

              

ca
t

(n
1
)

V
P

                           S
Y

N

    H
E

A
D

[ v
er

b
]

V
A

L

[ S
P

R
〈
2
Q

2
〉

C
O

M
P

S
〈
〉

]    

S
Y

N
S

E
M

[ Q
2
rB

in
d
p
′ 2
,
l 1

rB
in
d
T
1
,

Q
1
rB

in
d
p
′ 1
,
R

1
rB

in
d
p
′ 1

]

S
E

M

            L
-T

Y
P

E
(ẽ

→
t̃)

T
E

R
M

         T
′ 1

T
-H

E
A

D
T
1

W
H

E
R

E
{
l 1

: =
Q

1
(R

1
),

Q
1
: =

q 1
(d

1
),
q 1

: =
so
m
e
,
d
1
: =

d
og

,

R
2 0
: =

λ
(x

d
2
)λ
(x

d
1
)h
(p

′ 1
(x

d
1
))
(p

′ 2
(x

d
2
))

h
: =

h
u
g
}

                     

                           

(n
3
)

V

                         w
o
rd

S
Y

N

    H
E

A
D

[ v
er

b
]

V
A

L

[ S
P

R
〈
2
Q

2
〉

C
O

M
P

S
〈
1
Q

1
〉]

    

S
Y

N
S

E
M

[ Q
1
rB

in
d
p
′ 1
,Q

2
rB

in
d
p
′ 2
,
]

S
E

M

          s
em

-c
a
t

L
-T

Y
P

E
(ẽ

→
(ẽ

→
t̃)
)

h
:
(ẽ

→
(ẽ

→
t̃)
)

T
E

R
M

  R
2 0

T
-H

E
A

D
λ
(x

d
2
)λ
(x

d
1
)h
(p

′ 1
(x

d
1
))
(p

′ 2
(x

d
2
))

W
H

E
R

E
{
h
: =

h
u
g
}

            

                         

h
u
g
s

(n
4
)

N
P
Q

1

1

                S
Y

N

   H
E

A
D

5

V
A

L

[ C
O

M
P

S
〈
〉

S
P

R
〈
〉]
   

S
E

M

       L
-T

Y
P

E
(ẽ

→
t̃)

→
t̃

T
E

R
M

    Q
1

T
-H

E
A

D
q 1
(d

1
)

W
H

E
R

E
{
q 1

: =
so
m
e

,

d
1
: =

d
og

}

           

                

so
m

e
d
o
g

F
ig

u
re

5
:

U
n
d
er

sp
ec

ifi
ed

S
co

p
e:

Q
u
an

ti
fi

er
N

P
as

S
u
b
je

ct
an

d
Q

u
an

ti
fi

er
N

P
as

C
o
m

p
le

m
en

t:
v
ia
λ

-a
b
st

ra
ct

io
n



48

Loukanova, R. (2011b). Syntax-Semantics Interface for Lexical Inflection with the Language of Acyclic

Recursion. In G. Bel-Enguix, V. Dahl, and M. D. Jiménez-López (Eds.), Biology, Computation and

Linguistics — New Interdisciplinary Paradigms, Volume 228 of Frontiers in Artificial Intelligence and

Applications, pp. 215–236. Amsterdam; Berlin; Tokyo; Washington, DC: IOS Press.

Loukanova, R. (2016). Relationships between Specified and Underspecified Quantification by the The-

ory of Acyclic Recursion. ADCAIJ: Advances in Distributed Computing and Artificial Intelligence

Journal 5(4), 19–42.

Loukanova, R. (2017a). An Approach to Functional Formal Models of Constraint-Based Lexicalized

Grammar (CBLG). Fundamenta Informaticae 152(4), 341–372.

Loukanova, R. (2017b). Binding Operators in Type-Theory of Algorithms for Algorithmic Binding of

Functional Neuro-Receptors. In M. Ganzha, L. Maciaszek, and M. Paprzycki (Eds.), Proceedings of

the 2017 Federated Conference on Computer Science and Information Systems, Volume 11 of Annals

of Computer Science and Information Systems, pp. 57–66. Polish Information Processing Society.

Loukanova, R. (2018). γ-Reduction in Type Theory of Acyclic Recursion. to appear.

Loukanova, R. (2019). Gamma-star canonical forms in the type-theory of acyclic algorithms. In

J. van den Herik and A. P. Rocha (Eds.), Agents and Artificial Intelligence, Cham, pp. 383–407.

Springer International Publishing.

Moortgat, M. (1996). Categorial type logics. In J. van Benthem and A. ter Meulen (Eds.), Handbook of

Logic and Language, pp. 93–177. Amsterdam: Elsevier.

Moschovakis, Y. N. (2006). A Logical Calculus of Meaning and Synonymy. Linguistics and Philoso-

phy 29(1), 27–89.

Pollard, C. and I. A. Sag (1994). Head-Driven Phrase Structure Grammar. Chicago, IL: University of

Chicago Press.

Ranta, A. (2011). Grammatical Framework: Programming with Multilingual Grammars. Stanford:

CSLI Publications.

Sag, I. A., T. Wasow, and E. M. Bender (2003). Syntactic Theory: A Formal Introduction. Stanford,

California: CSLI Publications.

Vijay-Shanker, K. and D. J. Weir (1994, November). The equivalence of four extensions of context-free

grammars. Mathematical Systems Theory 27(6), 511–546.


	Introduction
	Overview of Moschovakis Type-Theory of Acyclic Recursion
	Syntax of LAR 

	Underspecified Terms and Universal Syntax
	Syntax-Semantics Interface in GCBLG by the Type-Theory of Acyclic Recursion
	Scope Underspecification and Specification
	Grammar Analyses with Syntax-Semantics Interface in GCBLG
	Conclusions and Future Work

