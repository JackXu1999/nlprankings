



















































EGG: a toolkit for research on Emergence of lanGuage in Games


Proceedings of the 2019 EMNLP and the 9th IJCNLP (System Demonstrations), pages 55–60
Hong Kong, China, November 3 – 7, 2019. c©2019 Association for Computational Linguistics

55

EGG: a toolkit for research on Emergence of lanGuage in Games

Eugene Kharitonov
Facebook AI

kharitonov@fb.com

Rahma Chaabouni
Facebook AI Research / LSCP
rchaabouni@fb.com

Diane Bouchacourt
Facebook AI

dianeb@fb.com

Marco Baroni
Facebook AI / ICREA
mbaroni@fb.com

Abstract

There is renewed interest in simulating lan-
guage emergence among deep neural agents
that communicate to jointly solve a task,
spurred by the practical aim to develop
language-enabled interactive AIs, as well as
by theoretical questions about the evolution of
human language. However, optimizing deep
architectures connected by a discrete commu-
nication channel (such as that in which lan-
guage emerges) is technically challenging. We
introduce EGG, a toolkit that greatly simpli-
fies the implementation of emergent-language
communication games. EGG’s modular de-
sign provides a set of building blocks that the
user can combine to create new games, eas-
ily navigating the optimization and architec-
ture space. We hope that the tool will lower the
technical barrier, and encourage researchers
from various backgrounds to do original work
in this exciting area.

1 Introduction

Studying the languages that emerge when neural
agents interact with each other recently became
a vibrant area of research (Havrylov and Titov,
2017; Lazaridou et al., 2016, 2018; Kottur et al.,
2017; Bouchacourt and Baroni, 2018; Lowe et al.,
2019). Interest in this scenario is fueled by the
hypothesis that the ability to interact through a
human-like language is a prerequisite for genuine
AI (Mikolov et al., 2016; Chevalier-Boisvert et al.,
2019). Furthermore, such simulations might lead
to a better understanding of both standard NLP
models (Chaabouni et al., 2019b) and the evolu-
tion of human language itself (Kirby, 2002).

For all its promise, research in this domain
is technically very challenging, due to the dis-
crete nature of communication. The latter pre-

A screencast demonstration of EGG is available at
https://vimeo.com/345470060

vents the use of conventional optimization meth-
ods, requiring either Reinforcement Learning al-
gorithms (e.g., REINFORCE; Williams 1992) or
the Gumbel-Softmax relaxation (Maddison et al.,
2016; Jang et al., 2016). The technical challenge
might be particularly daunting for researchers
whose expertise is not in machine learning, but
in fields such as linguistics and cognitive science,
that could contribute to this interdisciplinary re-
search area.

To lower the starting barrier and encourage
high-level research in this domain, we introduce
the EGG (Emergence of lanGuage in Games)
toolkit. EGG aims at

1. Providing reliable building bricks for quick
prototyping;

2. Serving as a library of pre-implemented
games;

3. Providing tools for analyzing the emergent
languages.

EGG is implemented in PyTorch (Paszke et al.,
2017) and it is licensed under the MIT license.
EGG can be installed from https://github.
com/facebookresearch/EGG.

Notable features of EGG include: (a) Prim-
itives for implementing single-symbol or
variable-length communication (with vanilla
RNNs (Elman, 1990), GRUs (Cho et al., 2014),
LSTMs (Hochreiter and Schmidhuber, 1997));1

(b) Training with optimization of the com-
munication channel through REINFORCE or
Gumbel-Softmax relaxation via a common
interface; (c) Simplified configuration of the
general components, such as check-pointing,
optimization, Tensorboard support,2 etc.; (d)

1EGG also provides an experimental support of Trans-
formers (Vaswani et al., 2017).

2https://www.tensorflow.org/
tensorboard

https://vimeo.com/345470060
https://github.com/facebookresearch/EGG
https://github.com/facebookresearch/EGG
https://www.tensorflow.org/tensorboard
https://www.tensorflow.org/tensorboard


56

A simple CUDA-aware command-line tool for
hyperparameter grid-search.

2 EGG’s architecture

In the first iteration of EGG, we concentrate on a
simple class of games, involving a single, unidi-
rectional (Sender → Receiver) message. In turn,
messages can be either single-symbol or multi-
symbol variable-length sequences. Our motiva-
tion for starting with this setup is two-fold. First,
it corresponds to classic signaling games (Lewis,
1969), it already covers a large portion of the lit-
erature (e.g., 5 out of 6 relevant studies mentioned
in Introduction) and it allows exploring many in-
teresting research questions. Second, it constitutes
a natural first step for further development; in par-
ticular, the majority of components should remain
useful in multi-directional, multi-step setups.

2.1 Design principles

As different training methods and architectures are
used in the literature, our primary goal is to pro-
vide EGG users with the ability to easily navigate
the space of common design choices.

Building up on this idea, EGG makes switching
between Gumbel-Softmax relaxation-based and
REINFORCE-based training effortless, through
the simple choice of a different wrapper. Simi-
larly, one can switch between one-symbol commu-
nication and variable-length messages with little
changes in the code.3

We aim to maintain EGG minimalist and “hack-
able” by encapsulating the user-implemented
agent architectures, the Reinforce/GS agent wrap-
pers and the game logic into PyTorch modules.
The user can easily replace any part.

Finally, since virtually any machine-learning
experiment has common pieces, such as setting the
random seeds, configuring the optimizer, model
check-pointing, etc., EGG pre-implements many
of them, reducing the necessary amount of boiler-
plate code to the minimum.

2.2 EGG design

EGG, in its first iteration, operates over the follow-
ing entities. Firstly, there are two distinct agent
roles: Sender and Receiver. Sender and Receiver

3This also proved to be a convenient debugging mecha-
nism, as single-symbol communication is typically simpler
to train.

SymbolGameReinforce
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

RFAgentWrapper
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Sender
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Receiver
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Channel
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Inputs
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Sender Inputs
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Receiver Inputs
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Receiver Outputs
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

RFAgentWrapper
<latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit><latexit sha1_base64="(null)">(null)</latexit>

Figure 1: Example of EGG’s game flow when using
REINFORCE. White boxes (Sender and Receiver) rep-
resent the user-implemented agent architectures. The
colored boxes are EGG-provided wrappers that im-
plement a REINFORCE-based scenario. For exam-
ple, SymbolGameReinforce is an instance of the Game
block. It sets up single-symbol Sender/Receiver game
optimized with REINFORCE. To use Gumbel-Softmax
relaxation-based training instead, the user only has to
change the EGG-provided wrappers.

are connected via a one-directional communica-
tion channel from the former to the latter, that has
to produce the game-specific output.

The next crucial entity is Game. It encapsu-
lates the agents and orchestrates the game sce-
nario: feeding the data to the agents, transmitting
the messages, and getting the output of Receiver.
Figure 1 illustrates EGG’s game flow in a specific
example. Game applies a user-provided loss func-
tion, which might depend on the outputs of Re-
ceiver, the message transmitted, and the data. The
value of the loss is minimized by a fourth entity,
Trainer. Trainer also controls model checkpoint-
ing, early stopping, etc.

The Trainer and Game modules are pre-
implemented in EGG. In a typical scenario, the
communication method (single or multiple symbol
messages) will be implemented by EGG-provided
wrappers. As a result, what is left for the user to
implement consists of: (a) the data stream, (b) core
(non-communication-related) parts of the agents,
(c) the loss. The data interface that is expected by
Trainer is an instance of the standard PyTorch data
loader utils.data.DataLoader.

To implement Sender, the user must define a
module that consumes the data and outputs a ten-
sor. On Receiver’s side, the user has to imple-
ment a module that takes an input consisting of a
message embedding and possibly further data, and
generates Receiver’s output.

Section 4 below provides examples of how to
implement agents, choose communication and op-
timization type, and train a game.



57

Figure 2: MNIST game: Defining and instantiating the
user-defined parts of the agents’ architecture.

3 Optimizing the communication
channel in EGG

EGG supports two widely adopted strategies for
learning with a discrete channel, Gumbel-Softmax
relaxation (used, e.g., by Havrylov and Titov
(2017)) and REINFORCE (used, e.g., by Lazari-
dou et al. (2016)). Below, we briefly review both
of them.

Gumbel-Softmax relaxation is based on the
Gumbel-Softmax (GS) (aka Concrete) distribu-
tion (Maddison et al., 2016; Jang et al., 2016),
that allows to approximate one-hot samples
from a Categorical distribution. At the same
time, GS admits reparametrization, hence allows
backpropagation-based training. Suppose that
Sender produces a distribution over the vocab-
ulary, with ith symbol having probability pi =
S(is). To obtain a sample from a corresponding
Gumbel-Softmax distribution, we take i.i.d. sam-
ples gi from the Gumbel(0, 1) distribution and
obtain the vector y with components yi:

yi =
exp((log pi + gi)/τ)∑
j exp((log pj + gj)/τ)

(1)

where τ is the temperature hyperparameter, which
controls the degree of relaxation. We treat y as
a relaxed symbol representation. In the case of
single-symbol communication, the embedding of
y is passed to Receiver. In case of variable-length
messages, the embedding is also fed into a RNN
cell to generate the next symbol in the message.

As a result, if Receiver and the game loss are
differentiable w.r.t. their inputs, we can get gra-
dients of all game parameters, including those of
Sender, via conventional backpropagation.

REINFORCE (Williams and Peng, 1991) is a
standard Reinforcement Learning algorithm. As-

sume that both agents are stochastic: Sender sam-
ples a message m, and Receiver samples its out-
put o. Let us fix a pair of inputs, is, ir, and
the ground-truth output l. Then, using the log-
gradient “trick”, the gradient of the expectation of
the loss L w.r.t. the vector of agents’ parameters
θ = θs

⊔
θr is:

Em,o [L(o, l)∇θ logP(m,o|θ)] (2)

where P(m,o|θ) specifies the joint probability
distribution over the agents’ outputs.

The gradient estimate is found by sampling
messages and outputs. A standard trick to reduce
variance of the estimator in Eq. 2 is to subtract
an action-independent baseline b from the opti-
mized loss (Williams, 1992). EGG uses the run-
ning mean baseline.

Importantly, the estimator in Eq. 2 allows us to
optimize agents even if the loss is not differen-
tiable (e.g., 0/1 loss). However, if the loss is dif-
ferentiable and Receiver is differentiable and de-
terministic, this can be leveraged by a “hybrid”
approach: the gradient of Receiver’s parameters
can be found by backpropagation, while Sender
is optimized with REINFORCE. This approach, a
special case of gradient estimation using stochas-
tic computation graphs as proposed by Schulman
et al. (2015), is also supported in EGG.

4 Implementing a game

In this Section we walk through the main steps to
build a communication game in EGG. We illus-
trate them through a MNIST (LeCun et al., 1998)
communication-based autoencoding task: Sender
observes an image and sends a message to Re-
ceiver. In turn, Receiver tries to reconstruct the
image. We only cover here the core aspects of the
implementation, ignoring standard pre- and post-
processing steps, such as data loading. The full
implementation can be found in an online tuto-
rial.4

We start by implementing the agents’ architec-
tures, as shown in Figure 2. Sender is passed
an input image to be processed by its pre-trained
vision module, and returns its output after a lin-
ear transformation. The way Sender’s output will
be interpreted depends on the type of communica-
tion to be used (discussed below). Receiver gets

4 https://colab.research.google.com/
github/facebookresearch/EGG/blob/master/
tutorials/EGG%20walkthrough%20with%20a%
20MNIST%20autoencoder.ipynb

https://colab.research.google.com/github/facebookresearch/EGG/blob/master/tutorials/EGG%20walkthrough%20with%20a%20MNIST%20autoencoder.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/tutorials/EGG%20walkthrough%20with%20a%20MNIST%20autoencoder.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/tutorials/EGG%20walkthrough%20with%20a%20MNIST%20autoencoder.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/tutorials/EGG%20walkthrough%20with%20a%20MNIST%20autoencoder.ipynb


58

(a) Single-symbol communication, Gumbel-Softmax
relaxation.

(b) Single-symbol communication, REINFORCE.

(c) Variable-length communication, Gumbel-Softmax
relaxation.

(d) Variable-length communication, REINFORCE.

Figure 3: MNIST game: The user can choose different communication wrappers to switch between training
regimes (Gumbel-Softmax or REINFORCE) and communication type (single-symbol or variable-length mes-
sages).

Figure 4: MNIST game: Once the agents and the game
are instantiated, the user must pass them to a Trainer,
which implements the training/validation loop, check-
pointing, etc.

an input from Sender and returns an image-sized
output with pixels valued in [0; 1]. Again, depend-
ing on the type of channel employed, the Receiver
input will have a different semantics.

In the case of one-symbol communication,
Sender’s output is passed through a softmax
layer and its output is interpreted as the probabil-
ities of sending a particular symbol. Hence, the
output dimensionality defines the size of the vo-
cabulary. In the case of variable-length messages,
Sender’s output specifies the initial hidden state of
an RNN cell. This cell is then “unrolled” to gen-
erate a message, until the end-of-sequence symbol
(eos) is produced or maximum length is reached.
Receiver’s input is an embedding of the message:
either the embedding of the single-symbol mes-
sage, or the last hidden state of the RNN cell that
corresponds to the eos symbol.

Once Sender and Receiver are defined, the
user wraps them into EGG-implemented wrap-
pers which determine the communication and
optimization scenarios. Importantly, the ac-
tual user-specified Sender and Receiver archi-
tectures can be agnostic to whether single-
symbol or variable-length communication is used;
and to whether Gumbel-Softmax relaxation- or
REINFORCE-based training is performed. In
Figure 3 we illustrate different communica-
tion/training scenarios: (a) single-symbol com-

munication, trained with Gumbel-Softmax relax-
ation, (b) single-symbol communication, trained
with REINFORCE, (c) variable-length communi-
cation, trained with Gumbel-Softmax relaxation,
(d) variable-length communication, trained with
REINFORCE.

Once the Game instance is defined, everything
is ready for training. That is, the user has to pass
the game instance to core.Trainer, as shown
in Figure 4.

We report some results obtained with the code
we just described. We used the following param-
eters. The vision module is a pre-trained LeNet-
1 (LeCun et al., 1990) instance, the maximal mes-
sage length is set to 2, the communication be-
tween the agents is done through LSTM units with
hidden-size 20, vocabulary size is 10. The agents
are trained with REINFORCE for 15 epochs with
batch size of 32, and the loss is per-pixel cross-
entropy.

In Figure 5 we illustrate the language that
emerges in this setup. To do this, we enumerate
all possible 100 two-symbol messages x, y and in-
put them to Receiver. We report all images that
Receiver produces. The eos symbol is fixed to be
0, hence if the first symbol is 0 then the second
symbol is ignored (top row of Figure 5).

Note that the first symbol x tends to denote
digit identity: x ∈ {2, 4, 7, 8, 9}. In contrast, the
second symbol y is either ignored (x ∈ {4, 8})
or specifies the style of the produced digit (x ∈
{3, 7}). The second symbol has the most striking
effect with x = 7, where y encodes the rotation
angle of the digit 1.



59

Figure 5: The emergent code-book in the MNIST auto-
encoder game. After training, we feed all 100 possible
two-symbol messages xy from the size-10 vocabulary
to Receiver and show the returned images. The rows
iterate over the first symbol x, the columns enumerate
the second symbol, y. The eos symbol has id 0.

5 Some pre-implemented games

EGG contains implementations of several games.
They (a) illustrate how EGG can be used to ex-
plore interesting research questions, (b) provide
reference usage patterns and building blocks, (c)
serve as means to ensure reproducibility of stud-
ies reported in the literature. For example, EGG
incorporates an implementation of the signaling
game of Lazaridou et al. (2016) and Bouchacourt
and Baroni (2018). It contains code that was re-
cently used to study the communicative efficiency
of artificial LSTM-based agents (Chaabouni et al.,
2019a) and the information-minimization proper-
ties of emergent discrete codes (Kharitonov et al.,
2019).5 Finally, EGG provides a pre-implemented
game that allows to train agents entirely via
the command line and external input/output files,
without having to write a single line of Python
code. We hope this will lower the learning curve
for those who want to experiment with language
emergence without previous coding experience.

6 Conclusion and future work

We introduced EGG, a toolkit for research on
emergence of language in games. We outlined its
main features design principles. Next, we briefly

5A small illustration can be run in Google Colab-
oratory: https://colab.research.google.
com/github/facebookresearch/EGG/blob/
master/egg/zoo/language_bottleneck/
mnist-style-transfer-via-bottleneck.
ipynb.

reviewed how training with a discrete communi-
cation channel is performed. Finally, we walked
through the main steps for implementing a MNIST
autoencoding game using EGG.

We intend to extend EGG in the following direc-
tions. First, we want to provide support for multi-
direction and multi-step communicative scenarios.
Second, we want to add more advanced tooling
for analyzing the properties of the emergent lan-
guages (such as compositionality; Andreas 2019).
We will also continue to enlarge the set of pre-
implemented games, to build a library of reference
implementations.

Acknowledgments

We are grateful to Roberto Dessı̀ and Tomek Ko-
rbak for their contributions to the EGG codebase
and to Serhii Havrylov for sharing his code with
us.

References
Jacob Andreas. 2019. Measuring compositionality in

representation learning. In ICLR, New Orleans, LA.

Diane Bouchacourt and Marco Baroni. 2018. How
agents see things: On visual representations in an
emergent language game. In EMNLP.

Rahma Chaabouni, Eugene Kharitonov, Emmanuel
Dupoux, and Marco Baroni. 2019a. Anti-efficient
encoding in emergent communication. arXiv
preprint arXiv:1905.12561.

Rahma Chaabouni, Eugene Kharitonov, Alessandro
Lazaric, Emmanuel Dupoux, and Marco Baroni.
2019b. Word-order biases in deep-agent emergent
communication. In ACL.

Maxime Chevalier-Boisvert, Dzmitry Bahdanau,
Salem Lahlou, Lucas Willems, Chitwan Saharia,
Thien Huu Nguyen, and Yoshua Bengio. 2019.
BabyAI: First steps towards grounded language
learning with a human in the loop. In International
Conference on Learning Representations.

Kyunghyun Cho, Bart Van Merriënboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Holger
Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using rnn encoder-decoder
for statistical machine translation. arXiv preprint
arXiv:1406.1078.

Jeffrey Elman. 1990. Finding structure in time. Cogni-
tive Science, 14:179–211.

Serhii Havrylov and Ivan Titov. 2017. Emergence of
language with multi-agent games: Learning to com-
municate with sequences of symbols. In NIPS.

https://colab.research.google.com/github/facebookresearch/EGG/blob/master/egg/zoo/language_bottleneck/mnist-style-transfer-via-bottleneck.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/egg/zoo/language_bottleneck/mnist-style-transfer-via-bottleneck.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/egg/zoo/language_bottleneck/mnist-style-transfer-via-bottleneck.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/egg/zoo/language_bottleneck/mnist-style-transfer-via-bottleneck.ipynb
https://colab.research.google.com/github/facebookresearch/EGG/blob/master/egg/zoo/language_bottleneck/mnist-style-transfer-via-bottleneck.ipynb
https://openreview.net/forum?id=rJeXCo0cYX
https://openreview.net/forum?id=rJeXCo0cYX


60

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural computation,
9(8):1735–1780.

Eric Jang, Shixiang Gu, and Ben Poole. 2016. Cat-
egorical reparameterization with Gumbel-Softmax.
arXiv preprint arXiv:1611.01144.

Eugene Kharitonov, Rahma Chaabouni, Diane Boucha-
court, and Marco Baroni. 2019. Information min-
imization in emergent languages. arXiv preprint
arXiv:1905.13687.

Simon Kirby. 2002. Natural language from artificial
life. Artificial life, 8(2):185–215.

Satwik Kottur, José MF Moura, Stefan Lee, and
Dhruv Batra. 2017. Natural language does not
emerge’naturally’in multi-agent dialog. arXiv
preprint arXiv:1706.08502.

Angeliki Lazaridou, Karl Moritz Hermann, Karl
Tuyls, and Stephen Clark. 2018. Emergence of
linguistic communication from referential games
with symbolic and pixel input. arXiv preprint
arXiv:1804.03984.

Angeliki Lazaridou, Alexander Peysakhovich, and
Marco Baroni. 2016. Multi-agent cooperation and
the emergence of (natural) language. arXiv preprint
arXiv:1612.07182.

Yann LeCun, Bernhard E Boser, John S Denker, Don-
nie Henderson, Richard E Howard, Wayne E Hub-
bard, and Lawrence D Jackel. 1990. Handwritten
digit recognition with a back-propagation network.
In NIPS.

Yann LeCun, Léon Bottou, Yoshua Bengio, Patrick
Haffner, et al. 1998. Gradient-based learning ap-
plied to document recognition. Proceedings of the
IEEE, 86(11):2278–2324.

David Lewis. 1969. Convention. Harvard University
Press, Cambridge, MA.

Ryan Lowe, Jakob Foerster, Y-Lan Boureau, Joelle
Pineau, and Yann Dauphin. 2019. On the pitfalls of
measuring emergent communication. arXiv preprint
arXiv:1903.05168.

Chris J Maddison, Andriy Mnih, and Yee Whye Teh.
2016. The concrete distribution: A continuous
relaxation of discrete random variables. arXiv
preprint arXiv:1611.00712.

Tomas Mikolov, Armand Joulin, and Marco Baroni.
2016. A roadmap towards machine intelligence.
In International Conference on Intelligent Text Pro-
cessing and Computational Linguistics, pages 29–
61. Springer.

Adam Paszke, Sam Gross, Soumith Chintala, Gre-
gory Chanan, Edward Yang, Zachary DeVito, Zem-
ing Lin, Alban Desmaison, Luca Antiga, and Adam
Lerer. 2017. Automatic differentiation in pytorch.
In NIPS-W.

John Schulman, Nicolas Heess, Theophane Weber, and
Pieter Abbeel. 2015. Gradient estimation using
stochastic computation graphs. In NIPS.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In NIPS.

Ronald J Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine learning, 8(3-4):229–256.

Ronald J Williams and Jing Peng. 1991. Function opti-
mization using connectionist reinforcement learning
algorithms. Connection Science, 3(3):241–268.


