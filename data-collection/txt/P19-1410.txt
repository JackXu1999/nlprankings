



















































A Unified Linear-Time Framework for Sentence-Level Discourse Parsing


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 4190–4200
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

4190

A Unified Linear-Time Framework for Sentence-Level Discourse Parsing

Xiang Lin∗¶, Shafiq Joty∗¶§, Prathyusha Jwalapuram¶ and M Saiful Bari¶
¶Nanyang Technological University, Singapore

§Salesforce Research Asia, Singapore
{linx0057@e., srjoty@, jwal0001@e., bari0001@e.}ntu.edu.sg

Abstract

We propose an efficient neural framework
for sentence-level discourse analysis in ac-
cordance with Rhetorical Structure Theory
(RST). Our framework comprises a discourse
segmenter to identify the elementary discourse
units (EDU) in a text, and a discourse parser
that constructs a discourse tree in a top-down
fashion. Both the segmenter and the parser are
based on Pointer Networks and operate in lin-
ear time. Our segmenter yields an F1 score of
95.4, and our parser achieves an F1 score of
81.7 on the aggregated labeled (relation) met-
ric, surpassing previous approaches by a good
margin and approaching human agreement on
both tasks (98.3 and 83.0 F1).

1 Introduction

Coherence analysis of a text is a fundamental task
in Natural Language Processing that can benefit
many downstream applications. Rhetorical Struc-
ture Theory or RST (Mann and Thompson, 1988)
is one of the most influential theories of text coher-
ence. According to RST, a text is represented by a
hierarchical structure known as a Discourse Tree
(DT). As exemplified in Figure 1, the leaves of
a DT correspond to contiguous atomic text spans
called Elementary Discourse Units (EDUs). The
adjacent EDUs and larger units are recursively
connected by certain coherence relations (e.g., AT-
TRIBUTION, EXPLANATION). The discourse units
connected by a relation are further categorized
based on their relative importance: NUCLEUS
refers to the core part(s), while SATELLITE refers
to the peripheral one. Coherence analysis in RST
involves two subtasks: (i) breaking the text into a
sequence of EDUs, referred to as Discourse Seg-
mentation, and (ii) linking the EDUs into a DT,
referred to as Discourse Parsing.

∗*equal contribution

CONDITION

ATTRIBUTION

e1

S
e2

N

N

TEMPORAL

e3

N
e4

N

S

[The Treasury also said]e1 [noncompetitive tenders will be

considered timely]e2 [if postmarked no later than Sunday,

Oct.29,]e3 [and received no later than tomorrow.]e4

Figure 1: An example discourse tree with four EDUs.

In this paper we consider sentence-level coher-
ence analysis, which involves discourse segmen-
tation and sentence-level parsing. For example,
consider the DT in figure 1 for the sentence “The
Treasury also said noncompetitive tenders will be
considered timely if postmarked no later than Sun-
day, Oct.29, and received no later than tomorrow.”,
which has four EDUs as shown below the tree.
Such sentence-level discourse annotations have
been shown to be beneficial for a number of ap-
plications including machine translation (Guzmán
et al., 2014) and sentence compression (Sporleder
and Lapata, 2005). Furthermore, sentence-level
analysis is considered to be a crucial step towards
full text-level analysis. For example, automatic
discourse segmentation has been shown to be the
main source of inaccuracies in discourse parsing
(Soricut and Marcu, 2003; Joty et al., 2012), and
sentence-level parsing is considered as an essential
first step in many existing discourse parsers (Feng
and Hirst, 2014b; Joty et al., 2015) including the
state-of-the-art one (Wang et al., 2017).

While earlier methods have mostly relied on
hand-crafted lexical and syntactic features, re-
cently researchers have shown competitive or even
better results with neural models. One of the cru-
cial advantages of neural models is that they can
learn the feature representation of the discourse



4191

units in an end-to-end fashion. This capability is
particularly enhanced through the use of effective
pretrained word embeddings such as Glove (Pen-
nington et al., 2014) that provide better general-
ization. Despite this, successful discourse parsers
(Li et al., 2014; Ji and Eisenstein, 2014; Li et al.,
2016) still needed to use hand-engineered features
to outperform the non-neural models.

Another important distinction between exist-
ing methods is whether they employ a greedy
transition-based algorithm (Marcu, 1999; Feng
and Hirst, 2012, 2014b; Ji and Eisenstein, 2014;
Braud et al., 2017; Li et al., 2016; Wang et al.,
2017) or a globally optimized chart parsing al-
gorithm (Soricut and Marcu, 2003; Li et al., 2014;
Joty et al., 2015). Transition-based parsers build
the tree incrementally by making a series of shift-
reduce action decisions. The advantage of this
method is that the parsing time is linear with re-
spect to the number of EDUs (Sagae, 2009). The
limitation, however, is that the decisions made at
each step are based on local information, causing
error propagation to subsequent steps. Also, when
humans are asked to perform discourse analysis
(segmentation and parsing), they tend to under-
stand the full text first, before executing the tasks.

Methods based on chart parsing, on the other
hand, learn scoring functions for discourse sub-
trees and perform dynamic programming search
over all possible trees to find the most probable
tree for a text. While these methods are more ac-
curate than greedy parsers, they are generally slow,
having a time complexity of O(n3M) for n EDUs
and M different relations (Joty et al., 2015).

In this paper, we propose a unified neural
framework for discourse segmentation and parsing
based on Pointer Networks (Vinyals et al., 2015).
Our parser employs a transition-based procedure
to construct a discourse tree in a top-down fash-
ion with the same computational efficiency, while
still maintaining a global view of the input text.
This is thanks to the encoder-decoder architecture
that makes it possible to capture information from
the whole text and the previously derived sub-
trees, while limiting the number of parsing steps
to linear in the number of EDUs. Our framework
is purely neural and does not rely on any hand-
engineered features. Additionally, the framework
allows us to train the segmentation and parsing
models seamlessly with a joint objective.

We conduct a series of experiments with our

framework on the standard RST Discourse Tree-
bank (RST-DT) dataset for sentence level parsing,
and our main findings are as follows.

• Our segmenter achieves an F1 score of 95.4 giv-
ing a relative error reduction of 32% over the
state-of-the-art segmenter.

• Evaluation of our sentence-level discourse
parser with manual segmentation shows that it
achieves an F1 score of 81.3 on the relation la-
beling task yielding a relative error reduction of
about 17% over the state-of-the-art parser.

• Joint training of the segmentation and parsing
models improves the results further giving 95.5
F1 on segmentation and 81.7 F1 on parsing,
while the human agreements on these two tasks
are 98.3 and 83 F1, respectively.

• Our end-to-end system (segmenter→parser)
reaches an F1 of 77.5 on relation labeling pro-
viding an absolute improvement of 10% com-
pared to the best existing system.

• Both our discourse segmenter and parser oper-
ate in linear time with respect to the number of
EDUs. In practice, our segmenter and parser in-
dividually give 6.79x and 3.92x speedups, while
the end-to-end system gives 5.9x speedup com-
pared to the best open-sourced system.

We make our code available at https:
//ntunlpsg.github.io/project/
parser/pointer-net-parser

2 Background

In this section, we give a brief overview of coher-
ence analysis with RST and pointer networks.

2.1 Coherence Analysis with RST

Coherence analysis has been a long standing prob-
lem. We give a brief overview of the studies
that are directly related to our method. Sori-
cut and Marcu (2003) proposed SPADE, a sys-
tem that uses generative models with syntactic
features for discourse segmentation and sentence-
level parsing. Subsequent research focuses on the
impact of syntax in discourse analysis (Sporleder
and Lapata, 2005; Fisher and Roark, 2007; Her-
nault et al., 2010). Joty et al. (2015) propose CO-
DRA, a system that comprises a discourse seg-
menter and a two-stage discourse parser – one

https://ntunlpsg.github.io/project/parser/pointer-net-parser
https://ntunlpsg.github.io/project/parser/pointer-net-parser
https://ntunlpsg.github.io/project/parser/pointer-net-parser


4192

for sentence-level parsing and the other for multi-
sentential parsing. Feng and Hirst (2014a) also
propose two-stage parsing based on CRFs that use
many hand-crafted features. Li et al. (2014) pro-
pose a recursive network for discourse parsing.
Ji and Eisenstein (2014) present a representation
learning method in a shift-reduce discourse parser.
Wang et al. (2017) propose a two-stage parser,
where they use shift-reduce parsing to first con-
struct a tree structure with only nuclearity labels,
and then in the second stage they identify the rela-
tions. They use SVMs with a large number of fea-
tures. Wang et al. (2018) propose a discourse seg-
menter based on LSTM-CRF and achieve state-of-
the-art results with ELMo. Li et al. (2018) also
propose a segmenter based on pointer networks.

Pointer networks have also been used for sum-
marization (See et al., 2017) and dependency pars-
ing (Ma et al., 2018). In our work, we use pointer
networks not only for segmentation but also for
parsing, and we also show how the segmenter and
parser can be trained jointly.

2.2 Pointer Networks

Sequence-to-sequence paradigms (Sutskever
et al., 2014) provide the flexibility that the output
sequence can be of a different length than the
input sequence. However, they still require the
output vocabulary size to be fixed a priori, which
limits their applicability to problems where one
needs to select (or point to) an element in the
input sequence; that is, the size of the output
vocabulary depends on the length of the input
sequence. Pointer Networks (Vinyals et al.,
2015) address this limitation by using attention
(Bahdanau et al., 2015) as a pointing mechanism.
Specifically, an encoder network first converts
the input sequence X = (x1, . . . ,xn) into a
sequence of hidden states H = (h1, . . . ,hn). At
each time step t, the decoder network receives
the input from previous step and produces a
decoder state dt that modulates an attention over
inputs. The output of the attention is a softmax
distribution over the inputs.

st,i = σ(dt,hi) for i = 1 . . . n (1)

at = softmax(st) =
exp(st,i)∑n
i=1 exp(st,i)

(2)

where σ(., .) is a scoring function for attention,
which can be another neural network or simply a

dot product. We use at for inferring the output:
ŷt = arg max(at) = arg max p(yt|y<t,X, θ),
where θ is the set of model parameters. To con-
dition on yt−1, the corresponding input xyt−1 is
copied as the input to the decoder.

3 Our Discourse Parser

Given a sentence as input, the framework first em-
ploys our discourse segmenter to break the sen-
tence into a sequence of EDUs. Our parser then
links these EDUs into a labeled tree by identifying
(i) which discourse units to relate (i.e., finding the
right structure of the tree), and (ii) what relations
and nuclearity statuses to use in connecting them
(i.e., finding the correct labels). In the interests
of presentational simplicity, we first describe the
discourse parser in this section assuming that the
EDUs have already been identified.

Model Overview. As shown in Figure 2, our
parser uses a pointer network as its backbone
parsing model. Given an input sentence contain-
ing n words (w1, . . . , wn), we first embed the
words into their respective distributed representa-
tion by initializing them either randomly or with
pretrained embeddings such as Glove (Penning-
ton et al., 2014) or ELMo (Peters et al., 2018).
The result of this is a sequence of word vectors
X = (x1, . . . ,xn), which is fed to the network.

The encoder of the pointer network first com-
poses the entire sentence sequentially into a se-
quence of hidden states H = (h1, . . . ,hn).
The last hidden state of each EDU (e.g.,
h2,h4,h6,h8,h9 and h10 in Figure 2) are se-
lected to represent the corresponding EDU, thus,
forming a sequence of EDU representations E =
(e1, . . . , em). From this, the greedy decoder then
constructs the discourse tree in a top-down depth-
first manner.

The decoder maintains a stack S to keep track
of the spans that need to be parsed further and their
order (depth-first). S is initialized with the spe-
cial Root symbol. At each decoding step t, the
decoder extracts a span ei:j from the top of S,
and uses the EDU representation ej to generate a
decoder hidden state dt, which is in turn used to
compute the attention scores over the EDU repre-
sentations in the selected range of spans (ei to ej).
Based on the attention scores, the decoder chooses
a position k in the range to generate a new split
(ei:k, ek+1:j). The parser then applies a relation
classifier Φθ(ei:k, ek+1:j), parameterized by θ, on



4193

Figure 2: Our discourse parser along with the decoding process for a synthetic sentence with 10 words and 6 EDUs.
EDU boundaries are marked in red color. For the inputs to the decoder at each step, P and S indicate the parent
and sibling representations, respectively. Φθ(ei:k, ek+1:j) denotes the relation-nuclearity classifier employed by
the parser to find the nuclearity and relation labels for the newly created spans, ei:k and ek+1:j .

the new split to predict the relation and the nucle-
arity labels. If the length of any of the newly cre-
ated spans (ei:k and ek+1:j) is larger than two, the
parser pushes it onto the stack. For the span con-
taining only two EDUs, the parser would automat-
ically run the classifier Φθ to predict the relation
and nuclearity between the two EDUs.

Since the parser works in a depth-first manner, a
text span is not parsed until a complete subtree for
the preceding span is built (assuming we process
the leftmost child first). This allows the decoder
to exploit information from the generated subtrees
in addition to the representation of the span being
parsed. In the following paragraphs, we describe
the components of our parser in detail.

The Encoder. Our parser uses a recurrent neu-
ral network (RNN) based on bidirectional Gated
Recurrent Units or BiGRU (Cho et al., 2014) as
the encoder. Like LSTM (Hochreiter and Schmid-
huber, 1997), GRU cells are also designed to cap-
ture long range dependencies, but have fewer pa-
rameters than LSTM cells. In particular, our en-
coder uses six (6) recurrent layers of BiGRU cells,
and generates hidden states H = (h1, . . . ,hn) by
composing the word representations sequentially
from left-to-right and from right-to-left, which is,

hi = [
→
hi;
←
hi] with

→
hi and

←
hi being the forward

and the backward states. The last hidden states of

an EDU are used as the EDU representation, gen-
erating a sequence of EDU representations E =
(e1, . . . , em) for the input sentence.

The Decoder. Our parser uses a six-layer unidi-
rectional GRU as the decoder. Instead of using the
word embeddings, we feed our decoder with the
corresponding encoder states for the span. This is
because the encoder states contain more contex-
tual information than the word embeddings (Ma
et al., 2018). We use the representation of the
last EDU as the representation of the span. For
example, span e1:3 in Figure 2 is represented by
e3 (or h6). We also experimented with taking
the mean of the corresponding hidden states (e.g.,
mean(h1, . . . ,h6) for e1:3). We found the former
to perform better in our experiments.

At each decoding step t, the decoder combines
the span representation with its previous state dt−1
to generate the current state dt, which is then used
to compute the attentions over the corresponding
encoder states (e1, . . . , e3 for e1:3). We use the
simple dot product as the scoring function (i.e.,
σ(dt,hi) in Equation 2).

Remark: In our earlier attempts, we experimented
with a self-attention based encoder-decoder with
positional encoding similar to (Vaswani et al.,
2017) to reduce the encoding time fromO(n) (lin-
ear) to O(1) (constant) time. However, the perfor-



4194

mance was inferior to the RNN-based encoder.

3.1 The Relation Classifier

For relation labeling, we adopt a bi-affine classi-
fier. The classifier is a two-layer neural network
that takes two spans ei:k and ek+1:j as input and
predicts the corresponding relation label and the
nuclearity statuses. As before, we consider the
representation of the last EDU as the representa-
tion of the span (ek for ei:k and ej for ek+1:j).
The first layer is a dense layer with Exponential
Linear Unit (ELU) activations that maps the span
representations ek and ej to latent label-specific
features ck and cj of dimensions d.

ck = ELU(eTkU1); cj = ELU(e
T
j U2) (3)

The second layer is a bi-affine layer with a
softmax activation to get a multinomial distribu-
tion over the relation labels:

Pθl(y|X) = softmax(c
T
k Wkjcj + c

T
kWk+

cTj Wj + b) (4)

where Wkj ∈ IRd×d×R,Wk ∈ IRd×R, and Wj ∈
IRd×R are the weights and b is a bias vector withR
being the number of relation labels. The bi-affine
layer not only does a linear transformation of ck
and cj but also models the correlation between ck
and cj vectors (Dozat and Manning, 2016).

Following previous work, we attach the nuclear-
ity statuses with the relation labels. For example,
in Figure 1, the ATTRIBUTION relation between
e1 as a satellite and e2 as a nucleus is jointly repre-
sented as ATTRIBUTION-SN. This representation
allows us to perform the two tasks - relation iden-
tification and nuclearity assignment jointly.

3.2 Incorporating Partial Tree Information

As mentioned before, parsing a tree in a depth-
first manner allows us to incorporate partial tree
information while decoding a span. In this work,
we consider information from the parent (P ) and
the immediate left-sibling (S) of the span being
parsed (E). For example, in Figure 2, when pars-
ing span e4:6, in addition to the current span, we
consider its parent span e1:6 (represented by e6)
and its left subtree span e1:3 (represented by e3).
As the relative importance of the three components

may vary, we put a self-attention layer before feed-
ing them to the decoder. Formally, we put them as
rows in a matrix M = [P ;E;S] and perform:

A = softmax(MMT )M (5)

We take an element-wise sum of the three (row)
vectors in A to form the final span representation
(s in the figure) and feed it to the decoder.

3.3 Training Loss
Our parser is trained to minimize the sum of the
loss for building the right tree structure and the
loss for finding the correct labels. The structure
lossLs is the pointing loss for the pointer network:

Ls(θs) = −
T∑
t=1

logPθs(yt|y<t,X) (6)

where θs denotes the parameters of the encoder
and the decoder, y<t represents the subtrees that
have been generated by our parser at previous
steps, and T is the number of spans containing
more than two EDUs (pushed in the stack).

The label loss Ll is the cross entropy loss for
the relation classifier, and can be defined as:

Ll(θl) = −
I∑
i=1

R∑
r=1

yi,r logPθl(yi = r|X) (7)

where θl are the parameters for the relation clas-
sifier (including the encoder), I is the number of
spans with at least two EDUs, R is the total num-
ber of relation labels, and yi,r is the one-hot en-
coding of the relation label. We also apply an L2-
regularization on the parameters. Hence, the final
parsing loss LP (θP ) can be written as:

LPAR(θP ) = Ls(θs) + Ll(θl) +
λ

2
‖θP ‖22 (8)

where λ is the regularization strength and θP de-
notes the set of all parameters of the parser.

4 Our Discourse Segmenter

The job of the discourse segmenter is to find the
EDU boundaries (if any) inside a sentence. Tradi-
tionally, discourse segmentation has been treated
either as an binary classification problem (Sori-
cut and Marcu, 2003; Fisher and Roark, 2007)



4195

Figure 3: Our neural discourse segmentation model for
the same synthetic sentence as in Figure 2. Words in
red color denote boundary words.

or as a sequence labeling problem (Wang et al.,
2018). Recently, Li et al. (2018) show the bene-
fits of using pointer networks over previous meth-
ods for this task, achieving state-of-the-art results.
In our work, we adopt their approach and ad-
vance the state-of-the-art further by simple modifi-
cations. More importantly, this framework allows
us to train the discourse segmenter and the parser
jointly with a shared encoder.

Model Description. Figure 3 depicts the archi-
tecture of our segmenter. Similar to our parser
(Figure 2), the encoder of our segmentation model
reads the whole sentence and transforms it into a
sequence of hidden states. Then, at each time step,
the decoder receives an encoder state correspond-
ing to the first token of a segment currently being
processed, and produces a decoder state which is
in turn used to compute a distribution (attention)
over all valid positions of the input sentence.

The encoder and the decoder have the same ar-
chitecture as in (Li et al., 2018) with the follow-
ing key improvements. First, following the same
idea as in our parser, the decoder takes the en-
coder states as the input instead of word embed-
dings. Second, similar to our parser, we adopt
dot product attention instead of an additive atten-
tion. Dot product attention is simple yet power-
ful, while using fewer parameters (Vaswani et al.,
2017). Third, instead of simple look-up based em-
bedding methods such as Glove, we use the con-
textual embedding ELMo that captures rich con-
textual information.

We train the model by minimizing the pointing
loss with an L2-regularization on the weights.

LSEG(θS) = −
J∑
j=1

logPθS (yj |y<j ,X)+
λ

2
‖θS‖22

(9)

Figure 4: Joint training for segmentation and parsing.

where θS represents the model parameters and J
is the number of EDUs in a sentence.

4.1 Joint and End-to-End Training
One crucial advantage of our framework is that it
allows us to train the segmentation and the pars-
ing models simultaneously and/or in an end-to-end
fashion, while sharing a common encoder. Intu-
itively, both discourse segmentation and parsing
can benefit from each other – a plausible segmen-
tation can result in a plausible parse and vice versa.
Such multitask learning was not possible in a non-
neural setup and the two discourse analysis tasks
have always been considered independently.

Figure 4 depicts the schematic diagram of our
joint training process. The segmentation and the
parsing models share a common encoder while
having two separate decoders for the two tasks.
The training objective can be written as:

L(θ) = LSEG(θ) + Ls(θ) + Ll(θ) +
λ

2
‖θ‖22 (10)

where θ denotes the parameters of our joint model.

5 Experiments

In this section, we present our experiments on dis-
course segmentation and parsing.

5.1 Datasets
We train and evaluate our models on the standard
RST Discourse Treebank (RST-DT) corpus (Carl-
son et al., 2002). RST-DT contains discourse an-
notations for 385 news articles from Penn Tree-
bank (Marcus et al., 1994). The training data con-
tains 347 documents (7673 sentences) and the test
data contains 38 documents (991 sentences). In
addition, 53 documents (1208 sentences) were an-
notated by two human annotators, which we use to
compute human agreement scores.

Since we focus on sentence-level discourse
analysis, we follow the same setup as Soricut and
Marcu (2003); Joty et al. (2012). For segmenta-
tion, we utilize all 7673 sentences for training and



4196

991 sentences for testing. For parsing, we extract
sentence-level DTs from a document-level DT by
finding the subtrees that span over the respective
sentences. This gives 7321 sentence-level DTs for
training, 951 for testing, and 1114 for getting hu-
man agreements. These numbers match the num-
bers reported by Joty et al. (2012). We randomly
selected 10% of the data from the training set for
hyperparameter tuning.

5.2 Discourse Segmentation Experiments

Settings. We compare our segmenter with five
baselines: SPADE segmenter (Soricut and Marcu,
2003), F&R (Fisher and Roark, 2007), JCN (Joty
et al., 2012), SegBot (Li et al., 2018), and WLY
(Wang et al., 2018). Following the standard, we
measure F1-score based on the segmenter’s ability
to find the intra-sentential segment boundaries.

When we evaluate the WLY segmenter on the
standard test set using their released pretrained
model,1 we get much lower results (90.5 F1) than
what they report in their paper (94.3 F1). Upon in-
vestigation, we found that their experimental set-
ting does not match with the standard one. Par-
ticularly, when extracting the sentences from the
RST-DT dataset, instead of using gold tokeniza-
tion, they use an automatic tokenizer, which gives
fewer sentences – 865 test sentences instead of 991
and 6132 training sentences instead of 7673. This
makes the scores artificially high.2

For a fair comparison with our model, we train
and evaluate WLY and SegBot on the same dataset
setting, and report the mean and standard devia-
tion of five runs, each run with a different random
seed. WLY uses ELMo embeddings, which we
also use in our model. To train our model, we use
Adam optimizer with a batch size of 80. We apply
0.2 dropout rate to the encoder and the decoder.
The hidden sizes of the encoder, the decoder and
the classifier are all set to 64. See Appendix for a
complete list of hyperparameter settings. In all our
experiments when comparing two systems, we use
the paired t-test to measure statistical significance.

Results. Table 1 shows our segmentation results.
As mentioned in Section 4, we implemented three
key improvements on the top of (Li et al., 2018).
Using encoder hidden states as decoder inputs and
adopting dot product as the attention score func-
tion together gives 0.40%-7.29% relative improve-

1https://github.com/PKU-TANGENT/NeuralEDUSeg
2We confirmed this by communicating with the authors.

Approach Precision Recall F1

Human Agreement 98.5 98.2 98.3

Baselines
SPADE (Soricut and Marcu, 2003) 83.8 86.8 85.2
F&R (Fisher and Roark, 2007) 91.3 89.7 90.5
JCN (Joty et al., 2012) 88.0 92.3 90.1
SegBotglove (Li et al., 2018) 91.08±0.46 91.03±0.42 91.05±0.11
WLYELMo (Wang et al., 2018) 92.04±0.43 94.41±0.53 93.21±0.33

Our Segmenter
Pointer Net (Glove) 90.55±0.33 92.29±0.09 91.41±0.21
Pointer Net (BERT) 92.05±0.44 95.03±0.28 93.51±0.16
Pointer Net (ELMo) 94.12±0.20? 96.63±0.12? 95.35±0.10?

+ Joint training 93.34±0.23? 97.88±0.16? 95.55±0.13?

Table 1: Discourse segmentation results. Superscript
? indicates the model is significantly superior to the
WLYELMo model with a p-value < 0.01.

ment in F1 over the first four baselines. Using
ELMo, our segmenter outperforms all the base-
lines in all three measures. We achieve 2.3%-
11.9%, 2.4%-11.3% and 2.3%-12.3% relative im-
provements in F1, Recall and Precision, respec-
tively. Jointly training with the parser improves
this further (95.55 F1). It is worthwhile to men-
tion that our segmenter’s performance of 95.55 F1
is very close to the human agreement of 98.3 F1.
ELMo, as a transfer learning method, provides no-
table improvements. A similar observation was re-
ported in (Wang et al., 2018). Surprisingly, the re-
sults with BERT were not as good. We suspect this
is due to BERT’s special tokenization.

5.3 Discourse Parsing Experiments

Settings. We evaluate our parser in two differ-
ent settings: (a) parsing with gold segmentation,
and (b) parsing with our automatic segmenta-
tion or end-to-end evaluation. In the first set-
ting, we compare our results with SPADE (Sori-
cut and Marcu, 2003), DCRF (Joty et al., 2012),
DPLP (Ji and Eisenstein, 2014), and the most re-
cent 2-Stage Parser (Wang et al., 2017). SPADE
and DCRF are both sentence-level parsers. How-
ever, DPLP and 2-Stage Parser are document-level
parsers, and they do not report sentence-level per-
formance. For DPLP, we feed the parser one sen-
tence at a time to get a sentence-level DT. The 2-
Stage Parser constructs a tree in multiple stages
– first sentence-level, then paragraph-level, and
finally document-level. We ran their parser to
generate all the document-level DTs in the test
set, from which we extract the sentence-level DTs
to evaluate. By our count, this gives 881 valid
sentence-level trees as opposed to 951. This is be-
cause like their discourse segmenter (WLY), they

https://github.com/PKU-TANGENT/NeuralEDUSeg


4197

Approach Span Nuclearity Relation

Human Agreement 95.7 90.4 83.0

Baselines
SPADE (Soricut and Marcu, 2003) 93.5 85.8 67.6
DCRF (Joty et al., 2012) 94.6 86.9 77.1
DPLP (Ji and Eisenstein, 2014) 93.5 81.3 70.5
2-Stage Parser (Wang et al., 2017) 95.6 87.8 77.6

Our Parser
Stack Pointer (ELMo-medium) 96.37 89.04? 79.03?

Stack Pointer (ELMo-large) 96.86? 90.77? 81.12?

+ Partial tree information 96.94? 90.89? 81.28?

+ Joint training 97.44? 91.34? 81.70?

Table 2: Parsing results with gold segmentation. Su-
perscript ? indicates the model is significantly superior
to the 2-Stage Parser with a p-value < 0.01.

use an automatic tokenizer instead of gold tok-
enization. We evaluate their parser based on these
881 sentences. This is also what the authors sug-
gested when contacted.

In our second setting for full system evalua-
tion, we compare with the two existing end-to-end
systems, SPADE and DCRF. The hyperparameters
(learning rate, batch size, layer size) of our models
in these two settings remain almost the same as the
segmentation model (see Appendix for details).

Metric and Relation Labels. We evaluate the
performance by using the standard unlabeled
(Span) and labeled (Nuclearity, Relation) micro-
averaged precision, recall and F1-score as de-
scribed in (Marcu, 2000). For brevity, we report
only the F1-scores here. Following previous work,
we use the same 18 relations as used by previous
studies, and we also attach the nuclearity statuses
(NS, SN, NN) to these relations, giving a total of
39 distinctive relation labels.

Results with Gold Segmentation. We present
the results in Table 2. Our base model
(with ELMo-medium) outperforms all the exist-
ing methods to date in all three tasks. We achieve
an absolute 1.43 F1 improvement on the most dif-
ficult task of relation labeling, compared to the
2-stage parser (SOTA). Notably, the F1 score of
96.37 for Span of our base model even exceeds
the human agreement (F1 score of 95.7) on the
doubly-annotated data. As it ought to be, incor-
porating full-size ELMo boosts the performance
in three tasks.

Our parser yields further improvements (+0.16
F1 in Relation) by exploiting partial tree informa-
tion generated in previous steps. The key compo-
nent contributing to this improvement is the self-

Figure 5: Confusion matrix for 14 most frequent
relation labels: EXPLANATION, TEMPORAL,
COMPARISON, ELABORATION, CONDITION,
ATTRIBUTION, CONTRAST, CAUSE, SAME-
UNIT, JOINT, SUMMARY, ENABLEMENT,
MANNER-MEANS, and BACKGROUND.

attention over original decoder inputs with partial
tree information as described in Section 3.3

Thanks to the pointer network as the back-
bone of our model, we are able to train our seg-
menter and parser jointly by sharing the same en-
coder. The last row of Table 2 shows the re-
sults when we train the model jointly, and feed the
parser with gold EDU segmentation during infer-
ence. The performance is improved further with
joint training, achieving 97.44, 91.34, 81.70 F1
score, in Span, Nuclearity and Relation, respec-
tively. The results accord with our assumption
that discourse segmentation and parsing may ben-
efit from each other. Our parser surpasses hu-
man agreement in span and nuclearity. We are
also approaching human agreement in the most
difficult task of relation labeling. We show a
confusion matrix for the relation labels in Fig-
ure 5. We see that our model gets confused be-
tween relations that are semantically similar (e.g.,
CAUSE vs. EXPLANATION, COMPARISON
vs. CONTRAST, and TEMPORAL vs. JOINT).

Remark: We observe that the relation labels in
RST-DT are highly imbalanced, which makes the
task harder. Therefore, we experimented with a
variant of our parser where we had a separate clas-
sifier for nuclearity prediction, leaving 18 labels
for relation classifier instead of 39. This model
gave 96.74, 90.38, and 80.89 F1 in Span, Nucle-
arity and Relation, respectively, which are lower
than what we get by having a single classifier.

3Simple averaging of the vectors did not show any gain.



4198

Approach Span Nuclearity Relation

Baselines
SPADE (Soricut and Marcu, 2003) 76.7 70.2 58.0
DCRF (Joty et al., 2012) 82.4 76.6 67.5

Our Model
Stack Pointer (Pipeline) 91.14? 85.80? 76.94?

Stack Pointer (Joint training) 91.75? 86.38? 77.52?

Table 3: Parsing results with automatic segmentation.
Superscript ? indicates the model is significantly supe-
rior to the DCRF model with a p-value < 0.01.

Jointly modeling nuclearity and relation enforces
the constraint that certain relations can have cer-
tain nuclearity orientations. For example, Elabo-
ration and Attribution are mono-nuclear (takes ei-
ther NS or SN), and SameUnit and Joint are multi-
nuclear relations (takes only NN).

End-to-End Performance. Table 3 shows the
results of our model and the two baselines. First,
we use our segmenter followed by our best parser
(independently trained) in a pipeline. The perfor-
mance of this system is significantly better com-
pared to the baselines. Against the best baseline
(DCRF), it yields 8.74%, 9.2%, 9.44% absolute
improvements in Span, Nuclearity, Relation, re-
spectively. We push the performance even further
by joint training of the segmenter and parser as in
Figure 4. Notice that the performance on Relation
(77.5 F1) is even better than the DCRF model with
gold segmentation (77.1 F1) in Table 2.

5.4 Run Time Analysis

As noted earlier, both our segmenter and parser
operate in linear time with respect to the number
of input units. We compare the speed (sentences
per second) of our systems against other base-
lines in Table 4 from a practical viewpoint. We
test all the systems with the same 100 sentences
randomly selected from our test set on our ma-
chine (CPU: Intel Xeon W-2133, GPU: NVIDIA
GTX 1080Ti). We include the model loading time
for all the systems.4 Since SPADE and CODRA
need to extract a handful of features, they are typi-
cally slower than the neural models which use pre-
trained embeddings. In addition, CODRA’s DCRF
parser has a O(n3) inference time. Our segmenter

4As a neural model, WLY should be faster than the num-
ber we report. We retest both WLY and our model by ex-
cluding the model loading time. The speed of WLY and our
segmenter are 157.80 sents/s and 181.30 sents/s, respectively.
This could be because the two models are implemented in dif-
ferent frameworks (WLY: TensorFlow, ours: PyTorch).

System Speed (Sents/s) Speedup

Only Segmenter
CODRA (Joty et al., 2015) 3.06 1.0x
WLY (Wang et al., 2018) 4.30 1.4x
SPADE (Soricut and Marcu, 2003) 5.24 1.7x
Our (CPU) 12.05 3.9x
Our (GPU) 35.54 11.6x

Only Parser
SPADE (Soricut and Marcu, 2003) 5.07 1.0x
CODRA (Joty et al., 2015) 7.77 1.5x
Our (CPU) 12.57 2.5x
Our (GPU) 30.45 6.0x

End-to-End (Segmenter→ Parser)
CODRA (Joty et al., 2015) 3.05 1.0x
SPADE (Soricut and Marcu, 2003) 4.90 1.6x
Our (CPU) 11.99 3.9x
Our (GPU) 28.96 9.5x

Table 4: Speed comparison of our systems with other
open-sourced systems.

is 6.8x faster than SPADE. Compared to CODRA
(the fastest parser as of yet), our parser is 3.9x
faster. Finally, our end-to-end system is 5.9x faster
than the fastest system out there (SPADE), making
our system not only effective but also highly effi-
cient. Even when tested only on CPU, our model
is faster than all the other models.

6 Conclusions

We have proposed a unified framework for
sentence-level discourse analysis based on pointer
networks that constructs a discourse tree in lin-
ear time. Both our segmenter and parser achieve
state-of-the-art results outperforming existing sys-
tems by a wide margin, without using any hand-
crafted features. We also train the segmenter and
the parser jointly through the encoder-decoder ar-
chitecture and improve the results further. Apart
from the effectiveness, our system is 6 times faster
than the fastest available system.

Based on what we have done so far, it is natural
for us to move our focus from sentence-level to
document-level RST parsing. Also, in the future,
we would like to investigate how our approach can
be generalized to other discourse frameworks such
as the Penn Discourse Treebank (PDTB).

Acknowledgments

We would like to extend our thanks for the funding
support from MOE Tier-1 (Grant M4011897.020).



4199

References
Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-

gio. 2015. Neural Machine Translation by Jointly
Learning to Align and Translate. In ICLR.

Chloé Braud, Maximin Coavoux, and Anders Søgaard.
2017. Cross-lingual rst discourse parsing. In Pro-
ceedings of the 15th Conference of the European
Chapter of the Association for Computational Lin-
guistics: Volume 1, Long Papers, pages 292–304.
Association for Computational Linguistics.

Lynn Carlson, Daniel Marcu, and Mary Ellen
Okurowski. 2002. RST Discourse Treebank (RST–
DT) LDC2002T07. Linguistic Data Consortium,
Philadelphia.

Kyunghyun Cho, Bart van Merrienboer, Çaglar
Gülçehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. 2014. Learning
phrase representations using RNN encoder-decoder
for statistical machine translation. In Proceedings of
the 2014 Conference on Empirical Methods in Nat-
ural Language Processing, EMNLP 2014, October
25-29, 2014, Doha, Qatar, A meeting of SIGDAT,
a Special Interest Group of the ACL, pages 1724–
1734.

Timothy Dozat and Christopher D. Manning. 2016.
Deep biaffine attention for neural dependency pars-
ing. CoRR, abs/1611.01734.

Vanessa Feng and Graeme Hirst. 2012. Text-level Dis-
course Parsing with Rich Linguistic Features. In
Proceedings of the 50th Annual Meeting of the As-
sociation for Computational Linguistics, ACL ’12,
pages 60–68, Jeju Island, Korea. ACL.

Vanessa Feng and Graeme Hirst. 2014a. A Linear-
Time Bottom-Up Discourse Parser with Constraints
and Post-Editing. In Proceedings of the 52nd An-
nual Meeting of the Association for Computational
Linguistics, ACL ’14, pages 511–521, Baltimore,
USA. ACL.

Vanessa Wei Feng and Graeme Hirst. 2014b. A linear-
time bottom-up discourse parser with constraints
and post-editing. In Proceedings of the 52nd Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers), pages 511–521.
Association for Computational Linguistics.

Seeger Fisher and Brian Roark. 2007. The Utility
of Parse-derived Features for Automatic Discourse
Segmentation. In Proceedings of the 45th Annual
Meeting of the Association for Computational Lin-
guistics, ACL’07, pages 488–495, Prague, Czech
Republic. ACL.

Francisco Guzmán, Shafiq Joty, Lluı́s Màrquez, and
Preslav Nakov. 2014. Using discourse structure im-
proves machine translation evaluation. In Proceed-
ings of the 52nd Annual Meeting of the Association
for Computational Linguistics (Volume 1: Long Pa-
pers), pages 687–698, Baltimore, Maryland. ACL.

Hugo Hernault, Helmut Prendinger, David duVerle,
and Mitsuru Ishizuka. 2010. HILDA: A Discourse
Parser Using Support Vector Machine Classification.
Dialogue and Discourse, 1(3):1–33.

Sepp Hochreiter and Jürgen Schmidhuber. 1997.
Long short-term memory. Neural Computation,
9(8):1735–1780.

Yangfeng Ji and Jacob Eisenstein. 2014. Represen-
tation learning for text-level discourse parsing. In
Proceedings of the 52nd Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 13–24, Baltimore, Maryland.
ACL.

Shafiq Joty, Giuseppe Carenini, and Raymond Ng.
2012. A novel discriminative framework for
sentence-level discourse analysis. In Proceedings
of the 2012 Joint Conference on Empirical Methods
in Natural Language Processing and Computational
Natural Language Learning, pages 904–915. Asso-
ciation for Computational Linguistics.

Shafiq Joty, Giuseppe Carenini, and Raymond T Ng.
2015. Codra: A novel discriminative framework
for rhetorical analysis. Computational Linguistics,
41:3:385–435.

Jing Li, Aixin Sun, and Shafiq Joty. 2018. Segbot: A
generic neural text segmentation model with pointer
network. In Proceedings of the 27th International
Joint Conference on Artificial Intelligence and the
23rd European Conference on Artificial Intelligence,
IJCAI-ECAI-2018, pages 4166 – 4172, Stockholm,
Sweden.

Jiwei Li, Rumeng Li, and Eduard Hovy. 2014. Recur-
sive deep models for discourse parsing. In Proceed-
ings of the 2014 Conference on Empirical Methods
in Natural Language Processing (EMNLP), pages
2061–2069, Doha, Qatar. ACL.

Qi Li, Tianshi Li, and Baobao Chang. 2016. Discourse
parsing with attention-based hierarchical neural net-
works. In Proceedings of the 2016 Conference on
Empirical Methods in Natural Language Process-
ing, pages 362–371. Association for Computational
Linguistics.

Xuezhe Ma, Zecong Hu, Jingzhou Liu, Nanyun Peng,
Graham Neubig, and Eduard H. Hovy. 2018. Stack-
pointer networks for dependency parsing. In Pro-
ceedings of the 56th Annual Meeting of the Associa-
tion for Computational Linguistics, ACL 2018, Mel-
bourne, Australia, July 15-20, 2018, Volume 1: Long
Papers, pages 1403–1414.

William Mann and Sandra Thompson. 1988. Rhetor-
ical Structure Theory: Toward a Functional Theory
of Text Organization. Text, 8(3):243–281.

Daniel Marcu. 1999. The automatic construction of
large-scale corpora for summarization research. In
Proceedings of SIGIR, pages 137–144.

http://aclweb.org/anthology/E17-1028
http://aclweb.org/anthology/D/D14/D14-1179.pdf
http://aclweb.org/anthology/D/D14/D14-1179.pdf
http://aclweb.org/anthology/D/D14/D14-1179.pdf
http://arxiv.org/abs/1611.01734
http://arxiv.org/abs/1611.01734
https://doi.org/10.3115/v1/P14-1048
https://doi.org/10.3115/v1/P14-1048
https://doi.org/10.3115/v1/P14-1048
http://www.aclweb.org/anthology/P14-1065
http://www.aclweb.org/anthology/P14-1065
http://www.aclweb.org/anthology/P/P14/P14-1002
http://www.aclweb.org/anthology/P/P14/P14-1002
http://aclweb.org/anthology/D12-1083
http://aclweb.org/anthology/D12-1083
https://www.ijcai.org/proceedings/2018/0579.pdf
https://www.ijcai.org/proceedings/2018/0579.pdf
https://www.ijcai.org/proceedings/2018/0579.pdf
http://www.aclweb.org/anthology/D14-1220
http://www.aclweb.org/anthology/D14-1220
https://doi.org/10.18653/v1/D16-1035
https://doi.org/10.18653/v1/D16-1035
https://doi.org/10.18653/v1/D16-1035
https://aclanthology.info/papers/P18-1130/p18-1130
https://aclanthology.info/papers/P18-1130/p18-1130


4200

Daniel Marcu. 2000. The Rhetorical Parsing of Unre-
stricted Texts: A Surface-based Approach. Compu-
tational Linguistics, 26:395–448.

Mitchell Marcus, Mary Marcinkiewicz, and Beatrice
Santorini. 1994. Building a Large Annotated Cor-
pus of English: The Penn Treebank. Computational
Linguistics, 19(2):313–330.

Jeffrey Pennington, Richard Socher, and Christopher
Manning. 2014. Glove: Global vectors for word
representation. In Proceedings of the 2014 confer-
ence on empirical methods in natural language pro-
cessing (EMNLP), pages 1532–1543.

Matthew E. Peters, Mark Neumann, Mohit Iyyer, Matt
Gardner, Christopher Clark, Kenton Lee, and Luke
Zettlemoyer. 2018. Deep contextualized word rep-
resentations. In Proc. of NAACL.

Kenji Sagae. 2009. Analysis of discourse struc-
ture with syntactic dependencies and data-driven
shift-reduce parsing. In Proceedings of the 11th
International Conference on Parsing Technologies
(IWPT’09), pages 81–84. Association for Computa-
tional Linguistics.

Abigail See, Peter J. Liu, and Christopher D. Manning.
2017. Get to the point: Summarization with pointer-
generator networks. In Proceedings of the 55th An-
nual Meeting of the Association for Computational
Linguistics (Volume 1: Long Papers), pages 1073–
1083. Association for Computational Linguistics.

Radu Soricut and Daniel Marcu. 2003. Sentence Level
Discourse Parsing Using Syntactic and Lexical In-
formation. In Proceedings of the 2003 Conference
of the North American Chapter of the Association
for Computational Linguistics on Human Language
Technology - Volume 1, NAACL’03, pages 149–156,
Edmonton, Canada. ACL.

Caroline Sporleder and Mirella Lapata. 2005. Dis-
course Chunking and its Application to Sentence
Compression. In Proceedings of the conference
on Human Language Technology and Empirical
Methods in Natural Language Processing, HLT-
EMNLP’05, pages 257–264, Vancouver, British
Columbia, Canada. ACL.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to sequence learning with neural net-
works. In Z. Ghahramani, M. Welling, C. Cortes,
N. D. Lawrence, and K. Q. Weinberger, editors, Ad-
vances in Neural Information Processing Systems
27, pages 3104–3112. Curran Associates, Inc.

Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob
Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz
Kaiser, and Illia Polosukhin. 2017. Attention is all
you need. In Advances in Neural Information Pro-
cessing Systems, pages 5998–6008.

Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly.
2015. Pointer networks. In C. Cortes, N. D.
Lawrence, D. D. Lee, M. Sugiyama, and R. Garnett,

editors, Advances in Neural Information Processing
Systems 28, pages 2692–2700. Curran Associates,
Inc.

Yizhong Wang, Sujian Li, and Houfeng Wang. 2017.
A two-stage parsing method for text-level discourse
analysis. In Proceedings of the 55th Annual Meet-
ing of the Association for Computational Linguistics
(Volume 2: Short Papers), pages 184–188. Associa-
tion for Computational Linguistics.

Yizhong Wang, Sujian Li, and Jingfeng Yang. 2018.
Toward fast and accurate neural discourse segmen-
tation. In Proceedings of the 2018 Conference on
Empirical Methods in Natural Language Processing
(EMNLP 2018).

http://aclweb.org/anthology/W09-3813
http://aclweb.org/anthology/W09-3813
http://aclweb.org/anthology/W09-3813
https://doi.org/10.18653/v1/P17-1099
https://doi.org/10.18653/v1/P17-1099
http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf
http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf
http://papers.nips.cc/paper/5866-pointer-networks.pdf
https://doi.org/10.18653/v1/P17-2029
https://doi.org/10.18653/v1/P17-2029

