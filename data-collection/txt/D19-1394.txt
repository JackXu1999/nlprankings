



















































Don‚Äôt paraphrase, detect! Rapid and Effective Data Collection for Semantic Parsing


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 3810‚Äì3820,
Hong Kong, China, November 3‚Äì7, 2019. c¬©2019 Association for Computational Linguistics

3810

Don‚Äôt paraphrase, detect! Rapid and Effective Data Collection for
Semantic Parsing

Jonathan Herzig1 Jonathan Berant1,2

1School of Computer Science, Tel-Aviv University
2Allen Institute for Artificial Intelligence

{jonathan.herzig,joberant}@cs.tau.ac.il

Abstract

A major hurdle on the road to conversa-
tional interfaces is the difficulty in collecting
data that maps language utterances to logi-
cal forms. One prominent approach for data
collection has been to automatically gener-
ate pseudo-language paired with logical forms,
and paraphrase the pseudo-language to natural
language through crowdsourcing (Wang et al.,
2015). However, this data collection proce-
dure often leads to low performance on real
data, due to a mismatch between the true dis-
tribution of examples and the distribution in-
duced by the data collection procedure. In
this paper, we thoroughly analyze two sources
of mismatch in this process: the mismatch in
logical form distribution and the mismatch in
language distribution between the true and in-
duced distributions. We quantify the effects of
these mismatches, and propose a new data col-
lection approach that mitigates them. Assum-
ing access to unlabeled utterances from the
true distribution, we combine crowdsourcing
with a paraphrase model to detect correct logi-
cal forms for the unlabeled utterances. On two
datasets, our method leads to 70.6 accuracy on
average on the true distribution, compared to
51.3 in paraphrasing-based data collection.

1 Introduction

Conversing with a virtual assistant in natural lan-
guage is one of the most exciting current ap-
plications of semantic parsing, the task of map-
ping natural language utterances to executable log-
ical forms (Zelle and Mooney, 1996; Zettlemoyer
and Collins, 2005; Liang et al., 2011). Semantic
parsing models rely on supervised training data
that pairs natural language utterances with logi-
cal forms. Alas, such data does not occur natu-
rally, especially in virtual assistants that are meant
to support thousands of different applications and
use-cases. Thus, efficient data collection is per-

c1: paper whose keyphrase
is parsing

c2: paper whose keyphrase
is parsing and that has the 
largest publication year

c3: number of paper whose
keyphrase is parsing
‚Ä¶

x:  Most recent parsing papers
Please detect the correct paraphrase:
‚Ä¢ number of paper whose keyphrase is parsing
‚Ä¢ paper whose keyphrase is parsing and that 

has the largest publication year
‚Ä¢ paper whose keyphrase is parsing
‚Ä¢ N/A

x1: How many papers use SQuAD?
x2: Papers in EMNLP‚Äù

x3: Most recent parsing papers

x4: Largest NLP conference

x4: Datasets for machine translation

‚Ä¶

Grammar output  ùíû"#Unlabeled utterances  ùí≥%&

2. Crowd workers annotate unlabeled examples

. ùüñùüê

. ùüëùüì

. ùüóùüè

st(x3,c1)

st(x3,c2)

st(x3,c3)

1. Unlabeled utterances are scored against canonical utterances 

3. train ùíîùíï0ùüè(2) using all aggregated annotations

Figure 1: An overview of GRANNO, a method for an-
notating unlabeled utterances with their logical forms.

haps the most pressing problem for scalable con-
versational interfaces.

In recent years, many attempts aim to reduce
the burden of data collection for semantic parsing,
including training from denotations (Kwiatkowski
et al., 2013; Artzi and Zettlemoyer, 2013), semi-
supervised learning (KociskyÃÅ et al., 2016; Yin
et al., 2018), human in the loop (Iyer et al., 2017;
Lawrence and Riezler, 2018), and training on ex-
amples from other domains (Herzig and Berant,
2017, 2018; Su and Yan, 2017). One promi-
nent approach for data collection was introduced
by Wang et al. (2015), termed OVERNIGHT. In
this method, one automatically generates logical
forms for an application from a grammar, paired
with pseudo-language utterances. These pseudo-
language utterances are then shown to crowd
workers, who are able to understand them and
paraphrase them into natural language, resulting



3811

in a supervised dataset.
The OVERNIGHT procedure has been adopted

and extended both within semantic parsing (Lo-
cascio et al., 2016; Ravichander et al., 2017;
Zhong et al., 2017; Cheng et al., 2018), in dialogue
(Shah et al., 2018; Damonte et al., 2019) and in vi-
sual reasoning (Johnson et al., 2017; Hudson and
Manning, 2019).

While the OVERNIGHT approach is appealing
since it generates training data from scratch, it suf-
fers from a major drawback ‚Äì training a parser on
data generated from OVERNIGHT and testing on
utterances collected from a target distribution re-
sults in a significant drop in performance (Wang
et al., 2015; Ravichander et al., 2017).

In this paper, we thoroughly analyze the sources
of mismatch between a target distribution and the
distribution induced by OVERNIGHT, and propose
a new method for overcoming this mismatch. We
decouple the mismatch into two terms: the logi-
cal form mismatch, i.e., the difference between the
target distribution of logical forms and the distri-
bution obtained when generating from a grammar,
and the language mismatch, i.e., the difference be-
tween the natural language obtained when para-
phrasing a pseudo-language utterance and the lan-
guage obtained by real users of an application.

We find that the most severe problem arising
from the logical form mismatch is insufficient cov-
erage of logical form templates that occur in the
true distribution, when generating from a gram-
mar. We also isolate the language mismatch ef-
fect by paraphrasing logical forms sampled from
the true logical form distribution, and find that the
language mismatch alone results in a decrease of
9 accuracy points on average on two datasets.

To overcome these mismatches, we propose
an alternative method to OVERNIGHT, that uti-
lizes unlabeled utterances. Our method, named
GRANNO (grammar-driven annotation), allows
crowd workers to iteratively annotate unlabeled ut-
terances by detecting their correct grammar gener-
ated paraphrase. Figure 1 illustrates a single iter-
ation of this approach. An unlabeled utterance is
matched using a paraphrase model against candi-
date pseudo-language utterances generated by the
grammar (step 1). The unlabeled utterance and its
top candidate paraphrases are presented to a crowd
worker that detects the correct paraphrase (step 2).
The paraphrase model is re-trained given all an-
notated utterances thus far (step 3), and is used to

1. Canonical utterances and logical forms are generated by the grammar

city that is contained by california, Type.City‚äìLocation.Cal
lake that has the largest area, argmax(Type.Lake,Area)
‚Ä¶

2. Crowd workers paraphrase the canonical utterances

city that is contained by california
lake that has the largest area
‚Ä¶

‚Üí
‚Üí

‚Üí
‚Üí

Cities in California? 
Find me the largest lake          
‚Ä¶

3. The framework outputs semantic parsing training data: ùììùê®ùêß
Cities in California?, Type.City‚äìLocation.Cal
Find me the largest lake, argmax(Type.Lake,Area)
‚Ä¶

Figure 2: OVERNIGHT: Canonical utterances are gen-
erated by a grammar and paraphrased by crowd work-
ers.

score the remaining unlabeled utterances.
On two semantic parsing datasets, we show

our procedure leads to annotation of 89% of
the original training data. The accuracy of the
resulting parser is 70.6 on average, well be-
yond the accuracy obtained through the original
OVERNIGHT procedure at 51.3. This substantially
closes the gap to a fully-supervised semantic
parser, which obtains 84.9 accuracy. All our code
and collected data is available at https:
//github.com/jonathanherzig/
semantic-parsing-annotation.

2 The OVERNIGHT Framework

We now describe the OVERNIGHT framework for
data collection, which we investigate and improve
upon in this work. The starting point is a user
who needs a semantic parser for some domain,
but has no data. OVERNIGHT describes a pro-
cedure for generating training data from scratch,
which comprises two steps (see Figure 2). First, a
synchronous grammar is used to generate logical
forms paired with canonical utterances, which are
pseudo-language utterances that are understand-
able to people, but do not sound natural. Second,
crowd workers paraphrase these canonical utter-
ances into natural language utterances. This re-
sults in a training set of utterances paired with log-
ical forms that is used to train the semantic parser.
We now briefly elaborate on these two steps.

Grammar The grammar in OVERNIGHT gen-
erates logical forms paired with canonical utter-
ances, which are understandable to crowd work-
ers (e.g., ‚Äúnumber of state that borders califor-
nia‚Äù). The grammar has two parts: the domain-

https://github.com/jonathanherzig/semantic-parsing-annotation
https://github.com/jonathanherzig/semantic-parsing-annotation
https://github.com/jonathanherzig/semantic-parsing-annotation


3812

general part contains domain-independent rules
that cover logical operators (e.g., comparatives,
superlatives, negation etc.). In addition, a seed
lexicon specifies a canonical phrase (‚Äúpublication
year‚Äù) for each knowledge-base (KB) constant
(PublicationYear), in each particular domain.

While there are many possible ways to sam-
ple data from the grammar, in OVERNIGHT log-
ical forms and canonical utterances are exhaus-
tively generated up to a certain maximal depth,
hereafter denoted D. This follows the assump-
tion that the semantic parser, trained from this
data, should generalize to logical forms that cor-
respond to deeper trees (we re-examine this as-
sumption in Section 3). In addition, a typing
system is used during generation, thus, semanti-
cally vacuous logical forms are not generated (e.g.,
PublicationYear.Parsing), which substantially
reduces the number of generated examples.

Crowdsourcing After the above generation pro-
cedure terminates, crowd workers paraphrase each
canonical utterance into a natural language utter-
ance (e.g., the canonical utterance ‚Äúpaper that has
the largest publication year‚Äù can be paraphrased
to ‚Äúwhat is the most recent paper?‚Äù). Finally,
the framework yields a training dataset Don =
{(xi, zi)}Noni=1 consisting of pairs of natural lan-
guage utterances and logical forms, which can be
used to train a semantic parser.

3 Mismatch Analysis

In supervised semantic parsing, we assume ac-
cess to training data of the form Dnat =
{(xi, zi)}Nnati=1 sampled from the true target distri-
bution pnat(x, z). Conversely, in the OVERNIGHT
framework, we train from Don, which is sampled
from a different distribution pon(x, z). Training on
data sampled from pon(x, z) and testing on data
sampled from pnat(x, z) leads to a substantial de-
crease in performance (compared to training on
data sampled from pnat(x, z)). In this section, we
will analyze and quantify the causes for this degra-
dation in performance.

By writing pnat(x, z) = pnat(z)pnat(x | z) and
pon(x, z) = pon(z)pon(x | z) (mirroring the data
generation procedure of OVERNIGHT), we can de-
couple the distribution mismatch into two terms:
The first is the logical form mismatch, i.e., the dif-
ference between the natural distribution of logical
forms pnat(z) and the distribution pon(z) of logi-
cal forms induced by OVERNIGHT. The second

is the language mismatch, i.e., the difference be-
tween the conditional distribution of natural lan-
guage pnat(x | z) and the conditional distribu-
tion pon(x | z) of natural language when perform-
ing crowdsourcing with the OVERNIGHT proce-
dure. We will now investigate these two types of
mismatch and their interaction with neural seman-
tic parsers in the context of two popular semantic
parsing datasets, GEOQUERY (Zelle and Mooney,
1996) and SCHOLAR (Iyer et al., 2017), which fo-
cus on the domains of geography and publications,
respectively. For this analysis, we replicated the
OVERNIGHT procedure and generated a dataset
Don for these two domains (details in Section 5).

3.1 Logical Form Mismatch
The first source of mismatch is that the natural dis-
tribution of logical forms pnat(z) can be quite dif-
ferent from the distribution pon(z) induced by the
ad-hoc procedure for generating logical forms in
OVERNIGHT.

Logical Operators Frequency A simple way
to quantify the logical form mismatch, is to look
whether the proportion of different logical opera-
tors, such as superlatives (e.g., argmax) and com-
paratives (e.g., >), substantially differs between
Don and Dnat. Table 1 examines this, where here-
after we use the original training and development
sets of GEOQUERY and SCHOLAR as Dnat. The
table shows that the frequency of logical operators
is different between the two training sets Dnat and
Don. For example, in Dnat of GEOQUERY, only
1% of the examples involve negation, compared
to 55% of the examples in Don. Such differences
may present generalization difficulties for a model
trained from Don, as the real distribution we care
about is Dnat.

Coverage Wang et al. (2015) proposed to ex-
haustively generate all logical forms correspond-
ing to a derivation tree of maximal depth D, as-
suming that the model will generalize to logical
forms that require deeper trees. However, recent
work from Finegan-Dollak et al. (2018) showed
this might not be the case. In their work, Finegan-
Dollak et al. (2018) consider logical form tem-
plates, i.e., logical forms where the KB constants
are abstracted to their semantic type, and split the
data such that templates in the test set are disjoint
from templates in the training set. They show
that neural semantic parsers struggle to general-
ize in this setup. Thus, covering the logical form



3813

operator
GEOQUERY SCHOLAR

exampleDnat Don Dnat Don
argmax .27 .14 .18 .08 ‚Äúthe longest river‚Äù
argmin .10 .14 .02 .08 ‚Äúearliest paper by...‚Äù
larger .01 .06 .02 .10 ‚Äúhigh point higher than that of...‚Äù
smaller .00 .06 .02 .10 ‚Äúpaper with less than 10 citations‚Äù
conj1 .81 .20 .50 .22 ‚Äúparsing papers‚Äù
conj2 .19 .80 .42 .78 ‚Äú2019 parsing papers‚Äù
conj3 .00 .00 .06 .00 ‚Äú2019 EMNLP parsing papers‚Äù
conj4 .00 .00 .01 .00 ‚Äú2019 EMNLP parsing papers by...‚Äù
negation .01 .55 .01 .57 ‚Äústate with no rivers‚Äù
aggregation .01 .04 .01 .03 ‚Äútotal population of all states‚Äù
count .10 .02 .16 .02 ‚Äúnumber of papers published by...‚Äù

Table 1: Logical operators frequency within the total number of examples. conjn refers to a logical from that
contains a conjunction of n clauses.

Dataset D |Don| Dnat coverage

SCHOLAR

7 655,516 95.16
6 91,739 90.85
5 2,283 63.73
4 91 17.44

GEOQUERY

7 2,086,830 94.13
6 249,617 89.43
5 4,480 76.52
4 166 51.68

Table 2: Logical form coverage of Dnat by Don, after
converting logical forms to their templates, for different
values of D.

templates that appear in Dnat is important in the
OVERNIGHT procedure.

Table 2 shows the number of examples gener-
ated by OVERNIGHT for different values of D,
along with the proportion of examples in Dnat
whose logical form template is covered by Don.
Because OVERNIGHT requires paraphrasing each
generated example, a reasonable value for D is
5. We observe that in this case only 63.73% of
the examples in SCHOLAR are covered, as well as
76.52% of the examples in GEOQUERY.

To verify whether coverage is indeed important
in our setup, we performed the following exper-
iment. We trained a semantic parser (detailed in
Section 5) on Don for GEOQUERY and SCHOLAR
(with D= 5), and evaluated its performance on the
training set ofDnat (which serves as a development
set in this context). Then, we calculated the ac-
curacy of the model with respect to examples for
which their template appears in Don (acccov), and
for those their template does not appear (accdisj).
Table 3 shows that accdisj is substantially lower

Dataset acccov accdisj
GEOQUERY 78.73 10.71
SCHOLAR 65.58 5.24

Table 3: Denotation accuracy for the set of examples in
Dnat covered by Don (acccov), and for the set of uncov-
ered examples (accdisj).

than acccov for both datasets. This shows the im-
portance of generating logical form templates that
are likely to appear in the target distribution. Thus,
our finding reinforces the conclusions in (Finegan-
Dollak et al., 2018), and shows that while neu-
ral semantic parsers obtain good performance on
existing benchmarks, their generalization to new
compositional structures is limited.

Unlikely Logical Forms In OVERNIGHT, logi-
cal forms that are unlikely to appear in a natural
interaction could be generated. For instance, the
canonical utterance ‚Äútotal publication year of pa-
per whose keyphrase is semantic parsing‚Äù, which
refers to the sum of publication years of all seman-
tic parsing papers. Although such logical forms
are valid with respect to type matching, users are
unlikely to produce them, and they are hard to
prune automatically. To estimate the logical form
mismatch caused by unlikely logical forms, we
manually inspected 100 random examples from
Don with D= 5 for GEOQUERY, and found that
31% of the examples are unlikely. While these ex-
amples are not necessarily harmful for a model,
they are difficult to paraphrase, and may introduce
noisy paraphrases that hurt performance.



3814

Example 1
c: ‚Äúriver that traverses california and that has the
largest length‚Äù
xon: ‚ÄúWhat river that traverses California has the
largest length?‚Äù
xnat: ‚ÄúWhat is the longest river in California?‚Äù

Example 2
c: ‚Äúpaper whose keyphrase is deep learning and that
has the largest publication year‚Äù
xon: ‚ÄúName the paper with a deep learning keyphrase
that has the most recent publication year.‚Äù
xnat: ‚ÄúMost recent deep learning papers.‚Äù

Figure 3: Examples for canonical utterances (c) gener-
ated by the grammar, their paraphrase by crowd work-
ers (xon), and their natural utterance in Dnat (xnat).
While the paraphrases are correct, they are biased to-
wards the language style in c.

3.2 Language mismatch

The second mismatch in OVERNIGHT, demon-
strated in Figure 3, is between the language used
when naturally interacting with a conversational
interface, and the language crowd workers use
when elicited to generate paraphrases conditioned
on a canonical utterance.

To directly measure the language mismatch, we
performed the following experiment. We gener-
ated a dataset Dlang by taking the examples from
Dnat and paraphrasing their logical forms using
the OVERNIGHT procedure. This ensures that
plang(z) = pnat(z), and thus the only difference be-
tweenDnat andDlang is due to language mismatch.
Then we measured the difference in performance
when training on these two datasets.

In more detail, for every example in Dnat, we
extracted the corresponding canonical utterance
template (since the examples are covered by the
OVERNIGHT grammar), denoted by Cnat. This list
of canonical utterances can be viewed as an or-
acle output of the OVERNIGHT grammar genera-
tion procedure, since they do not exhibit any log-
ical form mismatch. Next, 12 NLP graduate stu-
dents paraphrased the examples in Cnat. The stu-
dents were presented with guidelines and exam-
ples for creating paraphrases, similar to the orig-
inal guidelines in Wang et al. (2015). Moreover,
we explicitly asked to paraphrase the canonical ut-
terances such that the output is significantly dif-
ferent from the input (while preserving the mean-
ing). After the paraphrase process was completed,
we manually fixed typos in all generated para-

Model GEOQUERY SCHOLAR
SUPERVISED+ELMO 86.3 83.4
OVERNIGHT-ORACLE-LF+ELMO 77.7 73.5
SUPERVISED+GLOVE 84.9 78.2
OVERNIGHT-ORACLE-LF+GLOVE 71.6 67.2

Table 4: Denotation accuracy on the test set, comparing
a semantic parser trained on Dnat (SUPERVISED) and
parser trained on Dlang (OVERNIGHT-ORACLE-LF).

phrases. Thus, our paraphrasing procedure yields
high quality paraphrases and is an upper bound to
what can be achieved by crowd workers.

We trained a neural semantic parser on
both Dnat (named SUPERVISED) and Dlang
(named OVERNIGHT-ORACLE-LF) using the orig-
inal train/development split. Results in Table 4
show that for each domain, a decrease of approxi-
mately 9 points in accuracy occurs only due to the
language mismatch, even with high-quality work-
ers. This gap is likely to grow when workers are
not experienced in paraphrasing, or are unfamiliar
with the domain they generate paraphrases for.

We additionally observe that when we use
GloVe embeddings (Pennington et al., 2014) in-
stead of contextual ELMo embeddings (Peters
et al., 2018), the gap is even higher. This shows
that better representations reduce the language
gap, though it is still substantial.

4 Grammar-driven Annotation

To overcome the logical form and language mis-
matches discussed, we propose in this section a
new data generation procedure that does not suffer
from these shortcomings. Our procedure, named
GRANNO, relies on two assumptions. First, un-
like OVERNIGHT, we assume access to unlabeled
utterances Xul = {xi}Nuli=1. These can typically be
found in query logs, or generated by users experi-
menting with a prototype. Second, we assume a
scoring function s0(x, c), which provides a rea-
sonable initial similarity score between a natural
language utterance x and a canonical utterance c.

The goal of our procedure is to iteratively label
Xul with crowd workers, aided by the OVERNIGHT
grammar. If we manage to label most of the
dataset Xul, which is sampled from the true target
distribution, we will end up with a labeled dataset
Dga that has very little distribution mismatch.

Figure 1 illustrates the procedure. First, we gen-
erate all canonical utterances Con up to a depth
D from the OVERNIGHT grammar. Because we



3815

Algorithm 1 GRANNO
Input: unlabeled utterances Xul, grammar G
Output: Dga - training data for a semantic parser
1: generate Con from G
2: Dga ‚Üê ‚àÖ, s0(¬∑)‚Üê ‚àíWMD(¬∑), t‚Üê 0
3: converge‚Üê False, Spos ‚Üê ‚àÖ, Sneg ‚Üê ‚àÖ
4: while not converge do
5: for x in Xul do
6: calculate CKx using st(¬∑) . top K candidates
7: crowd workers annotate cx given x and CKx
8: if cx 6= N/A then
9: Dga ‚Üê Dga ‚à™ (x, cx)

10: Xul ‚Üê Xul \ x
11: Spos ‚Üê Spos ‚à™ (x, cx) . positive examples
12: for c in CMx \ {cx} do
13: Sneg ‚Üê Sneg ‚à™ (x, c) . negative examples
14: converge‚Üê check for convergence, t‚Üê t+ 1
15: train st(¬∑) over Spos and Sneg
16: return Dga

do not paraphrase all the canonical utterances, we
can generate to a higher depth D compared to
OVERNIGHT and cover more of the examples in
Xul (see Table 2). Then, we iteratively label the ut-
terances in Xul. At each iteration t, we use a para-
phrase detection model st(x, c) to present promis-
ing canonical utterances to crowd workers for each
unlabeled utterance x, who label the dataset. Im-
portantly, crowd workers in our setup do not gen-
erate paraphrases, they only detect them. We now
describe GRANNO in more detail.

Iterative Annotation At each iteration t, we
rely on a trained scoring function st(x, c) that es-
timates the similarity between an unlabeled utter-
ance x ‚àà Xul and a generated canonical utterance
c ‚àà Con. We follow the procedure described in Al-
gorithm 1. For an utterance x ‚àà Xul, we calculate
the top-K (= 5) most similar canonical utterances
in Con, denoted by CKx . We then present x along
with its candidate paraphrases CKx to a worker, and
ask her to choose the correct candidate paraphrase.
If a paraphrase does not appear in the top-K can-
didates, the worker selects no candidates.

These annotations are then used to train
st+1(x, c), which will be used in the next itera-
tion. For each x ‚àà Xul for which a worker de-
tected a paraphrase cx, we label (x, cx) as a pos-
itive example. We use the top-M (= 100) other
most similar canonical utterances CMx \ {cx} (ac-
cording to st(¬∑)) as negative examples. We train
st+1 from all the examples generated in iterations
0 ¬∑ ¬∑ ¬∑ t. Thus, in every iteration more and more ex-
amples are labeled, and a better scoring function is
trained. We stop when we meet convergence, i.e.,

when no new unlabeled utterances are labeled. We
then output the dataset Dga that contains every ut-
terance x from Xul that is now labeled, paired with
the logical form that corresponds to the detected
canonical utterance paraphrase cx.

We note that an alternative modeling choice was
to use the semantic parser itself as the scorer for
candidate canonical utterances. However, decou-
pling the parser and the scorer is beneficial, as the
discriminative scoring function st(¬∑) benefits from
negative examples (incorrect paraphrases), unlike
the generative semantic parser.

The success of our procedure depends on a good
initial scoring function s0(x, c), to be used in the
first iteration, that we next describe.

Initial Scoring Function We implement
s0(x, c) in an unsupervised manner, as no labeled
examples are available in the first iteration.
Formally, we take s0(x, c) = ‚àíWMD(x, c),
where WMD(x, c) is the Word Mover‚Äôs Distance
(WMD) (Kusner et al., 2015) between x and c,
which is the minimum amount of distance that the
embedded words of one utterance need to travel
to reach those of the other utterance. We found
WMD to perform better than cosine similarity
over averaged pre-trained embeddings, as WMD
performs word-level alignment, and shared words
(such as entities) encourage small distance.

Implementation details We take the unlabeled
utterance set to be all utterances in Dnat, when ig-
noring logical forms: Xul = {x | (x, ¬∑) ‚àà Dnat}.
We generate all canonical utterances up to depth
D= 6, resulting in roughly 350K canonical utter-
ances in SCHOLAR and GEOQUERY, and cover-
age of 90% of the examples in Xul (Table 2).

Our binary classifier st(¬∑) is trained from para-
phrases detected by workers. We utilize the ESIM
neural architecture originally used for natural lan-
guage inference (Chen et al., 2017). We also
employ ELMo contextualized embeddings (Pe-
ters et al., 2018), and minimize the binary cross-
entropy loss for each example.

5 Experiments

5.1 Experimental Setup

Datasets We experiment with two popular se-
mantic parsing datasets: GEOQUERY (Zettle-
moyer and Collins, 2005) and SCHOLAR (Iyer
et al., 2017), that contain questions about US ge-
ography and academic publications, respectively.



3816

Because we utilize the original grammar from
Wang et al. (2015) that generates logical forms in
lambda-DCS (Liang, 2013), we first manually an-
notated GEOQUERY and SCHOLAR with lambda-
DCS logical forms that are translations of the orig-
inal logical forms (Prolog for GEOQUERY and
SQL for SCHOLAR). We only convert examples
that are covered by the OVERNIGHT grammar,
which results in annotating 99.3% of the exam-
ples in GEOQUERY (874 in total), and 96.7% of
the examples in SCHOLAR (790 in total).

Grammar Generation To generate the train-
ing data Don for our OVERNIGHT baseline and
GRANNO, we first exhaustively generated logical
form and canonical utterance pairs from the gram-
mar up to depth D = 5 for OVERNIGHT and D = 6
for GRANNO, using type matching rules such that
vacuous logical forms are not generated. Then, we
further pruned unlikely logical forms that can be
automatically detected (e.g., contradictions such
as ‚Äústate that borders california and that not bor-
ders california‚Äù). We additionally pruned equiva-
lent examples: if we generated a logical form with
the structure A u B, we pruned B u A.

Crowd Sourcing We gathered annotations from
crowd workers by running a qualification task
where we manually verified workers (annotators
with at least 85% success rate were qualified).
Then, qualified workers performed the tasks for
the remaining examples, and for those where un-
qualified workers failed.

For OVERNIGHT, we gathered a single para-
phrase per canonical utterance in Don with a cost
of 0.06$. For GRANNO, we detected a single para-
phrase for each unlabeled utterance inXul that was
not annotated in previous iterations, with a cost of
0.05$.

In total, we gathered 7,140 paraphrases for
OVERNIGHT with a total cost of 515$, and 2,594
detections for GRANNO with a total cost of 155$.
Thus, GRANNO had lower cost per task, and given
the results below, benefits more from fewer tasks.

Neural Semantic Parser We use a standard se-
mantic parser provided by AllenNLP (Gardner
et al., 2017), based on a sequence-to-sequence
model (Sutskever et al., 2014). The encoder is a
BiLSTM that receives ELMo pre-trained embed-
dings (Peters et al., 2018) as input. The attention-
based decoder (Bahdanau et al., 2015) is an LSTM
that also employs copying (Jia and Liang, 2016).

Model GEOQUERY SCHOLAR
SUPERVISED 86.3 83.4
GRANNO 72.0 69.2
OVERNIGHT 61.9 40.8
OVERNIGHT-ORACLE-LF 77.7 73.5
GRANNO-ORCALE 79.1 72.5

Table 5: Denotation accuracy on the test set.

Training Scheme For both the semantic parser
and the paraphrase detection model st(¬∑) we take
10% of the training data for validation (or the of-
ficial development set, if it exists). When training
both models, we abstract examples to their tem-
plates, as in Dong and Lapata (2016) and Finegan-
Dollak et al. (2018) inter alia. For our semantic
parser, we tune the learning rate and dropout over
the development set, and for st(¬∑) we use the same
hyper-parameter values as in Chen et al. (2017).
We use early-stopping, and choose the model with
the highest denotation accuracy and F1 measure
for the semantic parser and st(¬∑), respectively.

5.2 Results

Main Results Table 5 shows the denotation ac-
curacy for all experiments, when training from:
Dnat (SUPERVISED);Don (OVERNIGHT);Dlang, as
described in Section 3.2 (OVERNIGHT-ORACLE-
LF); Dga, described in Section 4 (GRANNO); and
Dga where we simulate a perfect worker that al-
ways detects the gold paraphrase if it appears in
the top-K candidates (GRANNO-ORCALE).

Results show that OVERNIGHT achieves sub-
stantially lower accuracy compared to train-
ing with examples from the target distribution
(SUPERVISED), inline with the analyses presented
in Section 3. For instance, SCHOLAR accuracy
more than halves (40.8 for OVERNIGHT in com-
parison to 83.4 for SUPERVISED). Conversely,
our suggested method GRANNO that directly an-
notates unlabeled utterances achieves much higher
accuracy than OVERNIGHT. Utilizing crowd
workers for detection leads to 70.6 accuracy on av-
erage, and to 75.8 when simulating perfect crowd
workers (GRANNO-ORACLE).

All models performed well on the development
set that was sampled from the same distribution
as the training set (> 80% accuracy), and thus
differences in performance are due to generaliza-
tion to the true distribution. Moreover, the accu-
racy of the paraphrase detection model st(¬∑) was
very high (> 95% F1 measure) on the develop-



3817

Case % Natural language utterance Gold canonical utterance Detected canonical utterance
us .48 ‚Äúwhat is the highest point in california?‚Äù ‚Äúplace that is high point of california‚Äù ‚Äúhigh point of california‚Äù
os .13 ‚Äúhow many citizens in california?‚Äù ‚Äúpopulation of california‚Äù ‚Äútotal population of california‚Äù
w .08 ‚Äúwhich state has the greatest density?‚Äù ‚Äústate that has the largest density‚Äù ‚Äútotal density of state‚Äù
pw .31 ‚Äúwhat is the lowest elevation in california?‚Äù ‚Äúplace that is low point of california‚Äù ‚Äúelevation of low point of california‚Äù

Table 6: Examples of false positive detections by crowd workers for different cases: under specification (us), over
specification (os), wrong (w) and partially wrong (pw).

0 1 2 3 4 5 6 7

0.5

0.6

0.7

0.8

0.9

Iteration t

GEOQUERY-cov
GEOQUERY-cov-oracle

GEOQUERY-cwAcc
SCHOLAR-cov

SCHOLAR-cov-oracle
SCHOLAR-cwAcc

Figure 4: Analysis of GRANNO across iterations.

ment set, showing that detection is easier to model
compared to generation.

We note in passing that we also implemented
a baseline that uses unlabeled examples in con-
junction with OVERNIGHT through self-training
(Konstas et al., 2017). We trained a model with
OVERNIGHT and iteratively labeled unlabeled ut-
terances for which model confidence was high.
However, we were unable to obtain good perfor-
mance with this method.

GRANNO Analysis GRANNO iteratively anno-
tates unlabeled utterances utilizing crowd workers.
Figure 4 reports several metrics for GRANNO for
each iteration: cov details the fraction of annotated
utterances in Xul, where cov-oracle corresponds
to the annotation coverage by GRANNO-ORACLE.
In addition, cwAcc is the crowd workers‚Äô detec-
tion accuracy per iteration, with respect to the gold
canonical utterances. The figure shows that in both
datasets, GRANNO converges in a few iterations,
and that workers‚Äô detection accuracy is high across
all iterations (> 85%).

An interesting phenomenon is that crowd work-
ers (GRANNO) cover the unlabeled utterances
faster than oracle workers (GRANNO-ORACLE).

To analyze this, we inspect false positive, i.e.,
cases where the gold canonical utterance does not
appear in the top-K candidates of st(¬∑), but the
crowd worker detects some candidate as the para-
phrase. Table 6 presents examples for these cases
and their fraction within all false positives for iter-
ation t = 0, where workers cover unlabeled utter-
ances faster than the oracle. We find that in 61%
of the cases, the choice of the workers was equiv-
alent to the gold candidate. This is due to under
specification, when the gold paraphrase is more
specific than the detected one, or over specifica-
tion, which is the opposite case. The other 39%
are indeed errors, which we split into wrong de-
tections, and partially wrong detections, where the
detected paraphrase is different than the gold one,
but is reasonable choice the phrasing of the ques-
tion. E.g., for ‚Äúwhat is the lowest elevation in Cal-
ifornia‚Äù it is unclear whether the answer should be
a location or the elevation. This shows that many
false positives are in fact correct.

Limitations GRANNO relies on the unsuper-
vised function s0(¬∑) to bootstrap the annotation
procedure. In both datasets, s0(¬∑) managed to rank
gold paraphrases within its top-5 candidates for
roughly half of the unlabeled utterances in Xul, but
this is not guaranteed.

During each iteration in GRANNO, the function
st(¬∑) is applied on all pairs of an unlabeled utter-
ance and candidate canonical utterances, thus st(¬∑)
is applied O(|Xul| ¬∑ |Don|) times. Empirically, we
find that computation time is manageable when
limiting the application of st(¬∑) to candidates that
share the same entities as the unlabeled utterance.
However, this might not suffice for KBs with large
schemas. In such cases, an information retrieval
module could retrieve a small number of candi-
dates, similar to Yang et al. (2019).

6 Related Work

Several works used a human in the loop for train-
ing a semantic parser. Iyer et al. (2017) incor-
porated user feedback to detect wrong parses and



3818

sent them to expert annotation. Lawrence and Rie-
zler (2018) and Berant et al. (2019) improved a
supervised parser by showing its predictions to
users and training from this feedback. Gupta et al.
(2018) built a hierarchical annotation scheme for
annotating utterances with multiple intents. Labu-
tov et al. (2019) trained a semantic parser through
interactive dialogues. Comparing to these works,
our proposed method requires no supervised data
or expert annotators, and is suitable for rapid de-
velopment of parsers in multiple domains.

In semi-supervised learning, Konstas et al.
(2017) used self-training to improve an existing
AMR parser. Others used a variational auto-
encoder by modeling unlabeled utterances (Ko-
ciskyÃÅ et al., 2016) or logical forms (Yin et al.,
2018) as latent variables. However, empirical
gains from the unlabeled data were relatively small
compared to annotating more examples.

Finally, several papers extended the
OVERNIGHT procedure. Ravichander et al.
(2017) replaced phrases in the lexicon with im-
ages to elicit more natural language from workers.
(Cheng et al., 2018) generated more complex
compositional structures by splitting the canonical
utterances into multiple steps. Such work relies
on workers to generate paraphrases, while we
propose to simply detect them.

7 Conclusion

We address the challenge of generating data for
training semantic parsers from scratch in multiple
domains. We thoroughly analyze the OVERNIGHT
procedure, and shed light on the factors that lead
to poor generalization, namely logical form mis-
match and language mismatch. We then pro-
pose GRANNO, a method that directly anno-
tates unlabeled utterances with their logical form,
by letting crowd workers detect automatically-
generated canonical utterances. We demonstrate
our method‚Äôs success on two popular datasets, and
find it substantially improves generalization to real
data, compared to OVERNIGHT.

Acknowledgments

We thank the anonymous reviewers for their con-
structive feedback. This work was completed in
partial fulfillment for the PhD degree of the first
author, which was also supported by a Google PhD
fellowship. This research was partially supported
by The Israel Science Foundation grant 942/16,

The Blavatnik Computer Science Research Fund
and The Yandex Initiative for Machine Learning.

References
Y. Artzi and L. Zettlemoyer. 2013. Weakly supervised

learning of semantic parsers for mapping instruc-
tions to actions. Transactions of the Association for
Computational Linguistics (TACL), 1:49‚Äì62.

D. Bahdanau, K. Cho, and Y. Bengio. 2015. Neural
machine translation by jointly learning to align and
translate. In International Conference on Learning
Representations (ICLR).

Jonathan Berant, Daniel Deutch, Amir Globerson,
Tova Milo, and Tomer Wolfson. 2019. Explaining
queries over web tables to non-experts. Interna-
tional Conference on Data Engineering (ICDE).

Qian Chen, Xiaodan Zhu, Zhen-Hua Ling, Si Wei, Hui
Jiang, and Diana Inkpen. 2017. Enhanced LSTM for
natural language inference. In Proceedings of the
55th Annual Meeting of the Association for Com-
putational Linguistics (Volume 1: Long Papers),
pages 1657‚Äì1668, Vancouver, Canada. Association
for Computational Linguistics.

Jianpeng Cheng, Siva Reddy, and Mirella Lapata. 2018.
Building a neural semantic parser from a domain on-
tology. arXiv preprint arXiv:1812.10037.

Marco Damonte, Rahul Goel, and Tagyoung Chung.
2019. Practical semantic parsing for spoken lan-
guage understanding. In Human Language Technol-
ogy and North American Association for Computa-
tional Linguistics (HLT/NAACL).

L. Dong and M. Lapata. 2016. Language to logical
form with neural attention. In Association for Com-
putational Linguistics (ACL).

Catherine Finegan-Dollak, Jonathan K. Kummerfeld,
Li Zhang, Karthik Ramanathan, Sesh Sadasivam,
Rui Zhang, and Dragomir Radev. 2018. Improv-
ing text-to-sql evaluation methodology. In Proceed-
ings of the 56th Annual Meeting of the Association
for Computational Linguistics (Volume 1: Long Pa-
pers), pages 351‚Äì360, Melbourne, Australia. Asso-
ciation for Computational Linguistics.

Matt Gardner, Joel Grus, Mark Neumann, Oyvind
Tafjord, Pradeep Dasigi, Nelson F. Liu, Matthew
Peters, Michael Schmitz, and Luke S. Zettlemoyer.
2017. Allennlp: A deep semantic natural language
processing platform.

Sonal Gupta, Rushin Shah, Mrinal Mohit, Anuj Ku-
mar, and Mike Lewis. 2018. Semantic parsing for
task oriented dialog using hierarchical representa-
tions. In Proceedings of the 2018 Conference on
Empirical Methods in Natural Language Process-
ing, pages 2787‚Äì2792, Brussels, Belgium. Associ-
ation for Computational Linguistics.

https://doi.org/10.18653/v1/P17-1152
https://doi.org/10.18653/v1/P17-1152
https://www.aclweb.org/anthology/P18-1033
https://www.aclweb.org/anthology/P18-1033
http://arxiv.org/abs/arXiv:1803.07640
http://arxiv.org/abs/arXiv:1803.07640
https://www.aclweb.org/anthology/D18-1300
https://www.aclweb.org/anthology/D18-1300
https://www.aclweb.org/anthology/D18-1300


3819

J. Herzig and J. Berant. 2017. Neural semantic parsing
over multiple knowledge-bases. In Association for
Computational Linguistics (ACL).

J. Herzig and J. Berant. 2018. Decoupling structure
and lexicon for zero-shot semantic parsing. In Em-
pirical Methods in Natural Language Processing
(EMNLP).

Drew A Hudson and Christopher D Manning. 2019.
Gqa: a new dataset for compositional question an-
swering over real-world images. arXiv preprint
arXiv:1902.09506.

S. Iyer, I. Konstas, A. Cheung, J. Krishnamurthy, and
L. Zettlemoyer. 2017. Learning a neural semantic
parser from user feedback. In Association for Com-
putational Linguistics (ACL).

R. Jia and P. Liang. 2016. Data recombination for neu-
ral semantic parsing. In Association for Computa-
tional Linguistics (ACL).

J. Johnson, B. Hariharan, L. van der Maaten, L. Fei-Fei,
C. L. Zitnick, and R. Girshick. 2017. Clevr: A di-
agnostic dataset for compositional language and el-
ementary visual reasoning. In Computer Vision and
Pattern Recognition (CVPR).

T. KociskyÃÅ, G. Melis, E. Grefenstette, C. Dyer,
W. Ling, P. Blunsom, and K. M. Hermann. 2016.
Semantic parsing with semi-supervised sequential
autoencoders. In Empirical Methods in Natural
Language Processing (EMNLP), pages 1078‚Äì1087.

I. Konstas, S. Iyer, M. Yatskar, Y. Choi, and L. Zettle-
moyer. 2017. Neural AMR: sequence-to-sequence
models for parsing and generation. CoRR, 0.

Matt Kusner, Yu Sun, Nicholas Kolkin, and Kilian
Weinberger. 2015. From word embeddings to docu-
ment distances. In International Conference on Ma-
chine Learning, pages 957‚Äì966.

T. Kwiatkowski, E. Choi, Y. Artzi, and L. Zettlemoyer.
2013. Scaling semantic parsers with on-the-fly on-
tology matching. In Empirical Methods in Natural
Language Processing (EMNLP).

Igor Labutov, Bishan Yang, and Tom Mitchell.
2019. Learning to learn semantic parsers from
natural language supervision. arXiv preprint
arXiv:1902.08373.

Carolin Lawrence and Stefan Riezler. 2018. Improving
a neural semantic parser by counterfactual learning
from human bandit feedback. In Proceedings of the
56th Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
1820‚Äì1830, Melbourne, Australia. Association for
Computational Linguistics.

P. Liang. 2013. Lambda dependency-based composi-
tional semantics. arXiv preprint arXiv:1309.4408.

P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Association for Computational Linguistics (ACL),
pages 590‚Äì599.

Nicholas Locascio, Karthik Narasimhan, Eduardo
De Leon, Nate Kushman, and Regina Barzilay.
2016. Neural generation of regular expressions from
natural language with minimal domain knowledge.
In Proceedings of the 2016 Conference on Empiri-
cal Methods in Natural Language Processing, pages
1918‚Äì1923, Austin, Texas. Association for Compu-
tational Linguistics.

J. Pennington, R. Socher, and C. D. Manning. 2014.
GloVe: Global vectors for word representation. In
Empirical Methods in Natural Language Processing
(EMNLP), pages 1532‚Äì1543.

M. E. Peters, M. Neumann, M. Iyyer, M. Gard-
ner, C. Clark, K. Lee, and L. Zettlemoyer. 2018.
Deep contextualized word representations. In North
American Association for Computational Linguis-
tics (NAACL).

Abhilasha Ravichander, Thomas Manzini, Matthias
Grabmair, Graham Neubig, Jonathan Francis, and
Eric Nyberg. 2017. How would you say it? eliciting
lexically diverse dialogue for supervised semantic
parsing. In Proceedings of the 18th Annual SIGdial
Meeting on Discourse and Dialogue, pages 374‚Äì
383, SaarbruÃàcken, Germany. Association for Com-
putational Linguistics.

Pararth Shah, Dilek Hakkani-TuÃàr, Gokhan TuÃàr, Ab-
hinav Rastogi, Ankur Bapna, Neha Nayak, and
Larry Heck. 2018. Building a conversational agent
overnight with dialogue self-play. arXiv preprint
arXiv:1801.04871.

Y. Su and X. Yan. 2017. Cross-domain semantic pars-
ing via paraphrasing. In Empirical Methods in Nat-
ural Language Processing (EMNLP).

I. Sutskever, O. Vinyals, and Q. V. Le. 2014. Sequence
to sequence learning with neural networks. In Ad-
vances in Neural Information Processing Systems
(NeurIPS), pages 3104‚Äì3112.

Y. Wang, J. Berant, and P. Liang. 2015. Building a
semantic parser overnight. In Association for Com-
putational Linguistics (ACL).

Wei Yang, Yuqing Xie, Aileen Lin, Xingyu Li, Luchen
Tan, Kun Xiong, Ming Li, and Jimmy Lin. 2019.
End-to-end open-domain question answering with
BERTserini. arXiv preprint arXiv:1902.01718.

Pengcheng Yin, Chunting Zhou, Junxian He, and Gra-
ham Neubig. 2018. StructVAE: Tree-structured la-
tent variable models for semi-supervised semantic
parsing. In Proceedings of the 56th Annual Meet-
ing of the Association for Computational Linguis-
tics (Volume 1: Long Papers), pages 754‚Äì765, Mel-
bourne, Australia. Association for Computational
Linguistics.

https://www.aclweb.org/anthology/P18-1169
https://www.aclweb.org/anthology/P18-1169
https://www.aclweb.org/anthology/P18-1169
https://doi.org/10.18653/v1/D16-1197
https://doi.org/10.18653/v1/D16-1197
https://doi.org/10.18653/v1/W17-5545
https://doi.org/10.18653/v1/W17-5545
https://doi.org/10.18653/v1/W17-5545
https://www.aclweb.org/anthology/P18-1070
https://www.aclweb.org/anthology/P18-1070
https://www.aclweb.org/anthology/P18-1070


3820

M. Zelle and R. J. Mooney. 1996. Learning to parse
database queries using inductive logic program-
ming. In Association for the Advancement of Arti-
ficial Intelligence (AAAI), pages 1050‚Äì1055.

L. S. Zettlemoyer and M. Collins. 2005. Learning to
map sentences to logical form: Structured classifica-
tion with probabilistic categorial grammars. In Un-
certainty in Artificial Intelligence (UAI), pages 658‚Äì
666.

Victor Zhong, Caiming Xiong, and Richard Socher.
2017. Seq2sql: Generating structured queries
from natural language using reinforcement learning.
CoRR, abs/1709.00103.


