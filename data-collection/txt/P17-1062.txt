



















































Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics


Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 665–677
Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/P17-1062

Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 665–677
Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics

https://doi.org/10.18653/v1/P17-1062

Hybrid Code Networks: practical and efficient end-to-end dialog control
with supervised and reinforcement learning

Jason D. Williams
Microsoft Research

jason.williams@microsoft.com

Kavosh Asadi
Brown University
kavosh@brown.edu

Geoffrey Zweig∗
Microsoft Research
g2zweig@gmail.com

Abstract

End-to-end learning of recurrent neural
networks (RNNs) is an attractive solu-
tion for dialog systems; however, cur-
rent techniques are data-intensive and re-
quire thousands of dialogs to learn sim-
ple behaviors. We introduce Hybrid
Code Networks (HCNs), which combine
an RNN with domain-specific knowledge
encoded as software and system action
templates. Compared to existing end-to-
end approaches, HCNs considerably re-
duce the amount of training data required,
while retaining the key benefit of inferring
a latent representation of dialog state. In
addition, HCNs can be optimized with su-
pervised learning, reinforcement learning,
or a mixture of both. HCNs attain state-
of-the-art performance on the bAbI dialog
dataset (Bordes and Weston, 2016), and
outperform two commercially deployed
customer-facing dialog systems.

1 Introduction

Task-oriented dialog systems help a user to ac-
complish some goal using natural language, such
as making a restaurant reservation, getting techni-
cal support, or placing a phonecall. Historically,
these dialog systems have been built as a pipeline,
with modules for language understanding, state
tracking, action selection, and language genera-
tion. However, dependencies between modules in-
troduce considerable complexity – for example, it
is often unclear how to define the dialog state and
what history to maintain, yet action selection re-
lies exclusively on the state for input. Moreover,
training each module requires specialized labels.

∗Currently at JPMorgan Chase

Recently, end-to-end approaches have trained
recurrent neural networks (RNNs) directly on text
transcripts of dialogs. A key benefit is that the
RNN infers a latent representation of state, obviat-
ing the need for state labels. However, end-to-end
methods lack a general mechanism for injecting
domain knowledge and constraints. For example,
simple operations like sorting a list of database re-
sults or updating a dictionary of entities can ex-
pressed in a few lines of software, yet may take
thousands of dialogs to learn. Moreover, in some
practical settings, programmed constraints are es-
sential – for example, a banking dialog system
would require that a user is logged in before they
can retrieve account information.

This paper presents a model for end-to-end
learning, called Hybrid Code Networks (HCNs)
which addresses these problems. In addition to
learning an RNN, HCNs also allow a developer
to express domain knowledge via software and ac-
tion templates. Experiments show that, compared
to existing recurrent end-to-end techniques, HCNs
achieve the same performance with considerably
less training data, while retaining the key benefit
of end-to-end trainability. Moreover, the neural
network can be trained with supervised learning
or reinforcement learning, by changing the gradi-
ent update applied.

This paper is organized as follows. Section 2
describes the model, and Section 3 compares the
model to related work. Section 4 applies HCNs
to the bAbI dialog dataset (Bordes and Weston,
2016). Section 5 then applies the method to real
customer support domains at our company. Sec-
tion 6 illustrates how HCNs can be optimized with
reinforcement learning, and Section 7 concludes.

665

https://doi.org/10.18653/v1/P17-1062
https://doi.org/10.18653/v1/P17-1062


What’s the weather 
this week in Seattle?

Choose 
action 

template

Entity 
output

Action 
type?

Anything else? text

Dense + 
softmaxRNN

Entity
tracking

Bag of words vector Forecast() 0.93

Normal-
ization.

X

Anything else? 0.07

<city>, right? 0.00
API call

API

WeatherBot

Utterance embedding 

2

3

4

7 9

11

14

15

18

6

1213

17

Action
mask

Context 
features

Fully-formed 
action

API 
result

1

5

Entity 
extraction

t+1

t+1

8

10

t+1
16

Figure 1: Operational loop. Trapezoids refer to programmatic code provided by the software developer,
and shaded boxes are trainable components. Vertical bars under “6” represent concatenated vectors
which form the input to the RNN.

2 Model description

At a high level, the four components of a Hy-
brid Code Network are a recurrent neural net-
work; domain-specific software; domain-specific
action templates; and a conventional entity extrac-
tion module for identifying entity mentions in text.
Both the RNN and the developer code maintain
state. Each action template can be a textual com-
municative action or an API call. The HCN model
is summarized in Figure 1.

The cycle begins when the user provides an ut-
terance, as text (step 1). The utterance is featurized
in several ways. First, a bag of words vector is
formed (step 2). Second, an utterance embedding
is formed, using a pre-built utterance embedding
model (step 3). Third, an entity extraction module
identifies entity mentions (step 4) – for example,
identifying “Jennifer Jones” as a <name> entity.
The text and entity mentions are then passed to
“Entity tracking” code provided by the developer
(step 5), which grounds and maintains entities –
for example, mapping the text “Jennifer Jones” to
a specific row in a database. This code can option-
ally return an “action mask”, indicating actions
which are permitted at the current timestep, as a
bit vector. For example, if a target phone number
has not yet been identified, the API action to place
a phone call may be masked. It can also option-
ally return “context features” which are features
the developer thinks will be useful for distinguish-

ing among actions, such as which entities are cur-
rently present and which are absent.

The feature components from steps 1-5 are con-
catenated to form a feature vector (step 6). This
vector is passed to an RNN, such as a long short-
term memory (LSTM) (Hochreiter and Schmidhu-
ber, 1997) or gated recurrent unit (GRU) (Chung
et al., 2014). The RNN computes a hidden state
(vector), which is retained for the next timestep
(step 8), and passed to a dense layer with a soft-
max activation, with output dimension equal to the
number of distinct system action templates (step
9).1 Thus the output of step 9 is a distribution over
action templates. Next, the action mask is applied
as an element-wise multiplication, and the result is
normalized back to a probability distribution (step
10) – this forces non-permitted actions to take on
probability zero. From the resulting distribution
(step 11), an action is selected (step 12). When RL
is active, exploration is required, so in this case an
action is sampled from the distribution; when RL
is not active, the best action should be chosen, and
so the action with the highest probability is always
selected.

The selected action is next passed to “Entity
output” developer code that can substitute in en-
tities (step 13) and produce a fully-formed action
– for example, mapping the template “<city>,

1Implementation details for the RNN such as size, loss,
etc. are given with each experiment in Sections 4-6.

666



right?” to “Seattle, right?”. In step 14, control
branches depending on the type of the action: if it
is an API action, the corresponding API call in the
developer code is invoked (step 15) – for example,
to render rich content to the user. APIs can act as
sensors and return features relevant to the dialog,
so these can be added to the feature vector in the
next timestep (step 16). If the action is text, it is
rendered to the user (step 17), and cycle then re-
peats. The action taken is provided as a feature to
the RNN in the next timestep (step 18).

3 Related work

Broadly there are two lines of work applying ma-
chine learning to dialog control. The first de-
composes a dialog system into a pipeline, typ-
ically including language understanding, dialog
state tracking, action selection policy, and lan-
guage generation (Levin et al., 2000; Singh et al.,
2002; Williams and Young, 2007; Williams, 2008;
Hori et al., 2009; Lee et al., 2009; Griol et al.,
2008; Young et al., 2013; Li et al., 2014). Specifi-
cally related to HCNs, past work has implemented
the policy as feed-forward neural networks (Wen
et al., 2016), trained with supervised learning fol-
lowed by reinforcement learning (Su et al., 2016).
In these works, the policy has not been recur-
rent – i.e., the policy depends on the state tracker
to summarize observable dialog history into state
features, which requires design and specialized la-
beling. By contrast, HCNs use an RNN which au-
tomatically infers a representation of state. For
learning efficiency, HCNs use an external light-
weight process for tracking entity values, but the
policy is not strictly dependent on it: as an illustra-
tion, in Section 5 below, we demonstrate an HCN-
based dialog system which has no external state
tracker. If there is context which is not apparent in
the text in the dialog, such as database status, this
can be encoded as a context feature to the RNN.

The second, more recent line of work applies
recurrent neural networks (RNNs) to learn “end-
to-end” models, which map from an observable
dialog history directly to a sequence of output
words (Sordoni et al., 2015; Shang et al., 2015;
Vinyals and Le, 2015; Yao et al., 2015; Serban
et al., 2016; Li et al., 2016a,c; Luan et al., 2016;
Xu et al., 2016; Li et al., 2016b; Mei et al., 2016;
Lowe et al., 2017; Serban et al., 2017). These
systems can be applied to task-oriented domains
by adding special “API call” actions, enumerating

database output as a sequence of tokens (Bordes
and Weston, 2016), then learning an RNN using
Memory Networks (Sukhbaatar et al., 2015), gated
memory networks (Liu and Perez, 2016), query
reduction networks (Seo et al., 2016), and copy-
augmented networks (Eric and Manning, 2017).
In each of these architectures, the RNN learns to
manipulate entity values, for example by saving
them in a memory. Output is produced by gen-
erating a sequence of tokens (or ranking all pos-
sible surface forms), which can also draw from
this memory. HCNs also use an RNN to accu-
mulate dialog state and choose actions. However,
HCNs differ in that they use developer-provided
action templates, which can contain entity refer-
ences, such as “<city>, right?”. This design re-
duce learning complexity, and also enable the soft-
ware to limit which actions are available via an ac-
tion mask, at the expense of developer effort. To
further reduce learning complexity in a practical
system, entities are tracked separately, outside the
the RNN, which also allows them to be substituted
into action templates. Also, past end-to-end re-
current models have been trained using supervised
learning, whereas we show how HCNs can also be
trained with reinforcement learning.

4 Supervised learning evaluation I

In this section we compare HCNs to existing ap-
proaches on the public “bAbI dialog” dataset (Bor-
des and Weston, 2016). This dataset includes two
end-to-end dialog learning tasks, in the restaurant
domain, called task5 and task6.2 Task5 consists of
synthetic, simulated dialog data, with highly regu-
lar user behavior and constrained vocabulary. Di-
alogs include a database access action which re-
trieves relevant restaurants from a database, with
results included in the dialog transcript. We test on
the “OOV” variant of Task5, which includes en-
tity values not observed in the training set. Task6
draws on human-computer dialog data from the
second dialog state tracking challenge (DSTC2),
where usability subjects (crowd-workers) inter-
acted with several variants of a spoken dialog sys-
tem (Henderson et al., 2014a). Since the database
from DSTC2 was not provided, database calls
have been inferred from the data and inserted into
the dialog transcript. Example dialogs are pro-
vided in the Appendix Sections A.2 and A.3.

To apply HCNs, we wrote simple domain-
2Tasks 1-4 are sub-tasks of Task5.

667



specific software, as follows. First, for entity
extraction (step 4 in Figure 1), we used a sim-
ple string match, with a pre-defined list of entity
names – i.e., the list of restaurants available in
the database. Second, in the context update (step
5), we wrote simple logic for tracking entities:
when an entity is recognized in the user input, it
is retained by the software, over-writing any pre-
viously stored value. For example, if the price
“cheap” is recognized in the first turn, it is retained
as price=cheap. If “expensive” is then recog-
nized in the third turn, it over-writes “cheap” so
the code now holds price=expensive. Third,
system actions were templatized: for example,
system actions of the form “prezzo is a nice restau-
rant in the west of town in the moderate price
range” all map to the template “<name> is a nice
restaurant in the <location> of town in the
<price> price range”. This results in 16 tem-
plates for Task5 and 58 for Task6.3 Fourth, when
database results are received into the entity state,
they are sorted by rating. Finally, an action mask
was created which encoded common-sense depen-
dencies. These are implemented as simple if-then
rules based on the presence of entity values: for
example, only allow an API call if pre-conditions
are met; only offer a restaurant if database results
have already been received; do not ask for an en-
tity if it is already known; etc.

For Task6, we noticed that the system can say
that no restaurants match the current query with-
out consulting the database (for an example dia-
log, see Section A.3 in the Appendix). In a prac-
tical system this information would be retrieved
from the database and not encoded in the RNN.
So, we mined the training data and built a table
of search queries known to yield no results. We
also added context features that indicated the state
of the database – for example, whether there were
any restaurants matching the current query. The
complete set of context features is given in Ap-
pendix Section A.4. Altogether this code con-
sisted of about 250 lines of Python.

We then trained an HCN on the training set,
employing the domain-specific software described
above. We selected an LSTM for the recurrent
layer (Hochreiter and Schmidhuber, 1997), with
the AdaDelta optimizer (Zeiler, 2012). We used
the development set to tune the number of hid-

3A handful of actions in Task6 seemed spurious; for these,
we replaced them with a special “UNK” action in the training
set, and masked this action at test time.

den units (128), and the number of epochs (12).
Utterance embeddings were formed by averaging
word embeddings, using a publicly available 300-
dimensional word embedding model trained us-
ing word2vec on web data (Mikolov et al., 2013).4

The word embeddings were static and not updated
during LSTM training. In training, each dialog
formed one minibatch, and updates were done on
full rollouts (i.e., non-truncated back propagation
through time). The training loss was categorical
cross-entropy. Further low-level implementation
details are in the Appendix Section A.1.

We ran experiments with four variants of our
model: with and without the utterance embed-
dings, and with and without the action mask (Fig-
ure 1, steps 3 and 6 respectively).

Following past work, we report average turn ac-
curacy – i.e., for each turn in each dialog, present
the (true) history of user and system actions to the
network and obtain the network’s prediction as a
string of characters. The turn is correct if the string
matches the reference exactly, and incorrect if not.
We also report dialog accuracy, which indicates if
all turns in a dialog are correct.

We compare to four past end-to-end approaches
(Bordes and Weston, 2016; Liu and Perez, 2016;
Eric and Manning, 2017; Seo et al., 2016). We em-
phasize that past approaches have applied purely
sequence-to-sequence models, or (as a baseline)
purely programmed rules (Bordes and Weston,
2016). By contrast, Hybrid Code Networks are a
hybrid of hand-coded rules and learned models.

Results are shown in Table 1. Since Task5 is
synthetic data generated using rules, it is possi-
ble to obtain perfect accuracy using rules (line 1).
The addition of domain knowledge greatly simpli-
fies the learning task and enables HCNs to also at-
tain perfect accuracy. On Task6, rules alone fare
poorly, whereas HCNs outperform past learned
models.

We next examined learning curves, training
with increasing numbers of dialogs. To guard
against bias in the ordering of the training set, we
averaged over 5 runs, randomly permuting the or-
der of the training dialogs in each run. Results are
in Figure 2. In Task5, the action mask and utter-
ance embeddings substantially reduce the number
of training dialogs required (note the horizontal
axis scale is logarithmic). For Task6, the bene-

4Google News 100B model from https://github.
com/3Top/word2vec-api

668



Task5-OOV Task6
Model Turn Acc. Dialog Acc. Turn Acc. Dialog Acc.
Rules 100% 100% 33.3% 0.0%

Bordes and Weston (2016) 77.7% 0.0% 41.1% 0.0%
Liu and Perez (2016) 79.4% 0.0% 48.7% 1.4%

Eric and Manning (2017) — — 48.0% 1.5%
Seo et al. (2016) 96.0% — 51.1% —

HCN 100% 100% 54.0% 1.2%
HCN+embed 100% 100% 55.6% 1.3%
HCN+mask 100% 100% 53.1% 1.9%

HCN+embed+mask 100% 100% 52.7% 1.5%

Table 1: Results on bAbI dialog Task5-OOV and Task6 (Bordes and Weston, 2016). Results for “Rules”
taken from Bordes and Weston (2016). Note that, unlike cited past work, HCNs make use of domain-
specific procedural knowledge.

20%

30%

40%

50%

60%

70%

80%

90%

100%

1 2 5 10 20 50 100 200 500 1000

Tu
rn

 a
cc

ur
ac

y

Supervised learning training dialogs

HCN+mask+embed
HCN+mask
HCN+embed
HCN

(a) bAbI dialog Task5-OOV.

0%

10%

20%

30%

40%

50%

60%

1 2 5 10 20 50 100 200 500 1000 1618

Tu
rn

 a
cc

ur
ac

y

Supervised learning training dialogs

HCN+mask+embed
HCN+mask
HCN+embed
HCN

(b) bAbI dialog Task6.

Figure 2: Training dialog count vs. turn accuracy for bAbI dialog Task5-OOV and Task6. “embed”
indicates whether utterance embeddings were included; “mask” indicates whether the action masking
code was active.

fits of the utterance embeddings are less clear. An
error analysis showed that there are several sys-
tematic differences between the training and test-
ing sets. Indeed, DSTC2 intentionally used differ-
ent dialog policies for the training and test sets,
whereas our goal is to mimic the policy in the
training set.

Nonetheless, these tasks are the best public
benchmark we are aware of, and HCNs exceed
performance of existing sequence-to-sequence
models. In addition, they match performance of
past models using an order of magnitude less data
(200 vs. 1618 dialogs), which is crucial in practi-
cal settings where collecting realistic dialogs for a
new domain can be expensive.

5 Supervised learning evaluation II

We now turn to comparing with purely hand-
crafted approaches. To do this, we obtained logs
from our company’s text-based customer support
dialog system, which uses a sophisticated rule-
based dialog manager. Data from this system is
attractive for evaluation because it is used by real
customers – not usability subjects – and because
its rule-based dialog manager was developed by
customer support professionals at our company,
and not the authors. This data is not publicly
available, but we are unaware of suitable human-
computer dialog data in the public domain which
uses rules.

Customers start using the dialog system by en-
tering a brief description of their problem, such

669



as “I need to update my operating system”. They
are then routed to one of several hundred domains,
where each domain attempts to resolve a particu-
lar problem. In this study, we collected human-
computer transcripts for the high-traffic domains
“reset password” and “cannot access account”.

We labeled the dialog data as follows. First,
we enumerated unique system actions observed in
the data. Then, for each dialog, starting from the
beginning, we examined each system action, and
determined whether it was “correct”. Here, cor-
rect means that it was the most appropriate action
among the set of existing system actions, given the
history of that dialog. If multiple actions were ar-
guably appropriate, we broke ties in favor of the
existing rule-based dialog manager. Example di-
alogs are provided in the Appendix Sections A.5
and A.6.

If a system action was labeled as correct, we left
it as-is and continued to the next system action. If
the system action was not correct, we replaced it
with the correct system action, and discarded the
rest of the dialog, since we do not know how the
user would have replied to this new system action.
The resulting dataset contained a mixture of com-
plete and partial dialogs, containing only correct
system actions. We partitioned this set into train-
ing and test dialogs. Basic statistics of the data are
shown in Table 2.

In this domain, no entities were relevant to the
control flow, and there was no obvious mask logic
since any question could follow any question.
Therefore, we wrote no domain-specific software
for this instance of the HCN, and relied purely on
the recurrent neural network to drive the conver-
sation. The architecture and training of the RNN
was the same as in Section 4, except that here we
did not have enough data for a validation set, so
we instead trained until we either achieved 100%
accuracy on the training set or reached 200 epochs.

To evaluate, we observe that conventional mea-
sures like average dialog accuracy unfairly penal-
ize the system used to collect the dialogs – in our
case, the rule-based system. If the system used
for collection makes an error at turn t, the labeled
dialog only includes the sub-dialog up to turn t,
and the system being evaluated off-line is only
evaluated on that sub-dialog. In other words, in
our case, reporting dialog accuracy would favor
the HCN because it would be evaluated on fewer
turns than the rule-based system. We therefore

Forgot Account
password Access

Av. sys. turns/dialog 2.2 2.2
Max. sys. turns/dialog 5 9

Av. words/user turn 7.7 5.4
Unique sys. actions 7 16

Train dialogs 422 56
Test dialogs 148 60

Test acc. (rules) 64.9% 42.1%

Table 2: Basic statistics of labeled customer sup-
port dialogs. Test accuracy refers to whole-dialog
accuracy of the existing rule-based system.

use a comparative measure that examines which
method produces longer continuous sequences of
correct system actions, starting from the begin-
ning of the dialog. Specifically, we report ∆P =
C(HCN-win)−C(rule-win)

C(all) , where C(HCN-win) is the
number of test dialogs where the rule-based ap-
proach output a wrong action before the HCN;
C(rule-win) is the number of test dialogs where
the HCN output a wrong action before the rule-
based approach; and C(all) is the number of di-
alogs in the test set. When ∆P > 0, there are
more dialogs in which HCNs produce longer con-
tinuous sequences of correct actions starting from
the beginning of the dialog. We run all experi-
ments 5 times, each time shuffling the order of the
training set. Results are in Figure 3. HCNs exceed
performance of the existing rule-based system af-
ter about 30 dialogs.

In these domains, we have a further source of
knowledge: the rule-based dialog managers them-
selves can be used to generate example “sunny-
day” dialogs, where the user provides purely ex-
pected inputs. From each rule-based controller,
synthetic dialogs were sampled to cover each ex-
pected user response at least once, and added to
the set of labeled real dialogs. This resulted in
75 dialogs for the “Forgot password” domain, and
325 for the “Can’t access account” domain. Train-
ing was repeated as described above. Results are
also included in Figure 3, with the suffix “sam-
pled”. In the “Can’t access account” domain, the
sampled dialogs yield a large improvement, proba-
bly because the flow chart for this domain is large,
so the sampled dialogs increase coverage. The
gain in the “forgot password” domain is present
but smaller.

In summary, HCNs can out-perform

670



-40%

-30%

-20%

-10%

0%

10%

20%

0 20 40 60 80 100

ΔP

Labeled supervised learning training dialogs

HCN+embed+sampled

HCN+sampled

HCN+embed

HCN

(a) “Forgot password” domain.

-40%

-30%

-20%

-10%

0%

10%

20%

30%

0 10 20 30 40 50

ΔP

Labeled supervised learning training dialogs

HCN+embed+sampled

HCN+sampled

HCN+embed

HCN

(b) “Can’t access account” domain.

Figure 3: Training dialogs vs. ∆P , where ∆P is the fraction of test dialogs where HCNs produced
longer initial correct sequences of system actions than the rules, minus the fraction where rules produced
longer initial correct sequences than the HCNs. “embed” indicates whether utterance embeddings were
included; “sampled” indicates whether dialogs sampled from the rule-based controller were included in
the training set.

production-grade rule-based systems with a
reasonable number of labeled dialogs, and
adding synthetic “sunny-day” dialogs improves
performance further. Moreover, unlike existing
pipelined approaches to dialog management that
rely on an explicit state tracker, this HCN used no
explicit state tracker, highlighting an advantage of
the model.

6 Reinforcement learning illustration

In the previous sections, supervised learning (SL)
was applied to train the LSTM to mimic dialogs
provided by the system developer. Once a system
operates at scale, interacting with a large number
of users, it is desirable for the system to continue
to learn autonomously using reinforcement learn-
ing (RL). With RL, each turn receives a measure-
ment of goodness called a reward; the agent ex-
plores different sequences of actions in different
situations, and makes adjustments so as to max-
imize the expected discounted sum of rewards,
which is called the return, denoted G.

For optimization, we selected a policy gradient
approach (Williams, 1992), which has been suc-
cessfully applied to dialog systems (Jurčı́ček et al.,
2011), robotics (Kohl and Stone, 2004), and the
board game Go (Silver et al., 2016). In policy
gradient-based RL, a model π is parameterized by
w and outputs a distribution from which actions
are sampled at each timestep. At the end of a tra-
jectory – in our case, dialog – the return G for

that trajectory is computed, and the gradients of
the probabilities of the actions taken with respect
to the model weights are computed. The weights
are then adjusted by taking a gradient step propor-
tional to the return:

w← w+α(
∑

t

Ow log π(at|ht;w))(G−b) (1)

where α is a learning rate; at is the action taken at
timestep t; ht is the dialog history at time t; G is
the return of the dialog; OxF denotes the Jacobian
of F with respect to x; b is a baseline described be-
low; and π(a|h;w) is the LSTM – i.e., a stochastic
policy which outputs a distribution over a given
a dialog history h, parameterized by weights w.
The baseline b is an estimate of the average return
of the current policy, estimated on the last 100 di-
alogs using weighted importance sampling.5 Intu-
itively, “better” dialogs receive a positive gradient
step, making the actions selected more likely; and
“worse” dialogs receive a negative gradient step,
making the actions selected less likely.

SL and RL correspond to different methods of
updating weights, so both can be applied to the
same network. However, there is no guarantee that
the optimal RL policy will agree with the SL train-
ing set; therefore, after each RL gradient step, we

5The choice of baseline does not affect the long-term con-
vergence of the algorithm (i.e., the bias), but can dramatically
affect the speed of convergence (i.e., the variance) (Williams,
1992).

671



check whether the updated policy reconstructs the
training set. If not, we re-run SL gradient steps
on the training set until the model reproduces the
training set. Note that this approach allows new
training dialogs to be added at any time during RL
optimization.

We illustrate RL optimization on a simulated
dialog task in the name dialing domain. In this
system, a contact’s name may have synonyms
(“Michael” may also be called “Mike”), and a con-
tact may have more than one phone number, such
as “work” or “mobile”, which may in turn have
synonyms like “cell” for “mobile”. This domain
has a database of names and phone numbers taken
from the Microsoft personnel directory, 5 entity
types – firstname, nickname, lastname,
phonenumber, and phonetype – and 14 ac-
tions, including 2 API call actions. Simple en-
tity logic was coded, which retains the most re-
cent copy of recognized entities. A simple action
mask suppresses impossible actions, such as plac-
ing a phonecall before a phone number has been
retrieved from the database. Example dialogs are
provided in Appendix Section A.7.

To perform optimization, we created a simu-
lated user. At the start of a dialog, the simulated
user randomly selected a name and phone type, in-
cluding names and phone types not covered by the
dialog system. When speaking, the simulated user
can use the canonical name or a nickname; usually
answers questions but can ignore the system; can
provide additional information not requested; and
can give up. The simulated user was parameter-
ized by around 10 probabilities, set by hand.

We defined the reward as being 1 for success-
fully completing the task, and 0 otherwise. A dis-
count of 0.95 was used to incentivize the system to
complete dialogs faster rather than slower, yield-
ing return 0 for failed dialogs, and G = 0.95T−1

for successful dialogs, where T is the number of
system turns in the dialog. Finally, we created a
set of 21 labeled dialogs, which will be used for
supervised learning.

For the RNN in the HCN, we again used an
LSTM with AdaDelta, this time with 32 hidden
units. RL policy updates are made after each dia-
log. Since a simulated user was employed, we did
not have real user utterances, and instead relied on
context features, omitting bag-of-words and utter-
ance embedding features.

We first evaluate RL by randomly initializing an

0%

10%

20%

30%

40%

50%

60%

70%

D
ia

lo
g 

su
cc

es
s r

at
e

Reinforcement learning training dialogs

10 interleaved
10 initial
5 initial
3 initial
1 initial
0

Figure 4: Dialog success rate vs. reinforcement
learning training dialogs. Curve marked “0” be-
gins with a randomly initialized LSTM. Curves
marked “N initial” are pre-trained with N labeled
dialogs. Curve marked “10, interleaved” adds one
SL training dialog before RL dialog 0, 100, 200,
... 900.

LSTM, and begin RL optimization. After 10 RL
updates, we freeze the policy, and run 500 dialogs
with the user simulation to measure task comple-
tion. We repeat all of this for 100 runs, and report
average performance. In addition, we also report
results by initializing the LSTM using supervised
learning on the training set, consisting of 1, 2, 5,
or 10 dialogs sampled randomly from the training
set, then running RL as described above.

Results are in Figure 4. Although RL alone can
find a good policy, pre-training with just a hand-
ful of labeled dialogs improves learning speed dra-
matically. Additional experiments, not shown for
space, found that ablating the action mask slowed
training, agreeing with Williams (2008).

Finally, we conduct a further experiment where
we sample 10 training dialogs, then add one to
the training set just before RL dialog 0, 100, 200,
... , 900. Results are shown in Figure 4. This
shows that SL dialogs can be introduced as RL is
in progress – i.e., that it is possible to interleave
RL and SL. This is an attractive property for prac-
tical systems: if a dialog error is spotted by a de-
veloper while RL is in progress, it is natural to add
a training dialog to the training set.

7 Conclusion

This paper has introduced Hybrid Code Networks
for end-to-end learning of task-oriented dialog

672



systems. HCNs support a separation of concerns
where procedural knowledge and constraints can
be expressed in software, and the control flow
is learned. Compared to existing end-to-end ap-
proaches, HCNs afford more developer control
and require less training data, at the expense of a
small amount of developer effort.

Results in this paper have explored three differ-
ent dialog domains. On a public benchmark in the
restaurants domain, HCNs exceeded performance
of purely learned models. Results in two trou-
bleshooting domains exceeded performance of a
commercially deployed rule-based system. Fi-
nally, in a name-dialing domain, results from di-
alog simulation show that HCNs can also be opti-
mized with a mixture of reinforcement and super-
vised learning.

In future work, we plan to extend HCNs by
incorporating lines of existing work, such as in-
tegrating the entity extraction step into the neu-
ral network (Dhingra et al., 2017), adding richer
utterance embeddings (Socher et al., 2013), and
supporting text generation (Sordoni et al., 2015).
We will also explore using HCNs with automatic
speech recognition (ASR) input, for example by
forming features from n-grams of the ASR n-best
results (Henderson et al., 2014b). Of course, we
also plan to deploy the model in a live dialog sys-
tem. More broadly, HCNs are a general model
for stateful control, and we would be interested
to explore applications beyond dialog systems –
for example, in NLP medical settings or human-
robot NL interaction tasks, providing domain con-
straints are important for safety; and in resource-
poor settings, providing domain knowledge can
amplify limited data.

References
Antoine Bordes and Jason Weston. 2016. Learn-

ing end-to-end goal-oriented dialog. CoRR
abs/1605.07683. http://arxiv.org/abs/1605.07683.

Franois Chollet. 2015. Keras. https://github.
com/fchollet/keras.

Junyoung Chung, Caglar Gulcehre, KyungHyun Cho,
and Yoshua Bengio. 2014. Empirical evaluation of
gated recurrent neural networks on sequence model-
ing. In Proc NIPS 2014 Deep Learning and Repre-
sentation Learning Workshop.

Bhuwan Dhingra, Lihong Li, Xiujun Li, Jianfeng Gao,
Yun-Nung Chen, Faisal Ahmed, and Li Deng. 2017.

Towards end-to-end reinforcement learning of dia-
logue agents for information access. In Proc As-
sociation for Computational Linguistics, Vancouver,
Canada.

Mihail Eric and Christopher D Manning. 2017.
A copy-augmented sequence-to-sequence ar-
chitecture gives good performance on task-
oriented dialogue. CoRR abs/1701.04024.
https://arxiv.org/abs/1701.04024.

David Griol, Llus F. Hurtado, Encarna Segarra, and
Emilio Sanchis. 2008. A statistical approach to spo-
ken dialog systems design and evaluation. Speech
Communication 50(8–9).

Matthew Henderson, Blaise Thomson, and Jason
Williams. 2014a. The second dialog state tracking
challenge. In Proc SIGdial Workshop on Discourse
and Dialogue, Philadelphia, USA.

Matthew Henderson, Blaise Thomson, and Steve
Young. 2014b. Word-based Dialog State Tracking
with Recurrent Neural Networks. In Proc SIGdial
Workshop on Discourse and Dialogue, Philadel-
phia, USA.

Sepp Hochreiter and Jurgen Schmidhuber. 1997.
Long short-term memory. Neural Computation
9(8):1735–1780.

Chiori Hori, Kiyonori Ohtake, Teruhisa Misu, Hideki
Kashioka, and Satoshi Nakamura. 2009. Sta-
tistical dialog management applied to WFST-
based dialog systems. In Acoustics, Speech and
Signal Processing, 2009. ICASSP 2009. IEEE
International Conference on. pages 4793–4796.
https://doi.org/10.1109/ICASSP.2009.4960703.

Filip Jurčı́ček, Blaise Thomson, and Steve Young.
2011. Natural actor and belief critic: Reinforcement
algorithm for learning parameters of dialogue sys-
tems modelled as pomdps. ACM Transactions on
Speech and Language Processing (TSLP) 7(3):6.

Nate Kohl and Peter Stone. 2004. Policy gradient re-
inforcement learning for fast quadrupedal locomo-
tion. In Robotics and Automation, 2004. Proceed-
ings. ICRA’04. 2004 IEEE International Conference
on. IEEE, volume 3, pages 2619–2624.

Cheongjae Lee, Sangkeun Jung, Seokhwan Kim, and
Gary Geunbae Lee. 2009. Example-based dialog
modeling for practical multi-domain dialog system.
Speech Communication 51(5):466–484.

Esther Levin, Roberto Pieraccini, and Wieland Eckert.
2000. A stochastic model of human-machine inter-
action for learning dialogue strategies. IEEE Trans
on Speech and Audio Processing 8(1):11–23.

Jiwei Li, Michel Galley, Chris Brockett, Jianfeng Gao,
and Bill Dolan. 2016a. A diversity-promoting ob-
jective function for neural conversation models. In
Proc HLT-NAACL, San Diego, California, USA.

673



Jiwei Li, Michel Galley, Chris Brockett, Georgios Sp-
ithourakis, Jianfeng Gao, and Bill Dolan. 2016b. A
persona-based neural conversation model. In Proc
Association for Computational Linguistics, Berlin,
Germany.

Jiwei Li, Will Monroe, Alan Ritter, Michel Galley,
Jianfeng Gao, and Dan Jurafsky. 2016c. Deep rein-
forcement learning for dialogue generation. In Proc
Conference on Empirical Methods in Natural Lan-
guage Processing, Austin, Texas, USA.

Lihong Li, He He, and Jason D. Williams. 2014. Tem-
poral supervised learning for inferring a dialog pol-
icy from example conversations. In Proc IEEE
Workshop on Spoken Language Technologies (SLT),
South Lake Tahoe, Nevada, USA.

Fei Liu and Julien Perez. 2016. Gated end-to-
end memory networks. CoRR abs/1610.04211.
http://arxiv.org/abs/1610.04211.

Ryan Thomas Lowe, Nissan Pow, Iulian Vlad Serban,
Laurent Charlin, Chia-Wei Liu, and Joelle Pineau.
2017. Training end-to-end dialogue systems with
the ubuntu dialogue corpus. Dialogue and Dis-
course 8(1).

Yi Luan, Yangfeng Ji, and Mari Ostendorf. 2016.
LSTM based conversation models. CoRR
abs/1603.09457. http://arxiv.org/abs/1603.09457.

Hongyuan Mei, Mohit Bansal, and Matthew R. Wal-
ter. 2016. Coherent dialogue with attention-
based language models. CoRR abs/1611.06997.
http://arxiv.org/abs/1611.06997.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Cor-
rado, and Jeff Dean. 2013. Distributed representa-
tions of words and phrases and their compositional-
ity. In Proc Advances in Neural Information Pro-
cessing Systems, Lake Tahoe, USA. pages 3111–
3119.

Min Joon Seo, Hannaneh Hajishirzi, and Ali
Farhadi. 2016. Query-regression networks for
machine comprehension. CoRR abs/1606.04582.
http://arxiv.org/abs/1606.04582.

Iulian V. Serban, Alessandro Sordoni, Yoshua Bengio,
Aaron Courville, and Joelle Pineau. 2016. Building
end-to-end dialogue systems using generative
hierarchical neural network models. In Proceedings
of the Thirtieth AAAI Conference on Artificial Intel-
ligence. AAAI Press, AAAI’16, pages 3776–3783.
http://dl.acm.org/citation.cfm?id=3016387.3016435.

Iulian Vlad Serban, Alessandro Sordoni, Ryan Lowe,
Laurent Charlin, Joelle Pineau, Aaron Courville, and
Yoshua Bengio. 2017. A hierarchical latent variable
encoder-decoder model for generating dialogues.

Lifeng Shang, Zhengdong Lu, , and Hang Li. 2015.
Neural responding machine for short-text conversa-
tion. In Proc Association for Computational Lin-
guistics, Beijing, China.

David Silver, Aja Huang, Chris J. Maddison, Arthur
Guez, Laurent Sifre, George Van Den Driessche, Ju-
lian Schrittwieser, Ioannis Antonoglou, Veda Pan-
neershelvam, Marc Lanctot, et al. 2016. Mastering
the game of Go with deep neural networks and tree
search. Nature 529(7587):484–489.

Satinder Singh, Diane J Litman, Michael Kearns, and
Marilyn A Walker. 2002. Optimizing dialogue man-
agement with reinforcement leaning: experiments
with the NJFun system. Journal of Artificial Intelli-
gence 16:105–133.

Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Chris Manning, Andrew Ng, and Chris
Potts. 2013. Recursive deep models for semantic
compositionality over a sentiment treebank. In Proc
Conference on Empirical Methods in Natural Lan-
guage Processing, Seattle, Washington, USA.

Alessandro Sordoni, Michel Galley, Michael Auli,
Chris Brockett, Yangfeng Ji, Meg Mitchell, Jian-Yun
Nie, Jianfeng Gao, and Bill Dolan. 2015. A neu-
ral network approach to context-sensitive generation
of conversational responses. In Proc HLT-NAACL,
Denver, Colorado, USA.

Pei-Hao Su, Milica Gašić, Nikola Mrkšić, Lina Rojas-
Barahona, Stefan Ultes, David Vandyke, Tsung-
Hsien Wen, and Steve Young. 2016. Continuously
learning neural dialogue management. In arXiv
preprint: 1606.02689.

Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston,
and Rob Fergus. 2015. End-to-end memory net-
works. In Proc Advances in Neural Information
Processing Systems (NIPS), Montreal, Canada.

Theano Development Team. 2016. Theano: A
Python framework for fast computation of mathe-
matical expressions. arXiv e-prints abs/1605.02688.
http://arxiv.org/abs/1605.02688.

Oriol Vinyals and Quoc Le. 2015. A neural conversa-
tional model. In Proc ICML Deep Learning Work-
shop.

Tsung-Hsien Wen, Milica Gasic, Nikola Mrksic,
Lina Maria Rojas-Barahona, Pei-Hao Su, Ste-
fan Ultes, David Vandyke, and Steve J. Young.
2016. A network-based end-to-end trainable task-
oriented dialogue system. CoRR abs/1604.04562.
http://arxiv.org/abs/1604.04562.

Jason D. Williams. 2008. The best of both worlds: Uni-
fying conventional dialog systems and POMDPs. In
Proc Intl Conf on Spoken Language Processing (IC-
SLP), Brisbane, Australia.

Jason D. Williams and Steve Young. 2007. Partially
observable Markov decision processes for spoken
dialog systems. Computer Speech and Language
21(2):393–422.

Ronald J Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine learning 8(3-4):229–256.

674



Zhen Xu, Bingquan Liu, Baoxun Wang, Chengjie Sun,
and Xiaolong Wang. 2016. Incorporating loose-
structured knowledge into LSTM with recall gate
for conversation modeling. CoRR abs/1605.05110.
http://arxiv.org/abs/1605.05110.

Kaisheng Yao, Geoffrey Zweig, and Baolin Peng.
2015. Attention with intention for a neural network
conversation model. In Proc NIPS workshop on Ma-
chine Learning for Spoken Language Understanding
and Interaction.

Steve Young, Milica Gasic, Blaise Thomson, and Ja-
son D. Williams. 2013. POMDP-based Statistical
Spoken Dialogue Systems: a Review. Proceedings
of the IEEE PP(99):1–20.

Matthew D. Zeiler. 2012. ADADELTA: an adap-
tive learning rate method. CoRR abs/1212.5701.
http://arxiv.org/abs/1212.5701.

A Supplemental Material

A.1 Model implementation details
The RNN was specified using Keras version 0.3.3,
with back-end computation in Theano version
0.8.0.dev0 (Theano Development Team, 2016;
Chollet, 2015). The Keras model specification is
given below. The input variable obs includes all
features from Figure 1 step 6 except for the previ-
ous action (step 18) and the action mask (step 6,
top-most vector).

# Given:
# obs_size, action_size, nb_hidden

g = Graph()
g.add_input(

name=’obs’,
input_shape=(None, obs_size)

)
g.add_input(

name=’prev_action’,
input_shape=(None, action_size)

)
g.add_input(

name=’avail_actions’,
input_shape=(None, action_size)

)
g.add_node(

LSTM(
n_hidden,
return_sequences=True,
activation=’tanh’,

),
name=’h1’,
inputs=[
’obs’,
’prev_action’,
’avail_actions’

]
)
g.add_node(

TimeDistributedDense(
action_size,

activation=’softmax’,
),
name=’h2’,
input=’h1’

)
g.add_node(
Activation(

activation=normalize,
),
name=’action’,
inputs=[’h2’,’avail_actions’],
merge_mode=’mul’,
create_output=True

)
g.compile(
optimizer=Adadelta(clipnorm=1.),
sample_weight_modes={

’action’: ’temporal’
},
loss={

’action’:’categorical_crossentropy’
}

)

Model sizes are given in Table 3. Example di-
alogs are given below for each of the 5 dialog sys-
tems. For space and readability, the entity tags
that appear in the user and system sides of the
dialogs have been removed – for example, Call
<name>Joan</name> is shown as Call Joan.

A.2 bAbI Task5 example dialog

good morning
hello what can i help you with today
i’d like to book a table with italian food
i’m on it
[silence]
where should it be
in paris
how many people would be in your party
for six people please
which price range are looking for
in a cheap price range please
ok let me look into some options for you
[silence]
api_call italian paris six cheap
[database results returned]
[silence]
what do you think of this option:
resto madrid cheap spanish 8stars
no this does not work for me
sure let me find an other option for you
[silence]
what do you think of this option:
resto madrid cheap spanish 6stars
do you have something else
sure let me find an other option for you
[silence]
what do you think of this option:
resto madrid cheap spanish 1stars
it’s perfect
great let me do the reservation
may i have the phone number of the restaurant
here it is resto madrid cheap spanish 1stars phone

675



bAbI Task5 bAbI Task6 Reset password Account access Dialer
Utterance embed. 300 300 300 300 0
Bag of words 85 523 1124 278 0
Context features 4 14 0 0 17

obs_size 389 837 1424 578 17
action_size 16 58 7 16 14
nb_hidden 128 128 128 128 32

Table 3: Dimensions of the 5 HCNs in this paper.

thanks
is there anything i can help you with
no thank you
you’re welcome

A.3 bAbI Task6 example dialog
In the system turn marked [*], the system pro-
vided venue information without first making an
API call.

Hello , welcome to the Cambridge restaurant sys-
tem . You can ask for restaurants by area , price
range or food type . How may I help you ?
im looking for canapes food in any price range
I am sorry but there is no canapes restaurant that
matches your request [*]
how about european
api_call european R_location R_price
[database results returned]
[silence]
michaelhouse cafe is a great restaurant serving
european food and it is in the expensive price
range
food an
What part of town do you have in mind?
any any part of town
michaelhouse cafe serves european food .
may i have the address and phone number please
The phone number of michaelhouse cafe is
michaelhouse cafe phone
thank you good bye
you are welcome

A.4 Task5 and Task6 context features
Context features used in Section 4 are in Table 4.

A.5 Forgot password example dialog
Some system actions have been shortened for
space.

How do I recover my password
Okay, you don’t need to remember your password,
we can reset it. Would you like to try that?
Yes
To reset your password, please see this URL ...
Was that helpful?

I don’t have a flashdrive
Let’s connect you to a person who can help you

A.6 Account access example dialog

Some system actions have been shortened for
space.

cannot sign in to my email
Please check caps lock is off, and that your email
is spelled correctly. Are you able to access your
account now?
no
If you still can’t sign in, please go the the following
page and check that the email server is running
ok... Is everything up and running?
yes
You need to reset your password - here’s how ...
Did this solve your problem?
still cannot get in
Did you receive the security code?
yes
Check you entered the right numbers. Did this
solve your problem?
no
Have you seen a message that your profile is tem-
porarily blocked?
just your message of update on sept 15
Did you turn on two-step verification recently?
whats that?
Sorry, I can’t help. Rephrase your question, or click
below to talk to a person.

A.7 Name dialing example dialogs

How can I help you?
Call Joe
There’s more than one person named Joe. Can
you say their full name?
Call Joe Adamson
SavePhonetypeavail()
Calling Joe Adamson, work
PlaceCall()

How can I help you?
Call Sally on her home

676



Feature bAbI Task5 bAbI Task6
Presence of each entity in dialog state 4 3
Presence of each entity in current utterance – 3
Whether DB has been queried yet – 1
Whether DB results are empty – 1
Whether DB results are non-empty – 1
Whether any DB results have been presented – 1
Whether all DB results have been presented – 1
Whether any DB results are available to present – 1
Whether curent query yields no results in training set – 1
Whether cuisine in current query yields no results in training set – 1
Total context features 4 14

Table 4: Binary context features used to convey entity and database state in Section 4.

Sorry, I don’t have a home number for Sally Smith.
I only have a work phone. Do you want to call that
number?
no
Oh, sorry about that. Goodbye.

677


	Hybrid Code Networks: practical and efficient end-to-end dialog control with supervised and reinforcement learning

