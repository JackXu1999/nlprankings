



















































Jointly Learning Semantic Parser and Natural Language Generator via Dual Information Maximization


Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 2090–2101
Florence, Italy, July 28 - August 2, 2019. c©2019 Association for Computational Linguistics

2090

Jointly Learning Semantic Parser and Natural Language Generator
via Dual Information Maximization

Hai Ye[ Wenjie Li\ Lu Wang]
[ Information Sciences Institute, University of Southern California

\ Department of Computing, The Hong Kong Polytechnic University
] College of Computer and Information Science, Northeastern University

hye@usc.edu, cswjli@comp.polyu.edu.hk, luwang@ccs.neu.edu

Abstract

Semantic parsing aims to transform natural
language (NL) utterances into formal meaning
representations (MRs), whereas an NL gener-
ator achieves the reverse: producing a NL de-
scription for some given MRs. Despite this
intrinsic connection, the two tasks are often
studied separately in prior work. In this paper,
we model the duality of these two tasks via a
joint learning framework, and demonstrate its
effectiveness of boosting the performance on
both tasks. Concretely, we propose the method
of dual information maximization (DIM) to
regularize the learning process, where DIM
empirically maximizes the variational lower
bounds of expected joint distributions of NL
and MRs. We further extend DIM to a semi-
supervision setup (SEMIDIM), which lever-
ages unlabeled data of both tasks. Experi-
ments on three datasets of dialogue manage-
ment and code generation (and summariza-
tion) show that performance on both seman-
tic parsing and NL generation can be consis-
tently improved by DIM, in both supervised
and semi-supervised setups1.

1 Introduction

Semantic parsing studies the task of translat-
ing natural language (NL) utterances into for-
mal meaning representations (MRs) (Zelle and
Mooney, 1996; Tang and Mooney, 2000). NL
generation models can be designed to learn the
reverse: mapping MRs to their NL descrip-
tions (Wong and Mooney, 2007). Generally
speaking, MR often takes a logical form that
captures the semantic meaning, including λ-
calculus (Zettlemoyer and Collins, 2005, 2007),
Abstract Meaning Representation (AMR) (Ba-
narescu et al., 2013; Misra and Artzi, 2016),
and general-purpose computer programs, such as

1Code for this paper is available at: https://
github.com/oceanypt/DIM

x ỹ 
pθ
→

(x, y) = p(x) (y|x)pe pθ

y x̃ 
qϕ

−→

(x, y) = q(y) (x|y)pd qϕ

x y⟷

(x, y)

Figure 1: Illustration of our joint learning model. x:
NL; y: MRs. pθ(y|x): semantic parser; qφ(x|y):
NL generator. We model the duality of the two
tasks by matching the joint distributions of pe(x,y)
(learned from semantic parser) and pd(x,y) (learned
from NL generator) to an underlying unknown distri-
bution P(x,y).

Python (Yin and Neubig, 2017) or SQL (Zhong
et al., 2017). Recently, NL generation models have
been proposed to automatically construct human-
readable descriptions from MRs, for code summa-
rization (Hu et al., 2018; Allamanis et al., 2016;
Iyer et al., 2016) that predicts the function of code
snippets, and for AMR-to-text generation (Song
et al., 2018; Konstas et al., 2017; Flanigan et al.,
2016).

Specifically, a common objective that semantic
parsers aim to estimate is pθ(y|x), the conditional
distribution between NL input x and the corre-
sponding MR output y, as demonstrated in Fig. 1.
Similarly, for NL generation from MRs, the goal is
to learn a generator of qφ(x|y). As demonstrated
in Fig. 2, there is a clear duality between the two
tasks, given that one task’s input is the other task’s
output, and vice versa. However, such duality re-
mains largely unstudied, even though joint mod-
eling has been demonstrated effective in various
NLP problems, e.g. question answering and gen-
eration (Tang et al., 2017), machine translation be-
tween paired languages (He et al., 2016), as well
as sentiment prediction and subjective text gener-

https://github.com/oceanypt/DIM
https://github.com/oceanypt/DIM


2091

1

000

001

002

003

004

005

006

007

008

009

010

011

012

013

014

015

016

017

018

019

020

021

022

023

024

025

026

027

028

029

030

031

032

033

034

035

036

037

038

039

040

041

042

043

044

045

046

047

048

049

050

051

052

053

054

055

056

057

058

059

060

061

062

063

064

065

066

067

068

069

070

071

072

073

074

075

076

077

078

079

080

081

082

083

084

085

086

087

088

089

090

091

092

093

094

095

096

097

098

099

ACL 2018 Submission ***. Confidential Review Copy. DO NOT DISTRIBUTE.

DATA EXAMPLE Ave. Token

ATIS
x can you list all flights from chicago to milwaukee 10.6
y ( lambda $0 e ( and ( flight $0) ( from $0 chicago: ci) ( to $0 milwaukee: ci) ) ) 26.5

DJANGO
x convert max entries into a string, substitute it for self. max entries. 11.9
y self. max entries = int(max entries) 8.2

CONALA
x more pythonic alternative for getting a value in range not using min and max 9.7
y a = 1 if x < 1 else 10 if x > 10 else x 14.1

Figure 2: Sample natural language utterances and meaning representations from datasets used in this work: ATIS
for dialogue management; DJANGO (Oda et al., 2015) and CONALA (Yin et al., 2018a) for code generation and
summarization.

ation (Xia et al., 2017).
In this paper, we propose to jointly model se-

mantic parsing and NL generation by exploiting
the interaction between the two tasks. Follow-
ing previous work on dual learning (Xia et al.,
2017), we leverage the joint distribution P(x,y)
of NL and MR to represent the duality. Intu-
itively, as shown in Fig. 1, the joint distributions of
pe(x,y) = p(x)pθ(y|x), which is estimated from
semantic parser, and pd(x,y) = q(y)qφ(x|y),
which is modeled by NL generator, are both ex-
pected to approximate P(x,y), the unknown joint
distribution of NL and MR.

To achieve this goal, we propose dual infor-
mation maximization (DIM) (§3) to empirically
optimize the variational lower bounds of the ex-
pected joint distributions of pe(x,y) and pd(x,y).
Concretely, the coupling of the two expected dis-
tributions is designed to capture the dual infor-
mation, with both optimized via variational ap-
proximation (Barber and Agakov, 2003) inspired
by Zhang et al. (2018). Furthermore, combined
with the supervised learning objectives of seman-
tic parsing and NL generation, DIM bridges the
two tasks within one joint learning framework by
serving as a regularization term (§2.2). Finally,
we extend supervised DIM to semi-supervision
setup (SEMIDIM), where unsupervised learning
objectives based on unlabeled data are also opti-
mized (§3.3).

We experiment with three datasets from two dif-
ferent domains: ATIS for dialogue management;
DJANGO and CONALA for code generation and
summarization. Experimental results show that
both the semantic parser and generator can be con-
sistently improved with joint learning using DIM
and SEMIDIM, compared to competitive compar-
ison models trained for each task separately.

Overall, we have the following contributions in
this work:

• We are the first to jointly study semantic pars-
ing and natural language generation by ex-
ploiting the duality between the two tasks;
• We propose DIM to capture the duality and

adopt variational approximation to maximize
the dual information;
• We further extend supervised DIM to semi-

supervised setup (SEMIDIM).

2 Problem Formulation

2.1 Semantic Parsing and NL Generation

Formally, the task of semantic parsing is to map
the input of NL utterances x to the output of struc-
tured MRs y, and NL generation learns to generate
NL from MRs.
Learning Objective. Given a labeled dataset
L = {〈xi,yi〉}, we aim to learn a semantic
parser (x → y) by estimating the conditional dis-
tribution pθ(y|x), parameterized by θ, and an NL
generator (y→ x) by modeling qφ(x|y), parame-
terized by φ. The learning objective for each task
is shown below:

Lparser = E〈x,y〉[log pθ(y|x)] (1)
Lgen. = E〈x,y〉[log qφ(x|y)] (2)

Frameworks. Sequence-to-sequence (seq2seq)
models have achieved competitive results on both
semantic parsing and generation (Dong and La-
pata, 2016; Hu et al., 2018), and without loss
of generality, we adopt it as the basic frame-
work for both tasks in this work. Specifically, for
both pθ(y|x) and qφ(x|y), we use a two-layer bi-
directional LSTM (bi-LSTM) as the encoder and
another one-layer LSTM as the decoder with at-
tention mechanism (Luong et al., 2015). Further-
more, we leverage pointer network (Vinyals et al.,
2015) to copy tokens from the input to handle out-
of-vocabulary (OOV) words. The structured MRs
are linearized for the sequential encoder and de-



2092

coder. More details of the parser and the generator
can be found in Appendix A. Briefly speaking, our
models differ from existing work as follows:
PARSER: Our architecture is similar to the one

proposed in Jia and Liang (2016) for seman-
tic parsing;

GENERATOR: Our model improves upon the
DEEPCOM coder summarization system (Hu
et al., 2018) by: 1) replacing LSTM with bi-
LSTM for the encoder to better model con-
text, and 2) adding copying mechanism.

2.2 Jointly Learning Parser and Generator

Our joint learning framework is designed to model
the duality between a parser and a generator. To
incorporate the duality into our learning process,
we design the framework to encourage the ex-
pected joint distributions pe(x,y) and pd(x,y)
to both approximate the unknown joint distribu-
tion of x and y (shown in Fig. 1). To achieve
this, we introduce dual information maximiza-
tion (DIM) to empirically optimize the variational
lower bounds of both pe(x,y) and pd(x,y), in
which the coupling of expected distributions is
captured as dual information (detailed in §3.1) and
will be maximized during learning.

Our joint learning objective takes the form of:

max
θ,φ
L(θ, φ) = Lparser+Lgen.+λ·LDIM(θ, φ) (3)

LDIM is the variational lower bound of the two ex-
pected joint distributions, specifically,

LDIM = LeDIM (Eq. 6) + LdDIM (Eq. 9) (4)
where LeDIM and LdDIM are the lower bounds over
pe(x,y) and pd(x,y) respectively. The hyper-
parameter λ trades off between supervised objec-
tives and dual information learning. With the ob-
jective of Eq. 3, we jointly learn a parser and a
generator, as well as maximize the dual informa-
tion between the two. LDIM serves as a regulariza-
tion term to influence the learning process, whose
detailed algorithm is described in §3.

Our method of DIM is model-independent. If
the learning objectives for semantic parser and NL
generator are subject to Eq. 1 and Eq. 2, we can
always adopt DIM to conduct joint learning. Out
of most commonly used seq2seq models for the
parser and generator, more complex tree and graph
structures have been adopted to model MRs (Dong
and Lapata, 2016; Song et al., 2018). In this
paper, without loss of generality, we study our
joint-learning method on the widely-used seq2seq

frameworks mentioned above (§2.1).

3 Dual Information Maximization

In this section, we first introduce dual information
in §3.1, followed by its maximization (§3.2). §3.3
discusses its extension with semi-supervision.

3.1 Dual Information
As discussed above, we treat semantic parsing and
NL generation as the dual tasks and exploit the
duality between the two tasks for our joint learn-
ing. With conditional distributions pθ(y|x) for
the parser and qφ(x|y) for the generator, the joint
distributions of pe(x,y) and pd(x,y) can be esti-
mated as pe(x,y) = p(x)pθ(y|x) and pd(x,y) =
q(y)qφ(x|y), where p(x) and q(y) are marginals.
The dual information Ipe,d(x,y) between the two
distributions is defined as follows:

Ipe,d(x,y) = Ipe(x,y) + Ipd(x,y) ,

Epe(x,y) log pe(x,y) + Epd(x,y) log pd(x,y)
(5)

which is the combination of the two joint distribu-
tion expectations.

To leverage the duality between the two tasks,
we aim to drive the learning of the model pa-
rameters θ and φ via optimizing Ipe,d(x,y), so that
the expectations of joint distributions pe(x,y) and
pd(x,y) will be both maximized and approximate
the latent joint distribution P(x,y), whose pro-
cedure is similar to the joint distribution match-
ing (Gan et al., 2017). By exploiting the inherent
probabilistic connection between the two distribu-
tions, we hypothesize that it would enhance the
learning of both tasks on parsing pθ(y|x) and gen-
eration qφ(x|y). Besides, to approach the same
distribution P(x,y), the expected joint distribu-
tions can learn to be close to each other, making
the dual models coupled.

3.2 Maximizing Dual Information
Here, we present the method for optimizing
Ipe(x,y), which can also be applied to Ipd(x,y). In
contrast to the parameter sharing techniques in
most multi-task learning work (Collobert et al.,
2011; Ando and Zhang, 2005), parameter θ for
the parser and parameter φ for generator are
independent in our framework. In order to jointly
train the two models and bridge the learning of θ
and φ, during the optimization of Ipe(x,y), where
the parser is the primal model, we utilize the
distributions of the dual task (i.e. the generator)
to estimate Ipe(x,y). In this way, θ and φ can



2093

is  there  ground
transportation in st. louis   pθ

ŷ 
1

ŷ 
n

lo
g

(x
|

)
q
(

)
q

ϕ
y
̂ 

y
̂ 

⋯⋯

(

(

+


e

DIM

\_lambda  \$0  e  (  \_and  (
\_ground\_transport \$0 ) ...   qϕ

x̂ 1

x̂ 
n

lo
g

(y
|

)
p

(
)

p
θ

x
̂ 

x
̂ 

⋯⋯

(

(

+


d

DIM

⋯
⋯

⋯
⋯

+ DIM
x

y

1

n

1

n

parsing
− →−−−−

generation
− →−−−−−−

Figure 3: The pipeline of calculating lower bounds. We firstly use the parser or generator to sample MR or NL
targets, then the sampled candidates go through the dual model and a language model to obtain the lower bounds.

be both improved during the update of Ipe(x,y).
Specifically, we rewrite Epe(x,y) log pe(x,y)
as Epe(x,y) log pe(y)pe(x|y), where pe(y) and
pe(x|y) are referred as the dual task distributions.
However, the direct optimization for this objective
is impractical since both pe(y) and pe(x|y) are
unknown. Our solution is detailed below.
Lower Bounds of Dual Information. To provide
a principled approach of optimizing Ipe(x,y), in-
spired by Zhang et al. (2018), we follow Barber
and Agakov (2003) to adopt variational approxi-
mation to deduce its lower bound and instead max-
imize the lower bound. The lower bound deduc-
tion process is as following:

Epe(x,y) log pe(x,y) = Epe(x,y) log pe(x|y)pe(y)
= Epe(x,y) log qφ(x|y) + Epe(x,y) log q(y)

+Epe(y)
[
KL(pe(x|y)‖qφ(x|y))

]
+Epe(x|y)

[
KL(pe(y)‖q(y))

]
> Epe(x,y)

[
log qφ(x|y) + log q(y)

]
= LeDIM(θ, φ)

(6)

where KL(·‖·)(> 0) is the Kullback-Leibler (KL)
divergence. Therefore, to maximize Ipe(x,y), we
can instead maximize its lower bound of LeDIM.
LeDIM is learned by using qφ(x|y) and q(y) which
approximate pe(x|y) and pe(y). Besides, the
lower bound of LeDIM is the function of θ and φ,
so in the process of learning LeDIM, the parser and
generator can be both optimized.

As illustrated in Fig. 3, in the training process,
to calculate the lower bound of LeDIM, we first
use the being-trained parser to sample MR can-
didates for a given NL utterance. The sampled
MRs then go through the generator and a marginal
model (i.e., a language model of MRs) to obtain
the final lower bound.

To learn the lower bound of LeDIM, we provide
the following method to calculate its gradients:

Gradient Estimation. We adopt Monte Carlo
samples using the REINFORCE policy (Williams,
1992) to approximate the gradient of LeDIM(θ, φ)
with regard to θ:

∇θLeDIM(θ, φ) = Epθ(y|x)∇θ log pθ(y|x)
· [log qφ(x|y) + log q(y)− b]

= Epθ(y|x)∇θ log pθ(y|x) · l(x,y;φ)

≈ 1
|S|

∑
ŷi∈S
∇θ log pθ(ŷi|x) · l(x, ŷi;φ)

(7)

l(x,y;φ) can be seen as the learning signal from
the dual model, which is similar to the reward
in reinforcement learning algorithms (Guu et al.,
2017; Paulus et al., 2017). To handle the high-
variance of learning signals, we adopt the baseline
function b by empirically averaging the signals
to stabilize the learning process (Williams, 1992).
With prior pθ(·|x), we use beam search to gener-
ate a pool of MR candidates (y), denoted as S, for
the input of x.

The gradient with regard to φ is then calculated
as:
∇φLeDIM(θ, φ) = Epθ(y|x)∇φ log qφ(x|y)

≈ 1
|S|

∑
ŷi∈S
∇φ log qφ(x|ŷi) (8)

The above maximization procedure for LeDIM is
analogous to the EM algorithm:
Step 1: Freeze φ and find the optimal θ∗ =

argmaxθ LeDIM(θ, φ) with Eq. 7;
Step 2: Based on Eq. 8, with freezing θ∗, find the

optimal φ∗ = argmaxφ LeDIM(θ, φ).
The two steps are repeated until convergence.

According to the gradient estimation in Eq. 7,
when updating θ for the parser, we receive the
learning signal l(x,y;φ) from the generator, and
this learning signal can be seen as a reward from
the generator: if parser pθ(y|x) predicts high-



2094

quality MRs, the reward will be high; otherwise,
the reward is low. This implies that the generator
guides the parser to generate high-quality MRs,
through which the lower bound for the expected
joint distribution gets optimized. This also applies
to the situation when we treat the generator as the
primal model and the parser as the dual model.

The lower bound of Ipd(x,y) can be calculated
in a similar way:

Epd(x,y) log pd(x,y)

> Epd(x,y)
[
log pθ(y|x)+log p(x)

]
= LdDIM(θ, φ)

(9)

which can be optimized the same way as in Eqs. 7
and 8 for estimating the gradients for LdDIM.
Marginal Distributions. To obtain the marginal
distributions p(x) and q(y), we separately train
an LSTM-based language model (Mikolov et al.,
2010) for NL and MR respectively, on each train-
ing set. Structured MRs are linearized into se-
quences for the sequential encoder and decoder in
seq2seq models. Details on learning marginal dis-
tributions can be found in Appendix B.
Joint Learning Objective. Our final joint learn-
ing objective becomes:

max
θ,φ
J =

∑
〈x,y〉∈L

(
log pθ(y|x) + log qφ(x|y)

+ λ
∑

ŷi∼pθ(·|x)

log qφ(x|ŷi) + log q(ŷi)

+ λ
∑

x̂i∼qφ(·|y)

log pθ(y|x̂i) + log p(x̂i)
)

(10)

According to this learning objective, after picking
up a data pair 〈x,y〉, we will firstly calculate the
supervised learning loss, then we sample MR can-
didates and NL samples using prior pθ(·|x) and
qφ(·|y) respectively to obtain the corresponding
lower bounds over Ipe(x,y) and Ipd(x,y).

3.3 Semi-supervised DIM (SEMIDIM)

We further extend DIM with semi-supervised
learning. We denote the unlabeled NL dataset
as Ux = {xi} and the unlabeled MR dataset as
Uy = {yi}. To leverage Ux, we maximize the un-
labeled objective Ex∼Ux log p(x). Our goal is to
involve model parameters in the optimization pro-
cess of Ex∼Ux log p(x), so that the unlabeled data
can facilitate parameter leanring.
Lower Bounds of Unsupervised Objective. The
lower bound of Ex∼Ux log p(x) is as follows, us-

ing the deduction in Ineq. 6:

Ex∼Ux log p(x)
≥ Ex∼Ux,y∼pθ(·|x) log p(x)pθ(y|x)

≥ Ex∼Ux,y∼pθ(·|x)
[
log qφ(x|y) + q(y)

]
(11)

Comparing Ineq. 11 to Ineq. 6, we can see that
the unsupervised objective Ex∼Ux log p(x) and
Ipe(x,y) share the same lower bound, so that the
same optimization method from Eq. 7 and Eq. 8
can be utilized for learning the lower bound over
Ex∼Ux log p(x).
Analysis. The lower bound of the unsupervised
objective Ex∼Ux log p(x) is a function of θ and
φ. Therefore, updating this unsupervised objec-
tive will jointly optimize the parser and the gen-
erator. From the updating algorithm in Eq. 7,
we can see that the parser pθ(y|x) is learned
by using pseudo pair (x, ŷ) where ŷ is sampled
from pθ(·|x). This updating process resembles
the popular semi-supervised learning algorithm
of self-train that predicts pseudo labels for un-
labeled data (Lee, 2013) and then attaches the
predicted labels to the unlabeled data as addi-
tional training data. In our algorithm, the pseudo
sample (x, ŷ) will be weighted by the learning
signal l(x, ŷ;φ), which decreases the impact of
low-quality pseudo samples. Furthermore, from
Eq. 8, the generator qφ(x|y) is updated using
the pseudo sample (x, ŷ), which is similar to the
semi-supervised learning method of back-boost
that is widely used in Neural Machine Translation
for low-resource language pairs (Sennrich et al.,
2016). Given the target-side corpus, back-boost
generates the pseudo sources to construct pseudo
samples, which is added for model training.

Similarly, to leverage the unlabeled data Uy
for semi-supervised learning, following Ineq. 11,
we could also have the lower bound for
Ey∼Uy log p(y) as following,

Ey∼Uy log p(y)
≥ Ey∼Uy,x∼qφ(·|y)

[
log pθ(y|x) + p(x)

]
(12)

which is the same as the lower bound of Ipd(x,y).

Semi-supervised Joint Learning Objective.
From the above discussions, we can deduce the
lower bounds for the unsupervised objectives to be
the same as the lower bounds of the dual informa-
tion. We thus have the following semi-supervised
joint-learning objective:

max
θ,φ
J =

∑
〈x,y〉∈L

(
log pθ(y|x) + log qφ(x|y)

)



2095

DATA Train Valid Test All
ATIS 4,480 480 450 5,410
DJANGO 16,000 1,000 1,805 18,805
CONALA 90,000 5,000 5,000 100,000

Table 1: Statistics of datasets used for evaluation.
Around 500K additional samples of low confidence
from CONALA are retained for model pre-training.

+λ
∑

x∼Dx,ŷi∼pθ(·|x)

(
log qφ(x|ŷi) + log q(ŷi)

)
+λ

∑
y∼Dy,x̂i∼qφ(·|y)

(
log pθ(y|x̂i) + log p(x̂i)

)
(13)

where Dx = Ux ∪ Lx and Dy = Uy ∪ Ly. In
this work, we weight the dual information and un-
supervised objectives equally for simplicity, so the
lower bounds over them are combined for joint op-
timization. We combine the labeled and unlabeled
data to calculate the lower bounds to optimize the
variational lower bounds of dual information and
unsupervised objectives.

4 Experiments

4.1 Datasets
Experiments are conducted on three datasets with
sample pairs shown in Fig. 2: one for dia-
logue management which studies semantic parsing
and generation from λ-calculus (Zettlemoyer and
Collins, 2007) (ATIS) and two for code generation
and summarization (DJANGO, CONALA).
ATIS. This dataset has 5,410 pairs of queries (NL)
from a flight booking system and corresponding λ-
calculus representation (MRs). The anonymized
version from Dong and Lapata (2016) is used.
DJANGO. It contains 18,805 lines of Python
code snippets (Oda et al., 2015). Each snippet is
annotated with a piece of human-written pseudo
code. Similar to Yin and Neubig (2017), we re-
place strings separated by quotation marks with
indexed place holder in NLs and MRs.
CONALA. This is another Python-related cor-
pus containing 598,237 intent/snippet pairs that
are automatically mined from Stack Overflow (Yin
et al., 2018a). Different from DJANGO, the intent
in CONALA is mainly about the question on a spe-
cific topic instead of pseudo code. The full dataset
contains noisy aligned pairs, and we keep the top
100,000 pairs of highest confidence scores for ex-
periment and the rest for model pre-training.

For DJANGO and CONALA, the NL utterances

SEMANTIC PARSING (in Acc.)
Pro. SUPER DIM SEMIDIM SELFTRAIN
1/4 64.7 69.0 71.9 66.3
1/2 78.1 78.8 80.8 79.2
full 84.6 85.3 – –
Previous Supervised Methods (Pro. = full) Acc.
SEQ2TREE (Dong and Lapata, 2016) 84.6
ASN (Rabinovich et al., 2017) 85.3
ASN+SUPATT (Rabinovich et al., 2017) 85.9
COARSE2FINE (Dong and Lapata, 2018) 87.7

NL GENERATION (in BLEU)
Pro. SUPER DIM SEMIDIM BACKBOOST
1/4 36.9 37.7 39.1 40.9
1/2 39.1 40.7 40.9 39.3
full 39.3 40.6 – –
Previous Supervised Methods (Pro. = full) BLEU
DEEPCOM (Hu et al., 2018) 42.3

Table 2: Semantic parsing and NL generation results
on ATIS. Pro.: proportion of the training samples used
for training. Best result in each row is highlighted in
bold. |full| = 4,434.

are lowercased and tokenized and the tokens in
code snippets are separated with space. Statistics
of the datasets are summarized in Table 1.

4.2 Experimental Setups
Joint-learning Setup. Before jointly learning
the models, we pre-train the parser and the gener-
ator separately, using the labeled dataset, to enable
the sampling of valid candidates with beam search
when optimizing the lower bounds of dual infor-
mation (Eqs. 7 and 8). The beam size is tuned
from {3,5}. The parser and the generator are pre-
trained until convergence. We also learn the lan-
guage models for NL and MRs on the training sets
beforehand, which are not updated during joint
learning. Joint learning stops when the parser or
the generator does not get improved for 5 contin-
uous iterations. λ is set to 0.1 for all the exper-
iments. Additional descriptions about our setup
are provided in Appendix C.

For the semi-supervised setup, since ATIS and
DJANGO do not have additional unlabeled cor-
pus and it is hard to obtain in-domain NL utter-
ances and MRs, we create a new partial training
set from the original training set via subsampling,
and the rest is used as the unlabeled corpus. For
CONALA, we subsample data from the full train-
ing set to construct the new training set and unla-
beled set instead of sampling from the low-quality
corpus which will much boost the data volume.
Evaluation Metrics. Accuracy (Acc.) is reported



2096

CODE GENERATION (in Acc.)
Pro. SUPER DIM SEMIDIM BACKBOOST
1/8 42.3 44.9 47.2 47.0
1/4 50.2 51.1 54.5 51.7
3/8 52.2 53.7 54.6 55.3
1/2 56.3 58.4 59.2 58.9
full 65.1 66.6 – –
Previous Supervised Methods (Pro. = full) Acc.
LPN (Ling et al., 2016) 62.3
SNM (Yin and Neubig, 2017) 71.6
COARSE2FINE (Dong and Lapata, 2018) 74.1

CODE SUMMARIZATION (in BLEU)
Pro. SUPER DIM SEMIDIM SELFTRAIN
1/8 54.1 56.0 58.5 54.4
1/4 57.1 61.4 62.7 58.0
3/8 63.0 64.3 64.6 63.0
1/2 65.2 66.3 66.7 65.4
full 68.1 70.8 – –
Previous Supervised Methods (Pro. = full) BLEU
DEEPCOM (Hu et al., 2018) 65.9

Table 3: Code generation and code summarization re-
sults on DJANGO. |full| = 16,000.

for parser evaluation based on exact match, and
BLEU-4 is adopted for generator evaluation. For
the code generation task in CONALA, we use
BLEU-4 following the setup in Yin et al. (2018a).
Baselines. We compare our methods of DIM and
SEMIDIM with the following baselines:
SUPER: Train the parser or generator separately

without joint learning. The models for the
parser and generator are the same as DIM.

SELFTRAIN (Lee, 2013): We use the pre-trained
parser or generator to generate pseudo la-
bels for the unlabeled sources, then the con-
structed pseudo samples will be mixed with
the labeled data to fine-tune the pre-trained
parser or generator.

BACKBOOST: Adopted from the back translation
method in Sennrich et al. (2016), which gen-
erates sources from unlabeled targets. The
training process for BACKBOOST is the same
as in SELFTRAIN.

In addition to the above baselines, we also com-
pare with popular supervised methods for each
task, shown in the corresponding result tables.

4.3 Results and Further Analysis

Main Results with Full- and Semi-supervision.
Results on the three datasets with supervised and
semi-supervised setups are presented in Tables 2,
3, and 4. For semi-supervised experiments on
ATIS, we use the NL part as extra unlabeled sam-

CODE GENERATION (in BLEU)
Pro. SUPER DIM SEMIDIM BACKBOOST
1/2 8.6 9.6 9.5 9.0
full 11.1 12.4 – –
CODE SUMMARIZATION (in BLEU)
Pro. SUPER DIM SEMIDIM SELFTRAIN
1/2 13.4 14.5 15.1 12.7
full 22.5 24.8 – –
Previous Supervised Methods (Pro. = full) BLEU
CODE GEN.: NMT (Yin et al., 2018a) 10.7
CODE SUM.: DEEPCOM (Hu et al., 2018) 20.1

After Pre-training (in BLEU)
CODE GEN. CODE SUM.

Pro. SUPER DIM SUPER DIM
1/2 10.3 10.6 23.1 23.0
full 11.1 12.4 25.9 26.3
Previous Supervised Methods (Pro. = full) BLEU
CODE GEN.: NMT (Yin et al., 2018a) 10.9
CODE SUM.: DEEPCOM (Hu et al., 2018) 26.5

Table 4: Code generation and code summarization re-
sults on CONALA. For semi-supervised learning (Pro.
= 1/2), we sample 30K code snippets from the left
data (not used as training data) as unlabeled samples.
|full| = 90,000.

ples following Yin et al. (2018b); for DJANGO and
CONALA, unlabeled code snippets are utilized.

We first note the consistent advantage of DIM
over SUPER across all datasets and proportions of
training samples for learning. This indicates that
DIM is able to exploit the interaction between the
dual tasks, and further improves the performance
on both semantic parsing and NL generation.

For semi-supervised scenarios, SEMIDIM,
which employs unlabeled samples for learning,
delivers stronger performance than DIM, which
only uses labeled data. Moreover, SEMIDIM out-
performs both SELFTRAIN and BACKBOOST, the
two semi-supervised learning methods. This is
attributed to SEMIDIM’s strategy of re-weighing
pseudo samples based on the learning signals,
which are indicative of their qualities, whereas
SELFTRAIN and BACKBOOST treat all pseudo
samples equally during learning. Additionally, we
study the pre-training effect on CONALA. As can
be seen in Table 4, pre-training further improves
the performance of SUPER and DIM on both code
generation and summarization.
Model Analysis. Here we study whether DIM
helps enhance the lower bounds of the expected
joint distributions of NL and MRs. Specifically,
lower bounds are calculated as in Eqs. 6 and 9
on the full training set for models of SUPER and



2097

-50 -40 -30 -20 -10
0

0.05

0.1

0.15

(a) ATIS

z (  = -29.3)
z' (  = -19.7)

-30 -25 -20 -15 -10 -5
0

0.1

0.2 z (  = -14.7)
z' (  = -12.6)

-60 -40 -20
0

0.05

0.1

0.15

(b) DJANGO

z (  = -33.8)
z' (  = -27.1)

-60 -50 -40 -30 -20 -10
0

0.05

0.1 z (  = -28.6)
z' (  = -24.6)

-80 -60 -40 -20
0

0.05

0.1

(c) CONALA

z (  = -33.6)
z' (  = -27.9)

-100 -80 -60 -40 -20
0

0.04

0.08
z (  = -38.0)
z' (  = -32.9)

Figure 4: Lower bounds of the full training set. x-axis:
lower bound value; y-axis: frequency. The left column
is for semantic parsing, and the right column for NL
generation. z is SUPER method and z′ is DIM. µ is the
average lower bound, with significantly better values
boldfaced (p < 0.01).

1 2 3 4 5 6
0

0.5

1

(a) ATIS
1 2 3 4 5 6

(b) DJANGO
1 2 3 4

(c) CONALA

Figure 5: Distributions of the rank of learning signals
over the gold-standard samples among the sampled set
on unlabeled data using SEMIDIM (Pro. = 1/2).

DIM. As displayed in Fig. 4, DIM better op-
timizes the lower bounds of both the parser and
the generator, with significantly higher values of
average lower bounds on the full data. These re-
sults further explains that when the lower bound of
the primal model is improved, it produces learning
signals of high quality for the dual model, leading
to better performance on both tasks.

As conjectured above, SEMIDIM outper-
forms SELFTRAIN in almost all setups because
SEMIDIM re-weights the pseudo data with learn-
ing signals from the dual model. To demon-
strate this, by giving the gold label for the un-
labeled corpus, we rank the learning signal over
the gold label among the sampled set using the
semi-trained model, e.g. on ATIS, given an NL
x from the dataset used as the unlabeled cor-
pus, we consider the position of the learning sig-
nal l(x,y∗;φ) of gold-standard sample among all
samples

{
l(x, ŷi;φ)|ŷi ∈ S

}
. As seen in Fig. 5,

the gold candidates are almost always top-ranked,
indicating that SEMIDIM is effective of separat-
ing pseudo samples of high and low-quality.

PARSER SUPER
 

  
¡ 
♂

GEN. DIM
ATIS 84.6 84.2 85.3
DJANGO 65.1 65.8 66.6
CONALA 11.1 11.4 12.4

GENERATOR SUPER
 

  
¡ 
♂

PARSER DIM
ATIS 39.3 41.0 40.6
DJANGO 68.1 66.5 70.8
CONALA 22.5 23.0 24.8

Table 5: Ablation study with full training set by freez-
ing (

 

  
¡ 
♂

) model parameters for generator or parser during
learning. Darker indicates higher values.

0 0.005 0.01 0.05 0.1 0.5 1

57

59

61

A
cc

.

(a) CODE GENERATION

DIM SEMI-DIM SUPER BACKBOOST

0 0.005 0.01 0.05 0.1 0.5 1

65

67

69

B
L

E
U

-4

(b) CODE SUMMARIZATION

DIM SEMI-DIM SUPER SELFTRAIN

Figure 6: Model performance with different λ values
on DJANGO (Pro. = 1/2).

Ablation Study. We conduct ablation studies by
training DIM with the parameters of parser or gen-
erator frozen. The results are presented in Table 5.
As anticipated, for both of parsing and generation,
when the dual model is frozen, the performance
of the primal model degrades. This again demon-
strates DIM’s effectiveness of jointly optimizing
both tasks. Intuitively, jointly updating both the
primal and dual models allows a better learned
dual model to provide high-quality learning sig-
nals, leading to an improved lower bound for the
primal. As a result, freezing parameters of the dual
model has a negative impact on the learning signal
quality, which affects primal model learning.
Effect of λ. λ controls the tradeoff between
learning dual information and the unsupervised
learning objective. Fig. 6 shows that the opti-
mal model performance can be obtained when λ
is within 0.1 ∼ 1. When λ is set to 0, the joint
training only employs labeled samples, and its per-
formance decreases significantly. A minor drop is
observed at λ = 0.01, which is considered to re-
sult from the variance of learning signals derived
from the REINFORCE algorithm.
Correlation between Parser and Generator.



2098

57 57.5 58 58.5
acc.

64

65

66

67

B
L

E
U

-4

(a) DIM

57.5 58 58.5 59 59.5
acc.

65

66

67

68

B
L

E
U

-4

(b) SEMI-DIM

Coef. = 0.922Coef. = 0.807

Figure 7: Performance correlation between parser and
generator. x-axis is for parser and y-axis is for genera-
tor. Coef. indicates Pearson correlation coefficient.

We further study the performance correlation be-
tween the coupled parser and generator. Using the
model outputs shown in Fig. 6, we run linear re-
gressions of generator performance on parser per-
formance, and a high correlation is observed be-
tween them (Fig. 7).

5 Related Work

Semantic Parsing and NL Generation. Neu-
ral sequence-to-sequence models have achieved
promising results on semantic parsing (Dong and
Lapata, 2016; Jia and Liang, 2016; Ling et al.,
2016; Dong and Lapata, 2018) and natural lan-
guage generation (Iyer et al., 2016; Konstas et al.,
2017; Hu et al., 2018). To better model struc-
tured MRs, tree structures and more complicated
graphs are explored for both parsing and genera-
tion (Dong and Lapata, 2016; Rabinovich et al.,
2017; Yin and Neubig, 2017; Song et al., 2018;
Cheng et al., 2017; Alon et al., 2018). Semi-
supervised learning has been widely studied for
semantic parsing (Yin et al., 2018b; Kociský et al.,
2016; Jia and Liang, 2016). Similar to our
work, Chen and Zhou (2018) and Allamanis et al.
(2015) study code retrieval and code summariza-
tion jointly to enhance both tasks. Here, we focus
on the more challenging task of code generation
instead of retrieval, and we also aim for general-
purpose MRs.
Joint Learning in NLP. There has been grow-
ing interests in leveraging related NLP problems
to enhance primal tasks (Collobert et al., 2011;
Peng et al., 2017; Liu et al., 2016), e.g. se-
quence tagging (Collobert et al., 2011), depen-
dency parsing (Peng et al., 2017), discourse anal-
ysis (Liu et al., 2016). Among those, multi-task
learning (MTL) (Ando and Zhang, 2005) is a com-
mon method for joint learning, especially for neu-
ral networks where parameter sharing is utilized

for representation learning. We follow the re-
cent work on dual learning (Xia et al., 2017) to
train dual tasks, where interactions can be em-
ployed to enhance both models. Dual learning has
been successfully applied in NLP and computer
vision problems, such as neural machine transla-
tion (He et al., 2016), question generation and an-
swering (Tang et al., 2017), image-to-image trans-
lation (Yi et al., 2017; Zhu et al., 2017). Differ-
ent from Xia et al. (2017) which minimizes the di-
vergence between the two expected joint distribu-
tions, we aim to learn the expected distributions in
a way similar to distribution matching (Gan et al.,
2017). Furthermore, our method can be extended
to semi-supervised scenario, prior to Xia et al.
(2017)’s work which can only be applied in su-
pervised setup. Following Zhang et al. (2018), we
deduce the variational lower bounds of expected
distributions via information maximization (Bar-
ber and Agakov, 2003). DIM aims to optimize the
dual information instead of the two mutual infor-
mation studied in Zhang et al. (2018).

6 Conclusion

In this work, we propose to jointly train the se-
mantic parser and NL generator by exploiting the
structural connections between them. We intro-
duce the method of DIM to exploit the duality, and
provide a principled way to optimize the dual in-
formation. We further extend supervised DIM to
semi-supervised scenario (SEMIDIM). Extensive
experiments demonstrate the effectiveness of our
proposed methods.

To overcome the issue of poor labeled corpus
for semantic parsing, some automatically mined
datasets have been proposed, e.g. CONALA (Yin
et al., 2018a) and STAQC (Yao et al., 2018). How-
ever, these datasets are noisy and it is hard to train
robust models out of them. In the future, we will
further apply DIM to learn semantic parser and NL
generator from the noisy datasets.

Acknowledgments

The work described in this paper is supported by
Research Grants Council of Hong Kong (PolyU
152036/17E) and National Natural Science Foun-
dation of China (61672445). Lu Wang is sup-
ported by National Science Foundation through
Grants IIS-1566382 and IIS-1813341. This work
was done when Hai was a research assistant in
PolyU from Oct. 2018 to March 2019.



2099

References
Miltiadis Allamanis, Hao Peng, and Charles Sutton.

2016. A convolutional attention network for ex-
treme summarization of source code. In Proceed-
ings of ICML.

Miltiadis Allamanis, Daniel Tarlow, Andrew D. Gor-
don, and Yi Wei. 2015. Bimodal modelling of
source code and natural language. In Proceedings
of ICML.

Uri Alon, Omer Levy, and Eran Yahav. 2018.
code2seq: Generating sequences from structured
representations of code. CoRR, abs/1808.01400.

Rie Kubota Ando and Tong Zhang. 2005. A framework
for learning predictive structures from multiple tasks
and unlabeled data. Journal of Machine Learning
Research, 6:1817–1853.

Laura Banarescu, Claire Bonial, Shu Cai, Madalina
Georgescu, Kira Griffitt, Ulf Hermjakob, Kevin
Knight, Philipp Koehn, Martha Palmer, and Nathan
Schneider. 2013. Abstract meaning representation
for sembanking. In Proceedings of the 7th Linguis-
tic Annotation Workshop and Interoperability with
Discourse.

David Barber and Felix V. Agakov. 2003. The IM algo-
rithm: A variational approach to information maxi-
mization. In Proceedings of NIPS.

Qingying Chen and Minghui Zhou. 2018. A neural
framework for retrieval and summarization of source
code. In Proceedings of ASE.

Jianpeng Cheng, Siva Reddy, Vijay Saraswat, and
Mirella Lapata. 2017. Learning structured natural
language representations for semantic parsing. In
Proceedings of ACL.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel P. Kuksa.
2011. Natural language processing (almost) from
scratch. Journal of Machine Learning Research,
12:2493–2537.

Li Dong and Mirella Lapata. 2016. Language to logical
form with neural attention. In Proceedings of ACL.

Li Dong and Mirella Lapata. 2018. Coarse-to-fine de-
coding for neural semantic parsing. In Proceedings
of ACL.

Jeffrey Flanigan, Chris Dyer, Noah A. Smith, and
Jaime G. Carbonell. 2016. Generation from abstract
meaning representation using tree transducers. In
Proceedings of NAACL HLT.

Zhe Gan, Liqun Chen, Weiyao Wang, Yunchen Pu,
Yizhe Zhang, Hao Liu, Chunyuan Li, and Lawrence
Carin. 2017. Triangle generative adversarial net-
works. In Proceedings of NIPS.

Kelvin Guu, Panupong Pasupat, Evan Zheran Liu,
and Percy Liang. 2017. From language to pro-
grams: Bridging reinforcement learning and maxi-
mum marginal likelihood. In Proceedings of ACL.

Di He, Yingce Xia, Tao Qin, Liwei Wang, Nenghai Yu,
Tie-Yan Liu, and Wei-Ying Ma. 2016. Dual learning
for machine translation. In Proceedings of NIPS.

Xing Hu, Ge Li, Xin Xia, David Lo, and Zhi Jin. 2018.
Deep code comment generation. In Proceedings of
ICPC.

Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and
Luke Zettlemoyer. 2016. Summarizing source code
using a neural attention model. In Proceedings of
ACL.

Robin Jia and Percy Liang. 2016. Data recombination
for neural semantic parsing. In Proceedings of ACL.

Tomás Kociský, Gábor Melis, Edward Grefenstette,
Chris Dyer, Wang Ling, Phil Blunsom, and
Karl Moritz Hermann. 2016. Semantic parsing with
semi-supervised sequential autoencoders. In Pro-
ceedings of EMNLP.

Ioannis Konstas, Srinivasan Iyer, Mark Yatskar, Yejin
Choi, and Luke Zettlemoyer. 2017. Neural AMR:
sequence-to-sequence models for parsing and gen-
eration. In Proceedings of ACL.

Dong-Hyun Lee. 2013. Pseudo-label: The simple and
efficient semi-supervised learning method for deep
neural networks. In Workshop on Challenges in
Representation Learning, ICML.

Wang Ling, Phil Blunsom, Edward Grefenstette,
Karl Moritz Hermann, Tomás Kociský, Fumin
Wang, and Andrew W. Senior. 2016. Latent predic-
tor networks for code generation. In Proceedings of
ACL.

Yang Liu, Sujian Li, Xiaodong Zhang, and Zhifang Sui.
2016. Implicit discourse relation classification via
multi-task neural networks. In Proceedings of AAAI.

Thang Luong, Hieu Pham, and Christopher D. Man-
ning. 2015. Effective approaches to attention-
based neural machine translation. In Proceedings
of EMNLP.

Tomas Mikolov, Martin Karafiát, Lukás Burget, Jan
Cernocký, and Sanjeev Khudanpur. 2010. Recurrent
neural network based language model. In Proceed-
ings of INTERSPEECH.

Dipendra Kumar Misra and Yoav Artzi. 2016. Neural
shift-reduce CCG semantic parsing. In Proceedings
of EMNLP.

Yusuke Oda, Hiroyuki Fudaba, Graham Neubig,
Hideaki Hata, Sakriani Sakti, Tomoki Toda, and
Satoshi Nakamura. 2015. Learning to generate
pseudo-code from source code using statistical ma-
chine translation (T). In Proceedings of ASE.



2100

Romain Paulus, Caiming Xiong, and Richard Socher.
2017. A deep reinforced model for abstractive sum-
marization. CoRR, abs/1705.04304.

Hao Peng, Sam Thomson, and Noah A. Smith. 2017.
Deep multitask learning for semantic dependency
parsing. In Proceedings of ACL.

Maxim Rabinovich, Mitchell Stern, and Dan Klein.
2017. Abstract syntax networks for code generation
and semantic parsing. In Proceedings of ACL.

Rico Sennrich, Barry Haddow, and Alexandra Birch.
2016. Improving neural machine translation models
with monolingual data. In Proceedings of ACL.

Linfeng Song, Yue Zhang, Zhiguo Wang, and Daniel
Gildea. 2018. A graph-to-sequence model for amr-
to-text generation. In Proceedings of ACL.

Duyu Tang, Nan Duan, Tao Qin, and Ming Zhou. 2017.
Question answering and question generation as dual
tasks. CoRR, abs/1706.02027.

Lappoon R. Tang and Raymond J. Mooney. 2000. Au-
tomated construction of database interfaces: Inter-
grating statistical and relational learning for seman-
tic parsing. In Joint SIGDAT Conference on EMNLP
and Very Large Corpora.

Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly.
2015. Pointer networks. In Proceedings of NIPS.

Ronald J. Williams. 1992. Simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. Machine Learning.

Yuk Wah Wong and Raymond J. Mooney. 2007. Gen-
eration by inverting a semantic parser that uses
statistical machine translation. In Proceedings of
NAACL-HLT.

Yingce Xia, Tao Qin, Wei Chen, Jiang Bian, Nenghai
Yu, and Tie-Yan Liu. 2017. Dual supervised learn-
ing. In Proceedings of ICML.

Ziyu Yao, Daniel S. Weld, Wei-Peng Chen, and Huan
Sun. 2018. Staqc: A systematically mined question-
code dataset from stack overflow. In Proceedings of
WWW.

Zili Yi, Hao (Richard) Zhang, Ping Tan, and Minglun
Gong. 2017. Dualgan: Unsupervised dual learning
for image-to-image translation. In Proceedings of
ICCV.

Pengcheng Yin, Bowen Deng, Edgar Chen, Bogdan
Vasilescu, and Graham Neubig. 2018a. Learning to
mine aligned code and natural language pairs from
stack overflow. In Proceedings of MSR.

Pengcheng Yin and Graham Neubig. 2017. A syntactic
neural model for general-purpose code generation.
In Proceedings of ACL.

Pengcheng Yin, Chunting Zhou, Junxian He, and Gra-
ham Neubig. 2018b. StructVAE: Tree-structured la-
tent variable models for semi-supervised semantic
parsing. In Proceedings of ACL.

John M. Zelle and Raymond J. Mooney. 1996. Learn-
ing to parse database queries using inductive logic
programming. In Proceedings of IAAI.

Luke S. Zettlemoyer and Michael Collins. 2005.
Learning to map sentences to logical form: Struc-
tured classification with probabilistic categorial
grammars. In Proceedings of UAI.

Luke S. Zettlemoyer and Michael Collins. 2007. On-
line learning of relaxed CCG grammars for parsing
to logical form. In Proceedings of EMNLP-CoNLL.

Yizhe Zhang, Michel Galley, Jianfeng Gao, Zhe Gan,
Xiujun Li, Chris Brockett, and Bill Dolan. 2018.
Generating informative and diverse conversational
responses via adversarial information maximization.
In Proceedings of NIPS.

Victor Zhong, Caiming Xiong, and Richard Socher.
2017. Seq2sql: Generating structured queries
from natural language using reinforcement learning.
CoRR, abs/1709.00103.

Jun-Yan Zhu, Taesung Park, Phillip Isola, and
Alexei A. Efros. 2017. Unpaired image-to-image
translation using cycle-consistent adversarial net-
works. In Proceedings of ICCV.



2101

A Model Details for the Parser and
Generator

The parser and generator have the same seq2seq
framework. We take the parser for example. Given
the NL utterance x and the linearized MR y, we
use bi-LSTM to encode x into context vectors, and
then a LSTM decoder generates y from the con-
text vectors. The parser pθ(y|x) is formulated as
following:

pθ(y|x) =
|y|∏
t=1

pθ(yt|y<t,x) (14)

where y<t = y1 · · · yt−1.
The hidden state vector at time t from the en-

coder is the concatenation of forward hidden vec-
tor
−→
h t and backward one

←−
h t, denoted as ht =

[
−→
h t,
←−
h t]. With the LSTM unit fLSTMe from the

encoder, we have
−→
h t = fLSTMe(xt,

−→
h t−1) and←−

h t = fLSTMe(xt,
←−
h t+1).

From the decoder side, using the decoder LSTM
unit fLSTMd , we have the hidden state vector at
time t as st = fLSTMd(yt−1, st−1). Global atten-
tion mechanism (Luong et al., 2015) is applied to
obtain the context vector ct at time t:

ct =

|x|∑
i=1

αt,ihi

where αt,i is the attention weight and is specified
as:

αt,i =
exp(Watt[st;hi])∑|x|
k=1 exp(Watt[sthk])

(15)

where Watt is the learnable parameters.
At time t, with hidden state st in the decoder

and context vector ct from the encoder, we have
the prediction probability for yt:

pvocab(yt|y<t,x) = fsoftmax(Wd1 · tanh(Wd2 [st; ct]))
where Wd1 and Wd2 are learnable parameters.

We further apply the pointer-network (Vinyals
et al., 2015) to copy tokens from the input to al-
leviate the out-of-vocabulary (OOV) issue. We
adopt the calculation flows for copying mecha-
nism from Yin et al. (2018b), readers can refer to
that paper for further details.

B Marginal Distributions

To estimate the marginal distributions p(x) and
q(y), we learn the LSTM language models over
the NL utterances and MRs. MRs are linearized.
Suppose given the NL x = {xi}|x|i=1, the learning

objective is:

p(x) =

|x|∏
i=1

p(xi|x<i) (16)

where x<i = x1 · · ·xi−1. At time t, we have the
following probability to predict xt:

p(xt|x<t) = fsoftmax(W · ht + b) (17)
Here, ht is estimated using the LSTM network:

ht = fLSTM(xt,ht−1) (18)

The above marginal distribution estimation for
NLs is also applied to linearized MRs.

C Experimental Setups

C.1 Marginal Distribution
We pre-train the language models on the full train-
ing set before joint learning and the language
mdoels will be fixed in the following experiments.
The embedding size is selected from {128, 256}
and the hidden size is tuned from {256, 512},
which are both evaluated on the validation set. We
use SGD to update the models. Early stopping is
applied and the training will be stopped if the ppl
value does not decrease for continuous 5 times.

C.2 Model Configuration
To conduct the joint learning using DIM and
SEMIDIM, we have to firstly train the parser and
generator separately referred as the method of SU-
PER.

To pre-train the parser and generator, we tune
the embedding size from {125, 150, 256} and hid-
den size from {256, 300, 512}. The batch size is
selected from {10, 16} varying over the datasets.
Early stopping is applied and the patience time is
set to 5. Initial learning rate is 0.001. Adam is
adopted to optimize the models. The parser and
generator will be trained until convergence.

After the pre-training, we conduct joint learning
based on the pre-trained parser and generator. The
learning rate will be slowed down to 0.00025. The
beam size for sampling is tuned from {3, 5}.


