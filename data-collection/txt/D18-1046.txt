




































Bootstrapping Transliteration with Constrained Discovery for Low-Resource Languages


Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 501–511
Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics

501

Bootstrapping Transliteration with Constrained Discovery
for Low-Resource Languages

Shyam Upadhyay
University of Pennsylvania

Philadelphia, PA
shyamupa@seas.upenn.edu

Jordan Kodner
University of Pennsylvania

Philadelphia, PA
jkodner@seas.upenn.edu

Dan Roth
University of Pennsylvania

Philadelphia, PA
danroth@seas.upenn.edu

Abstract
Generating the English transliteration of a
name written in a foreign script is an important
and challenging step in multilingual knowl-
edge acquisition and information extraction.
Existing approaches to transliteration genera-
tion require a large (>5000) number of train-
ing examples. This difficulty contrasts with
transliteration discovery, a somewhat easier
task that involves picking a plausible translit-
eration from a given list. In this work, we
present a bootstrapping algorithm that uses
constrained discovery to improve generation,
and can be used with as few as 500 training ex-
amples, which we show can be sourced from
annotators in a matter of hours. This opens
the task to languages for which large number
of training examples are unavailable. We eval-
uate transliteration generation performance it-
self, as well the improvement it brings to cross-
lingual candidate generation for entity linking,
a typical downstream task. We present a com-
prehensive evaluation of our approach on nine
languages, each written in a unique script.1

1 Introduction

Transliteration is the process of transducing
names from one writing system to another (e.g.,
ओबामा in Devanagari to Obama in Latin script)
while preserving their pronunciation (Knight and
Graehl, 1998; Karimi et al., 2011). In particu-
lar, back-transliteration from foreign languages
to English has applications in multilingual knowl-
edge acquisition tasks including named entity
recognition (Darwish, 2013) and information re-
trieval (Virga and Khudanpur, 2003). Two tasks
feature prominently in the transliteration literature:
generation (Knight and Graehl, 1998) which in-
volves producing an appropriate transliteration for
a given word in an open-ended way, and discov-
ery (Sproat et al., 2006; Klementiev and Roth,

1code at github.com/shyamupa/hma-translit.

2008) which involves selecting an appropriate
transliteration for a word from a list of candidates.
This work develops transliteration generation ap-
proaches for low-resource languages.
Existing transliteration generation models re-

quire supervision in the form of source-target name
pairs (≈5-10k), which are often collected from
names in Wikipedia inter-language links (Irvine
et al., 2010). However, most languages that use
non-Latin scripts are under-represented in terms of
such resources. Table 1 illustrates this issue, and
the extra coverage one can achieve by extending
to low-resource languages. A model that requires
50k name pairs as supervision can only support 6
languages, while one that just needs 500 could sup-
port 56. For a model to be widely applicable, it
must function in low-resource settings.

# Name Pairs in Wikipedia Languages Scripts

> 50, 000 6 5
> 10, 000 18 14
> 5, 000 24 15
> 1, 000 45 22
> 500 56 23
> 0 93 30

Table 1: Cumulative number of person name pairs in
Wikipedia inter-language links. While previous approaches
for transliteration generation were applicable to only 24 lan-
guages (spanning 15 scripts), our approach is applicable to
56 languages (23 scripts). When counting scripts we exclude
variants (e.g., all Cyrillic scripts and variants count as one).

Our Approach

Previous Work

We propose a new bootstrapping algorithm that
uses a weak generation model to guide discov-
ery of good transliterations, which in turn aids fu-
ture bootstrapping iterations.2 By carefully con-
trolling the interaction of discovery and the gen-
eration model via constrained inference, we show

2All generative approaches are also capable of discovery,
by using the posterior P(y | x) to select the most likely can-
didate transliteration, while the opposite is not true.

github.com/shyamupa/hma-translit


502

how to bootstrap a generation model using a dic-
tionary of names in English, a list of words in the
foreign script, and little initial supervision (≈500
name pairs). To the best of our knowledge, ours is
the first work to accomplish transliteration genera-
tion in such a low-resource setting.
We demonstrate the practicality of our approach

in truly low-resource scenarios and downstream
applications through two case studies. First, in
§8.1 we show that one can obtain the initial super-
vision from a single human annotator within a few
hours for two languages – Armenian and Punjabi.
This is a realistic scenario where language access
is limited to a single native informant. Second, in
§8.2 we show that our approach benefits a typical
downstream application, namely candidate genera-
tion for cross-lingual entity linking, by improving
recall on two low-resource languages – Tigrinya
and Macedonian. We also present an analysis (§7)
of the inherent challenges of transliteration, and
the trade-off between native (i.e., source) and for-
eign (i.e., target) vocabulary.

2 Related Work

We briefly review the limitations of existing gen-
eration and discovery approaches, and provide an
overview of how our work addresses them.

Transliteration Generation (Haizhou et al.,
2004; Jiampojamarn et al., 2009; Ravi and Knight,
2009; Jiampojamarn et al., 2010; Finch et al., 2015,
inter alia) requires generous amount of name
pairs (≈5-10k) in order to learn to map words
in the source script to the target script. While
some approaches (Irvine et al., 2010; Tsai and
Roth, 2018) use Wikipedia inter-language links to
identify name pairs for supervision, a truly low-
resource language (like Tigrinya) is likely to have
limited Wikipedia presence as well.

Transliteration Discovery (Sproat et al., 2006;
Chang et al., 2009) is considerably easier than gen-
eration, owing to the smaller search space. How-
ever, discovery often uses features derived from
resources that are unavailable for low-resource lan-
guages, like comparable corpora (Sproat et al.,
2006; Klementiev and Roth, 2008).
A key limitation of discovery is the assumption

that the correct transliteration(s) is in the list of can-
didates N . Since discovery models always pick
something from N , they can produce false posi-
tives, if no correct transliteration is present in N .

To overcome this, it is prudent to develop genera-
tion models which can handle input for which the
transliteration does not belong in N .

Our Work We show that a weak generation
model can be iteratively improved using con-
strained discovery. In particular, our work uses
a weak generation model to discover new train-
ing pairs, using constraints to drive the bootstrap-
ping. Our generation model is inspired by the
success of sequence to sequence generation mod-
els (Sutskever et al., 2014; Bahdanau et al., 2015)
for string transduction tasks like inflection and
derivation generation (Faruqui et al., 2016; Cot-
terell et al., 2017; Aharoni and Goldberg, 2017;
Makarov et al., 2017). Our bootstrapping frame-
work can be viewed as an instance of constraint
driven learning (Chang et al., 2007, 2012).

3 Transliteration Generation with Hard
Monotonic Attention - Seq2Seq(HMA)

We view generation as a string transduction task
and use a sequence to sequence (Seq2Seq) gen-
eration model that uses hard monotonic atten-
tion (Aharoni and Goldberg, 2017), henceforth
referred to as Seq2Seq(HMA). During genera-
tion, Seq2Seq(HMA) directly models the mono-
tonic source-to-target sequence alignments, using
a pointer that attends to a single input character
at a time. Monotonic attention is a natural fit
for transliteration because even though the num-
ber of characters needed to represent a sound in
the source and target language vary, the sequence
of sounds is presented in the same order.3 We re-
view Seq2Seq(HMA) below, and describe how it
can be applied to transliteration generation.

Encoding Input Word Let Σf be the source al-
phabet and Σe be the English alphabet. Let x =
(x1, x2, · · · , xn) denote an input word where each
character xi ∈ Σf . The characters are first en-
coded using a embedding matrix W ∈ R|Σf |×d
to get character embeddingsx1,x2, · · · ,xn where
each xi ∈ Rd. These embeddings are fed into
a bidirectional RNN encoder to generate encoded
vectors h1,h2, · · · ,hn where each hi ∈ R2k,
and k is the size of output vector of the forward
(and backward) encoder. The encoded vectors
h1,h2, · · · ,hn are then fed into the decoder.

3Many Indic scripts, that sometimes write vowels before
the consonants they are pronounced after, seem to violate this
claim, but Unicode representations of these scripts actually
preserve the consonant-vowel order.



503

Bidirectional LSTM

h0 h1 h2 h3 h4 h5

step t h a n

step t h asos

sos

n

sos eosथ न स◌ो

o

o s

s

t h a n o s

step step step step

step step step step eos

Figure 1: Transliteration using Seq2Seq transduction with
Hard Monotonic Attention, or Seq2Seq(HMA). The figure
shows how decoding proceeds for transliterating “थनोस” to
“thanos”. During decoding, themodel attends to a source char-
acter (e.g.,थ shown in blue) and outputs target characters (t, h,
a) until a step action is generated, which moves the attention
position forward by one character (to न), and so on.

MonotonicDecodingwithHardAttention Fig-
ure 1 illustrates the decoding process. The decoder
RNN generates a sequence of actions {s1, s2, · · · },
such that each si ∈ Σe ∪ {step}. The step ac-
tion controls an attention position a, attending on
input character xa, with encoded vector ha. Each
action si is embedded into si ∈ Rd using a output
embedding matrix A ∈ R(|Σe|+1)×d. At any time
during decoding, the decoder uses its last hidden
state, the embedding of the previous action si and
the encoded vector ha of the current attended po-
sition to generate the next action si+1. If the gen-
erated action is step, the decoder increments the
attention position by one. This ensures that the de-
coding is monotonic, as the attention position can
only move forward or stay at the same position dur-
ing generation. We use Inference(G, x) to refer
to the above decoding process for a trained gener-
ation model G and input word x.

Training requires the oracle action sequence
{si} for input x1:n that generates the correct
transliteration y1:m. The oracle sequence is gener-
ated using the train name pairs and Algorithm 1 in
Aharoni and Goldberg (2017), with the character-
level alignment between x1:n and y1:m being gen-
erated using the algorithm in Cotterell et al. (2016).

Inference Strategies We describe an uncon-
strained and a constrained inference strategy to se-
lect the best transliteration ŷ from a beam {yi}ki=1
of transliteration hypotheses, sorted in descending
order by likelihood. The constrained strategy use a
name dictionary N , to guide the inference. These
strategies are applicable to any generation model.

• Unconstrained (U) selects the most likely
item y1 in the beam as ŷ.

• Dictionary-Constrained (DC) selects the
highest scoring hypothesis that is present in
N , and defaults to y1 if none are in N .

It is tempting to disallow the model from gen-
erating hypotheses which are not in the dictionary
N . However, dictionaries are always incomplete,
and restricting the search to generate from N in-
evitably leads to incorrect predictions if the correct
transliteration is not in N . This is essentially the
same as the problem inherent to discovery models.

Other Strategies in Previous Work A related
constrained inference strategy was proposed by
Lin et al. (2016), who use a entity linking sys-
tem (Wang et al., 2015) to correct and re-rank hy-
potheses, using any available context to aid hypoth-
esis correction. Our constrained inference strategy
is much simpler, requiring only a name dictionary
N . We experimentally show that our approach out-
performs that of Lin et al. (2016).

4 Low-Resource Bootstrapping

Low-resource languages will have a limited num-
ber of name pairs for training a generation model.
To learn a good generation model in this setting,
we propose a new bootstrapping algorithm, that
uses constrained discovery to mine name pairs to
re-train the generation model. Our algorithm re-
quires a small (≈500) seed list of name pairs S for
supervision, a dictionary N containing names in
English, and a list of words Vf in the foreign script.
Below we describe our algorithm and the con-

straints used to guide discovery of new name pairs.

4.1 The Bootstrapping Algorithm
Algorithm 1 shows the pseudo-code of the boot-
strapping procedure. We initialize a weak gener-
ation model G0 using a seed list of name pairs
S (line 1). At iteration t, the current generation
model Gt produces the top-k transliteration hy-
potheses {yi}ki=1 for each word x ∈ Vf (line 5). A
sourceword and hypothesis pair (x, yi), is added to
the set of mined name pairsB if they satisfy a set of
discovery constraints (described below) (line 8). A
new generation model Gt+1 is trained for the next
iteration using the union of the seed list S and the
mined name pairs B (line 12). B is purged after ev-
ery iteration (line 3) to preventGt+1 from being in-
fluenced by possibly incorrect name pairs mined in



504

Algorithm 1 Bootstrapping a Transliteration Generation
Model via Constrained Discovery
Input:

English name dictionaryN ; Seed training pairs S;
Vocabulary in the target language Vf .

Hyper-parameters:
initial minimum length threshold Lmin0 ;
minimum likelihood threshold δmin;
length ratio tolerance ϵ.

Output: Generation model GT
1: G0 = train(S) ▷ init. generation model.
2: while not converged do
3: B = ∅ ▷ purge mined set.
4: for x in Vf do
5: {yi}ki=1 = argtopk Inference(Gt,x)
6: for yi in {yi}ki=1 do
7: if (x, yi) satisfies constraints in §4.2 then
8: B = B ∪ {(x, yi)} ▷ add to mined set.
9: end if
10: end for
11: end for
12: Gt+1 = train (S ∪ B)
13: Lmint+1 = Lmint − 1 ▷ reduce length threshold.
14: t = t+ 1 ▷ track iteration
15: end while

earlier iterations. The algorithm converges when
accuracy@1 stops increasing on a development set.
We note that our bootstrapping approach is applica-
ble to any transliteration generation model.
To ensure that high quality name pairs are added

to themined setB during bootstrapping, we use the
following discovery constraints.

4.2 Discovery Constraints
A word-transliteration pair (x, y) is added to the
set of mined pairs B, only if all the following con-
straints are satisfied,

1. y ∈ N . i.e., y belongs in the dictionary.

2. P(y | x) > δmin. The model is sufficiently
confident about the transliteration.

3. The ratio of lengths |y||x| should be close to the
average ratio estimated from S (Matthews,
2007). We encode this using the constraint
| |y||x| − r(S)| ≤ ϵ, where ϵ is a tunable toler-
ance and r(S) is the average ratio in S.

4. |y| > Lmint . We found that false positives
were more likely to be short hypotheses in
early iterations. As the model improves with
each iteration, Lmint is lowered to allow more
new pairs to be mined.

We note that our bootstrapping algorithm can
be formulated as an instance of constraint driven
learning (Chang et al., 2007, 2012).

5 Experimental Setup

Unless otherwise specified, we evaluate all gener-
ation models using the best model prediction ŷ us-
ing acc@1 against the reference transliteration y∗.

Training and Evaluation Dataset We use the
train and development sets from the Named
Entities Workshop 2015 (Duan et al., 2015)
(NEWS2015) for Hindi (hi), Kannada (kn), Ben-
gali (bn), Tamil (ta) and Hebrew (he) as our train
and evaluation set.4 The size of the train set was
∼12k, 10k, 14k, 10k and 10k respectively, and all
evaluation sets were ∼1k.
For the low resource experiments, we sub-

sample 500 examples from each train set in the
NEWS2015 dataset using five random seeds and
report the averaged results. We also set aside a
1k name pairs from the corresponding NEWS2015
train set of each language as development data.
The foreign script portion of the remaining train
data is used as Vf in the bootstrapping algorithm.

Model and Tuning Details We implemented
Seq2Seq(HMA) using PyTorch.5 We used 50 di-
mensional character embeddings, and single layer
GRU (Cho et al., 2014) encoder with 20 hidden
states for all experiments. The Adam (Kingma and
Ba, 2014) optimizer was used with default hyper-
parameters, a learning rate of 0.001, a batch size
of 1, and maximum of 20 iterations in all experi-
ments. Beam search used a width of 10. For low-
resource experiments, all bootstrapping parame-
ters were tuned on the development data set aside
above. Lmin0 is chosen from {10, 15, 20, 25}.

Name Dictionary We use a name dictionary of
1.05 million names constructed from the English
Wikipedia (dump dated 05/20/2017) by taking the
list of title tokens inWikipedia sorted by frequency,
and removing tokens which appears only once.

5.1 Comparisons

We compare with the following generation models:

P&R (Pasternack and Roth, 2009) A prob-
abilistic transliteration generation approach that
learns latent alignments between substrings in the
source and the target words. The model is trained
to score all possible segmentation and their align-
ments, using an EM-like algorithm.

4Test set was not available since shared task concluded.
5github.com/pytorch



505

DirecTL+ (Jiampojamarn et al., 2009) A
HMM-like discriminative string transduction
model that predicts the output transliteration
using many-to-many alignments between the
source word and target transliteration. Following
Jiampojamarn et al. (2009), we use the m2m-
aligner (Jiampojamarn et al., 2007) to generate
the many-to-many alignments, and the public
implementation of DirecTL+ to train models.6

RPI-ISI (Lin et al., 2016) A transliteration ap-
proach that uses a language-independent entity
linking system (Wang et al., 2015) to jointly cor-
rect and re-rank the hypotheses produced by the
generation model. We compare to both the uncon-
strained inference (U) approach and the entity link-
ing constrained inference (+EL) approach.

Seq2Seq w/ Att A sequence to sequence gener-
ation model which uses soft attention as described
in (Bahdanau et al., 2015). This model does not
enforce monotonicity at inference time, and serves
as direct comparison for Seq2Seq(HMA).

6 Experiments

This section aims to analyze: (a) how effective
is Seq2Seq(HMA) for transliteration generation
when provided all available supervision (§6.1)?
and (b) how effective is the bootstrapping algo-
rithm in the low-resource setting when only 500
examples are available (§6.2)?

6.1 Full Supervision Setting
We compare Seq2Seq(HMA) with previous ap-
proaches when provided all available supervision,
to see how it fares under standard evaluation.
Results in the unconstrained inference (U) set-

ting (Table 2 top 5 rows) shows Seq2Seq(HMA),
denoted by “Ours”, outperforms previous ap-
proaches on Hindi, Kannada, and Bengali, with al-
most 3-4% gains. Improvements over the Seq2Seq
with Attention (Seq2Seq w/ Att) model demon-
strate the benefit of imposing the monotonicity
constraint in the generation model. On Tamil and
Hebrew, Seq2Seq(HMA) is at par with the best
approaches, with negligible gap (∼0.3) in scores.
Overall, we see that Seq2Seq(HMA) can achieve
better (and sometimes competitive) scores than
state-of-the-art approaches in full supervision set-
tings. When comparing approaches which use con-
strained inference (Table 2, rows 6 and 7), we see

6https://code.google.com/p/directl-p

Lang. → hi kn bn ta he Avg.Approach ↓

Full Supervision Setting (5-10k examples)

Seq2Seq w/ Att (U) 35.5 33.4 46.1 17.2 20.3 30.5
P&R (U) 37.4 31.6 45.4 20.2 18.7 30.7
DirecTL+ (U) 38.9 34.7 48.4 19.9 16.8 31.7
RPI-ISI (U) 40.3 29.8 49.4 20.2 21.5 32.2
Ours(U) 42.8 38.9 52.4 20.5 23.4 35.6

Approaches Using Constrained Inference

RPI-ISI + EL 44.8 37.6 52.0 29.0 37.2 40.1
Ours(DC) 51.8 43.3 56.6 28.0 36.1 43.2

Low-Resource Setting (500 examples)

Seq2Seq w/ Att (U) 17.0 13.6 14.5 6.0 9.5 12.1
P&R (U) 21.1 16.6 34.2 9.4 13.0 18.9
DirecTL+ (U) 26.6 25.3 35.5 11.8 10.7 22.0
Ours(U) 29.1 27.7 37.7 11.5 16.2 24.4
Ours(U) + Boot. 40.1 35.1 50.3 17.8 22.8 33.2

Table 2: Comparing different approaches on theNEWS2015
dataset using acc@1 as the evaluation metric. “Ours” denotes
the Seq2Seq(HMA) model, with (.) denoting the inference
strategy. Numbers for RPI-ISI are from Lin et al. (2016).

that using dictionary-constrained inference (as in
Ours(DC)) is more effective than using a entity-
linking model for re-ranking (RPI-ISI + EL).

6.2 Low-Resource Setting

In Table 2 (rows under “Low-Resource Setting”),
we evaluate different models in a low-resource set-
tingwhen provided only 500 name pairs as supervi-
sion. Results are averaged over 5 different random
sub-samples of 500 examples.
The results clearly demonstrate that all gener-

ation models suffer a drop in performance when
provided limited training data. Note that models
like Seq2Seq with Attention suffer a larger drop
than those which enforce monotonicity, suggesting
that incorporating monotonicity into the inference
step in the low-resource setting is essential. After
bootstrapping ourweak generationmodel usingAl-
gorithm 1, the performance improves substantially
(last row in Table 2). On almost all languages, the
generation model improves by at least 6%, with
performance for Hindi and Bengali improving by
more than 10%. Bootstrapping results for the lan-
guages are within 2-4% of the best model trained
with all available supervision.
To better analyze the progress of the transliter-

ation model during bootstrapping, we plot the ac-
curacy@1 of the current transliteration model af-
ter each bootstrapping iteration for each of the lan-
guages (solid lines in Figure 2). For reference,
we also show the best performance for a gener-

https://code.google.com/p/directl-p


506

1 2 3 4 5 6
0.1

0.2

0.3

0.4

0.5

Hindi-Full

Kannada-Full

Bengali-Full

Tamil-Full
Hebrew-Full

# iteration

ac
c@

1

Hindi Kannada Bengali
Tamil Hebrew

Figure 2: Plot showing acc@1 after each bootstrapping itera-
tion for Hindi, Kannada, Bengali, Tamil and Hebrew, starting
with only 500 training pairs as supervision. For comparison,
the acc@1 of a model trained with all available supervision is
also shown (respective dashed lines, marked X-Full).

ation model using all available supervision from
§6.1 (dotted horizontal lines in Figure 2). From
Figure 2, we can see that almost after 5 bootstrap-
ping iterations, the generation model attains com-
petitive performance to respective state-of-the-art
models trained with full supervision.

6.3 Error Analysis

Though our model is state of the art, it does
present a few weaknesses. We have found that
the dictionary sometimes misleads the model dur-
ing constrained inference. For example, the cor-
rect transliteration “vidyul” of the Hindi व ुल, is
not present in the dictionary, but another hypothe-
sis “vidul” is. Another issue comes from the pro-
portion of native (i.e., from the source language)
and foreign (i.e., from English or other languages)
names in the training data. It is usually not the
case that the source and target scripts have the
same transliteration rules. For example, य in Hindi
might represent ya in English or Hindi names, but
ja in German. Similarly, while अ should be a in
Hindi names, it could be any of a few vowels in
English. The NEWS2015 dataset does not report
a native/foreign ratio, but by our estimation, it is
about 70/30 for each language. This native and
foreign names dichotomy are some of the inherent
challenges in transliteration, that we discuss in de-
tail in the next section.

7 Challenges Inherent to Transliteration

The fact that all models in Table 2 perform well or
poorly on the same languages suggests that most
of the observed performance variation is the result
of factors intrinsic to the specific languages. Here
we analyze some challenges that are inherent to
the transliteration task, and explain why the per-
formance ceiling is well under 100% for all lan-
guages, and lower for languages like Tamil and He-
brew than the others.

7.1 Source and Target-Specific Issues
Source-Driven Some transliteration errors are
due to ambiguities in the source scripts. For in-
stance, the Tamil script uses a single character to
denote {ta, da, tha, dha}, a single character for {ka,
ga, kha, gha}, etc., while the rest of the Indian
scripts have unique characters for each of these.
Thus, names like Hartley and Hardley are entirely
indistinguishable in Tamil but are distinguishable
in the other scripts. We illustrate this problem
by transliterating back and forth between Tamil
andHindi. When transliteratingHindi→Tamil, the
model achieves an accuracy of 31%, which drops
to 15% when transliterating Tamil→Hindi, sug-
gesting that the Tamil script is more ambiguous.
The Hebrew script also introduces error because

it tends to omit vowels or write them ambigu-
ously, leaving the model to guess between plau-
sible choices. For example, the word מלך could
be transliterated melech “king” just as easily as
malach “he ruled.” When Hebrew does write vow-
els, it reuses consonant letters, again ambiguously.
For example, ה can be used to express a or e, so
שמונה can be either shmona or shmone “eight mas-
culine/feminine”. The script also does not reliably
distinguish b from v or p from f, among others.
All languages run into problems when they are

faced with writing sounds that they do not natively
distinguish. For example, Hindi does not make a
distinction between w and v, so both vest and west
are written as वे ट in its script.
These script-specific deficiencies explains why

all models struggle on Tamil and Hebrew relative
to the others. These issues cannot be completely
resolved without memorizing individual source-
target pairs and leveraging context.

Target-Driven Some errors arise from the chal-
lenges presented by target script (here Latin script
for English). To handle English’s notoriously con-
voluted orthography, a model has to infer silent let-



507

Native Foreign Ratio

Hindi 45.1 31.4 1.44
Bengali 63.1 20.1 3.14
Kannada 42.6 23.1 1.84
Tamil 24.3 05.2 4.67

Table 3: Acc@1 for native and foreign words for four lan-
guages (§7.2). Ratio is native performance relative to foreign.

ters, decide whether to use f or ph for /f/; use k, c,
ck, ch, or q for /k/, and so on. The problem is made
worse because English is not the only language that
uses Latin script. For example, German names like
Schmidt should be written with sch instead of sh,
and for French names like Margot and Margeau
(which are pronounced the same), we have to re-
sort to memorization. The arbitrariness extends
into borrowings from the source languages as well.
For example, the Indian name Bangalore is writ-
ten with a silent-e, and the name Lakshadweep con-
tains ee, instead of the expected i.

7.2 Disparity between Native and Foreign
All these issues come together to create a per-
formance disparity between native names, which
are well-integrated into the source language ety-
mologically (Indian names like Jasodhara or Ra-
manathan for Hindi), and foreign names (French
Grenoble or Japanese Honshu for Hindi), which
are not. The above datasets include an unspecified
mix of native and foreign names. This is a prob-
lem since any model must learn essentially sepa-
rate transliteration schemes for each.
To quantify the effect of this, we annotate na-

tive and foreign names in the test split of the four
Indian languages, and evaluate performance for
both categories. Table 3 shows that our model
performs significantly better on native names for
all the languages. A possible reason for is that
the source scripts were designed for writing na-
tive names (e.g., Tamil script lacks separate {ta,
da, tha, dha} characters because the Tamil lan-
guage does not distinguish these sounds). Further-
more, foreign names have a wide variety of origins
with their own conventions as discussed in §7.1.
The performance gap is proportionally greatest for
Tamil, likely due to its script.

8 Case Studies

In this section, we evaluate the practical utility
of our approach in low-resource settings and for
downstream applications through two case studies.

We first show that obtaining an adequate seed list
is possible with a few hours of manual annotation
(§8.1) from a single human annotator. We then
show the positive impact that our approach has on
a downstream task, by evaluating its contribution
to candidate generation for Tigrinya and Macedo-
nian entity linking (§8.2).

Language Monolingual Corpus Vocabulary

Punjabi Corpus ILCI-II♠ 30k
Armenian TED♣ 50k
Tigrinya Habit Project♦ 225k

Macedonian TED♣ 60k
♦=habit-project.eu/wiki/TigrinyaCorpus,
♠=tdil-dc.in,
♣=github.com/ajinkyakulkarni14/
TED-Multilingual-Parallel-Corpus

Table 4: Corpora used for obtaining foreign vocabulary Vf
for bootstrapping in the case studies in §8.1 and §8.2.

8.1 Manual Annotation
The manual annotation exercises simulate a low-
resource setting with only a single human annota-
tor is available. We judge the usability of the anno-
tations by training models on them and evaluating
the models on test sets of 1000 names each, ob-
tained from Wikipedia inter-language links. For
bootstrapping experiments, we use the corpora
shown in Table 4 to obtain foreign vocabulary Vf .

Languages Studied We investigate perfor-
mance on two languages: Armenian and Punjabi.
Spoken in Armenia and Turkey, Armenian is

an Indo-European language with no close relatives.
It has Eastern and Western dialects with different
spelling conventions. Armenian Wikipedia is pri-
marily written in the Eastern dialect, while our an-
notator was a native Western speaker.7
Punjabi is an Indic language from Northwest In-

dia and Pakistan that is closely related to Hindi.
Our annotator grew up primarily speaking Hindi.

Annotation Guidelines Annotators were given
two tasks. First, they were asked to write two
names and their English transliterations for each
letter in the source script: one beginning with the
letter and another containing it elsewhere. (e.g.
“Julia” and “Benjamin” for the letter “j” if the
source were English). The is done to ensure good
coverage over the alphabet. Next, annotators were
shown a list of English words and were asked to

7The annotator produced Western Armenian which was
mechanically mapped to “Eastern” by swapping five Arme-
nian character pairs: դ/տ, պ/բ , ք/կ , ձ/ծ, ճ/ջ

habit-project.eu/wiki/TigrinyaCorpus
tdil-dc.in
github.com/ajinkyakulkarni14/TED-Multilingual-Parallel-Corpus
github.com/ajinkyakulkarni14/TED-Multilingual-Parallel-Corpus


508

Lang. → Punjabi ArmenianApproach ↓

Ours(U) 33.4 49.9
Ours(U) + Bootstrapping 44.5 55.8

Annotation Time (hours) 5 4

Table 5: Acc@1 using human annotated seed set and boot-
strapping the Seq2Seq(HMA) model. Both languages per-
form well relative to the other languages investigated so far.
Both annotation sub-tasks took roughly the same time.

provide plausible transliteration(s) into the target
script. The list had a mix of recognizable foreign
(e.g., Clinton, Helsinki) and native names (e.g.,
Sarkessian, Yerevan for Armenian).
We collected about 600 and 500 annotated pairs

respectively for Armenian and Punjabi. Table 5
shows that the performance of the models trained
on the annotated data is comparable to that on the
standard test corpora for other languages. This
show that our approach is robust to human incon-
sistencies and regional spelling variations, and that
obtaining an adequate seed list is possible with just
a few hours of manual annotation.

8.2 Candidate Generation (CG)

Since transliteration is an intermediate step in
many downstreammultilingual information extrac-
tion tasks (Darwish, 2013; Kim et al., 2012; Jeong
et al., 1999; Virga and Khudanpur, 2003; Chen
et al., 2006), it is possibly to gauge its performance
extrinsically by the impact it has on such tasks. We
use the task of candidate generation (CG), which
is a key step in cross-lingual entity linking.
The goal of cross-lingual entity linking (Mc-

Namee et al., 2011; Tsai and Roth, 2016; Upad-
hyay et al., 2018) is to ground spans of text written
in any language to an entity in a knowledge base
(KB). For instance, grounding [Chicago] in the fol-
lowing German sentence to Chicago_(band).8

[Chicago] wird in Woodstock aufzutreten.

The role of CG in cross-lingual entity linking is
to create a set of plausible entities given a string
while ensuring the correct KB entity belongs to
that set. For the above German sentence, it would
provide a list of possible KB entities for the string
Chicago: Chicago_(band), Chicago_(city),
Chicago_(font), etc., so that entity linking can
select the band. Foreign scripts pose an additional
challenge for CG because they must be transliter-

8Translation: Chicago will perform at Woodstock.

ated before they are passed on to candidate gener-
ation. For instance, any mention of “Chicago” in
Amharic must first be transliterated from ሺካጎ.
Most approaches for CG use Wikipedia inter-

language links to generate the lists of candi-
dates (Tsai and Roth, 2016). While recent ap-
proaches such as Tsai and Roth (2018) have re-
sorted to name translation for CG, they require
over 10k examples for languages written in non-
Latin scripts, which is prohibitive for low-resource
languages with little Wikipedia presence.

Candidate Generation with Transliteration
We evaluate the extent to which our approach im-
proves recall of a naive CG baseline that generates
candidates by performing exact name match. For
each span of text to be linked (or query mention),
we first check if the naive name matching strategy
finds any candidates in the KB. If none are found,
the query mention is back-transliterated to English,
and at most 20 candidates are generated using a
inverted-index from English names to KB entities.
The evaluation metric is recall@20, i.e., if the
gold KB entity is in the top 20 candidates. We use
Tigrinya and Macedonian as our test languages.

Tigrinya is a South Semitic language related to
Amharic, written in the Ethiopic script, and spo-
ken primarily in Eritrea and northern Ethiopia. The
Tigrinya Wikipedia has <200 articles, so we use
inter-language links (∼7.5k) from the Amharic
Wikipedia instead to extract 1k name pairs for the
seed set. We use the monolingual corpus in Ta-
ble 4 for bootstrapping and evaluate on the unse-
questered set provided under the NIST LoReHLT
evaluation, containing 4,630 query mentions.
The Ethiopic script is an alphasyllabary, where

each character is consonant-vowel pair. For exam-
ple, the characterመ is mä,ሚ with a tail is mi, and
ሞwith a line ismo. With 26 consonants and 8 vow-
els, this leads to a set of>200 characters creating a
sparsity problem since each character has its own
Unicode code point. However, the code points are
organized so that they can be automatically split9
into unique consonant and vowel codes without ex-
plicitly understanding the script. We assign arbi-
trary ASCII codes to each consonant and vowel so
thatመ/mä becomes “D 1” and ሞ/mo becomes “D
6.” This consonant-vowel splitting (CV-split) re-
duces the number of unique input characters to 55.

9Consonant = Unicode / 8; Vowel = Unicode % 8



509

Approach Recall@20
Tigrinya

Name match (baseline) 31.4

Ours 35.6
Ours (CV-split) 41.3
Ours (CV-split) + Bootstrapping 46.2

Macedonian

Name match (baseline) 33.6

Ours 72.2
Ours + Bootstrapping 76.8

Table 6: Comparing candidate recall@20 for different ap-
proaches on Tigrinya and Macedonian. CV-split refers to
consonant-vowel splitting. Using our transliteration genera-
tion model with bootstrapping yields the highest recall, im-
proving significantly over a name match baseline.

Macedonian is a South Slavic language closely
related to the languages of the former Yugoslavia
and written in a local variant of the Cyrillic alpha-
bet similar to Serbian’s. We use the Macedonian
test set constructed by McNamee et al. (2011) con-
taining 1956 query mentions. A seed set of 1k
name pairs was obtained from the inter-language
Wikipedia links for Macedonian, and the monolin-
gual corpus from Table 4 is used for bootstrapping.

Candidate Generation Results Table 6 shows
the results for the two languages. For Tigrinya,
candidate generation with transliteration improves
on the baseline by 4.2%. Splitting the characters
(CV-split) gives another 5.7%, and adding boot-
strapping gives 4.9% more. Our approach yields
an overall 14.8% improvement in recall over the
baseline, showing that we can effectively exploit
the little available supervision by bootstrapping.
Macedonian yields more dramatic results, where
transliteration provides 38.6% improvement (more
than double the baseline), with bootstrapping pro-
viding another 4.6%. The differences between
Tigrinya andMacedonian is likely due both to their
test sets, corpora and writing systems.

9 Conclusion and Future Work

We presented a new transliteration generation
model, namely Seq2Seq(HMA), and a new boot-
strapping algorithm that can iteratively improve a
weak generation model using constrained discov-
ery. The model presented here achieves state-of-
the-art results on typical training set sizes, and
more importantly, works well in a low-resource
setting with the aid of the bootstrapping algorithm.
The key benefit of the bootstrapping approach is

that it can “recover” most of the performance lost
in the low-resource setting when little supervision
is available by training with a smaller seed set, an
English name dictionary, and a list of unannotated
words in the target script. Additionally, our boot-
strapping algorithm admits any generation model,
giving it wide applicability. Through case studies,
we showed that collecting an adequate seed list is
practical with a few hours of annotation. The ben-
efit of incorporating our transliteration approach
in a downstream task, namely candidate genera-
tion, was also demonstrated. Finally, we discussed
some of the inherent challenges of learning translit-
eration and the deficits of existing training sets.
There are several interesting directions for fu-

ture work. Performing model combination, either
by developing hybrid transliterationmodels (Nico-
lai et al., 2015) or by ensembling (Finch et al.,
2016), can further improve low resource translit-
eration. Jointly leveraging similarities between re-
lated languages, such as writing systems or pho-
netic properties (Kunchukuttan et al., 2018), also
shows promise for low-resource settings. Our anal-
ysis suggests value in revisiting “transliteration in
context” approaches (Goto et al., 2003; Hermjakob
et al., 2008), especially for languages like Hebrew.
We would also like to expand on the analyses pro-
vided in §7 which uncover challenges inherent to
the transliteration task, particularly the impact of
the native/foreign distinction in the train and test
data, the difficulties posed by specific scripts or
pairs of scripts, and how these impact both back-
and forward-transliteration. Recent work from
Merhav and Ash (2018) suggests many useful anal-
yses that we would like to incorporate.

Acknowledgments

The authors thank Mitch Marcus, Snigdha
Chaturvedi, Stephen Mayhew, Nitish Gupta,
Dan Deutsch, and the anonymous reviewers for
their useful comments. We are grateful to the
Armenian and Punjabi annotators for help with
the case studies.
This work was supported under DARPA

LORELEI by Contract HR0011-15-2-0025,
Agreement HR0011-15-2-0023 with DARPA, and
an NDSEG fellowship for the second author. Ap-
proved for Public Release, Distribution Unlimited.
The views expressed are those of the authors and
do not reflect the official policy or position of the
Department of Defense or the U.S. Government.



510

References
Roee Aharoni and Yoav Goldberg. 2017. Morpholog-
ical Inflection Generation with Hard Monotonic At-
tention. In Proc. of ACL.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-
gio. 2015. Neural Machine Translation by Jointly
Learning to Align and Translate. In Proc. of ICLR.

Ming-Wei Chang, Dan Goldwasser, Dan Roth, and
Yuancheng Tu. 2009. Unsupervised Constraint
Driven Learning For Transliteration Discovery. In
Proc. of NAACL.

Ming-Wei Chang, Lev Ratinov, and Dan Roth. 2007.
Guiding Semi-Supervision with Constraint-Driven
Learning. In Proc. of ACL.

Ming-Wei Chang, Lev Ratinov, and Dan Roth. 2012.
Structured Learning with Constrained Conditional
Models. Machine Learning, 88(3):399–431.

Hsin-Hsi Chen, Wen-Cheng Lin, Changhua Yang, and
Wei-Hao Lin. 2006. Translating-Transliterating
Named Entities for Multilingual Information Access.
Journal of the Association for Information Science
and Technology, 57(5).

Kyunghyun Cho, Bart van Merrienboer, Caglar Gul-
cehre, Dzmitry Bahdanau, Fethi Bougares, Hol-
ger Schwenk, and Yoshua Bengio. 2014. Learn-
ing Phrase Representations using RNN Encoder–
Decoder for StatisticalMachine Translation. InProc.
of EMNLP.

Ryan Cotterell, Christo Kirov, John Sylak-Glassman,
David Yarowsky, Jason Eisner, and Mans Hulden.
2016. The SIGMORPHON 2016 Shared Task—
Morphological Reinflection. In Proc. of the 14th
SIGMORPHON Workshop on Computational Re-
search in Phonetics, Phonology, and Morphology.

Ryan Cotterell, Ekaterina Vylomova, Huda Khayral-
lah, Christo Kirov, and David Yarowsky. 2017.
Paradigm Completion for Derivational Morphology.
In Proc. of EMNLP.

Kareem Darwish. 2013. Named Entity Recognition us-
ing Cross-lingual Resources: Arabic as an Example.
In Proc. of ACL.

Xiangyu Duan, Rafael E Banchs, Min Zhang, Haizhou
Li, and A Kumaran, editors. 2015. Proc. of the Fifth
Named Entity Workshop.

Manaal Faruqui, Yulia Tsvetkov, Graham Neubig, and
Chris Dyer. 2016. Morphological Inflection Gener-
ation Using Character Sequence to Sequence Learn-
ing. In Proc. of NAACL-HLT.

Andrew Finch, Lemao Liu, Xiaolin Wang, and Eiichiro
Sumita. 2015. Neural Network TransductionModels
in Transliteration Generation. In Proc. of the Fifth
Named Entity Workshop.

Andrew Finch, Lemao Liu, Xiaolin Wang, and Eiichiro
Sumita. 2016. Target-Bidirectional Neural Models
for Machine Transliteration. In Proc. of the Sixth
Named Entity Workshop.

Isao Goto, Naoto Kato, Noriyoshi Uratani, and Teru-
masa Ehara. 2003. Transliteration Considering Con-
text Information based on the Maximum Entropy
Method. In Proc. of MT-Summit IX, volume 125132.

Li Haizhou, Zhang Min, and Su Jian. 2004. A Joint
Source-Channel Model for Machine Transliteration.
In Proc. of ACL.

Ulf Hermjakob, Kevin Knight, and Hal Daumé III.
2008. Name Translation in Statistical Machine
Translation - Learning When to Transliterate. Proc.
of ACL-HLT.

Ann Irvine, Chris Callison-Burch, and Alexandre Kle-
mentiev. 2010. Transliterating from All Languages.
In Proc. of AMTA.

Kil Soon Jeong, Sung-Hyon Myaeng, Jae Sung Lee,
and K-S Choi. 1999. Automatic Identification and
Back-Transliteration of Foreign Words for Informa-
tion Retrieval. Information Processing & Manage-
ment, 35(4):523–540.

Sittichai Jiampojamarn, Aditya Bhargava, Qing Dou,
Kenneth Dwyer, and Grzegorz Kondrak. 2009.
DirecTL: A Language-Independent Approach to
Transliteration. In Proc. of the 2009 Named Entities
Workshop: Shared Task on Transliteration.

Sittichai Jiampojamarn, Kenneth Dwyer, Shane
Bergsma, Aditya Bhargava, Qing Dou, Mi-Young
Kim, and Grzegorz Kondrak. 2010. Transliteration
Generation and Mining with Limited Training
Resources. In Proc. of the 2010 Named Entities
Workshop.

Sittichai Jiampojamarn, Grzegorz Kondrak, and Tarek
Sherif. 2007. Applying Many-to-Many Alignments
and Hidden Markov Models to Letter-to-Phoneme
Conversion. In Proc. of NAACL.

Sarvnaz Karimi, Falk Scholer, and Andrew Turpin.
2011. Machine Transliteration Survey. ACM Com-
puting Surveys.

Sungchul Kim, Kristina Toutanova, and Hwanjo Yu.
2012. Multilingual Named Entity Recognition using
Parallel Data andMetadata fromWikipedia. In Proc.
of ACL.

Diederik Kingma and Jimmy Ba. 2014. Adam: A
Method for Stochastic Optimization. In Proc. of
ICLR.

Alex Klementiev and Dan Roth. 2008. Named Entity
Transliteration and Discovery in Multilingual Cor-
pora. In Learning Machine Translation. MIT Press.

Kevin Knight and Jonathan Graehl. 1998. Machine
Transliteration. volume 24, pages 599–612. MIT
Press.



511

Anoop Kunchukuttan, Mitesh Khapra, Gurneet Singh,
and Pushpak Bhattacharyya. 2018. Leveraging
Orthographic Similarity for Multilingual Neural
Transliteration. In Transactions of the Association
for Computational Linguistics, volume 6.

Ying Lin, Xiaoman Pan, Aliya Deri, Heng Ji, and Kevin
Knight. 2016. Leveraging Entity Linking and Re-
lated Language Projection to ImproveNameTranslit-
eration. In Proc. of the Sixth Named Entity Work-
shop.

Peter Makarov, Tatiana Ruzsics, and Simon Clematide.
2017. Align and Copy: UZH at SIGMORPHON
2017 Shared Task for Morphological Reinflection.
In Proc. of the CoNLL SIGMORPHON 2017 Shared
Task: Universal Morphological Reinflection.

David Matthews. 2007. Machine Transliteration of
Proper Names. Master’s Thesis, University of Ed-
inburgh, Edinburgh, United Kingdom.

Paul McNamee, James Mayfield, Dawn Lawrie, Dou-
glas W Oard, and David S Doermann. 2011. Cross-
Language Entity Linking. In Proc. of IJCNLP.

Yuval Merhav and Stephen Ash. 2018. Design Chal-
lenges in Named Entity Transliteration. In Proc. of
COLING.

Garrett Nicolai, Bradley Hauer, Mohammad Salameh,
Adam St Arnaud, Ying Xu, Lei Yao, and Grzegorz
Kondrak. 2015. Multiple System Combination for
Transliteration. In Proc. of the Fifth Named Entity
Workshop.

Jeff Pasternack and Dan Roth. 2009. Learning Better
Transliterations. In Proc. of CIKM.

Sujith Ravi and Kevin Knight. 2009. Learning
Phoneme Mappings for Transliteration without Par-
allel Data. In Proc. of NAACL-HLT.

Richard Sproat, Tao Tao, and ChengXiang Zhai. 2006.
Named Entity Transliteration with Comparable Cor-
pora. In Proc. of COLING-ACL.

Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014.
Sequence to Sequence Learning with Neural Net-
works. In Proc. of NIPS.

Chen-Tse Tsai and Dan Roth. 2016. Cross-lingual Wik-
ification Using Multilingual Embeddings. In Proc.
of NAACL.

Chen-Tse Tsai and Dan Roth. 2018. Learning Bet-
ter Name Translation for Cross-LingualWikification.
In Proc. of AAAI.

Shyam Upadhyay, Nitish Gupta, and Dan Roth. 2018.
Joint Multilingual Supervision for Cross-lingual En-
tity Linking. In Proc. of EMNLP.

Paola Virga and Sanjeev Khudanpur. 2003. Transliter-
ation of Proper Names in Cross-lingual Information
Retrieval. In Proc. of the Workshop on Multilingual
and Mixed-Language Named Entity Recognition.

Han Wang, Jin Guang Zheng, Xiaogang Ma, Peter Fox,
and Heng Ji. 2015. Language and Domain Indepen-
dent Entity Linking with Quantified Collective Vali-
dation. In Proc. of EMNLP.


