



















































Inferring Logical Forms From Denotations


Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 23–32,
Berlin, Germany, August 7-12, 2016. c©2016 Association for Computational Linguistics

Inferring Logical Forms From Denotations

Panupong Pasupat
Computer Science Department

Stanford University
ppasupat@cs.stanford.edu

Percy Liang
Computer Science Department

Stanford University
pliang@cs.stanford.edu

Abstract

A core problem in learning semantic
parsers from denotations is picking out
consistent logical forms—those that yield
the correct denotation—from a combina-
torially large space. To control the search
space, previous work relied on restricted
set of rules, which limits expressivity. In
this paper, we consider a much more ex-
pressive class of logical forms, and show
how to use dynamic programming to effi-
ciently represent the complete set of con-
sistent logical forms. Expressivity also
introduces many more spurious logical
forms which are consistent with the cor-
rect denotation but do not represent the
meaning of the utterance. To address
this, we generate fictitious worlds and use
crowdsourced denotations on these worlds
to filter out spurious logical forms. On
the WIKITABLEQUESTIONS dataset, we
increase the coverage of answerable ques-
tions from 53.5% to 76%, and the ad-
ditional crowdsourced supervision lets us
rule out 92.1% of spurious logical forms.

1 Introduction

Consider the task of learning to answer com-
plex natural language questions (e.g., “Where did
the last 1st place finish occur?”) using only
question-answer pairs as supervision (Clarke et
al., 2010; Liang et al., 2011; Berant et al.,
2013; Artzi and Zettlemoyer, 2013). Seman-
tic parsers map the question into a logical form
(e.g., R[Venue].argmax(Position.1st, Index))
that can be executed on a knowledge source to ob-
tain the answer (denotation). Logical forms are
very expressive since they can be recursively com-
posed, but this very expressivity makes it more

difficult to search over the space of logical forms.
Previous work sidesteps this obstacle by restrict-
ing the set of possible logical form compositions,
but this is limiting. For instance, for the system
in Pasupat and Liang (2015), in only 53.5% of the
examples was the correct logical form even in the
set of generated logical forms.

The goal of this paper is to solve two main chal-
lenges that prevent us from generating more ex-
pressive logical forms. The first challenge is com-
putational: the number of logical forms grows ex-
ponentially as their size increases. Directly enu-
merating over all logical forms becomes infeasi-
ble, and pruning techniques such as beam search
can inadvertently prune out correct logical forms.

The second challenge is the large increase in
spurious logical forms—those that do not reflect
the semantics of the question but coincidentally
execute to the correct denotation. For example,
while logical forms z1, . . . , z5 in Figure 1 are all
consistent (they execute to the correct answer y),
the logical forms z4 and z5 are spurious and would
give incorrect answers if the table were to change.

We address these two challenges by solving two
interconnected tasks. The first task, which ad-
dresses the computational challenge, is to enumer-
ate the set Z of all consistent logical forms given
a question x, a knowledge source w (“world”),
and the target denotation y (Section 4). Observ-
ing that the space of possible denotations grows
much more slowly than the space of logical forms,
we perform dynamic programming on denotations
(DPD) to make search feasible. Our method is
guaranteed to find all consistent logical forms up
to some bounded size.

Given the set Z of consistent logical forms, the
second task is to filter out spurious logical forms
from Z (Section 5). Using the property that spuri-
ous logical forms ultimately give a wrong answer
when the data in the world w changes, we create

23



Year Venue Position Event Time
2001 Hungary 2nd 400m 47.12
2003 Finland 1st 400m 46.69
2005 Germany 11th 400m 46.62
2007 Thailand 1st relay 182.05
2008 China 7th relay 180.32

x: “Where did the last 1st place finish occur?”
y: Thailand

Consistent
Correct

z1: R[Venue].argmax(Position.1st, Index)
Among rows with Position = 1st, pick the one with
maximum index, then return the Venue of that row.

z2: R[Venue].Index.max(R[Index].Position.1st)
Find the maximum index of rows with Position =
1st, then return the Venue of the row with that index.

z3: R[Venue].argmax(Position.Number.1,
R[λx.R[Date].R[Year].x])

Among rows with Position number 1, pick one with
latest date in the Year column and return the Venue.

Spurious
z4: R[Venue].argmax(Position.Number.1,

R[λx.R[Number].R[Time].x])

Among rows with Position number 1, pick the one
with maximum Time number. Return the Venue.

z5: R[Venue].Year.Number.(
R[Number].R[Year].argmax(Type.Row, Index)−1)

Subtract 1 from the Year in the last row, then return
the Venue of the row with that Year.

Inconsistent
z̃: R[Venue].argmin(Position.1st, Index)

Among rows with Position = 1st, pick the one with
minimum index, then return the Venue. (= Finland)

Figure 1: Six logical forms generated from the
question x. The first five are consistent: they ex-
ecute to the correct answer y. Of those, correct
logical forms z1, z2, and z3 are different ways to
represent the semantics of x, while spurious logi-
cal forms z4 and z5 get the right answer y for the
wrong reasons.

fictitious worlds to test the denotations of the logi-
cal forms in Z. We use crowdsourcing to annotate
the correct denotations on a subset of the gener-
ated worlds. To reduce the amount of annotation
needed, we choose the subset that maximizes the
expected information gain. The pruned set of log-
ical forms would provide a stronger supervision
signal for training a semantic parser.

We test our methods on the WIKITABLEQUES-
TIONS dataset of complex questions on Wikipedia
tables. We define a simple, general set of deduc-
tion rules (Section 3), and use DPD to confirm
that the rules generate a correct logical form in

...

r1 · · ·

1 Finland 1st

r2 · · ·

2 Germany 11th

r3 · · ·

3 Thailand 1st

...

1

11

1

Next

Next

Next

Next

Index

Index

Index

Venue Position

Venue Position

Venue Position

Number

Number

Number

z1 = R[Venue]. argmax( Position. 1st , Index)

Figure 2: The table in Figure 1 is converted into a
graph. The recursive execution of logical form z1
is shown via the different colors and styles.

76% of the examples, up from the 53.5% in Pa-
supat and Liang (2015). Moreover, unlike beam
search, DPD is guaranteed to find all consistent
logical forms up to a bounded size. Finally, by us-
ing annotated data on fictitious worlds, we are able
to prune out 92.1% of the spurious logical forms.

2 Setup

The overarching motivation of this work is allow-
ing people to ask questions involving computa-
tion on semi-structured knowledge sources such
as tables from the Web. This section introduces
how the knowledge source is represented, how the
computation is carried out using logical forms, and
our task of inferring correct logical forms.

Worlds. We use the term world to refer to a col-
lection of entities and relations between entities.
One way to represent a world w is as a directed
graph with nodes for entities and directed edges
for relations. (For example, a world about geog-
raphy would contain a node Europe with an edge
Contains to another node Germany.)

In this paper, we use data tables from the Web
as knowledge sources, such as the one in Figure 1.
We follow the construction in Pasupat and Liang
(2015) for converting a table into a directed graph
(see Figure 2). Rows and cells become nodes (e.g.,
r0 = first row and Finland) while columns be-
come labeled directed edges between them (e.g.,
Venue maps r1 to Finland). The graph is aug-
mented with additional edges Next (from each

24



row to the next) and Index (from each row to its
index number). In addition, we add normaliza-
tion edges to cell nodes, including Number (from
the cell to the first number in the cell), Num2 (the
second number), Date (interpretation as a date),
and Part (each list item if the cell represents a
list). For example, a cell with content “3-4” has
a Number edge to the integer 3, a Num2 edge to 4,
and a Date edge to XX-03-04.

Logical forms. We can perform computation on
a world w using a logical form z, a small program
that can be executed on the world, resulting in a
denotation JzKw.

We use lambda DCS (Liang, 2013) as the lan-
guage of logical forms. As a demonstration, we
will use z1 in Figure 2 as an example. The small-
est units of lambda DCS are entities (e.g., 1st) and
relations (e.g., Position). Larger logical forms
can be constructed using logical operations, and
the denotation of the new logical form can be com-
puted from denotations of its constituents. For ex-
ample, applying the join operation on Position
and 1st gives Position.1st, whose denotation
is the set of entities with relation Position point-
ing to 1st. With the world in Figure 2, the denota-
tion is JPosition.1stKw = {r1, r3}, which cor-
responds to the 2nd and 4th rows in the table. The
partial logical form Position.1st is then used
to construct argmax(Position.1st, Index), the
denotation of which can be computed by mapping
the entities in JPosition.1stKw = {r1, r3} us-
ing the relation Index ({r0 : 0, r1 : 1, . . . }), and
then picking the one with the largest mapped value
(r3, which is mapped to 3). The resulting logical
form is finally combined with R[Venue] with an-
other join operation. The relation R[Venue] is the
reverse of Venue, which corresponds to traversing
Venue edges in the reverse direction.

Semantic parsing. A semantic parser maps a
natural language utterance x (e.g., “Where did the
last 1st place finish occur?”) into a logical form z.
With denotations as supervision, a semantic parser
is trained to put high probability on z’s that are
consistent—logical forms that execute to the cor-
rect denotation y (e.g., Thailand). When the space
of logical forms is large, searching for consistent
logical forms z can become a challenge.

As illustrated in Figure 1, consistent logical
forms can be divided into two groups: correct log-
ical forms represent valid ways for computing the

answer, while spurious logical forms accidentally
get the right answer for the wrong reasons (e.g., z4
picks the row with the maximum time but gets the
correct answer anyway).

Tasks. Denote by Z and Zc the sets of all con-
sistent and correct logical forms, respectively. The
first task is to efficiently compute Z given an ut-
terance x, a world w, and the correct denotation y
(Section 4). With the set Z, the second task is to
infer Zc by pruning spurious logical forms from Z
(Section 5).

3 Deduction rules

The space of logical forms given an utterance x
and a world w is defined recursively by a set of de-
duction rules (Table 1). In this setting, each con-
structed logical form belongs to a category (Set,
Rel, or Map). These categories are used for type
checking in a similar fashion to categories in syn-
tactic parsing. Each deduction rule specifies the
categories of the arguments, category of the re-
sulting logical form, and how the logical form is
constructed from the arguments.

Deduction rules are divided into base rules and
compositional rules. A base rule follows one of
the following templates:

TokenSpan[span]→ c [f(span)] (1)
∅ → c [f()] (2)

A rule of Template 1 is triggered by a span of
tokens from x (e.g., to construct z1 in Figure 2
from x in Figure 1, Rule B1 from Table 1 con-
structs 1st of category Set from the phrase “1st”).
Meanwhile, a rule of Template 2 generates a log-
ical form without any trigger (e.g., Rule B5 gen-
erates Position of category Rel from the graph
edge Position without a specific trigger in x).

Compositional rules then construct larger logi-
cal forms from smaller ones:

c1 [z1] + c2 [z2]→ c [g(z1, z2)] (3)
c1 [z1]→ c [g(z1)] (4)

A rule of Template 3 combines partial logical
forms z1 and z2 of categories c1 and c2 into
g(z1, z2) of category c (e.g., Rule C1 uses 1st of
category Set and Position of category Rel to con-
struct Position.1st of category Set). Template 4
works similarly.

Most rules construct logical forms without re-
quiring a trigger from the utterance x. This is

25



Rule Semantics
Base Rules

B1 TokenSpan→ Set fuzzymatch(span)
(entity fuzzily matching the text: “chinese”→ China)

B2 TokenSpan→ Set val(span)
(interpreted value: “march 2015”→ 2015-03-XX)

B3 ∅ → Set Type.Row
(the set of all rows)

B4 ∅ → Set c ∈ ClosedClass
(any entity from a column with few unique entities)

(e.g., 400m or relay from the Event column)
B5 ∅ → Rel r ∈ GraphEdges

(any relation in the graph: Venue, Next, Num2, . . . )
B6 ∅ → Rel != | < | <= | > | >=

Compositional Rules
C1 Set + Rel→ Set z2.z1 | R[z2].z1

(R[z] is the reverse of z; i.e., flip the arrow direction)
C2 Set→ Set a(z1)

(a ∈ {count, max, min, sum, avg})
C3 Set + Set→ Set z1 u z2 | z1 t z2 | z1 − z2

(subtraction is only allowed on numbers)
Compositional Rules with Maps

Initialization
M1 Set→ Map (z1, x) (identity map)

Operations on Map
M2 Map + Rel→ Map (u1, z2.b1) | (u1,R[z2].b1)
M3 Map→ Map (u1, a(b1))

(a ∈ {count, max, min, sum, avg})
M4 Map + Set→ Map (u1, b1 u z2) | . . .
M5 Map + Map→ Map (u1, b1 u b2) | . . .

(Allowed only when u1 = u2)
(Rules M4 and M5 are repeated for t and −)

Finalization
M6 Map→ Set argmin(u1,R[λx.b1])

| argmax(u1,R[λx.b1])

Table 1: Deduction rules define the space of logi-
cal forms by specifying how partial logical forms
are constructed. The logical form of the i-th argu-
ment is denoted by zi (or (ui, bi) if the argument
is a Map). The set of final logical forms contains
any logical form with category Set.

crucial for generating implicit relations (e.g., gen-
erating Year from “what’s the venue in 2000?”
without a trigger “year”), and generating opera-
tions without a lexicon (e.g., generating argmax
from “where’s the longest competition”). How-
ever, the downside is that the space of possible
logical forms becomes very large.

The Map category. The technique in this paper
requires execution of partial logical forms. This
poses a challenge for argmin and argmax oper-
ations, which take a set and a binary relation as
arguments. The binary could be a complex func-
tion (e.g., in z3 from Figure 1). While it is possible
to build the binary independently from the set, ex-
ecuting a complex binary is sometimes impossible
(e.g., the denotation of λx.count(x) is impossible
to write explicitly without knowledge of x).

We address this challenge with the Map cat-
egory. A Map is a pair (u, b) of a finite set
u (unary) and a binary relation b. The deno-
tation of (u, b) is (JuKw, JbK′w) where the binaryJbK′w is JbKw with the domain restricted to the setJuKw. For example, consider the construction of
argmax(Position.1st, Index). After construct-
ing Position.1st with denotation {r1, r3}, Rule
M1 initializes (Position.1st, x) with denotation
({r1, r3}, {r1 : {r1}, r3 : {r3}}). Rule M2 is then
applied to generate (Position.1st,R[Index].x)
with denotation ({r1, r3}, {r1 : {1}, r3 : {3}}).
Finally, Rule M6 converts the Map into the desired
argmax logical form with denotation {r3}.

Generality of deduction rules. Using domain
knowledge, previous work restricted the space of
logical forms by manually defining the categories
c or the semantic functions f and g to fit the do-
main. For example, the category Set might be di-
vided into Records, Values, and Atomic when the
knowledge source is a table (Pasupat and Liang,
2015). Another example is when a compositional
rule g (e.g., sum(z1)) must be triggered by some
phrase in a lexicon (e.g., words like “total” that
align to sum in the training data). Such restrictions
make search more tractable but greatly limit the
scope of questions that can be answered.

Here, we have increased the coverage of logi-
cal forms by making the deduction rules simple
and general, essentially following the syntax of
lambda DCS. The base rules only generates en-
tities that approximately match the utterance, but
all possible relations, and all possible further com-
binations.

Beam search. Given the deduction rules, an ut-
terance x and a worldw, we would like to generate
all derived logical forms Z. We first present the
floating parser (Pasupat and Liang, 2015), which
uses beam search to generate Zb ⊆ Z, a usually
incomplete subset. Intuitively, the algorithm first
constructs base logical forms based on spans of
the utterance, and then builds larger logical forms
of increasing size in a “floating” fashion—without
requiring a trigger from the utterance.

Formally, partial logical forms with category c
and size s are stored in a cell (c, s). The algorithm
first generates base logical forms from base deduc-
tion rules and store them in cells (c, 0) (e.g., the
cell (Set, 0) contains 1st, Type.Row, and so on).
Then for each size s = 1, . . . , smax, we populate

26



· · ·

· · ·

· · ·

· · ·

· · ·

· · ·

· · ·

(Set , 7,

{Thailand})

(Set , 7,

{Finland})

Figure 3: The first pass of DPD constructs cells
(c, s, d) (square nodes) using denotationally in-
variant semantic functions (circle nodes). The sec-
ond pass enumerates all logical forms along paths
that lead to the correct denotation y (solid lines).

the cells (c, s) by applying compositional rules on
partial logical forms with size less than s. For in-
stance, when s = 2, we can apply Rule C1 on
logical forms Number.1 from cell (Set, s1 = 1)
and Position from cell (Rel, s2 = 0) to create
Position.Number.1 in cell (Set, s0+s1+1 = 2).
After populating each cell (c, s), the list of logi-
cal forms in the cell is pruned based on the model
scores to a fixed beam size in order to control the
search space. Finally, the set Zb is formed by
collecting logical forms from all cells (Set, s) for
s = 1, . . . , smax.

Due to the generality of our deduction rules, the
number of logical forms grows quickly as the size
s increases. As such, partial logical forms that
are essential for building the desired logical forms
might fall off the beam early on. In the next sec-
tion, we present a new search method that com-
presses the search space using denotations.

4 Dynamic programming on denotations

Our first step toward finding all correct logical
forms is to represent all consistent logical forms
(those that execute to the correct denotation). For-
mally, given x, w, and y, we wish to generate the
set Z of all logical forms z such that JzKw = y.

As mentioned in the previous section, beam
search does not recover the full set Z due to prun-
ing. Our key observation is that while the number
of logical forms explodes, the number of distinct
denotations of those logical forms is much more
controlled, as multiple logical forms can share the
same denotation. So instead of directly enumerat-
ing logical forms, we use dynamic programming
on denotations (DPD), which is inspired by sim-
ilar methods from program induction (Lau et al.,

2003; Liang et al., 2010; Gulwani, 2011).
The main idea of DPD is to collapse logical

forms with the same denotation together. Instead
of using cells (c, s) as in beam search, we per-
form dynamic programming using cells (c, s, d)
where d is a denotation. For instance, the logi-
cal form Position.Number.1 will now be stored
in cell (Set, 2, {r1, r3}).

For DPD to work, each deduction rule must
have a denotationally invariant semantic function
g, meaning that the denotation of the resulting log-
ical form g(z1, z2) only depends on the denota-
tions of z1 and z2:

Jz1Kw = Jz′1Kw ∧ Jz2Kw = Jz′2Kw
⇒ Jg(z1, z2)Kw = Jg(z′1, z′2)Kw

All of our deduction rules in Table 1 are de-
notationally invariant, but a rule that, for in-
stance, returns the argument with the larger log-
ical form size would not be. Applying a de-
notationally invariant deduction rule on any pair
of logical forms from (c1, s1, d1) and (c2, s2, d2)
always results in a logical form with the same
denotation d in the same cell (c, s1 + s2 +
1, d).1 (For example, the cell (Set, 4, {r3}) con-
tains z1 := argmax(Position.1st, Index) and
z′1 := argmin(Event.Relay, Index). Combin-
ing each of these with Venue using Rule C1 gives
R[Venue].z1 and R[Venue].z′1, which belong to
the same cell (Set, 5, {Thailand})).
Algorithm. DPD proceeds in two forward
passes. The first pass finds the possible combi-
nations of cells (c, s, d) that lead to the correct de-
notation y, while the second pass enumerates the
logical forms in the cells found in the first pass.
Figure 3 illustrates the DPD algorithm.

In the first pass, we are only concerned about
finding relevant cell combinations and not the ac-
tual logical forms. Therefore, any logical form
that belongs to a cell could be used as an argu-
ment of a deduction rule to generate further logical
forms. Thus, we keep at most one logical form per
cell; subsequent logical forms that are generated
for that cell are discarded.

After populating all cells up to size smax, we
list all cells (Set, s, y) with the correct denotation
y, and then note all possible rule combinations
(cell1, rule) or (cell1, cell2, rule) that lead to those

1Semantic functions f with one argument work similarly.

27



final cells, including the combinations that yielded
discarded logical forms.

The second pass retrieves the actual logical
forms that yield the correct denotation. To do this,
we simply populate the cells (c, s, d) with all log-
ical forms, using only rule combinations that lead
to final cells. This elimination of irrelevant rule
combinations effectively reduces the search space.
(In Section 6.2, we empirically show that the num-
ber of cells considered is reduced by 98.7%.)

The parsing chart is represented as a hyper-
graph as in Figure 3. After eliminating unused
rule combinations, each of the remaining hyper-
paths from base predicates to the target denotation
corresponds to a single logical form. making the
remaining parsing chart a compact implicit repre-
sentation of all consistent logical forms. This rep-
resentation is guaranteed to cover all possible log-
ical forms under the size limit smax that can be
constructed by the deduction rules.

In our experiments, we apply DPD on the de-
duction rules in Table 1 and explicitly enumerate
the logical forms produced by the second pass. For
efficiency, we prune logical forms that are clearly
redundant (e.g., applying max on a set of size 1).
We also restrict a few rules that might otherwise
create too many denotations. For example, we re-
stricted the union operation (t) except unions of
two entities (e.g., we allow Germany t Finland
but not Venue.Hungary t . . . ), subtraction when
building a Map, and count on a set of size 1.2

5 Fictitious worlds

After finding the set Z of all consistent logical
forms, we want to filter out spurious logical forms.
To do so, we observe that semantically correct log-
ical forms should also give the correct denotation
in worlds w′ other than than w. In contrast, spu-
rious logical forms will fail to produce the correct
denotation on some other world.

Generating fictitious worlds. With the ob-
servation above, we generate fictitious worlds
w1, w2, . . . , where each world wi is a slight alter-
ation of w. As we will be executing logical forms
z ∈ Z on wi, we should ensure that all entities and
relations in z ∈ Z appear in the fictitious world wi
(e.g., z1 in Figure 1 would be meaningless if the
entity 1st does not appear in wi). To this end, we

2While we technically can apply count on sets of size 1,
the number of spurious logical forms explodes as there are
too many sets of size 1 generated.

Year Venue Position Event Time
2001 Finland 7th relay 46.62
2003 Germany 1st 400m 180.32
2005 China 1st relay 47.12
2007 Hungary 7th relay 182.05

Figure 4: From the example in Figure 1, we gen-
erate a table for the fictitious world w1.

w w1 w2 · · ·
z1 Thailand China Finland · · ·}

q1z2 Thailand China Finland · · ·
z3 Thailand China Finland · · ·
z4 Thailand Germany China · · · } q2
z5 Thailand China China · · · } q3z6 Thailand China China · · ·
...

...
...

...

Figure 5: We execute consistent logical forms
zi ∈ Z on fictitious worlds to get denotation tu-
ples. Logical forms with the same denotation tuple
are grouped into the same equivalence class qj .

impose that all predicates present in the original
world w should also be present in wi as well.

In our case where the world w comes from a
data table t, we construct wi from a new table ti as
follows: we go through each column of t and re-
sample the cells in that column. The cells are sam-
pled using random draws without replacement if
the original cells are all distinct, and with replace-
ment otherwise. Sorted columns are kept sorted.
To ensure that predicates in w exist in wi, we use
the same set of table columns and enforce that any
entity fuzzily matching a span in the question x
must be present in ti (e.g., for the example in Fig-
ure 1, the generated ti must contain “1st”). Fig-
ure 4 shows an example fictitious table generated
from the table in Figure 1.

Fictitious worlds are similar to test suites for
computer programs. However, unlike manually
designed test suites, we do not yet know the cor-
rect answer for each fictitious world or whether a
world is helpful for filtering out spurious logical
forms. The next subsections introduce our method
for choosing a subset of useful fictitious worlds to
be annotated.

Equivalence classes. Let W = (w1, . . . , wk) be
the list of all possible fictitious worlds. For each
z ∈ Z, we define the denotation tuple JzKW =
(JzKw1 , . . . , JzKwk). We observe that some logi-
cal forms produce the same denotation across all

28



fictitious worlds. This may be due to an algebraic
equivalence in logical forms (e.g., z1 and z2 in Fig-
ure 1) or due to the constraints in the construction
of fictitious worlds (e.g., z1 and z3 in Figure 1 are
equivalent as long as the Year column is sorted).
We group logical forms into equivalence classes
based on their denotation tuples, as illustrated in
Figure 5. When the question is unambiguous, we
expect at most one equivalence class to contain
correct logical forms.

Annotation. To pin down the correct equiva-
lence class, we acquire the correct answers to the
question x on some subset W ′ = (w′1, . . . , w′`) ⊆
W of ` fictitious worlds, as it is impractical to ob-
tain annotations on all fictitious worlds in W . We
compile equivalence classes that agree with the an-
notations into a set Zc of correct logical forms.

We want to choose W ′ that gives us the most
information about the correct equivalence class as
possible. This is analogous to standard practices
in active learning (Settles, 2010).3 Let Q be the
set of all equivalence classes q, and let JqKW ′ be
the denotation tuple computed by executing an ar-
bitrary z ∈ q on W ′. The subset W ′ divides Q
into partitions Ft = {q ∈ Q : JqKW ′ = t} based
on the denotation tuples t (e.g., from Figure 5, if
W ′ contains just w2, then q2 and q3 will be in the
same partition F(China)). The annotation t∗, which
is also a denotation tuple, will mark one of these
partitions Ft∗ as correct. Thus, to prune out many
spurious equivalence classes, the partitions should
be as numerous and as small as possible.

More formally, we choose a subset W ′ that
maximizes the expected information gain (or
equivalently, the reduction in entropy) about
the correct equivalence class given the annota-
tion. With random variables Q ∈ Q represent-
ing the correct equivalence class and T ∗W ′ for
the annotation on worlds W ′, we seek to find
arg minW ′ H(Q | T ∗W ′). Assuming a uniform
prior on Q (p(q) = 1/|Q|) and accurate annota-
tion (p(t∗ | q) = I[q ∈ Ft∗ ]):

H(Q | T ∗W ′) =
∑
q,t

p(q, t) log
p(t)
p(q, t)

=
1
|Q|

∑
t

|Ft| log |Ft|. (*)

3The difference is that we are obtaining partial informa-
tion about an individual example rather than partial informa-
tion about the parameters.

We exhaustively search for W ′ that minimizes
(*). The objective value follows our intuition since∑

t |Ft| log |Ft| is small when the terms |Ft| are
small and numerous.

In our experiments, we approximate the full
set W of fictitious worlds by generating k =
30 worlds to compute equivalence classes. We
choose a subset of ` = 5 worlds to be annotated.

6 Experiments

For the experiments, we use the training portion
of the WIKITABLEQUESTIONS dataset (Pasupat
and Liang, 2015), which consists of 14,152 ques-
tions on 1,679 Wikipedia tables gathered by crowd
workers. Answering these complex questions re-
quires different types of operations. The same
operation can be phrased in different ways (e.g.,
“best”, “top ranking”, or “lowest ranking num-
ber”) and the interpretation of some phrases de-
pend on the context (e.g., “number of ” could be
a table lookup or a count operation). The lexical
content of the questions is also quite diverse: even
excluding numbers and symbols, the 14,152 train-
ing examples contain 9,671 unique words, only
10% of which appear more than 10 times.

We attempted to manually annotate the first 300
examples with lambda DCS logical forms. We
successfully constructed correct logical forms for
84% of these examples, which is a good number
considering the questions were created by humans
who could use the table however they wanted. The
remaining 16% reflect limitations in our setup—
for example, non-canonical table layouts, answers
appearing in running text or images, and com-
mon sense reasoning (e.g., knowing that “Quarter-
final” is better than “Round of 16”).

6.1 Generality of deduction rules

We compare our set of deduction rules with the
one given in Pasupat and Liang (2015) (hence-
forth PL15). PL15 reported generating the anno-
tated logical form in 53.5% of the first 200 exam-
ples. With our more general deduction rules, we
use DPD to verify that the rules are able to gener-
ate the annotated logical form in 76% of the first
300 examples, within the logical form size limit
smax of 7. This is 90.5% of the examples that were
successfully annotated. Figure 6 shows some ex-
amples of logical forms we cover that PL15 could
not. Since DPD is guaranteed to find all consis-
tent logical forms, we can be sure that the logical

29



“which opponent has the most wins”
z = argmax(R[Opponent].Type.Row,

R[λx.count(Opponent.x u Result.Lost])
“how long did ian armstrong serve?”
z = R[Num2].R[Term].Member.IanArmstrong

−R[Number].R[Term].Member.IanArmstrong
“which players came in a place before lukas bauer?”
z = R[Name].Index.<.R[Index].Name.LukasBauer

“which players played the same position as ardo kreek?”
z = R[Player].Position.R[Position].Player.Ardo

u !=.Ardo
Figure 6: Several example logical forms our sys-
tem can generated that are not covered by the de-
duction rules from the previous work PL15.

forms not covered are due to limitations of the de-
duction rules. Indeed, the remaining examples ei-
ther have logical forms with size larger than 7 or
require other operations such as addition, union of
arbitrary sets, etc.

6.2 Dynamic programming on denotations
Search space. To demonstrate the savings
gained by collapsing logical forms with the same
denotation, we track the growth of the number of
unique logical forms and denotations as the log-
ical form size increases. The plot in Figure 7
shows that the space of logical forms explodes
much more quickly than the space of denotations.

The use of denotations also saves us from con-
sidering a significant amount of irrelevant partial
logical forms. On average over 14,152 training
examples, DPD generates approximately 25,000
consistent logical forms. The first pass of DPD
generates ≈ 153,000 cells (c, s, d), while the sec-
ond pass generates only ≈ 2,000 cells resulting
from ≈ 8,000 rule combinations, resulting in a
98.7% reduction in the number of cells that have
to be considered.

Comparison with beam search. We compare
DPD to beam search on the ability to generate (but
not rank) the annotated logical forms. We consider
two settings: when the beam search parameters
are uninitialized (i.e., the beams are pruned ran-
domly), and when the parameters are trained using
the system from PL15 (i.e., the beams are pruned
based on model scores). The plot in Figure 8
shows that DPD generates more annotated logical
forms (76%) compared to beam search (53.7%),
even when beam search is guided heuristically by
learned parameters. Note that DPD is an exact al-
gorithm and does not require a heuristic.

0 1 2 3 4 5 6 7

logical form size

0

0.2K

0.4K

0.6K

0.8K

1.0K

co
u
n
t

logical forms

denotations

Figure 7: The median of the number of logical
forms (dashed) and denotations (solid) as the for-
mula size increases. The space of logical forms
grows much faster than the space of denotations.

0 5000 10000 15000 20000 25000

number of final LFs produced

0.0

0.2

0.4

0.6

0.8

an
n
ot

at
ed

L
F

s
co

v
er

ag
e

?

Figure 8: The number of annotated logical forms
that can be generated by beam search, both unini-
tialized (dashed) and initialized (solid), increases
with the number of candidates generated (con-
trolled by beam size), but lacks behind DPD (star).

6.3 Fictitious worlds

We now explore how fictitious worlds divide the
set of logical forms into equivalence classes, and
how the annotated denotations on the chosen
worlds help us prune spurious logical forms.

Equivalence classes. Using 30 fictitious worlds
per example, we produce an average of 1,237
equivalence classes. One possible concern with
using a limited number of fictitious worlds is that
we may fail to distinguish some pairs of non-
equivalent logical forms. We verify the equiva-
lence classes against the ones computed using 300
fictitious worlds. We found that only 5% of the
logical forms are split from the original equiva-
lence classes.

Ideal Annotation. After computing equivalence
classes, we choose a subset W ′ of 5 fictitious
worlds to be annotated based on the information-
theoretic objective. For each of the 252 exam-
ples with an annotated logical form z∗, we use
the denotation tuple t∗ = Jz∗KW ′ as the annotated
answers on the chosen fictitious worlds. We are
able to rule out 98.7% of the spurious equivalence
classes and 98.3% of spurious logical forms. Fur-
thermore, we are able to filter down to just one
equivalence class in 32.7% of the examples, and

30



at most three equivalence classes in 51.3% of the
examples. If we choose 5 fictitious worlds ran-
domly instead of maximizing information gain,
then the above statistics are 22.6% and 36.5%,
respectively. When more than one equivalence
classes remain, usually only one class is a dom-
inant class with many equivalent logical forms,
while other classes are small and contain logical
forms with unusual patterns (e.g., z5 in Figure 1).

The average size of the correct equivalence
class is ≈ 3,000 with the standard deviation of
≈ 8,000. Because we have an expressive logical
language, there are fundamentally many equiva-
lent ways of computing the same quantity.

Crowdsourced Annotation. Data from crowd-
sourcing is more susceptible to errors. From the
252 annotated examples, we use 177 examples
where at least two crowd workers agree on the an-
swer of the original world w. When the crowd-
sourced data is used to rule out spurious logical
forms, the entire set Z of consistent logical forms
is pruned out in 11.3% of the examples, and the
correct equivalent class is removed in 9% of the
examples. These issues are due to annotation er-
rors, inconsistent data (e.g., having date of death
before birth date), and different interpretations of
the question on the fictitious worlds. For the re-
maining examples, we are able to prune out 92.1%
of spurious logical forms (or 92.6% of spurious
equivalence classes).

To prevent the entire Z from being pruned, we
can relax our assumption and keep logical forms
z that disagree with the annotation in at most 1
fictitious world. The number of times Z is pruned
out is reduced to 3%, but the number of spurious
logical forms pruned also decreases to 78%.

7 Related Work and Discussion

This work evolved from a long tradition of learn-
ing executable semantic parsers, initially from an-
notated logical forms (Zelle and Mooney, 1996;
Kate et al., 2005; Zettlemoyer and Collins, 2005;
Zettlemoyer and Collins, 2007; Kwiatkowski et
al., 2010), but more recently from denotations
(Clarke et al., 2010; Liang et al., 2011; Berant
et al., 2013; Kwiatkowski et al., 2013; Pasupat
and Liang, 2015). A central challenge in learn-
ing from denotations is finding consistent logical
forms (those that execute to a given denotation).

As Kwiatkowski et al. (2013) and Berant
and Liang (2014) both noted, a chief difficulty

with executable semantic parsing is the “schema
mismatch”—words in the utterance do not map
cleanly onto the predicates in the logical form.
This mismatch is especially pronounced in the
WIKITABLEQUESTIONS of Pasupat and Liang
(2015). In the second example of Figure 6, “how
long” is realized by a logical form that computes
a difference between two dates. The ramification
of this mismatch is that finding consistent logi-
cal forms cannot solely proceed from the language
side. This paper is about using annotated denota-
tions to drive the search over logical forms.

This takes us into the realm of program in-
duction, where the goal is to infer a program
(logical form) from input-output pairs (for us,
world-denotation pairs). Here, previous work
has also leveraged the idea of dynamic program-
ming on denotations (Lau et al., 2003; Liang et
al., 2010; Gulwani, 2011), though for more con-
strained spaces of programs. Continuing the pro-
gram analogy, generating fictitious worlds is simi-
lar in spirit to fuzz testing for generating new test
cases (Miller et al., 1990), but the goal there is
coverage in a single program rather than identi-
fying the correct (equivalence class of) programs.
This connection can potentially improve the flow
of ideas between the two fields.

Finally, the effectiveness of dynamic program-
ming on denotations relies on having a manage-
able set of denotations. For more complex logi-
cal forms and larger knowledge graphs, there are
many possible angles worth exploring: performing
abstract interpretation to collapse denotations into
equivalence classes (Cousot and Cousot, 1977),
relaxing the notion of getting the correct denota-
tion (Steinhardt and Liang, 2015), or working in a
continuous space and relying on gradient descent
(Guu et al., 2015; Neelakantan et al., 2016; Yin et
al., 2016; Reed and de Freitas, 2016). This paper,
by virtue of exact dynamic programming, sets the
standard.

Acknowledgments. We gratefully acknowledge
the support of the Google Natural Language Un-
derstanding Focused Program. In addition, we
would like to thank anonymous reviewers for their
helpful comments.

Reproducibility. Code and experiments for
this paper are available on the CodaLab platform
at https://worksheets.codalab.org/worksheets/
0x47cc64d9c8ba4a878807c7c35bb22a42/.

31



References
Y. Artzi and L. Zettlemoyer. 2013. UW SPF: The Uni-

versity of Washington semantic parsing framework.
arXiv preprint arXiv:1311.3011.

J. Berant and P. Liang. 2014. Semantic parsing via
paraphrasing. In Association for Computational
Linguistics (ACL).

J. Berant, A. Chou, R. Frostig, and P. Liang. 2013.
Semantic parsing on Freebase from question-answer
pairs. In Empirical Methods in Natural Language
Processing (EMNLP).

J. Clarke, D. Goldwasser, M. Chang, and D. Roth.
2010. Driving semantic parsing from the world’s re-
sponse. In Computational Natural Language Learn-
ing (CoNLL), pages 18–27.

P. Cousot and R. Cousot. 1977. Abstract interpreta-
tion: a unified lattice model for static analysis of
programs by construction or approximation of fix-
points. In Principles of Programming Languages
(POPL), pages 238–252.

S. Gulwani. 2011. Automating string processing in
spreadsheets using input-output examples. ACM
SIGPLAN Notices, 46(1):317–330.

K. Guu, J. Miller, and P. Liang. 2015. Travers-
ing knowledge graphs in vector space. In Em-
pirical Methods in Natural Language Processing
(EMNLP).

R. J. Kate, Y. W. Wong, and R. J. Mooney. 2005.
Learning to transform natural to formal languages.
In Association for the Advancement of Artificial In-
telligence (AAAI), pages 1062–1068.

T. Kwiatkowski, L. Zettlemoyer, S. Goldwater, and
M. Steedman. 2010. Inducing probabilistic CCG
grammars from logical form with higher-order uni-
fication. In Empirical Methods in Natural Language
Processing (EMNLP), pages 1223–1233.

T. Kwiatkowski, E. Choi, Y. Artzi, and L. Zettlemoyer.
2013. Scaling semantic parsers with on-the-fly on-
tology matching. In Empirical Methods in Natural
Language Processing (EMNLP).

T. Lau, S. Wolfman, P. Domingos, and D. S. Weld.
2003. Programming by demonstration using version
space algebra. Machine Learning, 53:111–156.

P. Liang, M. I. Jordan, and D. Klein. 2010. Learn-
ing programs: A hierarchical Bayesian approach.
In International Conference on Machine Learning
(ICML), pages 639–646.

P. Liang, M. I. Jordan, and D. Klein. 2011. Learn-
ing dependency-based compositional semantics. In
Association for Computational Linguistics (ACL),
pages 590–599.

P. Liang. 2013. Lambda dependency-based composi-
tional semantics. arXiv.

B. P. Miller, L. Fredriksen, and B. So. 1990. An empir-
ical study of the reliability of UNIX utilities. Com-
munications of the ACM, 33(12):32–44.

A. Neelakantan, Q. V. Le, and I. Sutskever. 2016.
Neural programmer: Inducing latent programs with
gradient descent. In International Conference on
Learning Representations (ICLR).

P. Pasupat and P. Liang. 2015. Compositional semantic
parsing on semi-structured tables. In Association for
Computational Linguistics (ACL).

S. Reed and N. de Freitas. 2016. Neural programmer-
interpreters. In International Conference on Learn-
ing Representations (ICLR).

B. Settles. 2010. Active learning literature survey.
Technical report, University of Wisconsin, Madison.

J. Steinhardt and P. Liang. 2015. Learning with re-
laxed supervision. In Advances in Neural Informa-
tion Processing Systems (NIPS).

P. Yin, Z. Lu, H. Li, and B. Kao. 2016. Neural en-
quirer: Learning to query tables with natural lan-
guage. arXiv.

M. Zelle and R. J. Mooney. 1996. Learning to
parse database queries using inductive logic pro-
gramming. In Association for the Advancement of
Artificial Intelligence (AAAI), pages 1050–1055.

L. S. Zettlemoyer and M. Collins. 2005. Learning to
map sentences to logical form: Structured classifica-
tion with probabilistic categorial grammars. In Un-
certainty in Artificial Intelligence (UAI), pages 658–
666.

L. S. Zettlemoyer and M. Collins. 2007. Online learn-
ing of relaxed CCG grammars for parsing to log-
ical form. In Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning (EMNLP/CoNLL), pages 678–687.

32


