



















































Latent Predictor Networks for Code Generation


Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 599–609,
Berlin, Germany, August 7-12, 2016. c©2016 Association for Computational Linguistics

Latent Predictor Networks for Code Generation

Wang Ling♦ Edward Grefenstette♦ Karl Moritz Hermann♦
Tomáš Kočiský♦♣ Andrew Senior♦ Fumin Wang♦ Phil Blunsom♦♣

♦Google DeepMind ♣University of Oxford
{lingwang,etg,kmh,tkocisky,andrewsenior,awaw,pblunsom}@google.com

Abstract

Many language generation tasks require
the production of text conditioned on both
structured and unstructured inputs. We
present a novel neural network architec-
ture which generates an output sequence
conditioned on an arbitrary number of in-
put functions. Crucially, our approach
allows both the choice of conditioning
context and the granularity of generation,
for example characters or tokens, to be
marginalised, thus permitting scalable and
effective training. Using this framework,
we address the problem of generating pro-
gramming code from a mixed natural lan-
guage and structured specification. We
create two new data sets for this paradigm
derived from the collectible trading card
games Magic the Gathering and Hearth-
stone. On these, and a third preexisting
corpus, we demonstrate that marginalis-
ing multiple predictors allows our model
to outperform strong benchmarks.

1 Introduction

The generation of both natural and formal lan-
guages often requires models conditioned on di-
verse predictors (Koehn et al., 2007; Wong and
Mooney, 2006). Most models take the restrictive
approach of employing a single predictor, such as
a word softmax, to predict all tokens of the output
sequence. To illustrate its limitation, suppose we
wish to generate the answer to the question “Who
wrote The Foundation?” as “The Foundation was
written by Isaac Asimov”. The generation of the
words “Issac Asimov” and “The Foundation” from
a word softmax trained on annotated data is un-
likely to succeed as these words are sparse. A ro-
bust model might, for example, employ one pre-

Figure 1: Example MTG and HS cards.

dictor to copy “The Foundation” from the input,
and a another one to find the answer “Issac Asi-
mov” by searching through a database. However,
training multiple predictors is in itself a challeng-
ing task, as no annotation exists regarding the pre-
dictor used to generate each output token. Fur-
thermore, predictors generate segments of differ-
ent granularity, as database queries can generate
multiple tokens while a word softmax generates
a single token. In this work we introduce Latent
Predictor Networks (LPNs), a novel neural archi-
tecture that fulfills these desiderata: at the core
of the architecture is the exact computation of the
marginal likelihood over latent predictors and gen-
erated segments allowing for scalable training.

We introduce a new corpus for the automatic
generation of code for cards in Trading Card
Games (TCGs), on which we validate our model 1.
TCGs, such as Magic the Gathering (MTG) and
Hearthstone (HS), are games played between two
players that build decks from an ever expanding
pool of cards. Examples of such cards are shown
in Figure 1. Each card is identified by its attributes

1Dataset available at https://deepmind.com/publications.html

599



(e.g., name and cost) and has an effect that is de-
scribed in a text box. Digital implementations of
these games implement the game logic, which in-
cludes the card effects. This is attractive from
a data extraction perspective as not only are the
data annotations naturally generated, but we can
also view the card as a specification communi-
cated from a designer to a software engineer.

This dataset presents additional challenges to
prior work in code generation (Wong and Mooney,
2006; Jones et al., 2012; Lei et al., 2013; Artzi
et al., 2015; Quirk et al., 2015), including the
handling of structured input—i.e. cards are com-
posed by multiple sequences (e.g., name and
description)—and attributes (e.g., attack and cost),
and the length of the generated sequences. Thus,
we propose an extension to attention-based neu-
ral models (Bahdanau et al., 2014) to attend over
structured inputs. Finally, we propose a code com-
pression method to reduce the size of the code
without impacting the quality of the predictions.

Experiments performed on our new datasets,
and a further pre-existing one, suggest that our ex-
tensions outperform strong benchmarks.

The paper is structured as follows: We first
describe the data collection process (Section 2)
and formally define our problem and our base-
line method (Section 3). Then, we propose our
extensions, namely, the structured attention mech-
anism (Section 4) and the LPN architecture (Sec-
tion 5). We follow with the description of our code
compression algorithm (Section 6). Our model
is validated by comparing with multiple bench-
marks (Section 7). Finally, we contextualize our
findings with related work (Section 8) and present
the conclusions of this work (Section 9).

2 Dataset Extraction

We obtain data from open source implementations
of two different TCGs, MTG in Java2 and HS in
Python.3 The statistics of the corpora are illus-
trated in Table 1. In both corpora, each card is im-
plemented in a separate class file, which we strip
of imports and comments. We categorize the con-
tent of each card into two different groups: sin-
gular fields that contain only one value; and text
fields, which contain multiple words representing
different units of meaning. In MTG, there are six
singular fields (attack, defense, rarity, set, id, and

2github.com/magefree/mage/
3github.com/danielyule/hearthbreaker/

MTG HS

Programming Language Java Python

Cards 13,297 665
Cards (Train) 11,969 533
Cards (Validation) 664 66
Cards (Test) 664 66

Singular Fields 6 4
Text Fields 8 2

Words In Description (Average) 21 7
Characters In Code (Average) 1,080 352

Table 1: Statistics of the two TCG datasets.

health) and four text fields (cost, type, name, and
description), whereas HS cards have eight singu-
lar fields (attack, health, cost and durability, rar-
ity, type, race and class) and two text fields (name
and description). Text fields are tokenized by
splitting on whitespace and punctuation, with ex-
ceptions accounting for domain specific artifacts
(e.g., Green mana is described as “{G}” in MTG).
Empty fields are replaced with a “NIL” token.

The code for the HS card in Figure 1 is shown
in Figure 2. The effect of “drawing cards until the
player has as many cards as the opponent” is im-
plemented by computing the difference between
the players’ hands and invoking the draw method
that number of times. This illustrates that the map-
ping between the description and the code is non-
linear, as no information is given in the text regard-
ing the specifics of the implementation.

class DivineFavor(SpellCard):
def __init__(self):

super().__init__("Divine Favor", 3,
CHARACTER_CLASS.PALADIN, CARD_RARITY.RARE)

def use(self, player, game):
super().use(player, game)
difference = len(game.other_player.hand)
- len(player.hand)
for i in range(0, difference):

player.draw()

Figure 2: Code for the HS card “Divine Favor”.

3 Problem Definition

Given the description of a card x, our decoding
problem is to find the code ŷ so that:

ŷ = argmax
y

logP (y | x) (1)

Here logP (y | x) is estimated by a given model.
We define y = y1..y|y| as the sequence of char-
acters of the code with length |y|. We index each
input field with k = 1..|x|, where |x| quantifies the

600



number of input fields. |xk| denotes the number of
tokens in xk and xki selects the i-th token.

4 Structured Attention

Background When |x| = 1, the atten-
tion model of Bahdanau et al. (2014) ap-
plies. Following the chain rule, logP (y|x) =∑

t=1..|y| logP (yt|y1..yt−1, x), each token yt is
predicted conditioned on the previously gener-
ated sequence y1..yt−1 and input sequence x1 =
x11..x1|x1|. Probability are estimated with a soft-
max over the vocabulary Y :

p(yt|y1..yt−1, x1) = softmax
yt∈Y

(ht) (2)

where ht is the Recurrent Neural Network (RNN)
state at time stamp t, which is modeled as
g(yt−1,ht−1, zt). g(·) is a recurrent update func-
tion for generating the new state ht based on
the previous token yt−1, the previous state ht−1,
and the input text representation zt. We imple-
ment g using a Long Short-Term Memory (LSTM)
RNNs (Hochreiter and Schmidhuber, 1997).

The attention mechanism generates the repre-
sentation of the input sequence x = x11..x1|x1|,
and zt is computed as the weighted sum zt =∑

i=1..|x1| aih(x1i), where ai is the attention co-
efficient obtained for token x1i and h is a func-
tion that maps each x1i to a continuous vector. In
general, h is a function that projects x1i by learn-
ing a lookup table, and then embedding contex-
tual words by defining an RNN. Coefficients ai
are computed with a softmax over input tokens
x11..x1|x1|:

ai = softmax
x1i∈x

(v(h(x1i),ht−1)) (3)

Function v computes the affinity of each token x1i
and the current output context ht−1. A common
implementation of v is to apply a linear projection
from h(x1i) : ht−1 (where : is the concatenation
operation) into a fixed size vector, followed by a
tanh and another linear projection.

Our Approach We extend the computation of
zt for cases when x corresponds to multiple fields.
Figure 3 illustrates how the MTG card “Serra An-
gel” is encoded, assuming that there are two singu-
lar fields and one text field. We first encode each
token xki using the C2W model described in Ling
et al. (2015), which is a replacement for lookup ta-
bles where word representations are learned at the

Figure 3: Illustration of the structured attention
mechanism operating on a single time stamp t.

character level (cf. C2W row). A context-aware
representation is built for words in the text fields
using a bidirectional LSTM (cf. Bi-LSTM row).
Computing attention over multiple input fields is
problematic as each input field’s vectors have dif-
ferent sizes and value ranges. Thus, we learn a
linear projection mapping each input token xki to
a vector with a common dimensionality and value
range (cf. Linear row). Denoting this process as
f(xki), we extend Equation 3 as:

aki = softmax
xki∈x

(v(f(xki),ht−1)) (4)

Here a scalar coefficient aki is computed for each
input token xki (cf. “Tanh”, “Linear”, and “Soft-
max” rows). Thus, the overall input representation
zt is computed as:

zt =
∑

k=1..|x|,i=1..|xk|
aijf(xki) (5)

5 Latent Predictor Networks

Background In order to decode from x to y,
many words must be copied into the code, such
as the name of the card, the attack and the cost
values. If we observe the HS card in Figure 1
and the respective code in Figure 2, we observe
that the name “Divine Favor” must be copied into
the class name and in the constructor, along with
the cost of the card “3”. As explained earlier,
this problem is not specific to our task: for in-
stance, in the dataset of Oda et al. (2015), a model
must learn to map from timeout = int (
timeout ) to “convert timeout into an integer.”,
where the name of the variable “timeout” must
be copied into the output sequence. The same is-
sue exists for proper nouns in machine translation

601



Figure 4: Generation process for the code init(‘Tirion Fordring’,8,6,6) using LPNs.

which are typically copied from one language to
the other. Pointer networks (Vinyals et al., 2015)
address this by defining a probability distribution
over a set of units that can be copied c = c1..c|c|.
The probability of copying a unit ci is modeled as:

p(ci) = softmax
ci∈c

(v(h(ci),q)) (6)

As in the attention model (Equation 3), v is a func-
tion that computes the affinity between an embed-
ded copyable unit h(ci) and an arbitrary vector q.

Our Approach Combining pointer networks
with a character-based softmax is in itself difficult
as these generate segments of different granularity
and there is no ground truth of which predictor to
use at each time stamp. We now describe Latent
Predictor Networks, which model the conditional
probability logP (y|x) over the latent sequence of
predictors used to generate y.

We assume that our model uses multiple pre-
dictors r ∈ R, where each r can generate
multiple segments st = yt..yt+|st|−1 with ar-
bitrary length |st| at time stamp t. An ex-
ample is illustrated in Figure 4, where we ob-
serve that to generate the code init(‘Tirion
Fordring’,8,6,6), a pointer network can
be used to generate the sequences y137 =Tirion
and y2214=Fordring (cf. “Copy From Name”
row). These sequences can also be generated us-
ing a character softmax (cf. “Generate Characters”

row). The same applies to the generation of the
attack, health and cost values as each of these pre-
dictors is an element inR. Thus, we define our ob-
jective function as a marginal log likelihood func-
tion over a latent variable ω:

logP (y | x) = log
∑
ω∈ω̄

P (y, ω | x) (7)

Formally, ω is a sequence of pairs rt, st, where
rt ∈ R denotes the predictor that is used at time-
stamp t and st the generated string. We decom-
pose P (y, ω | x) as the product of the probabilities
of segments st and predictors rt:

P (y, ω | x) =
∏

rt,st∈ω
P (st, rt | y1..yt−1, x) =∏

rt,st∈ω
P (st | y1..yt−1, x, rt)P (rt | y1..yt−1, x)

where the generation of each segment is per-
formed in two steps: select the predictor rt with
probability P (rt | y1..yt−1, x) and then gener-
ate st conditioned on predictor rt with probabil-
ity logP (st | y1..yt−1, x, rt). The probability of
each predictor is computed using a softmax over
all predictors in R conditioned on the previous
state ht−1 and the input representation zt (cf. “Se-
lect Predictor” box). Then, the probability of gen-
erating the segment st depends on the predictor
type. We define three types of predictors:

602



Character Generation Generate a single char-
acter from observed characters from the training
data. Only one character is generated at each time
stamp with probability given by Equation 2.

Copy Singular Field For singular fields only
the field itself can be copied, for instance, the
value of the attack and cost attributes or the type
of card. The size of the generated segment is the
number of characters in the copied field and the
segment is generated with probability 1.

Copy Text Field For text fields, we allow each
of the words xki within the field to be copied.
The probability of copying a word is learned with
a pointer network (cf. “Copy From Name” box),
where h(ci) is set to the representation of the word
f(xki) and q is the concatenation ht−1 : zt of the
state and input vectors. This predictor generates a
segment with the size of the copied word.

It is important to note that the state vector ht−1
is generated by building an RNN over the se-
quence of characters up until the time stamp t− 1,
i.e. the previous context yt−1 is encoded at the
character level. This allows the number of pos-
sible states to remain tractable at training time.

5.1 Inference
At training time we use back-propagation to max-
imize the probability of observed code, according
to Equation 7. Gradient computation must be per-
formed with respect to each computed probabil-
ity P (rt | y1..yt−1, x) and P (st | y1..yt−1, x, rt).
The derivative ∂ log P (y|x)∂P (rt|y1..yt−1,x) yields:

∂αtP (rt | y1..yt−1, x)βt,rt + ξrt
P (y | x)∂P (rt | y1..yt−1, x) =

αtβt,rt
α|y|+1

Here αt denotes the cumulative probability of all
values of ω up until time stamp t and α|y|+1 yields
the marginal probability P (y | x). βt,rt = P (st |
y1..yt−1)βt+|st|−1 denotes the cumulative proba-
bility starting from predictor rt at time stamp t, ex-
clusive. This includes the probability of the gener-
ated segment P (st | y1..yt−1, x, rt) and the proba-
bility of all values of ω starting from timestamp t+
|st|−1, that is, all possible sequences that generate
segment y after segment st is produced. For com-
pleteness, ξr denotes the cumulative probabilities
of all ω that do not include rt. To illustrate this,
we refer to Figure 4 and consider the timestamp
t = 14, where the segment s14 =Fordring is
generated. In this case, the cumulative probability

α14 is the sum of the path that generates the se-
quence init(‘Tirion with characters alone,
and the path that generates the word Tirion by
copying from the input. β21 includes the prob-
ability of all paths that follow the generation of
Fordring, which include 2×3×3 different paths
due to the three decision points that follow (e.g.
generating 8 using a character softmax vs. copy-
ing from the cost). Finally, ξr refers to the path
that generates Fordring character by character.

While the number of possible paths grows ex-
ponentially, α and β can be computed efficiently
using the forward-backward algorithm for Semi-
Markov models (Sarawagi and Cohen, 2005),
where we associate P (rt | y1..yt−1, x) to edges
and P (st | y1..yt−1, x, rt) to nodes in the Markov
chain.

The derivative ∂ log P (y|x)∂P (st|y1..yt−1,x,rt) can be com-
puted using the same logic:

∂αt,stP (st | y1..yt−1, x, rt)βt+|st|−1 + ξrt
P (y | x)∂P (st | y1..yt−1, x, rt) =

αt,rtβt+|st|−1
α|y|+1

Once again, we denote αt,rt = αtP (rt |
y1..yt−1, x) as the cumulative probability of all
values of ω that lead to st, exclusive.

An intuitive interpretation of the derivatives is
that gradient updates will be stronger on prob-
ability chains that are more likely to generate
the output sequence. For instance, if the model
learns a good predictor to copy names, such as
Fordring, other predictors that can also gener-
ate the same sequences, such as the character soft-
max will allocate less capacity to the generation
of names, and focus on elements that they excel at
(e.g. generation of keywords).

5.2 Decoding

Decoding is performed using a stack-based de-
coder with beam search. Each state S corre-
sponds to a choice of predictor rt and segment st
at a given time stamp t. This state is scored as
V (S) = logP (st | y1..yt−1, x, rt) + logP (rt |
y1..yt−1, x) + V (prev(S)), where prev(S) de-
notes the predecessor state of S. At each time
stamp, the n states with the highest scores V
are expanded, where n is the size of the beam.
For each predictor rt, each output st generates a
new state. Finally, at each timestamp t, all states

603



which produce the same output up to that point are
merged by summing their probabilities.

6 Code Compression

As the attention-based model traverses all input
units at each generation step, generation becomes
quite expensive for datasets such as MTG where
the average card code contains 1,080 characters.
While this is not the essential contribution in our
paper, we propose a simple method to compress
the code while maintaining the structure of the
code, allowing us to train on datasets with longer
code (e.g., MTG).

The idea behind that method is that many
keywords in the programming language (e.g.,
public and return) as well as frequently used
functions and classes (e.g., Card) can be learned
without character level information. We exploit
this by mapping such strings onto additional sym-
bols Xi (e.g., public class copy() →
“X1 X2 X3()”). Formally, we seek the string v̂
among all strings V (max) up to length max that
maximally reduces the size of the corpus:

v̂ = argmax
v∈V (max)

(len(v)− 1)C(v) (8)

where C(v) is the number of occurrences of
v in the training corpus and len(v) its length.
(len(v) − 1)C(v) can be seen as the number of
characters reduced by replacing v with a non-
terminal symbol. To find q(v) efficiently, we lever-
age the fact that C(v) ≤ C(v′) if v contains v′. It
follows that (max− 1)C(v) ≤ (max− 1)C(v′),
which means that the maximum compression ob-
tainable for v at size max is always lower than
that of v′. Thus, if we can find a v̄ such that
(len(v̄) − 1)C(v̄) > (max − 1)C(v′), that is v̄
at the current size achieves a better compression
rate than v′ at the maximum length, then it fol-
lows that all sequences that contain v can be dis-
carded as candidates. Based on this idea, our itera-
tive search starts by obtaining the counts C(v) for
all segments of size s = 2, and computing the best
scoring segment v̄. Then, we build a list L(s) of
all segments that achieve a better compression rate
than v̄ at their maximum size. At size s + 1, only
segments that contain a element in L(s − 1) need
to be considered, making the number of substrings
to be tested to be tractable as s increases. The al-
gorithm stops once s reaches max or the newly
generated list L(s) contains no elements.

X v size

X1 card)⇓{⇓super(card);⇓}⇓@Override⇓public 1041
X2 bility 1002
X3 ;⇓this. 964
X4 (UUID ownerId)⇓{⇓super(ownerId 934
X5 public 907
X6 new 881
X7 copy() 859
X8 }”)X3expansionSetCode = ” 837
X9 X6CardType[]{CardType. 815
X10 ffect 794

Table 2: First 10 compressed units in MTG. We
replaced newlines with ⇓ and spaces with .

Once v̂ is obtained, we replace all occurrences
of v̂ with a new non-terminal symbol. This pro-
cess is repeated until a desired average size for the
code is reached. While training is performed on
the compressed code, the decoding will undergo
an additional step, where the compressed code is
restored by expanding the all Xi. Table 2 shows
the first 10 replacements from the MTG dataset,
reducing its average size from 1080 to 794.

7 Experiments

Datasets Tests are performed on the two
datasets provided in this paper, described in Ta-
ble 1. Additionally, to test the model’s ability of
generalize to other domains, we report results in
the Django dataset (Oda et al., 2015), comprising
of 16000 training, 1000 development and 1805 test
annotations. Each data point consists of a line of
Python code together with a manually created nat-
ural language description.

Neural Benchmarks We implement two stan-
dard neural networks, namely a sequence-to-
sequence model (Sutskever et al., 2014) and an
attention-based model (Bahdanau et al., 2014).
The former is adapted to work with multiple in-
put fields by concatenating them, while the latter
uses our proposed attention model. These models
are denoted as “Sequence” and “Attention”.

Machine Translation Baselines Our problem
can also be viewed in the framework of seman-
tic parsing (Wong and Mooney, 2006; Lu et al.,
2008; Jones et al., 2012; Artzi et al., 2015). Unfor-
tunately, these approaches define strong assump-
tions regarding the grammar and structure of the
output, which makes it difficult to generalize for
other domains (Kwiatkowski et al., 2010). How-
ever, the work in Andreas et al. (2013) provides

604



evidence that using machine translation systems
without committing to such assumptions can lead
to results competitive with the systems described
above. We follow the same approach and create
a phrase-based (Koehn et al., 2007) model and a
hierarchical model (or PCFG) (Chiang, 2007) as
benchmarks for the work presented here. As these
models are optimized to generate words, not char-
acters, we implement a tokenizer that splits on all
punctuation characters, except for the “ ” charac-
ter. We also facilitate the task by splitting Camel-
Case words (e.g., class TirionFordring
→ class Tirion Fordring). Otherwise all
class names would not be generated correctly by
these methods. We used the models implemented
in Moses to generate these baselines using stan-
dard parameters, using IBM Alignment Model 4
for word alignments (Och and Ney, 2003), MERT
for tuning (Sokolov and Yvon, 2011) and a 4-gram
Kneser-Ney Smoothed language model (Heafield
et al., 2013). These models will be denoted as
“Phrase” and “Hierarchical”, respectively.

Retrieval Baseline It was reported in (Quirk et
al., 2015) that a simple retrieval method that out-
puts the most similar input for each sample, mea-
sured using Levenshtein Distance, leads to good
results. We implement this baseline by computing
the average Levenshtein Distance for each input
field. This baseline is denoted “Retrieval”.

Evaluation A typical metric is to compute the
accuracy of whether the generated code exactly
matches the reference code. This is informative
as it gives an intuition of how many samples can
be used without further human post-editing. How-
ever, it does not provide an illustration on the de-
gree of closeness to achieving the correct code.
Thus, we also test using BLEU-4 (Papineni et
al., 2002) at the token level. There are clearly
problems with these metrics. For instance, source
code can be correct without matching the refer-
ence. The code in Figure 2, could have also been
implemented by calling the draw function in an
cycle that exists once both players have the same
number of cards in their hands. Some tasks, such
as the generation of queries (Zelle and Mooney,
1996), have overcome this problem by executing
the query and checking if the result is the same
as the annotation. However, we shall leave the
study of these methologies for future work, as
adapting these methods for our tasks is not triv-

ial. For instance, the correctness cards with con-
ditional (e.g. if player has no cards,
then draw a card) or non-deterministc (e.g.
put a random card in your hand) ef-
fects cannot be simply validated by running the
code.

Setup The multiple input types (Figure 3) are
hyper-parametrized as follows: The C2W model
(cf. “C2W” row) used to obtain continuous vec-
tors for word types uses character embeddings of
size 100 and LSTM states of size 300, and gener-
ates vectors of size 300. We also report on results
using word lookup tables of size 300, where we
replace singletons with a special unknown token
with probability 0.5 during training, which is then
used for out-of-vocabulary words. For text fields,
the context (cf. “Bi-LSTM” row) is encoded with
a Bi-LSTM of size 300 for the forward and back-
ward states. Finally, a linear layer maps the differ-
ent input tokens into a common space with of size
300 (cf. “Linear” row). As for the attention model,
we used an hidden layer of size 200 before ap-
plying the non-linearity (row “Tanh”). As for the
decoder (Figure 4), we encode output characters
with size 100 (cf. “output (y)” row), and an LSTM
state of size 300 and an input representation of
size 300 (cf. “State(h+z)” row). For each pointer
network (e.g., “Copy From Name” box), the inter-
section between the input units and the state units
are performed with a vector of size 200. Train-
ing is performed using mini-batches of 20 sam-
ples using AdaDelta (Zeiler, 2012) and we report
results using the iteration with the highest BLEU
score on the validation set (tested at intervals of
5000 mini-batches). Decoding is performed with a
beam of 1000. As for compression, we performed
a grid search over compressing the code from 0%
to 80% of the original average length over inter-
vals of 20% for the HS and Django datasets. On
the MTG dataset, we are forced to compress the
code up to 80% due to performance issues when
training with extremely long sequences.

7.1 Results

Baseline Comparison Results are reported in
Table 3. Regarding the retrieval results (cf. “Re-
trieval” row), we observe the best BLEU
scores among the baselines in the card datasets
(cf. “MTG” and “HS” columns). A key advantage
of this method is that retrieving existing entities
guarantees that the output is well formed, with no

605



MTG HS Django

BLEU Acc BLEU Acc BLEU Acc

Retrieval 54.9 0.0 62.5 0.0 18.6 14.7
Phrase 49.5 0.0 34.1 0.0 47.6 31.5
Hierarchical 50.6 0.0 43.2 0.0 35.9 9.5

Sequence 33.8 0.0 28.5 0.0 44.1 33.2
Attention 50.1 0.0 43.9 0.0 58.9 38.8

Our System 61.4 4.8 65.6 4.5 77.6 62.3
– C2W 60.9 4.4 67.1 4.5 75.9 60.9
– Compress - - 59.7 6.1 76.3 61.3
– LPN 52.4 0.0 42.0 0.0 63.3 40.8
– Attention 39.1 0.5 49.9 3.0 48.8 34.5

Table 3: BLEU and Accuracy scores for the pro-
posed task on two in-domain datasets (HS and
MTG) and an out-of-domain dataset (Django).

Compression 0% 20% 40% 60% 80%

Seconds Per Card
Softmax 2.81 2.36 1.88 1.42 0.94
LPN 3.29 2.65 2.35 1.93 1.41

BLEU Scores
Softmax 44.2 46.9 47.2 51.4 52.7
LPN 59.7 62.8 61.1 66.4 67.1

Table 4: Results with increasing compression rates
with a regular softmax (cf. “Softmax”) and a LPN
(cf. “LPN”). Performance values (cf. “Seconds Per
Card” block) are computed using one CPU.

syntactic errors such as producing a non-existent
function call or generating incomplete code. As
BLEU penalizes length mismatches, generating
code that matches the length of the reference pro-
vides a large boost. The phrase-based transla-
tion model (cf. “Phrase” row) performs well in
the Django (cf. “Django” column), where map-
ping from the input to the output is mostly mono-
tonic, while the hierarchical model (cf. “Hierar-
chical” row) yields better performance on the card
datasets as the concatenation of the input fields
needs to be reordered extensively into the out-
put sequence. Finally, the sequence-to-sequence
model (cf. “Sequence” row) yields extremely low
results, mainly due to the lack of capacity needed
to memorize whole input and output sequences,
while the attention based model (cf. “Attention”
row) produces results on par with phrase-based
systems. Finally, we observe that by including all
the proposed components (cf. “Our System” row),
we obtain significant improvements over all base-
lines in the three datasets and is the only one that
obtains non-zero accuracies in the card datasets.

Component Comparison We present ablation
results in order to analyze the contribution of each
of our modifications. Removing the C2W model
(cf. “– C2W” row) yields a small deterioration, as
word lookup tables are more susceptible to spar-
sity. The only exception is in the HS dataset,
where lookup tables perform better. We believe
that this is because the small size of the training
set does not provide enough evidence for the char-
acter model to scale to unknown words. Surpris-
ingly, running our model compression code (cf. “–
Compress” row) actually yields better results. Ta-
ble 4 provides an illustration of the results for dif-
ferent compression rates. We obtain the best re-
sults with an 80% compression rate (cf. “BLEU
Scores” block), while maximising the time each
card is processed (cf. “Seconds Per Card” block).
While the reason for this is uncertain, it is simi-
lar to the finding that language models that output
characters tend to under-perform those that output
words (Józefowicz et al., 2016). This applies when
using the regular optimization process with a char-
acter softmax (cf. “Softmax” rows), but also when
using the LPN (cf. “LPN” rows). We also note
that the training speed of LPNs is not significantly
lower as marginalization is performed with a dy-
namic program. Finally, a significant decrease is
observed if we remove the pointer networks (cf. “–
LPN” row). These improvements also generalize
to sequence-to-sequence models (cf. “– Attention”
row), as the scores are superior to the sequence-to-
sequence benchmark (cf. “Sequence” row).

Result Analysis Examples of the code gener-
ated for two cards are illustrated in Figure 5.
We obtain the segments that were copied by the
pointer networks by computing the most likely
predictor for those segments. We observe from the
marked segments that the model effectively copies
the attributes that match in the output, including
the name of the card that must be collapsed. As
expected, the majority of the errors originate from
inaccuracies in the generation of the effect of the
card. While it is encouraging to observe that a
small percentage of the cards are generated cor-
rectly, it is worth mentioning that these are the re-
sult of many cards possessing similar effects. The
“Madder Bomber” card is generated correctly as
there is a similar card “Mad Bomber” in the train-
ing set, which implements the same effect, except
that it deals 3 damage instead of 6. Yet, it is a
promising result that the model was able to capture

606



this difference. However, in many cases, effects
that radically differ from seen ones tend to be gen-
erated incorrectly. In the card “Preparation”, we
observe that while the properties of the card are
generated correctly, the effect implements a unre-
lated one, with the exception of the value 3, which
is correctly copied. Yet, interestingly, it still gener-
ates a valid effect, which sets a minion’s attack to
3. Investigating better methods to accurately gen-
erate these effects will be object of further studies.

Figure 5: Examples of decoded cards from HS.
Copied segments are marked in green and incor-
rect segments are marked in red.

8 Related Work

While we target widely used programming lan-
guages, namely, Java and Python, our work is
related to studies on the generation of any ex-
ecutable code. These include generating regu-
lar expressions (Kushman and Barzilay, 2013),
and the code for parsing input documents (Lei
et al., 2013). Much research has also been in-
vested in generating formal languages, such as
database queries (Zelle and Mooney, 1996; Be-
rant et al., 2013), agent specific language (Kate
et al., 2005) or smart phone instructions (Le et
al., 2013). Finally, mapping natural language
into a sequence of actions for the generation of
executable code (Branavan et al., 2009). Fi-
nally, a considerable effort in this task has fo-
cused on semantic parsing (Wong and Mooney,
2006; Jones et al., 2012; Lei et al., 2013; Artzi
et al., 2015; Quirk et al., 2015). Recently pro-
posed models focus on Combinatory Categorical
Grammars (Kushman and Barzilay, 2013; Artzi

et al., 2015), Bayesian Tree Transducers (Jones et
al., 2012; Lei et al., 2013) and Probabilistic Con-
text Free Grammars (Andreas et al., 2013). The
work in natural language programming (Vadas and
Curran, 2005; Manshadi et al., 2013), where users
write lines of code from natural language, is also
related to our work. Finally, the reverse map-
ping from code into natural language is explored
in (Oda et al., 2015).

Character-based sequence-to-sequence models
have previously been used to generate code from
natural language in (Mou et al., 2015). Inspired
by these works, LPNs provide a richer framework
by employing attention models (Bahdanau et al.,
2014), pointer networks (Vinyals et al., 2015) and
character-based embeddings (Ling et al., 2015).
Our formulation can also be seen as a generaliza-
tion of Allamanis et al. (2016), who implement
a special case where two predictors have the same
granularity (a sub-token softmax and a pointer net-
work). Finally, HMMs have been employed in
neural models to marginalize over label sequences
in (Collobert et al., 2011; Lample et al., 2016) by
modeling transitions between labels.

9 Conclusion

We introduced a neural network architecture
named Latent Prediction Network, which allows
efficient marginalization over multiple predictors.
Under this architecture, we propose a generative
model for code generation that combines a char-
acter level softmax to generate language-specific
tokens and multiple pointer networks to copy key-
words from the input. Along with other exten-
sions, namely structured attention and code com-
pression, our model is applied on on both exist-
ing datasets and also on a newly created one with
implementations of TCG game cards. Our experi-
ments show that our model out-performs multiple
benchmarks, which demonstrate the importance of
combining different types of predictors.

References
M. Allamanis, H. Peng, and C. Sutton. 2016. A Con-

volutional Attention Network for Extreme Summa-
rization of Source Code. ArXiv e-prints, February.

Jacob Andreas, Andreas Vlachos, and Stephen Clark.
2013. Semantic parsing as machine translation. In
Proceedings of the 51st Annual Meeting of the Asso-
ciation for Computational Linguistics, pages 47–52,
August.

607



Yoav Artzi, Kenton Lee, and Luke Zettlemoyer. 2015.
Broad-coverage ccg semantic parsing with amr. In
Proceedings of the 2015 Conference on Empirical
Methods in Natural Language Processing, pages
1699–1710, September.

Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua
Bengio. 2014. Neural machine translation by
jointly learning to align and translate. CoRR,
abs/1409.0473.

Jonathan Berant, Andrew Chou, Roy Frostig, and Percy
Liang. 2013. Semantic parsing on freebase from
question-answer pairs. In Proceedings of the 2013
Conference on Empirical Methods in Natural Lan-
guage Processing, pages 1533–1544.

S. R. K. Branavan, Harr Chen, Luke S. Zettlemoyer,
and Regina Barzilay. 2009. Reinforcement learn-
ing for mapping instructions to actions. In Pro-
ceedings of the Joint Conference of the 47th Annual
Meeting of the ACL and the 4th International Joint
Conference on Natural Language Processing of the
AFNLP, pages 82–90.

David Chiang. 2007. Hierarchical phrase-based trans-
lation. Comput. Linguist., 33(2):201–228, June.

Ronan Collobert, Jason Weston, Léon Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural language processing (almost) from
scratch. J. Mach. Learn. Res., 12:2493–2537,
November.

Kenneth Heafield, Ivan Pouzyrevsky, Jonathan H.
Clark, and Philipp Koehn. 2013. Scalable modi-
fied Kneser-Ney language model estimation. In Pro-
ceedings of the 51th Annual Meeting on Association
for Computational Linguistics, pages 690–696.

Sepp Hochreiter and Jürgen Schmidhuber. 1997. Long
short-term memory. Neural Comput., 9(8):1735–
1780, November.

Bevan Keeley Jones, Mark Johnson, and Sharon Gold-
water. 2012. Semantic parsing with bayesian tree
transducers. In Proceedings of the 50th Annual
Meeting of the Association for Computational Lin-
guistics, pages 488–496.

Rafal Józefowicz, Oriol Vinyals, Mike Schuster, Noam
Shazeer, and Yonghui Wu. 2016. Exploring the lim-
its of language modeling. CoRR, abs/1602.02410.

Rohit J. Kate, Yuk Wah Wong, and Raymond J.
Mooney. 2005. Learning to transform natural to for-
mal languages. In Proceedings of the Twentieth Na-
tional Conference on Artificial Intelligence (AAAI-
05), pages 1062–1068, Pittsburgh, PA, July.

Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris
Callison-Burch, Marcello Federico, Nicola Bertoldi,
Brooke Cowan, Wade Shen, Christine Moran,
Richard Zens, Chris Dyer, Ondřej Bojar, Alexandra
Constantin, and Evan Herbst. 2007. Moses: Open
source toolkit for statistical machine translation. In

Proceedings of the 45th Annual Meeting of the ACL
on Interactive Poster and Demonstration Sessions,
pages 177–180.

Nate Kushman and Regina Barzilay. 2013. Using se-
mantic unification to generate regular expressions
from natural language. In Proceedings of the 2013
Conference of the North American Chapter of the
Association for Computational Linguistics: Human
Language Technologies, pages 826–836, Atlanta,
Georgia, June.

Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-
ter, and Mark Steedman. 2010. Inducing proba-
bilistic ccg grammars from logical form with higher-
order unification. In Proceedings of the 2010 Con-
ference on Empirical Methods in Natural Language
Processing, pages 1223–1233.

G. Lample, M. Ballesteros, S. Subramanian,
K. Kawakami, and C. Dyer. 2016. Neural
Architectures for Named Entity Recognition. ArXiv
e-prints, March.

Vu Le, Sumit Gulwani, and Zhendong Su. 2013.
Smartsynth: Synthesizing smartphone automation
scripts from natural language. In Proceeding of
the 11th Annual International Conference on Mo-
bile Systems, Applications, and Services, pages 193–
206.

Tao Lei, Fan Long, Regina Barzilay, and Martin Ri-
nard. 2013. From natural language specifications
to program input parsers. In Proceedings of the
51st Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
1294–1303, Sofia, Bulgaria, August.

Wang Ling, Tiago Luı́s, Luı́s Marujo, Rámon Fernan-
dez Astudillo, Silvio Amir, Chris Dyer, Alan W
Black, and Isabel Trancoso. 2015. Finding function
in form: Compositional character models for open
vocabulary word representation. In Proceedings of
the 2015 Conference on Empirical Methods in Nat-
ural Language Processing.

Wei Lu, Hwee Tou Ng, Wee Sun Lee, and Luke S.
Zettlemoyer. 2008. A generative model for pars-
ing natural language to meaning representations. In
Proceedings of the 2008 Conference on Empirical
Methods in Natural Language Processing, EMNLP
’08, pages 783–792, Stroudsburg, PA, USA. Associ-
ation for Computational Linguistics.

Mehdi Hafezi Manshadi, Daniel Gildea, and James F.
Allen. 2013. Integrating programming by exam-
ple and natural language programming. In Marie
desJardins and Michael L. Littman, editors, AAAI.
AAAI Press.

Lili Mou, Rui Men, Ge Li, Lu Zhang, and Zhi Jin.
2015. On end-to-end program generation from
user intention by deep neural networks. CoRR,
abs/1510.07211.

608



Franz Josef Och and Hermann Ney. 2003. A sys-
tematic comparison of various statistical alignment
models. Comput. Linguist., 29(1):19–51, March.

Yusuke Oda, Hiroyuki Fudaba, Graham Neubig,
Hideaki Hata, Sakriani Sakti, Tomoki Toda, and
Satoshi Nakamura. 2015. Learning to gener-
ate pseudo-code from source code using statistical
machine translation. In 30th IEEE/ACM Interna-
tional Conference on Automated Software Engineer-
ing (ASE), Lincoln, Nebraska, USA, November.

Kishore Papineni, Salim Roukos, Todd Ward, and Wei-
Jing Zhu. 2002. Bleu: A method for automatic eval-
uation of machine translation. In Proceedings of the
40th Annual Meeting on Association for Computa-
tional Linguistics, pages 311–318.

Chris Quirk, Raymond Mooney, and Michel Galley.
2015. Language to code: Learning semantic parsers
for if-this-then-that recipes. In Proceedings of the
53rd Annual Meeting of the Association for Compu-
tational Linguistics, pages 878–888, Beijing, China,
July.

Sunita Sarawagi and William W. Cohen. 2005. Semi-
markov conditional random fields for information
extraction. In L. K. Saul, Y. Weiss, and L. Bottou,
editors, Advances in Neural Information Processing
Systems 17, pages 1185–1192. MIT Press.

Artem Sokolov and François Yvon. 2011. Mini-
mum Error Rate Semi-Ring. In Mikel Forcada and
Heidi Depraetere, editors, Proceedings of the Eu-
ropean Conference on Machine Translation, pages
241–248, Leuven, Belgium.

Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014.
Sequence to sequence learning with neural net-
works. CoRR, abs/1409.3215.

David Vadas and James R. Curran. 2005. Program-
ming with unrestricted natural language. In Pro-
ceedings of the Australasian Language Technology
Workshop 2005, pages 191–199, Sydney, Australia,
December.

Oriol Vinyals, Meire Fortunato, and Navdeep Jaitly.
2015. Pointer networks. In C. Cortes, N.D.
Lawrence, D.D. Lee, M. Sugiyama, and R. Garnett,
editors, Advances in Neural Information Processing
Systems 28, pages 2674–2682. Curran Associates,
Inc.

Yuk Wah Wong and Raymond J. Mooney. 2006.
Learning for semantic parsing with statistical ma-
chine translation. In Proceedings of the Main Con-
ference on Human Language Technology Confer-
ence of the North American Chapter of the Associa-
tion of Computational Linguistics, pages 439–446.

Matthew D. Zeiler. 2012. ADADELTA: an adaptive
learning rate method. CoRR, abs/1212.5701.

John M. Zelle and Raymond J. Mooney. 1996. Learn-
ing to parse database queries using inductive logic
programming. In AAAI/IAAI, pages 1050–1055,
Portland, OR, August. AAAI Press/MIT Press.

609


