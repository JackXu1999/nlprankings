



















































Cross-Lingual Dependency Parsing Using Code-Mixed TreeBank


Proceedings of the 2019 Conference on Empirical Methods in Natural Language Processing
and the 9th International Joint Conference on Natural Language Processing, pages 997–1006,
Hong Kong, China, November 3–7, 2019. c©2019 Association for Computational Linguistics

997

Cross-Lingual Dependency Parsing Using Code-Mixed TreeBank

Meishan Zhang1 and Yue Zhang2∗ and Guohong Fu3
1. School of New Media and Communication, Tianjin University, China

2. Institute of Advanced Technology, Westlake Institute for Advanced Study
3. Institute of Artificial Intelligence, Soochow University, China

mason.zms@gmail.com,
zhangyue@westlake.edu.cn,

ghfu@hotmail.com

Abstract

Treebank translation is a promising method for
cross-lingual transfer of syntactic dependency
knowledge. The basic idea is to map depen-
dency arcs from a source treebank to its tar-
get translation according to word alignments.
This method, however, can suffer from im-
perfect alignment between source and target
words. To address this problem, we investigate
syntactic transfer by code mixing, translating
only confident words in a source treebank.
Cross-lingual word embeddings are leveraged
for transferring syntactic knowledge to the tar-
get from the resulting code-mixed treebank.
Experiments on University Dependency Tree-
banks show that code-mixed treebanks are
more effective than translated treebanks, giv-
ing highly competitive performances among
cross-lingual parsing methods.

1 Introduction

Treebank translation (Tiedemann et al., 2014;
Tiedemann, 2015; Tiedemann and Agić, 2016) has
been considered as a method for cross-lingual syn-
tactic transfer. Take dependency grammar for in-
stance. Given a source treebank, machine transla-
tion is used to find target translations of its sen-
tences. Then word alignment is used to find
mappings between source and target words, so
that source syntactic dependencies can be pro-
jected to the target translations. Following, a post-
processing step is applied by removing unaligned
target words, in order to ensure that the result-
ing target syntax forms a valid dependency tree,
The method has shown promising performance
for unsupervised cross-lingual dependency pars-
ing among transfer methods (McDonald et al.,
2011; Täckström et al., 2012; Rasooli and Collins,
2015; Guo et al., 2016b).

∗Corresponding author.

we are being accused unfairly here

vi beskylls med orätt där

en

sv

root

advmod
advmodauxpass

aux
nsubjpass

vi(we) beskylls(accused) orätt(unfairly) där(there)

root
advmod

advmod
nsubjpass

(a) full-scale translation.

vi(we) being beskylls(accused) orätt(unfairly) here
sv en sv sv en

root

advmod
advmodauxpass

nsubjpass

(b) this method, partial translation.

Figure 1: An example to illustrate our method, where
the source and target languages are English (en) and
Swedish (sv), respectively.

The treebank translation method, however, suf-
fers from various sources of noise. For exam-
ple, machine translation errors directly affect the
resulting treebank, by introducing ungrammatical
word sequences. In addition, the alignments be-
tween source and target words may not be iso-
morphic due to inherent differences between lan-
guages or paraphrasing during translation. For ex-
ample, in the case of Figure 1, the English words
“are” and “being”, and the Swedish word “med”,
do not have corresponding word-level translation.
In addition, it can be perfect to express “as soon
as they can” using “very quickly” in a translation,
which looses word alignment information because
of the longer span. Finally, errors in automatic
word alignments can also bring noise. Such align-
ment errors can directly affect grammaticality of
the resulting target treebank due to deletion of
unaligned words during post-processing, or cause



998

lost or mistaken dependency arcs.
We consider a different approach for

translation-based syntactic knowledge trans-
fer, which aims at making the best use of source
syntax with the minimum noise being intro-
duced. To this end, we leverage recent advances
in cross-lingual word representations, such as
cross-lingual word clusters (Täckström et al.,
2012) and cross-lingual word embeddings (Guo
et al., 2015), which allow words from different
languages to reside within a consistent feature
vector space according to structural similarities
between words. Thus, they offer a bridge on the
lexical level between different languages (Ammar
et al., 2016).

A cross-lingual model can be trained by di-
rectly using cross-lingual word representations on
a source treebank (Guo et al., 2015). Using this
method, knowledge transfer can be achieved on
the level of token correspondences. We take this
approach as a naive baseline. To further introduce
structural feature transfer, we transform a source
treebank into a code-mixed treebank by consider-
ing word alignments between a source sentence
and its machine translation. In particular, source
words with highly confident target alignments are
translated into target words by consulting the ma-
chine translation output, so that target word vec-
tors can be directly used for learning target syn-
tax. In addition, continuous spans of target words
of the code-mixed treebank are reordered accord-
ing to the translation, so that target grammaticality
can be exploited to the maximum potent.

We conduct experiments on Universal Depen-
dency Treebanks (v2.0) (McDonald et al., 2013;
Nivre et al., 2016). The results show that a code-
mixed treebank can bring significantly better per-
formance compared to a fully translated treebank,
resulting in averaged improvements of 4.30 points
on LAS. The code and related data will be released
publicly available under Apache License 2.0.1

2 Related Work

Existing work on cross-lingual transfer can be
classified into two categories. The first aims
to train a dependency parsing model on source
treebanks (McDonald et al., 2011; Guo et al.,
2016a,b), or their adapted versions (Zhao et al.,
2009; Tiedemann et al., 2014; Wang et al., 2017)
in the target language. The second category,

1https://github.com/zhangmeishan/CodeMixedTreebank

namely annotation projection, aims to produce a
set of large-scale training instances full of auto-
matic dependencies by parsing parallel sentences
(Hwa et al., 2005; Rasooli and Collins, 2015). The
two broad methods are orthogonal to each other,
and can both make use of the lexicalized depen-
dency models trained with cross-lingual word rep-
resentations (Rasooli and Collins, 2017, 2019).

Source Treebank Adaption. There has been
much work on unsupervised cross-lingual depen-
dency parsing by direct source treebank transfer-
ring. Several researchers investigate delexicalized
models where only non-lexical features are used
in the models (Zeman and Resnik, 2008; Cohen
et al., 2011; McDonald et al., 2011; Naseem et al.,
2012; Täckström et al., 2013; Rosa and Zabokrt-
sky, 2015). All the features in these models are
language independent, and are consistent across
languages and treebanks. Thus they can be applied
into target languages directly.

Subsequent research proposes to exploit lexi-
calized features to enhance the parsing models,
by resorting to cross-lingual word representations
(Täckström et al., 2012; Guo et al., 2015; Duong
et al., 2015b,a; Zhang and Barzilay, 2015; Guo
et al., 2016b; Ammar et al., 2016; Wick et al.,
2016; de Lhoneux et al., 2018). Cross-lingual
word clusters and cross-lingual word embeddings
are two main sources of features for transferring
knowledge between source and target language
sentences. These studies enable us to train lexi-
calized models on code-mixed treebanks as well.
Thus here we integrate the cross-lingual word rep-
resentations as well, which gives more direct in-
teraction between source and target words.

Our work follows another mainstream method
of this line of work, namely treebank translation
(Tiedemann et al., 2014; Tiedemann, 2015; Tiede-
mann and Agić, 2016), which aims to adapt an an-
notated source treebank into the target language
by machine translation. In addition, the target-
side sentences are produced by machine transla-
tion. Previous work aims to build a well-formed
tree (Tiedemann and Agić, 2016) from source de-
pendencies, solving word alignment conflicts by
heuristic rules. In contrast, we use partial transla-
tion instead to avoid unnecessary noise.

Annotation Projection. The annotation pro-
jection approach relies on a set of parallel sen-
tences between the source and target languages
(Hwa et al., 2005; Ganchev et al., 2009). In par-



999

w1c1 t1 ... wncn tn
e(w1)e(c1) e(t1) ... e(wn)e(cn) e(tn)

⊕⊕⊕ ⊕⊕⊕
...x1 xn

hlstm1 h
lstm
n...

BiLSTM × 3

h
dep
1

hhead1 h
dep
n h

head
n...

s1x∗ snx∗...

BiAffine

Figure 2: The overall architecture of the BiAffine
parser.

ticular, a source parser trained on the source tree-
bank is used to parse the source-side sentences of
the parallel corpus. The source dependencies are
then projected onto the target sentences accord-
ing to word alignments. Different strategies can
be applied for the dependency projection task (Ma
and Xia, 2014; Rasooli and Collins, 2015; Xiao
and Guo, 2015; Agić et al., 2016; Schlichtkrull
and Søgaard, 2017). For example, one can project
only dependency arcs whose words are aligned to
target-side words with high confidence (Lacroix
et al., 2016). The resulting treebank can be highly
noisy due to the auto-parsed source dependency
trees. Recently Lacroix et al. (2016) and Rasooli
and Collins (2017) propose to filter the results
from the large-scale parallel corpus. Our work is
different in that the source dependencies are from
gold-standard treebanks.

3 Dependency Parsing

We adopt a state-of-the-art neural BiAffine parser
(Dozat and Manning, 2016) as the baseline, which
has achieved competitive performances for depen-
dency parsing. The overall architecture is shown
in Figure 2. Given an input sentence w1 · · ·wn,
the model finds its embedding representations of
each word x1 · · ·xn, where

xi = e(wi)⊕ e(ci)⊕ e(ti) (1)

Here ci denotes the word cluster of wi, and ti de-
notes the POS tag. We exploit cross-lingual word
embeddings, clusters and also universal POS tags,
respectively, which are consistent across language
and treebanks.

A three-layer deep bidirectional long short
term memory (LSTM) neural structure is ap-
plied on x1 · · ·xn to obtain hidden vectors

hLSTM1 · · ·hLSTMn . For head finding, two non-
linear feed-forward neural layers are used on
hLSTM1 · · ·hLSTMn to obtain h

dep
1 · · ·h

dep
n and

hhead1 · · ·hheadn . We compute the score for each de-
pendency ixj by:

sixj = BiAffine(h
dep
i ,h

head
j ) (2)

The above process is also used for scoring a la-

beled dependency i
lxj, by extending the 1-dim

vector s into L dims, where L is the total number
of dependency labels.

When all scores are ready, a softmax function is
used at each position for all candidate heads and
labels, and then the normalized scores are used
for decoding and training. For decoding, we ex-
ploit the MST algorithm to ensure tree-structural
outputs. For training, we accumulate the cross-
entropy loss at the word-level by treating the nor-
malized scores as prediction probabilities. The
reader is referred to Dozat and Manning (2016)
for more details.

4 Code-Mixed Treebank Translation

We derive code-mixed trees from source depen-
dency trees by partial translation, projecting words
and the corresponding dependencies having high-
confidence alignments with machine-translated
target sentences. Our approach assumes that sen-
tence level translations and alignment probabili-
ties are available. The motivation is to reduce
noise induced by problematic word alignments.

We adopt the word-level alignment strategy,
which has been demonstrated as effective as
phrase-level alignment yet much simpler (Tiede-
mann et al., 2014; Tiedemann, 2015; Tiede-
mann and Agić, 2016). Give a source sen-
tence e1 · · · en and its target language translation
f1 · · · fm, p(ei|fj) denotes the probability of word
fj being aligned with ei (0 ≤ i ≤ n and 0 < j ≤
m), where e0 denotes a null word, indicating the
no alignment probability for one target word.

The translation process can be conducted by
three steps:

(1) word substitution, which incrementally sub-
stitutes the source words with the target trans-
lations;

(2) word deletion, which removes several un-
aligned source words;



1000

Algorithm 1 The process of tree translation.
Input: e1 · · · en, f1 · · · fm, Te, {p(e|f)}, λ
Output: Tmix

1: Let Tmix = Te.
2: for j ∈ [1,m] do
3: aj , pj ← argmaxi p(ei|fj),maxi p(ei|fj)
4: end for
5: Ssub ← SELECT({〈fj , aj ,v=pj〉}, λ)
6: for fj , aj ∈ Ssub do
7: Tmix ← SUBSTITUTE(fj , aj ,Tmix)
8: end for
9: D = [1, n]− {aj}|j∈[1,m]

10: for i ∈ D do
11: ri =

∑
j p(ei|fj)

12: end for
13: Sdel← SELECT({〈ei,v=-ri〉}, λ)
14: for ei ∈ Sdel do
15: Tmix← DELETE(ei,Tmix)
16: end for
17: Tmix← REORDER(Tmix, f1 · · · fm)

(3) sentence reordering, which reorders the par-
tially translated sentence, ensuring local tar-
get language word order.

Algorithm 1 shows pseudocode for code-mixing
tree translation, where line 1-8 denotes the first
step, line 9-16 denotes the second and line 17 de-
notes the last step.

There is a hyper-parameter λ to control the
overall ratio of translation. The function SE-
LECT(S, λ) is to obtain a subset of S by ratio λ
with top element values as indicated by v inside
S. If λ = 0, it is still the source language de-
pendence tree, since no source word is substituted
or deleted. In this condition, our method is equal
to Guo et al. (2015) by bridging source and target
dependency parsing with universal word represen-
tations. If λ = 1, the resulting tree is a fully trans-
lated target dependency tree, as all words are target
language produced by translation. In this setting,
our method is equal to Tiedemann and Agić (2016)
where the only difference the our baseline parsing
model. Thus our method can be regarded as a gen-
eralization of both source-side training (Guo et al.,
2015) and fully translated target training (Tiede-
mann and Agić, 2016) with fine-grained control
over translation confidence.

he has meanwhile found ...

han har(has) under(during) tiden (time) hittat ...

nsubj

nsubj

(a) one-to-one.

he has meanwhile found ...

han(he) har (has) under(during) tiden (time) hittat ...

advmod

advmod
advmod

(b) many-to-one.

Figure 3: Examples of word substitution, where the
thicker lines indicates more confident alignments.

4.1 Word Substitution
Word substitution is the key step for producing
a target treebank. We first obtain the most con-
fidently aligned source word eaj for each target
word fj as well as their alignment probability
pj = p(eaj |fj), as shown by line 3 in Algorithm
1. Then we sort the target words by these align-
ment probabilities, choosing the top dmλe words
with highest alignment probabilities for substitu-
tion. The sorting and choosing is reflected in line
line 5 of Algorithm 1. Finally for each chosen
word fj and its aligned source word eaj , we re-
place the source word eaj by fj , as shown by line
7 in Algorithm 1.

One key of the substitution is to maintain the
corresponding dependency structures. If eaj and
fj bares a one-one mapping, with no other tar-
get word being aligned with eaj , the source de-
pendencies are kept unchanged, as shown by Fig-
ure 3(a). While if two or more words (i.e.,
fj1 , · · · , fjk(j1 < · · · < jk)) are aligned to eaj ,
we simply link all words to eaj , with the same
dependency label as the original dependency arc.
Figure 3(b) illustrates this condition. Both the
Swedish words “under” and “tiden” are headed to
“hittat” (the Swedish translation of English word
“found”) by the dependency label “advmod” in-
herited from the source English side . Note that
the POS tags of the substituted words are the same
as the corresponding source words.

4.2 Word Deletion
There can be source words to which no target word
is aligned. These words are typically functional
words belonging to source language only, such as



1001

vi(we) are being beskylls(accused) orätt(unfairly) here
sv en en sv sv en

root

advmod
advmodauxpass

aux
nsubjpass
× × × ×

Figure 4: An example of word deletion.

“the”, “are” and “have”. We remove such words to
produce dependency trees that are close in syntax
to the target language.

In particular, we accumulate the probabilities of
p(ei|fj) for the source word ei who has no aligned
target word:

ri =
∑
j

p(ei|fj) (line 11 in Algorithm 1),

where we traverse all target words to sum their
alignment probabilities with ei. The value of ri
can be interpreted as the confidence score of re-
tention. The words with lower retention scores
should be more preferred to be deleted, as these
words have lower probabilities aligning with some
word of the target language sentence. Concretely,
we collect all source words with no aligned target
words, computing their retention values, and the
selecting a subset of these words with the lowest
retention values by the hyper-parameter λ (line 13
in Algorithm 1). Finally we delete all the selected
words (line 15 in Algorithm 1).

Figure 4 shows an example of word deletion.
The two words “are” and “being” both have no
aligned words in the other side, and meanwhile
“are” has a lower retention score compared with
“being”.2 Thus the source word “are” is prefer
to be deleted. In most cases, the deleted words
are leaf nodes, which can be unattached to the re-
sulted dependency tree and deleted them directly.
In case of exceptions, we simply reset the corre-
sponding heads of its child nodes by the head of
ei (i.e., hei) instead. For example, a dependency
wxi ei is changed into w

x
i hei .

4.3 Sentence Reordering
Continuous target spans are reordered to make
the final code-mixed sentence contain grammat-
ical phrases in the target language. Figure 5(a)
shows one example of full sentence reordering.
We can see that the word order by word-level sub-
stitutions on the source words is different with the

2Both the two words are only related to the Swedish word
“med”, but p(are|med) is slightly lower.

vi(we) kan(can) avsluta(finish) det(it) nu(now)

nu(now) kan(can) vi(we) avsluta(finish) det(it)

root

nsubj
aux obj

advmod

advmod
aux

nsubj obj

root

(a) full sentence

också(also) sök(look) upp(up) the familjen(family) Kingston(Kingston)

sök(look) också(also) upp(up) the Kingston(Kingston) familjen(family)

root

advmod
compound:prt det

obj

nmod

root

advmod
compound:prt det

nmod

obj

(b) two spans

Figure 5: Two examples of sentence reorder.

order of the machine-translated sentence. Thus we
adjust the leaf nodes, letting the word order strictly
follow the machine-translated sentence order For
example, the word “vi” is moved from the first
position into the third position, and similarly the
word “mu” is moved from the last position into
the first position.

Concretely, we perform the word reorder by the
span level, extracting all the continuous spans of
target words, because the target language words
may be interrupted by source language words.
Then we reorder the words in each span accord-
ing to their order in the machine translation out-
puts. Figure 5(b) shows another example, where
there are two spans separated by the English word
“the”. Each span is reordered individually. We do
not consider the inconsistent orders inter the spans
in this work. Note that this step does not change
any dependency arc between words.

5 Experiments

We conduct experiments to verify the effective-
ness of our proposed models in this section.

5.1 Settings

Our experiments are conducted on the Google
Universal Dependency Treebanks (v2.0) (McDon-
ald et al., 2013; Nivre et al., 2016), using En-
glish as the source language, and choosing six
languages, including Spanish (ES), German (DE),
French (FR), Italian (IT), Portuguese (PT) and
Swedish (sv), as the target languages. Google



1002

Translate3 is used to translate the sentences in
the English training set into other languages. In
order to generate high-quality word-level align-
ments, we merge the translated sentence pairs and
the parallel data of EuroParl (Koehn, 2005) to ob-
tain word alignments. We use the fastAlign tool
(Dyer et al., 2013) to obtain word alignments.

We use the cross-lingual word embeddings and
clusters by Guo et al. (2016b) for the baseline sys-
tem. The dimension size of word embeddings is
50 and the word cluster number across of all lan-
guages is 256.

For network building and training, we use the
same setting as Dozat and Manning (2016), in-
cluding the dimensional sizes, the dropout ratio,
as well as the parameter optimization method. We
assume that no labeled corpus is available for the
target language. Thus training is performed for
50 iterations over the whole training data without
early-stopping.

To evaluate dependency parsing performances,
we adopt UAS and LAS as the major metrics,
which indicate the accuracies of unlabeled depen-
dencies and labeled dependencies, respectively.
We ignore the punctuation words during evalua-
tion following previous work. We run each exper-
iment 10 times and report the averaged results.

5.2 Models

We compare performances on the following mod-
els:

• Delex (McDonald et al., 2013): The delexi-
calized BiAffine model without cross-lingual
word embeddings and clusters.

• Src (Guo et al., 2015): The BiAffine model
trained on the source English treebank only.

• PartProj (Lacroix et al., 2016): The Bi-
Affine model trained on the corpus by pro-
jecting only the source dependencies involv-
ing high-confidence alignments into target
sentences. Note that the baseline only draws
the idea from Lacroix et al. (2016), and the
two models are significant different in fact.

• Tgt (Tiedemann and Agić, 2016): The Bi-
Affine model trained on the fully translated
target treebank only.

3https://translate.google.com/ at Oct, 2018

0.0 0.2 0.4 0.6 0.7 0.8 1.0
69

69.5

70

70.5

71

71.5

.

Figure 6: The LAS relative to the translation ratio λ.

Model UAS LAS
Src 79.52 69.54
Tgt 79.34 69.96
Mix 80.33 71.29
Src + Tgt 80.12 71.16
Src + Mix 80.91 71.73

Table 1: Experiments of corpus mixing.

• Src+Tgt: The BiAffine model trained on
the combination dataset of the source and
fully translated target treebanks.

• Mix: The BiAffine model trained on the
code-mixed treebank only.

• Src+Mix: The BiAffine model trained on
the combination dataset of the source and
code-mixed treebanks.

The Src and Tgt methods have been discussed
in Section 4. The PartProj model is an-
other way to leverage imperfect word alignments
(Lacroix et al., 2016). The training corpus of
PartProj may be incomplete dependency trees
with a number of words missing heads, because
no word is deleted from machine translation out-
puts. The POS tags of words in PartProj with
low-confidence alignments are obtained by a su-
pervised POS tagger (Yang et al., 2018) trained on
the corresponding universal treebank.

5.3 Development Results

We conduct several developmental experiments on
the Swedish dataset to examine important factors
to our model.

5.3.1 Influence of The Translation Ratio λ
Our model has an important hyper-parameter λ
to control the percentage of translation. Figure 6
shows the influence of this factor, where the per-
centages increase from 0 to 1 by intervals of 0.1. A



1003

Model UAS LAS
Mix 80.33 71.29
−Sentence Reordering 79.79 70.47
−Word Deletion 79.82 70.64
−Both 79.46 69.59

Table 2: Ablation experiments.

λ of 0 gives our baseline by using the source tree-
bank only. As the λ grows, more source words are
translated into the target. We can see that the per-
formance improves after translating some source
dependencies into the target, demonstrating the ef-
fectiveness of syntactic transferring. The perfor-
mance reaches the peak when λ = 0.7, but there
is a significant drop when λ grows from 0.8 to
0.9. This can be because the newly added depen-
dency arc projections are mostly noisy. This sharp
decrease indicates that noise from low-confidence
word alignments can have strong impact on the
performance. According to the results, we adopt
λ = 0.7 for code-mixed treebanking.

5.3.2 Mixing with Source TreeBank
We investigate the effectiveness of the source tree-
bank by merging it into the translated treebanks.
First, we show the model performances of Src,
Tgt and Mix, which are trained on the individ-
ual treebanks, respectively. Then we merge the
source treebank with the two translated treebanks,
and show the results trained on the merging cor-
pora. Table 1 shows the results. According to
the results, we can find that the source treebank is
complementary with the translated treebanks. No-
ticeably, although Src + Mix gives the best per-
formance, its improvement over Mix is relatively
smaller than that of Src + Tgt over Tgt. This
is reasonable as the code-mixed treebank contains
relatively more source treebank content than the
fully translated target treebank.

5.3.3 Ablation Studies
The overall translation is conducted by three steps
as mentioned in Section 4, where the first word
substitution is compulsory, and the remaining two
steps aim to build better mixed dependency trees.
Here we conduct ablation studies to test the ef-
fectiveness of word deletion and sentence reorder-
ing. Table 2 shows the experimental results. We
can see both steps are important for dependency
tree translation. Without word deletion and sen-

tence reordering, the mix model shows decreases
of 0.82 and 0.65 on LAS, respectively. If both
are removed, the performance is only comparable
with the baseline src model (see Table 1).

5.4 Final Results
We show the final results of our proposed models
in Table 3. As shown, the model Tgt gives better
averaged performance compared to Src. How-
ever, its results on French and Italian are slightly
worse, which indicates that noise from transla-
tion impacts the quality of the projected tree-
bank. The model Mix gives much better perfor-
mance compared with Src, demonstrating the ef-
fectiveness of structural transfer. Mix also out-
performs Tgt significantly, obtaining average in-
creases of 80.93 − 76.37 = 4.56 points on UAS
and 72.87− 68.28 = 4.59 points on LAS, respec-
tively. The best setting is the model Src + Mix,
trained on the combined corpus of the source and
code-mixed treebanks, which gives better perfor-
mance than solely code-mixed treebanks.

By comparing with the delexicalized model
Delex, we can see that lexicalized features are
highly useful for cross-lingual transfer. For the
PartProj model, we conduct preliminary ex-
periments on Swedish to tune the ratio of the pro-
jected dependencies. The results show that the dif-
ference is very small (δ = 0.24 for UAS) between
0.9 to 1.0, and the performance degrades signifi-
cantly as the ratio decreases below 0.9. The obser-
vation indicates that this method is probably not
effective for filtering low-confidence word align-
ments. The final results confirm our hypothesis.
As shown in Table 3, the PartProj model gives
only comparable performance with Src. One pos-
sible reason may be the unremoved target words
(if the words are removed, the PartProj model
with ratio 1.0 will be identical to Tgt), which have
been demonstrated noisy previously (Tiedemann
and Agić, 2016).

5.5 Comparison with Previous Work
We compare our method with previous work in
the literature. Table 4 shows the results, where
the UAS values are reported. Our model denoted
by This refers to the model of Src + Mix.
Note that these models are not directly comparable
due to the setting and baseline parser differences.
The first block shows several models by directly
transferring gold-standard source treebank knowl-
edge into the target side, including the models of



1004

Lang.
Delex PartProj Src Tgt Src + Tgt Mix Src + Mix

UAS LAS UAS LAS UAS LAS UAS LAS UAS LAS UAS LAS UAS LAS
DE 64.10 53.77 69.90 61.28 66.87 57.46 70.84 62.30 72.41 63.74 71.41 63.46 72.78 64.38
ES 71.53 63.33 75.81 66.83 75.63 65.85 76.49 67.39 77.00 67.95 81.18 71.80 81.44 71.66
FR 75.13 67.26 75.54 67.63 78.13 70.63 76.91 69.39 78.75 71.17 83.20 76.32 83.77 76.48
IT 77.71 69.27 77.71 69.27 81.11 72.83 79.30 71.65 81.56 74.09 85.30 77.43 86.13 78.38
PT 74.03 67.70 79.44 71.30 77.37 69.36 78.32 70.67 79.73 71.84 83.54 75.34 84.05 75.89

AVG 72.50 64.27 75.68 67.26 75.82 67.23 76.37 68.28 77.89 69.76 80.93 72.87 81.63 73.36

Table 3: Final results.

Model DE ES FR IT PT
TreeBank Transferring

This 72.78 81.44 83.77 86.13 84.05
Guo15 60.35 71.90 72.93 – –
Guo16 65.01 79.00 77.69 78.49 81.86
TA16 75.27 76.85 79.21 – –

Annotation Projection
MX14 74.30 75.53 70.14 77.74 76.65
RC15 79.68 80.86 82.72 83.67 82.07
LA16 75.99 78.94 80.80 79.39 –

TreeBank Transferring + Annotation Projection
RC17 82.1 82.6 83.9 84.4 84.6

Table 4: Comparison with previous work (UAS).

Guo15 (Guo et al., 2015), Guo16 (Guo et al.,
2016b) and TA16 (Tiedemann and Agić, 2016).
Our model gives the best performance with one
exception on the German language. One possible
reason may be that TA16 has exploited multiple
sources of treebanks besides English.

The second block shows representative annota-
tion projection models, including MX14 (Ma and
Xia, 2014), RC15 (Rasooli and Collins, 2015),
LA16. The models of annotation projection can
be complementary with our work, since they build
target training corpus from raw parallel texts. The
best-performed results of the RC17 model (Ra-
sooli and Collins, 2017) have demonstrated this
point, which can be regarded as a combination of
the dictionary-based treebank translation4 (Zhao
et al., 2009) and RC15.

5.6 Analysis
We conduct experimental analysis on the Spanish
(ES) dataset to show the differences between the
models of Src, Tgt and Mix.

4The method has been demonstrated worse than TA16 in
Tiedemann and Agić (2016).

NOUN ADP DET VERB ADJ ADV

50

55

60

65

70

75

80

85

Src Tgt Mix

Figure 7: Performance relative to POS tags (F-score).

5.6.1 Performance Relative to POS Tags
Figure 7 show the F-scores of labeled dependen-
cies on different POS tags. We list the six most
representative POS tags. The Mix model achieves
the best F-scores on 5 of 6 POS tags, with the
only exception on tag ADV which has no signifi-
cant difference with the Tgt model. The Mix and
Tgt models are much better than the Src model
as a whole, especially on the POS tag ADJ where
an increase of over 20% has been achieved. In
addition, we find that the Src model can signif-
icantly outperform the Tgt model on ADP and
DET. For Spanish, ADP words are typically “de”,
“en”, “con” and etc., which behave similarly to the
English words such as “’s”, “to” and “of”. The
Spanish words of DET include “el”, “la”, “su” and
etc., which are similar to the English words such as
“the” and “a”. These words are highly ambiguous
for automatic word alignment. The results indicate
that our Mix model can better handle these word
alignment noise, mitigating their negative influ-
ence of treebank translation, while the Tgt model
suffers from such noise.

5.6.2 Performance Relative to Arc Distances
Figure 8 show the F-scores of labeled dependen-
cies by different arc distances. Particularly we
treat the root type as one special case. According



1005

root 1 2 3 ≥4

50

60

70

80
Src Tgt Mix

Figure 8: Performance relative to arc distances (F-
score).

to the results, the Mix model performs the best
over all distances, indicating its effectiveness on
treebank transferring. The Tgt model achieves
better performance than the Src model with one
exception on distance 2. We look into the depen-
dency patterns of distance 2 arcs further, finding
that the dependency arc ADPxxx* accounts for over
30%, and it is the major source of errors. The
finding is consistent with that on POS tags, denot-
ing the effectiveness of the code-mixed treebank
in handling noise. In addition, as the distance in-
creases the performance drops gradually. The F-
score of root dependency is the highest.

6 Conclusion

We proposed a new treebank translation method
for unsupervised cross-lingual dependency pars-
ing. Unlike previous work, which adopts full-scale
translation for source dependency trees, we inves-
tigated partial translation instead, producing syn-
thetic code-mixed treebanks. The method can bet-
ter leverage imperfect word alignments between
source and target sentence pairs, translating only
high-confidence source sentential words, thus gen-
erating dependencies in high-quality. Experimen-
tal results on Universal Dependency Treebak v2.0
showed that partial translation is highly effective,
and code-mixed treebanks can give significantly
better results than full-scale translation.

Our method is complementary with several
other methods for cross-lingual transfer, such as
annotation projection, and thus can be further in-
tegrated with these methods.

Acknowledgments

We thank all anonymous reviewers for their valu-
able comments. Several suggestions are not inte-
grated in this version, i.e., more experiments on
really low-resource languages, and detailed analy-

sis on more languages. We will supplement later
on the webpages of the authors. This work is sup-
ported by National Natural Science Foundation of
China (NSFC) grants 61602160, U1836222 and
61672211.

References
Željko Agić, Anders Johannsen, Barbara Plank,

Héctor Martı́nez Alonso, Natalie Schluter, and An-
ders Søgaard. 2016. Multilingual projection for
parsing truly low-resource languages. TACL, 4:301–
312.

Waleed Ammar, George Mulcaire, Miguel Ballesteros,
Chris Dyer, and Noah A Smith. 2016. Many lan-
guages, one parser. TACL, 4:431–444.

Shay B Cohen, Dipanjan Das, and Noah A Smith.
2011. Unsupervised structure prediction with non-
parallel multilingual guidance. In Proceedings of
the Conference on Empirical Methods in Natural
Language Processing, pages 50–61. Association for
Computational Linguistics.

Timothy Dozat and Christopher D Manning. 2016.
Deep biaffine attention for neural dependency pars-
ing. arXiv preprint arXiv:1611.01734.

Long Duong, Trevor Cohn, Steven Bird, and Paul
Cook. 2015a. Cross-lingual transfer for unsuper-
vised dependency parsing without parallel data. In
Proceedings of the CONLL, pages 113–122.

Long Duong, Trevor Cohn, Steven Bird, and Paul
Cook. 2015b. Low resource dependency parsing:
Cross-lingual parameter sharing in a neural network
parser. In Proceedings of the 53rd ACL, volume 2,
pages 845–850.

Chris Dyer, Victor Chahuneau, and Noah A Smith.
2013. A simple, fast, and effective reparameteriza-
tion of ibm model 2. In Proceedings of the NAACL,
pages 644–648.

Kuzman Ganchev, Jennifer Gillenwater, and Ben
Taskar. 2009. Dependency grammar induction via
bitext projection constraints. In Proceedings of the
Joint Conference of ACL-IJCNLP, pages 369–377.

Jiang Guo, Wanxiang Che, David Yarowsky, Haifeng
Wang, and Ting Liu. 2015. Cross-lingual depen-
dency parsing based on distributed representations.
In Proceedings of ACL-IJCNLP, pages 1234–1244.

Jiang Guo, Wanxiang Che, David Yarowsky, Haifeng
Wang, and Ting Liu. 2016a. A distributed
representation-based framework for cross-lingual
transfer parsing. Journal of Artificial Intelligence
Research, 55:995–1023.

Jiang Guo, Wanxiang Che, David Yarowsky, Haifeng
Wang, and Ting Liu. 2016b. A representation learn-
ing framework for multi-source transfer parsing. In
AAAI.



1006

Rebecca Hwa, Philip Resnik, Amy Weinberg, Clara
Cabezas, and Okan Kolak. 2005. Bootstrapping
parsers via syntactic projection across parallel texts.
Natural language engineering, 11(3):311–325.

Philipp Koehn. 2005. Europarl: A parallel corpus for
statistical machine translation. In MT summit, vol-
ume 5, pages 79–86.

Ophélie Lacroix, Lauriane Aufrant, Guillaume Wis-
niewski, and François Yvon. 2016. Frustratingly
easy cross-lingual transfer for transition-based de-
pendency parsing. In Proceedings of the NAACL,
pages 1058–1063.

Miryam de Lhoneux, Johannes Bjerva, Isabelle Augen-
stein, and Anders Søgaard. 2018. Parameter sharing
between dependency parsers for related languages.
In Proceedings of the EMNLP, pages 4992–4997.

Xuezhe Ma and Fei Xia. 2014. Unsupervised depen-
dency parsing with transferring distribution via par-
allel guidance and entropy regularization. In Pro-
ceedings of ACL, volume 1, pages 1337–1348.

Ryan McDonald, Joakim Nivre, Yvonne Quirmbach-
Brundage, Yoav Goldberg, Dipanjan Das, Kuzman
Ganchev, Keith Hall, Slav Petrov, Hao Zhang, Oscar
Täckström, et al. 2013. Universal dependency an-
notation for multilingual parsing. In Proceedings of
the 51st ACL, volume 2, pages 92–97.

Ryan McDonald, Slav Petrov, and Keith Hall. 2011.
Multi-source transfer of delexicalized dependency
parsers. In Proceedings of the conference on
EMNLP, pages 62–72.

Tahira Naseem, Regina Barzilay, and Amir Globerson.
2012. Selective sharing for multilingual dependency
parsing. In Proceedings of the 50th ACL, pages 629–
637.

Joakim Nivre, Marie-Catherine De Marneffe, Filip
Ginter, Yoav Goldberg, Jan Hajic, Christopher D
Manning, Ryan T McDonald, Slav Petrov, Sampo
Pyysalo, Natalia Silveira, et al. 2016. Universal de-
pendencies v1: A multilingual treebank collection.
In LREC.

Mohammad Sadegh Rasooli and Michael Collins.
2015. Density-driven cross-lingual transfer of de-
pendency parsers. In Proceedings of the 2015
EMNLP, pages 328–338.

Mohammad Sadegh Rasooli and Michael Collins.
2017. Cross-lingual syntactic transfer with limited
resources. TACL, 5:279–293.

Mohammad Sadegh Rasooli and Michael Collins.
2019. Low-resource syntactic transfer with un-
supervised source reordering. arXiv preprint
arXiv:1903.05683.

Rudolf Rosa and Zdenek Zabokrtsky. 2015. Klcpos3-a
language similarity measure for delexicalized parser
transfer. In Proceedings of the 53rd ACL, volume 2,
pages 243–249.

Michael Schlichtkrull and Anders Søgaard. 2017.
Cross-lingual dependency parsing with late decod-
ing for truly low-resource languages. In Proceed-
ings of the 15th Conference of the EACL, volume 1,
pages 220–229.

Oscar Täckström, Ryan McDonald, and Joakim Nivre.
2013. Target language adaptation of discrimina-
tive transfer parsers. In Proceedings of the NAACL,
pages 1061–1071.

Oscar Täckström, Ryan McDonald, and Jakob Uszko-
reit. 2012. Cross-lingual word clusters for direct
transfer of linguistic structure. In Proceedings of the
NAACL, pages 477–487.

Jörg Tiedemann. 2015. Improving the cross-lingual
projection of syntactic dependencies. In Proceed-
ings of the 20th NODALIDA, 109, pages 191–199.
Linköping University Electronic Press.

Jörg Tiedemann and Zeljko Agić. 2016. Synthetic tree-
banking for cross-lingual dependency parsing. Jour-
nal of Artificial Intelligence Research, 55:209–248.

Jörg Tiedemann, Željko Agić, and Joakim Nivre. 2014.
Treebank translation for cross-lingual parser induc-
tion. In Proceedings of the EMNLP, pages 130–140.

Hongmin Wang, Yue Zhang, GuangYong Leonard
Chan, Jie Yang, and Hai Leong Chieu. 2017. Uni-
versal dependencies parsing for colloquial singa-
porean english. In Proceedings of the 55th ACL.

Michael Wick, Pallika Kanani, and Adam Pocock.
2016. Minimally-constrained multilingual embed-
dings via artificial code-switching. In AAAI.

Min Xiao and Yuhong Guo. 2015. Annotation
projection-based representation learning for cross-
lingual dependency parsing. In Proceedings of the
Nineteenth Conference on Computational Natural
Language Learning, pages 73–82.

Jie Yang, Shuailong Liang, and Yue Zhang. 2018. De-
sign challenges and misconceptions in neural se-
quence labeling. In Proceedings of the 27th Inter-
national Conference on Computational Linguistics,
pages 3879–3889.

Daniel Zeman and Philip Resnik. 2008. Cross-
language parser adaptation between related lan-
guages. In Proceedings of the IJCNLP-08 Workshop
on NLP for Less Privileged Languages.

Yuan Zhang and Regina Barzilay. 2015. Hierarchical
low-rank tensors for multilingual transfer parsing.
In Proceedings of the 2015 Conference on EMNLP,
pages 1857–1867.

Hai Zhao, Yan Song, Chunyu Kit, and Guodong Zhou.
2009. Cross language dependency parsing using a
bilingual lexicon. In Proceedings of ACL-IJCNLP,
pages 55–63.


